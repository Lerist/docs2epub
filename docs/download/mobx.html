
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="https://fonts.googleapis.com/css?family=Merriweather:400,400i,700" rel="stylesheet">

    <style>
      body {
        font-family: 'Merriweather', serif;
        background: '#ddd';
        color: '#444';
        font-size: 17px;
        line-height: 1.75;
      }

      code, pre {
        font-size: 15px;
        background: #fafafa;
        padding: 0.5rem;
        margin: 0.5rem 0;
      }

      #main {
        max-width: 740px;
      }

      article {
        margin: 1em 0;
        padding: 1em;
      }
    </style>
  </head>
  <body>
    <div id="main">
      
        <article>
          <h3>mobx documentation</h3>
          <div>
<div>
  <h3>About this book.</h3>
  <div>
    Documentation generated by <b>docs2epub</b> [http://javier.xyz/docs2epub/] on Fri Sep 02 2016 01:51:48 GMT-0500 (CDT), scrapped from http://expressjs.com/en/4x/api.html.
  </div>
  <br /><br />
  <div>
    Find more about this project on https://github.com/expressjs/express.
    LICENCE of mobx: https://raw.githubusercontent.com/expressjs/express/master/LICENSE
  </div>
</div>
  </div>
        </article>
      <h2></h2>
        <article>
          <h3>Introduction</h3>
          <div><section class="normal" id="section-">
                    
                        <a id="edit-link" href="https://github.com/mobxjs/mobx/tree/gh-pages/docs/README.md" class="btn fa fa-edit pull-left">&#xA0;&#xA0;Edit This Page</a><p><img src="https://mobxjs.github.io/mobx/docs/mobx.png" alt="logo" height="120" align="right"></p>

<p><em>Simple, scalable state management</em></p>
<p><a href="https://travis-ci.org/mobxjs/mobx" target="_blank"><img src="https://travis-ci.org/mobxjs/mobx.svg?branch=master" alt="Build Status"></a>
<a href="https://coveralls.io/github/mobxjs/mobx?branch=master" target="_blank"><img src="https://coveralls.io/repos/mobxjs/mobx/badge.svg?branch=master&amp;service=github" alt="Coverage Status"></a>
<a href="https://gitter.im/mobxjs/mobx?utm_source=badge&amp;utm_medium=badge&amp;utm_campaign=pr-badge&amp;utm_content=badge" target="_blank"><img src="https://badges.gitter.im/Join%20Chat.svg" alt="Join the chat at https://gitter.im/mobxjs/mobx"></a></p>

<h2 id="introduction">Introduction</h2>
<p>MobX is a battle tested library that makes state management simple and scalable by transparently applying functional reactive programming (TFRP).
The philosophy behind MobX is very simple:</p>
<p><em>Anything that can be derived from the application state, should be derived. Automatically.</em></p>
<p>which includes the UI, data serialization, server communication, etc.</p>
<p><img alt="MobX unidirectional flow" src="https://mobxjs.github.io/mobx/docs/flow.png" align="center"></p>
<p>React and MobX together are a powerful combination. React renders the application state by providing mechanisms to translate it into a tree of renderable components. MobX provides the mechanism to store and update the application state that React then uses.</p>
<p>Both React and MobX provide very optimal and unique solutions to common problems in application development. React provides mechanisms to optimally render UI by using a virtual DOM that reduces the number of costly DOM mutations. MobX provides mechanisms to optimally synchronize application state with your React components by using a reactive virtual dependency state graph that is only updated when strictly needed and is never stale.</p>
<h2 id="core-concepts">Core concepts</h2>
<p>MobX has only a few core concepts. The following snippets can be tried online using <a href="https://jsfiddle.net/mweststrate/wv3yopo0/" target="_blank">JSFiddle</a> (or <a href="https://jsfiddle.net/rubyred/55oc981v/" target="_blank">without ES6 and JSX</a>).</p>
<h3 id="observable-state">Observable state</h3>
<p>MobX adds observable capabilities to existing data structures like objects, arrays and class instances. This can simply be done by annotating your class properties with the <a href="http://mobxjs.github.io/mobx/refguide/observable-decorator.html" target="_blank">@observable</a> decorator (ES.Next), or by invoking the <a href="http://mobxjs.github.io/mobx/refguide/observable.html" target="_blank"><code>observable</code></a> or <a href="http://mobxjs.github.io/mobx/refguide/extend-observable.html" target="_blank"><code>extendObservable</code></a> functions (ES5). See <a href="https://github.com/mobxjs/mobx/wiki/Language-Support" target="_blank">Language support</a> for language-specific examples.</p>
<pre><code class="lang-javascript">
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Todo</span> </span>{
    id = <span class="hljs-built_in">Math</span>.random();
    @observable title = <span class="hljs-string">&quot;&quot;</span>;
    @observable finished = <span class="hljs-literal">false</span>;
}



<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Todo</span> </span>{
    constructor() {
        <span class="hljs-keyword">this</span>.id = <span class="hljs-built_in">Math</span>.random()
        extendObservable(<span class="hljs-keyword">this</span>, {
            title: <span class="hljs-string">&quot;&quot;</span>,
            finished: <span class="hljs-literal">false</span>
        })
    }
}


<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Todo</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">this</span>.id = <span class="hljs-built_in">Math</span>.random()
    extendObservable(<span class="hljs-keyword">this</span>, {
        title: <span class="hljs-string">&quot;&quot;</span>,
        finished: <span class="hljs-literal">false</span>
    })
}


<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createTodo</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> observable({
        id: <span class="hljs-built_in">Math</span>.random(),
        title: <span class="hljs-string">&quot;&quot;</span>,
        finished: <span class="hljs-literal">false</span>
    })
}
</code></pre>
<p>Using <code>@observable</code> is like turning a value into a spreadsheet cell. But unlike spreadsheets, not only can these values be primitive values, but references, objects and arrays as well. You can even <a href="http://mobxjs.github.io/mobx/refguide/extending.html" target="_blank">define your own</a> observable data sources.</p>
<h3 id="computed-values">Computed values</h3>
<p>With MobX you can define values that will be derived automatically when relevant data is modified. By using the <a href="http://mobxjs.github.io/mobx/refguide/computed-decorator.html" target="_blank"><code>@computed</code></a> decorator or by using parameterless functions as property values in <code>extendObservable</code>.</p>
<pre><code class="lang-javascript">
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TodoList</span> </span>{
    @observable todos = [];
    @computed get unfinishedTodoCount() {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.todos.filter(todo =&gt; !todo.finished).length;
    }
}


<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">TodoList</span>(<span class="hljs-params"></span>) </span>{
    extendObservable(<span class="hljs-keyword">this</span>, {
        todos: [],
        unfinishedTodoCount: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.todos.filter(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">todo</span>) </span>{
                <span class="hljs-keyword">return</span> !todo.finished
            }).length;
        }
    })
}
</code></pre>
<p>MobX will ensure that <code>unfinishedTodoCount</code> is updated automatically when a todo is added or when one of the <code>finished</code> properties is modified.
Computations like these can very well be compared with formulas in spreadsheet programs like MS Excel. They update automatically whenever, and only when, needed.</p>
<h3 id="reactions">Reactions</h3>
<p>Reactions are similar to a computed value, but instead of producing a new value, a reaction produces a side effect for things like printing to the console, making network requests, incrementally updating the React component tree to patch the DOM, etc.
In short, reactions bridge <a href="https://en.wikipedia.org/wiki/Reactive_programming" target="_blank">reactive</a> and <a href="https://en.wikipedia.org/wiki/Imperative_programming" target="_blank">imperative</a> programming.</p>
<p>If you are using React, you can turn your (stateless function) components into reactive components by simply adding the <a href="http://mobxjs.github.io/mobx/refguide/observer-component.html" target="_blank"><code>@observer</code></a> decorator from the <code>mobx-react</code> package onto them.</p>
<pre><code class="lang-javascript">import React, {Component} from &apos;react&apos;;
import ReactDOM from &apos;react-dom&apos;;
import {observer} from &quot;mobx-react&quot;;

// ESNext decorator / JSX
@observer
class TodoListView extends Component {
    render() {
        return &lt;div&gt;
            &lt;ul&gt;
                {this.props.todoList.todos.map(todo =&gt;
                    &lt;TodoView todo={todo} key={todo.id} /&gt;
                )}
            &lt;/ul&gt;
            Tasks left: {this.props.todoList.unfinishedTodoCount}
        &lt;/div&gt;
    }
}

const TodoView = observer(({todo}) =&gt;
    &lt;li&gt;
        &lt;input
            type=&quot;checkbox&quot;
            checked={todo.finished}
            onClick={() =&gt; todo.finished = !todo.finished}
        /&gt;{todo.title}
    &lt;/li&gt;
);

const store = new TodoList();
ReactDOM.render(&lt;TodoListView todoList={store} /&gt;, document.getElementById(&apos;mount&apos;));
</code></pre>
<p>In ES5 a component declaration looks like this:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> TodoListView = observer(React.createClass({  }))
</code></pre>
<p><code>observer</code> turns React (function) components into derivations of the data they render.</p>
<p>Also, reactions can be created using the <a href="http://mobxjs.github.io/mobx/refguide/autorun.html" target="_blank"><code>autorun</code></a>, <a href="http://mobxjs.github.io/mobx/refguide/autorun-async.html" target="_blank"><code>autorunAsync</code></a> or <a href="http://mobxjs.github.io/mobx/refguide/when.html" target="_blank"><code>when</code></a> functions to fit your specific situations.</p>
<p>When using MobX there are no smart or dumb components.</p>
<p>All components render smartly but are defined in a dumb manner. MobX will simply make sure the components are always re-rendered whenever needed, but also no more than that. So the <code>onClick</code> handler in the above example will force the proper <code>TodoView</code> to render, and it will cause the <code>TodoListView</code> to render if the number of unfinished tasks has changed.</p>
<p>However, if you would remove the <code>Tasks left</code> line (or put it into a separate component), the <code>TodoListView</code> will no longer re-render when ticking a box. You can verify this yourself by changing the <a href="https://jsfiddle.net/mweststrate/wv3yopo0/" target="_blank">JSFiddle</a>.</p>
<p>For an in-depth explanation about how MobX determines to which observables needs to be reacted, check out: <a href="https://github.com/mobxjs/mobx/blob/gh-pages/docs/best/react.md" target="_blank">Understanding what MobX reacts to</a></p>
<h3 id="actions">Actions</h3>
<p>Unlike many flux frameworks, MobX is unopinionated about how user events should be handled.</p>
<ul>
<li>This can be done in a Flux like manner.</li>
<li>Or by processing events using RxJS.</li>
<li>Or by simply handling events in the most straightforward way possible, as demonstrated in the above <code>onClick</code> handler.</li>
</ul>
<p>In the end it all boils down to: Somehow the state should be updated.</p>
<p>After updating the state <code>MobX</code> will take care of the rest in an efficient, glitch-free manner. So simple statements, like below, are enough to automatically update the user interface.</p>
<p>There is no technical need for firing events, calling dispatcher or what more. A React component is in the end nothing more than a fancy representation of your state. A derivation that will be managed by MobX.</p>
<pre><code class="lang-javascript">store.todos.push(
    <span class="hljs-keyword">new</span> Todo(<span class="hljs-string">&quot;Get Coffee&quot;</span>),
    <span class="hljs-keyword">new</span> Todo(<span class="hljs-string">&quot;Write simpler code&quot;</span>)
);
store.todos[<span class="hljs-number">0</span>].finished = <span class="hljs-literal">true</span>;
</code></pre>
<p>Nonetheless, MobX has an optional built-in concept of <a href="https://mobxjs.github.io/mobx/refguide/action.html" target="_blank"><code>actions</code></a>.
Use them to your advantage; they will help you to structure your code better and make wise decisions about when and where state should be modified.</p>
<h2 id="mobx-simple-and-scalable">MobX: Simple and scalable</h2>
<p>MobX is one of the least obtrusive libraries you can use for state management. That makes the <code>MobX</code> approach not just simple, but very scalable as well:</p>
<h3 id="using-classes-and-real-references">Using classes and real references</h3>
<p>With MobX you don&apos;t need to normalize your data. This makes the library very suitable for very complex domain models (At Mendix for example ~500 different domain classes in a single application).</p>
<h3 id="referential-integrity-is-guaranteed">Referential integrity is guaranteed</h3>
<p>Since data doesn&apos;t need to be normalized, and MobX automatically tracks the relations between state and derivations, you get referential integrity for free. Rendering something that is accessed through three levels of indirection?</p>
<p>No problem, MobX will track them and re-render whenever one of the references changes. As a result staleness bugs are a thing of the past. As a programmer you might forget that changing some data might influence a seemingly unrelated component in a corner case. MobX won&apos;t forget.</p>
<h3 id="simpler-actions-are-easier-to-maintain">Simpler actions are easier to maintain</h3>
<p>As demonstrated above, modifying state when using MobX is very straightforward. You simply write down your intentions. MobX will take care of the rest.</p>
<h3 id="fine-grained-observability-is-efficient">Fine grained observability is efficient</h3>
<p>MobX builds a graph of all the derivations in your application to find the least number of re-computations that is needed to prevent staleness. &quot;Derive everything&quot; might sound expensive, MobX builds a virtual derivation graph to minimize the number of recomputations needed to keep derivations in sync with the state.</p>
<p>In fact, when testing MobX at Mendix we found out that using this library to track the relations in our code is often a lot more efficient then pushing changes through our application by using handwritten events or &quot;smart&quot; selector based container components.</p>
<p>The simple reason is that MobX will establish far more fine grained &apos;listeners&apos; on your data then you would do as a programmer.</p>
<p>Secondly MobX sees the causality between derivations so it can order them in such a way that no derivation has to run twice or introduces a glitch.</p>
<p>How that works? See this <a href="https://medium.com/@mweststrate/becoming-fully-reactive-an-in-depth-explanation-of-mobservable-55995262a254" target="_blank">in-depth explanation of MobX</a>.</p>
<h3 id="easy-interoperability">Easy interoperability</h3>
<p>MobX works plain javascript structures. Due to it&apos;s unobtrusiveness it works with most javascript libraries out of the box, without needing MobX specific library flavors.</p>
<p>So you can simple keep using your existing router-, data fetching and utility libraries like <code>react-router</code>, <code>director</code>, <code>superagent</code>, <code>lodash</code> etc.</p>
<p>For the same reason you can use it out of the box both server- and client side, in isomorphic applications and with react-native.</p>
<p>The result of this is that you often need to learn less new concepts when using MobX in comparison to other state management solutions.</p>
<hr>
<center>
<img src="https://www.mendix.com/styleguide/img/logo-mendix.png" align="center" width="200">

__MobX is proudly used in mission critical systems at [Mendix](https://www.mendix.com)__
</center>

<h2 id="credits">Credits</h2>
<p>MobX is inspired by reactive programming principles as found in spreadsheets. It is inspired by MVVM frameworks like in MeteorJS tracker, knockout and Vue.js. But MobX brings Transparent Functional Reactive Programming to the next level and provides a stand alone implementation. It implements TFRP in a glitch-free, synchronous, predictable and efficient manner.</p>
<p>A ton of credits for <a href="https://github.com/mendix" target="_blank">Mendix</a>, for providing the flexibility and support to maintain MobX and the chance to proof the philosophy of MobX in a real, complex, performance critical applications.</p>
<p>And finally kudo&apos;s for all the people that believed in, tried and validated MobX.</p>
<h2 id="further-resources-and-documentation">Further resources and documentation</h2>

<h2 id="what-others-are-saying">What others are saying...</h2>
<blockquote>
<p>After using #mobx for lone projects for a few weeks, it feels awesome to introduce it to the team. Time: 1/2, Fun: 2X</p>
<p>Working with #mobx is basically a continuous loop of me going &#x201C;this is way too simple, it definitely won&#x2019;t work&#x201D; only to be proven wrong</p>
<p>Try react-mobx with es6 and you will love it so much that you will hug someone.</p>
<p>I have built big apps with MobX already and comparing to the one before that which was using Redux, it is simpler to read and much easier to reason about.</p>
<p>The #mobx is the way I always want things to be! It&apos;s really surprising simple and fast! Totally awesome! Don&apos;t miss it!</p>
</blockquote>
<h2 id="contributing">Contributing</h2>
<ul>
<li>Feel free to send small pull requests. Please discuss new features or big changes in a GitHub issue first.</li>
<li>Use <code>npm test</code> to run the basic test suite, <code>npm run coverage</code> for the test suite with coverage and <code>npm run perf</code> for the performance tests.</li>
</ul>
<h2 id="enabling-decorators-optional">Enabling decorators (optional)</h2>
<p><strong>TypeScript</strong></p>
<p>Enable the compiler option <code>experimentalDecorators</code> in <code>tsconfig.json</code> or pass it as flag <code>--experimentalDecorators</code> to the compiler.</p>
<p><strong>Babel:</strong></p>
<p>Install support for decorators: <code>npm i --save-dev babel-plugin-transform-decorators-legacy</code>. And enable it in your <code>.babelrc</code> file:</p>
<pre><code>{
  &quot;presets&quot;: [
    &quot;es2015&quot;,
    &quot;stage-1&quot;
  ],
  &quot;plugins&quot;: [&quot;transform-decorators-legacy&quot;]
}
</code></pre><p>Probably you have more plugins and presets in your <code>.babelrc</code> already, note that the order is important and <code>transform-decorators-legacy</code> should come as first.</p>
<h2 id="bower-support">Bower support</h2>
<p>Bower support is available through the infamous npmcdn.com:
<code>bower install https://npmcdn.com/mobx/bower.zip</code></p>
<p>Then use <code>lib/mobx.umd.js</code> or <code>lib/mobx.umd.min.js</code></p>
<h2 id="mobx-was-formerly-known-as-mobservable">MobX was formerly known as Mobservable.</h2>
<p>See the <a href="https://github.com/mobxjs/mobx/blob/master/CHANGELOG.md#200" target="_blank">changelog</a> for all the details about <code>mobservable</code> to <code>mobx</code>.</p>
<h2 id="donating">Donating</h2>
<p>Was MobX key in making your project a success? Share the victory by using the <a href="https://mobxjs.github.io/mobx/donate.html" target="_blank">donate button</a>!
MobX is developed largely in free time, so any ROI is appreciated :-).
If you leave a name it will be added to the sponsors list.</p>

                    
                    </section></div>
        </article>
      <h2>1. Introduction to MobX</h2>
        <article>
          <h3>The Gist of MobX</h3>
          <div><div class="page-inner"><span>
                
                
                    </span><section class="normal" id="section-">
                    
                        <a id="edit-link" href="https://github.com/mobxjs/mobx/tree/gh-pages/docs/intro/overview.md" class="btn fa fa-edit pull-left">&#xA0;&#xA0;Edit This Page</a>
<p>So far it all might sound a bit fancy, but making an app reactive using MobX boils down to just these three steps:</p>
<h2 id="1-define-your-state-and-make-it-observable">1. Define your state and make it observable</h2>
<p>Store state in any data structure you like; objects, array, classes.
Cyclic data structures, references, it doesn&apos;t matter.
Just make sure that all properties that you want to change over time are marked by <code>mobx</code> to make them observable.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">import</span> {observable} <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;mobx&apos;</span>;

<span class="hljs-keyword">var</span> appState = observable({
    timer: <span class="hljs-number">0</span>
});
</code></pre>
<h2 id="2-create-a-view-that-responds-to-changes-in-the-state">2. Create a view that responds to changes in the State</h2>
<p>We didn&apos;t make our <code>appState</code> observable just for nothing;
you can now create views that automatically update whenever relevant data in the <code>appState</code> changes.
MobX will find the minimal way to update your views.
This single fact saves you tons of boilerplate and is <a href="https://mendix.com/tech-blog/making-react-reactive-pursuit-high-performing-easily-maintainable-react-apps/" target="_blank">wickedly efficient</a>.</p>
<p>Generally speaking any function can become a reactive view that observes its data, and MobX can be applied in any ES5 conformant JavaScript environment.
But here is an (ES6) example of a view in the form of a React component.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">import</span> {observer} <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;mobx-react&apos;</span>;

@observer
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TimerView</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
    render() {
        <span class="hljs-keyword">return</span> (<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">button</span> <span class="hljs-attribute">onClick</span>=<span class="hljs-value">{this.onReset.bind(this)}</span>&gt;</span>
                Seconds passed: {this.props.appState.timer}
            <span class="hljs-tag">&lt;/<span class="hljs-title">button</span>&gt;</span>)</span>;
    }

    onReset () {
        <span class="hljs-keyword">this</span>.props.appState.resetTimer();
    }
};

React.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">TimerView</span> <span class="hljs-attribute">appState</span>=<span class="hljs-value">{appState}</span> /&gt;</span>, document.body);
</span></code></pre>
<p>(For the implementation of <code>resetTimer</code> function see the next section)</p>
<h2 id="3-modify-the-state">3. Modify the State</h2>
<p>The third relevant thing to do is modifying the state.
That is what your app is about after all.
Unlike many other frameworks, MobX doesn&apos;t dictate you how to do this.
There are best practices, but the key thing to remember is:
<strong><em>MobX helps you to do things in a simple straightforward way</em></strong>.</p>
<p>The following code will alter your data every second, and the UI will update automatically when needed.
No explicit relations are defined in either in the controller functions that <em>change</em> the state or in the views that should <em>update</em>.
Decorating your <em>state</em> and <em>views</em> with <code>observable</code> is enough for MobX to detect all relationships.
Here are two examples of changing the state:</p>
<pre><code class="lang-javascript">appState.resetTimer = action(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reset</span>(<span class="hljs-params"></span>) </span>{
    appState.timer = <span class="hljs-number">0</span>;
});

setInterval(action(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">tick</span>(<span class="hljs-params"></span>) </span>{
    appState.timer += <span class="hljs-number">1</span>;
}), <span class="hljs-number">1000</span>);
</code></pre>
<p>The <code>action</code> wrapper is only needed when using MobX in strict mode (by default off), but will help you to better structure applications and expresses the intention of a function to modify state.</p>
<p>Feel free to try this example on <a href="http://jsfiddle.net/mweststrate/wgbe4guu/" target="_blank">JSFiddle</a> or by cloning the <a href="https://github.com/mobxjs/mobx-react-boilerplate" target="_blank">MobX boilerplate project</a></p>

                    
                    </section><span>
                
                
                </span></div></div>
        </article>
      
        <article>
          <h3>Concepts & Principles</h3>
          <div><section class="normal" id="section-">
                    
                        <a id="edit-link" href="https://github.com/mobxjs/mobx/tree/gh-pages/docs/intro/concepts.md" class="btn fa fa-edit pull-left">&#xA0;&#xA0;Edit This Page</a>
<h2 id="concepts">Concepts</h2>
<p>MobX distinguishes the following concepts in your application. You saw them in the previous gist, but let&apos;s dive into them in a bit more detail.</p>
<h3 id="1-state">1. State</h3>
<p><em>State</em> is the data that drives your application.
Usually there is <em>domain specific state</em> like a list of todo items and there is <em>view state</em> such as the currently selected element.
Remember, state is like spreadsheets cells that hold a value.</p>
<h3 id="2-derivations">2. Derivations</h3>
<p><em>Anything</em> that can be derived from the <em>state</em> without any further interaction is a derivation.
Derivations exist in many forms:</p>
<ul>
<li>The <em>user interface</em>.</li>
<li><em>Derived data</em>, such as the amount of todos left.</li>
<li><em>Backend integrations</em> like sending changes to the server.</li>
</ul>
<p>MobX distinguishes two kind of derivations:</p>
<ul>
<li><em>Computed values</em>. These are values that can always be derived from the current observable state using a pure function.</li>
<li><em>Reactions</em>. Reactions are side effects that need to happen automatically if the state changes. These are needed to as bridge between imperative and reactive programming. Or to make it more clear, they are ultimately needed to achieve I/O.</li>
</ul>
<p>People starting with MobX tend to use reactions too often.
The golden rule is: if you want to create a value based on the current state, use <code>computed</code>. </p>
<p>Back to the spreadsheet analogy, formulas are derivations that <em>compute</em> a value. But for you as a user to be able to see it on the screen a <em>reaction</em> is needed that repaints part of the GUI.</p>
<h3 id="3-actions">3. Actions</h3>
<p>An <em>action</em> is any piece of code that changes the <em>state</em>. User events, backend data pushes, scheduled events etc.
An action is like a user that enters a new value in a spreadsheet cell.</p>
<p>Actions can be defined explicitly in MobX to help you to structure code more clearly.
If MobX is used in <em>strict mode</em>, MobX will enforce that no state can be modified outside actions.</p>
<h2 id="principles">Principles</h2>
<p>MobX supports an uni-directional data flow where <em>actions</em> changes the <em>state</em>, which in turn updates all affected <em>views</em>.</p>
<p><img src="https://mobxjs.github.io/mobx/images/action-state-view.png" alt="Action, State, View"></p>
<p>All <em>Derivations</em> are updated <strong>automatically</strong> and <strong>atomically</strong> when the <em>state</em> changes. As a result it is not possible to ever observe intermediate values.</p>
<p>All <em>Derivations</em> are updated <strong>synchonously</strong> by default. This means that for example <em>actions</em> can safely inspect a computed value directly after altering the <em>state</em>.</p>
<p><em>Computed values</em> are updated <strong>lazily</strong>. Any computed value that is not actively in use will not be updated until it is needed for a side effect (I/O).
If a view is no longer in use it will be garbage collected automatically.</p>
<p>All <em>Computed values</em> should be <strong>pure</strong>. They are not supposed to change <em>state</em>.</p>
<h2 id="illustration">Illustration</h2>
<p>The following listing illustrates the above concepts and principles:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">import</span> {observable, autorun} <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;mobx&apos;</span>;

<span class="hljs-keyword">var</span> todoStore = observable({
    
    todos: [],

    
    completedCount: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.todos.filter(todo =&gt; todo.completed).length;
    }
});


autorun(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Completed %d of %d items&quot;</span>,
        todoStore.completedCount,
        todoStore.todos.length
    );
});


todoStore.todos[<span class="hljs-number">0</span>] = {
    title: <span class="hljs-string">&quot;Take a walk&quot;</span>,
    completed: <span class="hljs-literal">false</span>
};


todoStore.todos[<span class="hljs-number">0</span>].completed = <span class="hljs-literal">true</span>;

</code></pre>
<p>In the <a href="https://mobxjs.github.io/mobx/getting-started.html" target="_blank">10 minute introduction to MobX and React</a> you can dive deeper into this example and build a user interface using <a href="https://facebook.github.io/react/" target="_blank">React</a> around it.</p>

                    
                    </section></div>
        </article>
      <h2></h2>
        <article>
          <h3>The Gist of MobX</h3>
          <div><div class="page-inner"><span>
                
                
                    </span><section class="normal" id="section-">
                    
                        <a id="edit-link" href="https://github.com/mobxjs/mobx/tree/gh-pages/docs/intro/overview.md" class="btn fa fa-edit pull-left">&#xA0;&#xA0;Edit This Page</a>
<p>So far it all might sound a bit fancy, but making an app reactive using MobX boils down to just these three steps:</p>
<h2 id="1-define-your-state-and-make-it-observable">1. Define your state and make it observable</h2>
<p>Store state in any data structure you like; objects, array, classes.
Cyclic data structures, references, it doesn&apos;t matter.
Just make sure that all properties that you want to change over time are marked by <code>mobx</code> to make them observable.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">import</span> {observable} <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;mobx&apos;</span>;

<span class="hljs-keyword">var</span> appState = observable({
    timer: <span class="hljs-number">0</span>
});
</code></pre>
<h2 id="2-create-a-view-that-responds-to-changes-in-the-state">2. Create a view that responds to changes in the State</h2>
<p>We didn&apos;t make our <code>appState</code> observable just for nothing;
you can now create views that automatically update whenever relevant data in the <code>appState</code> changes.
MobX will find the minimal way to update your views.
This single fact saves you tons of boilerplate and is <a href="https://mendix.com/tech-blog/making-react-reactive-pursuit-high-performing-easily-maintainable-react-apps/" target="_blank">wickedly efficient</a>.</p>
<p>Generally speaking any function can become a reactive view that observes its data, and MobX can be applied in any ES5 conformant JavaScript environment.
But here is an (ES6) example of a view in the form of a React component.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">import</span> {observer} <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;mobx-react&apos;</span>;

@observer
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TimerView</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
    render() {
        <span class="hljs-keyword">return</span> (<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">button</span> <span class="hljs-attribute">onClick</span>=<span class="hljs-value">{this.onReset.bind(this)}</span>&gt;</span>
                Seconds passed: {this.props.appState.timer}
            <span class="hljs-tag">&lt;/<span class="hljs-title">button</span>&gt;</span>)</span>;
    }

    onReset () {
        <span class="hljs-keyword">this</span>.props.appState.resetTimer();
    }
};

React.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">TimerView</span> <span class="hljs-attribute">appState</span>=<span class="hljs-value">{appState}</span> /&gt;</span>, document.body);
</span></code></pre>
<p>(For the implementation of <code>resetTimer</code> function see the next section)</p>
<h2 id="3-modify-the-state">3. Modify the State</h2>
<p>The third relevant thing to do is modifying the state.
That is what your app is about after all.
Unlike many other frameworks, MobX doesn&apos;t dictate you how to do this.
There are best practices, but the key thing to remember is:
<strong><em>MobX helps you to do things in a simple straightforward way</em></strong>.</p>
<p>The following code will alter your data every second, and the UI will update automatically when needed.
No explicit relations are defined in either in the controller functions that <em>change</em> the state or in the views that should <em>update</em>.
Decorating your <em>state</em> and <em>views</em> with <code>observable</code> is enough for MobX to detect all relationships.
Here are two examples of changing the state:</p>
<pre><code class="lang-javascript">appState.resetTimer = action(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reset</span>(<span class="hljs-params"></span>) </span>{
    appState.timer = <span class="hljs-number">0</span>;
});

setInterval(action(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">tick</span>(<span class="hljs-params"></span>) </span>{
    appState.timer += <span class="hljs-number">1</span>;
}), <span class="hljs-number">1000</span>);
</code></pre>
<p>The <code>action</code> wrapper is only needed when using MobX in strict mode (by default off), but will help you to better structure applications and expresses the intention of a function to modify state.</p>
<p>Feel free to try this example on <a href="http://jsfiddle.net/mweststrate/wgbe4guu/" target="_blank">JSFiddle</a> or by cloning the <a href="https://github.com/mobxjs/mobx-react-boilerplate" target="_blank">MobX boilerplate project</a></p>

                    
                    </section><span>
                
                
                </span></div></div>
        </article>
      <h2></h2>
        <article>
          <h3>Concepts & Principles</h3>
          <div><section class="normal" id="section-">
                    
                        <a id="edit-link" href="https://github.com/mobxjs/mobx/tree/gh-pages/docs/intro/concepts.md" class="btn fa fa-edit pull-left">&#xA0;&#xA0;Edit This Page</a>
<h2 id="concepts">Concepts</h2>
<p>MobX distinguishes the following concepts in your application. You saw them in the previous gist, but let&apos;s dive into them in a bit more detail.</p>
<h3 id="1-state">1. State</h3>
<p><em>State</em> is the data that drives your application.
Usually there is <em>domain specific state</em> like a list of todo items and there is <em>view state</em> such as the currently selected element.
Remember, state is like spreadsheets cells that hold a value.</p>
<h3 id="2-derivations">2. Derivations</h3>
<p><em>Anything</em> that can be derived from the <em>state</em> without any further interaction is a derivation.
Derivations exist in many forms:</p>
<ul>
<li>The <em>user interface</em>.</li>
<li><em>Derived data</em>, such as the amount of todos left.</li>
<li><em>Backend integrations</em> like sending changes to the server.</li>
</ul>
<p>MobX distinguishes two kind of derivations:</p>
<ul>
<li><em>Computed values</em>. These are values that can always be derived from the current observable state using a pure function.</li>
<li><em>Reactions</em>. Reactions are side effects that need to happen automatically if the state changes. These are needed to as bridge between imperative and reactive programming. Or to make it more clear, they are ultimately needed to achieve I/O.</li>
</ul>
<p>People starting with MobX tend to use reactions too often.
The golden rule is: if you want to create a value based on the current state, use <code>computed</code>. </p>
<p>Back to the spreadsheet analogy, formulas are derivations that <em>compute</em> a value. But for you as a user to be able to see it on the screen a <em>reaction</em> is needed that repaints part of the GUI.</p>
<h3 id="3-actions">3. Actions</h3>
<p>An <em>action</em> is any piece of code that changes the <em>state</em>. User events, backend data pushes, scheduled events etc.
An action is like a user that enters a new value in a spreadsheet cell.</p>
<p>Actions can be defined explicitly in MobX to help you to structure code more clearly.
If MobX is used in <em>strict mode</em>, MobX will enforce that no state can be modified outside actions.</p>
<h2 id="principles">Principles</h2>
<p>MobX supports an uni-directional data flow where <em>actions</em> changes the <em>state</em>, which in turn updates all affected <em>views</em>.</p>
<p><img src="https://mobxjs.github.io/mobx/images/action-state-view.png" alt="Action, State, View"></p>
<p>All <em>Derivations</em> are updated <strong>automatically</strong> and <strong>atomically</strong> when the <em>state</em> changes. As a result it is not possible to ever observe intermediate values.</p>
<p>All <em>Derivations</em> are updated <strong>synchonously</strong> by default. This means that for example <em>actions</em> can safely inspect a computed value directly after altering the <em>state</em>.</p>
<p><em>Computed values</em> are updated <strong>lazily</strong>. Any computed value that is not actively in use will not be updated until it is needed for a side effect (I/O).
If a view is no longer in use it will be garbage collected automatically.</p>
<p>All <em>Computed values</em> should be <strong>pure</strong>. They are not supposed to change <em>state</em>.</p>
<h2 id="illustration">Illustration</h2>
<p>The following listing illustrates the above concepts and principles:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">import</span> {observable, autorun} <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;mobx&apos;</span>;

<span class="hljs-keyword">var</span> todoStore = observable({
    
    todos: [],

    
    completedCount: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.todos.filter(todo =&gt; todo.completed).length;
    }
});


autorun(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Completed %d of %d items&quot;</span>,
        todoStore.completedCount,
        todoStore.todos.length
    );
});


todoStore.todos[<span class="hljs-number">0</span>] = {
    title: <span class="hljs-string">&quot;Take a walk&quot;</span>,
    completed: <span class="hljs-literal">false</span>
};


todoStore.todos[<span class="hljs-number">0</span>].completed = <span class="hljs-literal">true</span>;

</code></pre>
<p>In the <a href="https://mobxjs.github.io/mobx/getting-started.html" target="_blank">10 minute introduction to MobX and React</a> you can dive deeper into this example and build a user interface using <a href="https://facebook.github.io/react/" target="_blank">React</a> around it.</p>

                    
                    </section></div>
        </article>
      <h2></h2>
        <article>
          <h3>API overview</h3>
          <div><section class="normal" id="section-">
                    
                        <a id="edit-link" href="https://github.com/mobxjs/mobx/tree/gh-pages/docs/refguide/api.md" class="btn fa fa-edit pull-left">&#xA0;&#xA0;Edit This Page</a><h1 id="mobx-api-reference">MobX Api Reference</h1>
<h1 id="core-api">Core API</h1>
<p><em>The most important MobX api&apos;s. Understanding <code>observable</code>, <code>computed</code>, <code>reactions</code> and <code>actions</code> is enough to master MobX and use it in your applications!</em></p>
<h2 id="creating-observables">Creating observables</h2>
<h3 id="-observable"><code>observable</code></h3>
<p>Usage:</p>
<ul>
<li><code>observable(value)</code></li>
<li><code>@observable classProperty = value</code></li>
</ul>
<p>Observable values can be JS primitives, references, plain objects, class instances, arrays and maps.
The following conversion rules are applied, but can be fine-tuned by using <em>modifiers</em>. See below.</p>
<ol>
<li>If <em>value</em> is wrapped in the <em>modifier</em> <code>asMap</code>: a new <a href="https://mobxjs.github.io/mobx/refguide/map.html">Observable Map</a> will be returned. Observable maps are very useful if you don&apos;t want to react just to the change of a specific entry, but also to the addition or removal of entries.</li>
<li>If <em>value</em> is an array, a new <a href="https://mobxjs.github.io/mobx/refguide/array.html">Observable Array</a> will be returned.</li>
<li>If <em>value</em> is an object <em>without</em> prototype, all its current properties will be made observable. See <a href="https://mobxjs.github.io/mobx/refguide/object.html">Observable Object</a></li>
<li>If <em>value</em> is an object <em>with</em> a prototype, a JavaScript primitive or function, a <a href="https://mobxjs.github.io/mobx/refguide/boxed.html">Boxed Observable</a> will be returned. MobX will not make objects with a prototype automatically observable; as that is the responsibility of it&apos;s constructor function. Use <code>extendObservable</code> in the constructor, or <code>@observable</code> in it&apos;s class definition instead.</li>
</ol>
<p>These rules might seem complicated at first sight, but you will notice that in practice they are very intuitive to work with.
Some notes:</p>
<ul>
<li>To create dynamically keyed objects use the <code>asMap</code> modifier! Only initially existing properties on an object will be made observable, although new ones can be added using <code>extendObservable</code>.</li>
<li>To use the <code>@observable</code> decorator, make sure that <a href="http://mobxjs.github.io/mobx/refguide/observable-decorator.html" target="_blank">decorators are enabled</a> in your transpiler (babel or typescript).</li>
<li>By default making a data structure observable is <em>infective</em>; that means that <code>observable</code> is applied automatically to any value that is contained by the data structure, or will be contained by the data structure in the future. This behavior can be changed by using <em>modifiers</em>.</li>
</ul>
<p><a href="https://mobxjs.github.io/mobx/refguide/observable.html">&#xAB;<code>observable</code>&#xBB;</a>  &#x2014;  <a href="https://mobxjs.github.io/mobx/refguide/observable-decorator.html">&#xAB;<code>@observable</code>&#xBB;</a></p>
<h3 id="-extendobservable"><code>extendObservable</code></h3>
<p>Usage: <code>extendObservable(target, propertyMap)</code>. For each key/value pair in <code>propertyMap</code> a (new) observable property will be introduced on the target object.
This can be used in constructor functions to introduce observable properties without using decorators.
If a value of the <code>propertyMap</code> is an argumentless function, a <em>computed</em> property will be introduced.
<a href="https://mobxjs.github.io/mobx/refguide/extend-observable.html">&#xAB;details&#xBB;</a></p>
<h2 id="computed-values">Computed values</h2>
<p>Usage:</p>
<ul>
<li><code>computed(() =&gt; expression)</code></li>
<li><code>@computed get classProperty() { return expression; }</code></li>
</ul>
<p>Creates a computed property. The <code>expression</code> should not have side effects but return a value.
The expression will automatically be re-evaluated if any observables it uses changes, but only if it is in use by some <em>reaction</em>.
<a href="https://mobxjs.github.io/mobx/refguide/computed-decorator.html">&#xAB;details&#xBB;</a></p>
<h2 id="actions">Actions</h2>
<p>Any application has actions. Actions are anything that modify the state.</p>
<p>With MobX you can make it explicit in your code where your actions live by marking them.
Actions helps you to structure your code better.
It is advised to use them on any function that modifies observables or has side effects.
<code>action</code> also provides useful debugging information in combination with the devtools.
Note: using <code>action</code> is mandatory when <em>strict mode</em> is enabled, see <code>useStrict</code>.
<a href="https://mobxjs.github.io/mobx/refguide/action.html">&#xAB;details&#xBB;</a></p>
<p>Usage:</p>
<ul>
<li><code>action(fn)</code></li>
<li><code>action(name, fn)</code></li>
<li><code>@action classMethod</code></li>
<li><code>@action(name) classMethod</code></li>
<li><code>@action boundClassMethod = (args) =&gt; { body }</code></li>
<li><code>@action(name) boundClassMethod = (args) =&gt; { body }</code></li>
</ul>
<p>For one-time-actions <code>runInAction(name?, fn, scope?)</code> can be used, which is sugar for <code>action(name, fn, scope)()</code>.</p>
<h2 id="reactions">Reactions</h2>
<p><em>Computed values</em> are <strong>values</strong> that react automatically to state changes.
<em>Reactions</em> are <strong>side effects</strong> that react automatically to state changes.
Reactions <em>can</em> be used to ensure that a certain side effect (mainly I/O) is automatically executed when relevant state changes, like logging, network requests etc.
The most commonly used reaction is the <code>observer</code> decorator for React components (see above).</p>
<h3 id="-observer"><code>observer</code></h3>
<p>Can be used as higher order component around a React component.
The component will then automatically re-render if any of the observables used in the <code>render</code> function of the component has changed.
Note that <code>observer</code> is provided by the <code>&quot;mobx-react&quot;</code> package and not by <code>&quot;mobx&quot;</code> itself.
<a href="https://mobxjs.github.io/mobx/refguide/observer-component.html">&#xAB;details&#xBB;</a></p>
<p>Usage:</p>
<ul>
<li><code>observer(React.createClass({ ... }))</code></li>
<li><code>observer((props, context) =&gt; ReactElement)</code></li>
<li><code>observer(class MyComponent extends React.Component { ... })</code></li>
<li><code>@observer class MyComponent extends React.Component { ... })</code></li>
</ul>
<h3 id="-autorun"><code>autorun</code></h3>
<p>Usage: <code>autorun(debugname?, () =&gt; { sideEffect })</code>. Autorun runs the provided <code>sideEffect</code> and tracks which observable state is accessed while running the side effect.
Whenever one of the used observables is changed in the future, the same sideEffect will be run again.
Returns a disposer function to cancel the side effect. <a href="https://mobxjs.github.io/mobx/refguide/autorun.html">&#xAB;details&#xBB;</a></p>
<h3 id="-when"><code>when</code></h3>
<p>Usage: <code>when(debugname?, () =&gt; condition, () =&gt; { sideEffect })</code>.
The condition expression will react automatically to any observables is uses.
As soon as the expression returns true the sideEffect function will be invoked, but only once.
<code>when</code> returns a disposer to prematurely cancel the whole thing. <a href="https://mobxjs.github.io/mobx/refguide/when.html">&#xAB;details&#xBB;</a></p>
<h3 id="-autorunasync"><code>autorunAsync</code></h3>
<p>Usage: <code>autorunAsync(debugname?, () =&gt; { sideEffect }, delay)</code>. Similar to <code>autorun</code>, but the sideEffect will be delayed and debounced with the given <code>delay</code>.
<a href="https://mobxjs.github.io/mobx/refguide/autorun-async.html">&#xAB;details&#xBB;</a></p>
<h3 id="-reaction"><code>reaction</code></h3>
<p>Usage: <code>reaction(debugname?, () =&gt; data, data =&gt; { sideEffect }, fireImmediately = false, delay = 0)</code>.
A variation on <code>autorun</code> that gives more fine-grained control on which observables that will be tracked.
It takes two function, the first one is tracked and returns data that is used as input for the second one, the side effect.
Unlike <code>autorun</code> the side effect won&apos;t be run initially, and any observables that are accessed while executing the side effect will not be tracked.
The side effect can be debounced, just like <code>autorunAsync</code>. <a href="https://mobxjs.github.io/mobx/refguide/reaction.html">&#xAB;details&#xBB;</a></p>
<h2 id="modifiers-for-observable">Modifiers for <code>observable</code></h2>
<p>By default <code>observable</code> is applied recursively and to values that are assigned in the future as well.
Modifiers can be used to influence how <code>observable</code> treats specific values.</p>
<ul>
<li><code>asMap</code>: This is the most important modifier. Instead of creating an object with observable properties, an <em>Observable Map</em> is created instead. The main difference with observable objects is that the addition and removal of properties can be easily observed. Use <code>asMap</code> if you want a map like data structure where the keys will change over time.</li>
<li><code>asFlat</code>: Don&apos;t apply <code>observable</code> recursively. The passed object / collection itself will be observable, but the values in it won&apos;t. This disables the possibility to deeply observe objects.</li>
<li><code>asReference</code>: Use the passed in value verbatim, just create an observable reference to the object.</li>
<li><code>asStructure</code>: When new values are assigned, ignore the new value if it structurally equal to the previous value.</li>
</ul>
<p><a href="https://mobxjs.github.io/mobx/refguide/modifiers.html">&#xAB;details&#xBB;</a></p>
<hr>
<h1 id="utilities">Utilities</h1>
<p><em>Here are some utilities that might make working with observable objects or computed values more convenient.
More, less trivial utilities can be found in the * <a href="https://github.com/mobxjs/mobx-utils" target="_blank">mobx-utils</a> package.</em></p>
<h3 id="-provider-mobx-react-package"><code>Provider</code> (<code>mobx-react</code> package)</h3>
<p>Can be used to pass stores to child components using React&apos;s context mechanism. See the <a href="https://github.com/mobxjs/mobx-react#provider-experimental" target="_blank"><code>mobx-react</code> docs</a>.</p>
<h3 id="-inject-mobx-react-package"><code>inject</code> (<code>mobx-react</code> package)</h3>
<p>Higher order component and counterpart of <code>Provider</code>. Can be used to pick stores from React&apos;s context and pass it as props to the target component. Usage:</p>
<ul>
<li><code>inject(&quot;store1&quot;, &quot;store2&quot;)(observer(MyComponent))</code></li>
<li><code>@inject(&quot;store1&quot;, &quot;store2&quot;) @observer MyComponent</code></li>
<li>`@inject((stores, props, context) =&gt; props) @observer MyComponent</li>
<li><code>@observer([&quot;store1&quot;, &quot;store2&quot;]) MyComponent</code> is a shorthand for the the <code>@inject() @observer</code> combo.</li>
</ul>
<h3 id="-tojs"><code>toJS</code></h3>
<p>Usage: <code>toJS(observableDataStructure)</code>. Converts observable data structures back to plain javascript objects, ignoring computed values. <a href="https://mobxjs.github.io/mobx/refguide/tojson.html">&#xAB;details&#xBB;</a></p>
<h3 id="-isobservable"><code>isObservable</code></h3>
<p>Usage: <code>isObservable(thing, property?)</code>. Returns true if the given thing, or the <code>property</code> of the given thing is observable.
Works for all observables, computed values and disposer functions of reactions. <a href="https://mobxjs.github.io/mobx/refguide/is-observable">&#xAB;details&#xBB;</a></p>
<h3 id="-isobservableobject-array-map"><code>isObservableObject|Array|Map</code></h3>
<p>Usage: <code>isObservableObject(thing)</code>, <code>isObservableArray(thing)</code>, <code>isObservableMap(thing)</code>. Returns <code>true</code> if.., well, do the math.</p>
<h3 id="-isaction"><code>isAction</code></h3>
<p>Usage: <code>isAction(func)</code>. Returns true if the given function is wrapped / decorated with <code>action</code>.</p>
<h3 id="-createtransformer"><code>createTransformer</code></h3>
<p>Usage: <code>createTransformer(transformation: A =&gt; B, onCleanup?): A = B</code>.
Can be used to make functions that transforms one value into another value reactive and memoized.
It behaves similar to computed and can be used for advanced patterns like very efficient array maps, map reduce or computed values that are not part of an object.
<a href="https://mobxjs.github.io/mobx/refguide/create-transformer.html">&#xAB;details&#xBB;</a></p>
<h3 id="-intercept"><code>intercept</code></h3>
<p>Usage: <code>intercept(object, property?, interceptor)</code>.
Api that can be used to intercept changes before they are applied to an observable api. Useful for validation, normalization or cancellation.
<a href="https://mobxjs.github.io/mobx/refguide/observe.html">&#xAB;details&#xBB;</a></p>
<h3 id="-observe"><code>observe</code></h3>
<p>Usage: <code>observe(object, property?, listener, fireImmediately = false)</code>
Low-level api that can be used to observe a single observable value.
<a href="https://mobxjs.github.io/mobx/refguide/observe.html">&#xAB;details&#xBB;</a></p>
<h3 id="-usestrict"><code>useStrict</code></h3>
<p>Usage: <code>useStrict(boolean)</code>.
Enables / disables strict mode <em>globally</em>.
In strict mode, it is not allowed to change any state outside of an <a href="https://mobxjs.github.io/mobx/refguide/action.html"><code>action</code></a>.
See also <code>extras.allowStateChanges</code>.</p>
<h1 id="development-utilities">Development utilities</h1>
<p><em>The following api&apos;s might come in handy if you want to build cool tools on top of MobX or if you want to inspect the internal state of MobX</em></p>
<h3 id="-mobx-react-devtools-package"><code>&quot;mobx-react-devtools&quot;</code> package</h3>
<p>The mobx-react-devtools is a powerful package that helps you to investigate the performance and dependencies of your react components.
Also has a powerful logger utility based on <code>spy</code>. <a href="https://mobxjs.github.io/mobx/best/devtools.html">&#xAB;details&#xBB;</a></p>
<h3 id="-spy"><code>spy</code></h3>
<p>Usage: <code>spy(listener)</code>.
Registers a global spy listener that listens to all events that happen in MobX.
It is similar to attaching an <code>observe</code> listener to <em>all</em> observables at once, but also notifies about running (trans/re)actions and computations.
Used for example by the <code>mobx-react-devtools</code>.
<a href="https://mobxjs.github.io/mobx/refguide/spy.html">&#xAB;details&#xBB;</a></p>
<h3 id="-whyrun"><code>whyRun</code></h3>
<p>Usage:</p>
<ul>
<li><code>whyRun()</code></li>
<li><code>whyRun(Reaction object / ComputedValue object / disposer function)</code></li>
<li><code>whyRun(object, &quot;computed property name&quot;)</code></li>
</ul>
<p><code>whyRun</code> is a small utility that can be used inside computed value or reaction (<code>autorun</code>, <code>reaction</code> or the <code>render</code> method of an <code>observer</code> React component)
and prints why the derivation is currently running, and under which circumstances it will run again.
This should help to get a deeper understanding when and why MobX runs stuff, and prevent some beginner mistakes.</p>
<h3 id="-extras-getatom"><code>extras.getAtom</code></h3>
<p>Usage: <code>getAtom(thing, property?)</code>.
Returns the backing <em>Atom</em> of a given observable object, property, reaction etc.</p>
<h3 id="-extras-getdebugname"><code>extras.getDebugName</code></h3>
<p>Usage: <code>getDebugName(thing, property?)</code>
Returns a (generated) friendly debug name of an observable object, property, reaction etc. Used by for example the <code>mobx-react-devtools</code>.</p>
<h3 id="-extras-getdependencytree"><code>extras.getDependencyTree</code></h3>
<p>Usage: <code>getDependencyTree(thing, property?)</code>.
Returns a tree structure with all observables the given reaction / computation currently depends upon.</p>
<h3 id="-extras-getobservertree"><code>extras.getObserverTree</code></h3>
<p>Usage: <code>getObserverTree(thing, property?)</code>.
Returns a tree structure with all reactions / computations that are observing the given observable.</p>
<h3 id="-extras-isspyenabled"><code>extras.isSpyEnabled</code></h3>
<p>Usage: <code>isSpyEnabled()</code>. Returns true if at least one spy is active</p>
<h3 id="-extras-spyreport"><code>extras.spyReport</code></h3>
<p>Usage: <code>spyReport({ type: &quot;your type&quot;, &amp;laquo;details&amp;raquo; data})</code>. Emit your own custom spy event.</p>
<h3 id="-extras-spyreportstart"><code>extras.spyReportStart</code></h3>
<p>Usage: <code>spyReportStart({ type: &quot;your type&quot;, &amp;laquo;details&amp;raquo; data})</code>. Emit your own custom spy event. Will start a new nested spy event group which should be closed using <code>spyReportEnd()</code></p>
<h3 id="-extras-spyreportend"><code>extras.spyReportEnd</code></h3>
<p>Usage: <code>spyReportEnd()</code>. Ends the current spy group that was started with <code>extras.spyReportStart</code>.</p>
<h3 id="-mobx-react-development-hooks"><code>&quot;mobx-react&quot;</code> development hooks</h3>
<p>The <code>mobx-react</code> package exposes the following additional api&apos;s that are used by the <code>mobx-react-devtools</code>:</p>
<ul>
<li><code>trackComponents()</code>: enables the tracking of <code>observer</code> based React components</li>
<li><code>renderReporter.on(callback)</code>: callback will be invoked on each rendering of an <code>observer</code> enabled React component, with timing information etc</li>
<li><code>componentByNodeRegistery</code>: ES6 WeakMap that maps from DOMNode to a <code>observer</code> based React component instance</li>
</ul>
<h1 id="internal-functions">Internal functions</h1>
<p><em>The following methods are all used internally by MobX, and might come in handy in rare cases. But usually MobX offers more declarative alternatives to tackle the same problem. They might come in handy though if you try to extend MobX</em></p>
<h3 id="-transaction"><code>transaction</code></h3>
<p>Usage: <code>transaction(() =&gt; { block })</code>.
Low-level api that can be used to batch state changes.
State changes made inside the block won&apos;t cause any computations or reactions to run until the end of the block is reached.
Nonetheless inspecting a computed value inside a transaction block will still return a consistent value.
It is recommended to use <code>action</code> instead, which uses <code>transaction</code> internally.
<a href="https://mobxjs.github.io/mobx/refguide/transaction.html">&#xAB;details&#xBB;</a></p>
<h3 id="-untracked"><code>untracked</code></h3>
<p>Usage: <code>untracked(() =&gt; { block })</code>.
Low-level api that might be useful inside reactions and computations.
Any observables accessed in the <code>block</code> won&apos;t cause the reaction / compuations to be recomputed automatically.
However it is recommended to use <code>action</code> instead, which uses <code>untracked</code> internally.
<a href="https://mobxjs.github.io/mobx/refguide/untracked.html">&#xAB;details&#xBB;</a></p>
<h3 id="-atom"><code>Atom</code></h3>
<p>Utility class that can be used to create your own observable data structures and hook them up to MobX.
Used internally by all observable data types.
<a href="https://mobxjs.github.io/mobx/refguide/extending.html">&#xAB;details&#xBB;</a></p>
<h3 id="-reaction"><code>Reaction</code></h3>
<p>Utility class that can be used to create your own reactions and hook them up to MobX.
Used internally by <code>autorun</code>, <code>reaction</code> (function) etc.
<a href="https://mobxjs.github.io/mobx/refguide/extending.html">&#xAB;details&#xBB;</a></p>
<h3 id="-extras-allowstatechanges"><code>extras.allowStateChanges</code></h3>
<p>Usage: <code>allowStateChanges(allowStateChanges, () =&gt; { block })</code>.
Can be used to (dis)allow state changes in a certain function.
Used internally by <code>action</code> to allow changes, and by <code>computed</code> and <code>observer</code> to disallow state changes.</p>
<h3 id="-extras-resetglobalstate"><code>extras.resetGlobalState</code></h3>
<p>Usage: <code>resetGlobalState()</code>.
Resets MobX internal global state. MobX by defaults fails fast if an exception occurs inside a computation or reaction and refuses to run them again.
This function resets MobX to the zero state. Existing <code>spy</code> listeners and the current value of strictMode will be preserved though.</p>
<h1 id="functions-that-might-get-deprecated">Functions that might get deprecated</h1>
<h3 id="-map"><code>map</code></h3>
<p><em>Will probably by deprecated, use <code>observable(asMap())</code> instead</em>. Usage: <code>map()</code>, <code>map(keyValueObject)</code>, <code>map(entries)</code>.
Returns an observable, largely ES6 compliant <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map" target="_blank">Map</a> data structure.
This is useful if you want to store data based on string keys.
For the full api of the returned <code>ObservableMap</code> see <em>Observable maps</em>.
<a href="https://mobxjs.github.io/mobx/refguide/map.html">&#xAB;details&#xBB;</a></p>
<h3 id="-expr"><code>expr</code></h3>
<p>Usage: <code>expr(() =&gt; someExpression</code>. Just a shorthand for <code>computed(() =&gt; someExpression).get()</code>.
<code>expr</code> is useful in some rare cases to optimize another computed function or reaction.
In general it is simpler and better to just split the function in multiple smaller computed&apos;s to achieve the same effect.
<a href="https://mobxjs.github.io/mobx/refguide/expr.html">&#xAB;details&#xBB;</a></p>

                    
                    </section></div>
        </article>
      
        <article>
          <h3>observable | MobX</h3>
          <div><div class="page-inner"><span>
                
                
                    </span><section class="normal" id="section-">
                    
                        <a id="edit-link" href="https://github.com/mobxjs/mobx/tree/gh-pages/docs/refguide/observable.md" class="btn fa fa-edit pull-left">&#xA0;&#xA0;Edit This Page</a>
<p>Usage: </p>
<ul>
<li><code>observable(value)</code></li>
<li><code>@observable classProperty = value</code> </li>
</ul>
<p>Observable values can be JS primitives, references, plain objects, class instances, arrays and maps.
The following conversion rules are applied, but can be fine-tuned by using <em>modifiers</em>. See below.</p>
<ol>
<li>If <em>value</em> is wrapped in the <em>modifier</em> <code>asMap</code>: a new <a href="https://mobxjs.github.io/mobx/refguide/map.html">Observable Map</a> will be returned. Observable maps are very useful if you don&apos;t want to react just to the change of a specific entry, but also to the addition or removal of entries.</li>
<li>If <em>value</em> is an array, a new <a href="https://mobxjs.github.io/mobx/refguide/array.html">Observable Array</a> will be returned.</li>
<li>If <em>value</em> is an object <em>without</em> prototype, all its current properties will be made observable. See <a href="https://mobxjs.github.io/mobx/refguide/object.html">Observable Object</a></li>
<li>If <em>value</em> is an object <em>with</em> a prototype, a JavaScript primitive or function, a <a href="https://mobxjs.github.io/mobx/refguide/boxed.html">Boxed Observable</a> will be returned. MobX will not make objects with a prototype automatically observable; as that is the responsibility of its constructor function. Use <code>extendObservable</code> in the constructor, or <code>@observable</code> in its class definition instead.</li>
</ol>
<p>These rules might seem complicated at first sight, but you will notice that in practice they are very intuitive to work with.
Some notes:</p>
<ul>
<li>To create dynamically keyed objects use the <code>asMap</code> modifier! Only initially existing properties on an object will be made observable, although new ones can be added using <code>extendObservable</code>.</li>
<li>To use the <code>@observable</code> decorator, make sure that <a href="http://mobxjs.github.io/mobx/refguide/observable-decorator.html" target="_blank">decorators are enabled</a> in your transpiler (babel or typescript).</li>
<li>By default, making a data structure observable is <em>infective</em>; that means that <code>observable</code> is applied automatically to any value that is contained by the data structure, or will be contained by the data structure in the future. This behavior can be changed by using <em>modifiers</em>.</li>
</ul>
<p>Some examples:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> map = observable(asMap({ key: <span class="hljs-string">&quot;value&quot;</span>}));
map.set(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;new value&quot;</span>);

<span class="hljs-keyword">const</span> list = observable([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>]);
list[<span class="hljs-number">2</span>] = <span class="hljs-number">3</span>;

<span class="hljs-keyword">const</span> person = observable({
    firstName: <span class="hljs-string">&quot;Clive Staples&quot;</span>,
    lastName: <span class="hljs-string">&quot;Lewis&quot;</span>
});
person.firstName = <span class="hljs-string">&quot;C.S.&quot;</span>;

<span class="hljs-keyword">const</span> temperature = observable(<span class="hljs-number">20</span>);
temperature.set(<span class="hljs-number">25</span>);
</code></pre>

                    
                    </section><span>
                
                
                </span></div></div>
        </article>
      
        <article>
          <h3>@observable</h3>
          <div><div class="page-inner"><span>
                
                
                    </span><section class="normal" id="section-">
                    
                        <a id="edit-link" href="https://github.com/mobxjs/mobx/tree/gh-pages/docs/refguide/observable-decorator.md" class="btn fa fa-edit pull-left">&#xA0;&#xA0;Edit This Page</a>
<p>Decorator that can be used on ES7- or TypeScript class properties to make them observable.
The @observable can be used on instance fields and property getters.
This offers fine-grained control on which parts of your object become observable.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">import</span> {observable} <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx&quot;</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderLine</span> </span>{
    @observable price:number = <span class="hljs-number">0</span>;
    @observable amount:number = <span class="hljs-number">1</span>;

    constructor(price) {
        <span class="hljs-keyword">this</span>.price = price;
    }

    @computed get total() {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.price * <span class="hljs-keyword">this</span>.amount;
    }
}
</code></pre>
<p>If your environment doesn&apos;t support decorators or field initializers,
<code>@observable key = value;</code> is sugar for <a href="https://mobxjs.github.io/mobx/refguide/extend-observable.html"><code>extendObservable(this, { key: value })</code></a></p>
<p>Enumerability: properties decorator with <code>@observable</code> are enumerable, but defined on the class prototype and not on the class instances.
In other words:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> line = <span class="hljs-keyword">new</span> OrderLine();
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;price&quot;</span> <span class="hljs-keyword">in</span> line) 
<span class="hljs-built_in">console</span>.log(line.hasOwnProperty(<span class="hljs-string">&quot;price&quot;</span>)) 
</code></pre>
<p>The <code>@observable</code> decorator can be combined with modifiers like <code>asStructure</code>:</p>
<pre><code class="lang-javascript">@observable position = asStructure({ x: <span class="hljs-number">0</span>, y: <span class="hljs-number">0</span>})
</code></pre>
<h3 id="enabling-decorators-in-your-transpiler">Enabling decorators in your transpiler</h3>
<p>Decorators are not supported by default when using TypeScript or Babel pending a definitive definition in the ES standard.</p>
<ul>
<li>For <em>typescript</em>, enable the <code>--experimentalDecorators</code> compiler flag or set the compiler option <code>experimentalDecorators</code> to <code>true</code> in <code>tsconfig.json</code> (Recommended)</li>
<li>For <em>babel5</em>, make sure <code>--stage 0</code> is passed to the Babel CLI</li>
<li>For <em>babel6</em>, see the example configuration as suggested in this <a href="https://github.com/mobxjs/mobx/issues/105" target="_blank">issue</a></li>
</ul>

                    
                    </section><span>
                
                
                </span></div></div>
        </article>
      
        <article>
          <h3>(@)computed</h3>
          <div><section class="normal" id="section-">
                    
                        <a id="edit-link" href="https://github.com/mobxjs/mobx/tree/gh-pages/docs/refguide/computed-decorator.md" class="btn fa fa-edit pull-left">&#xA0;&#xA0;Edit This Page</a><h1 id="-computed">@computed</h1>
<p>Decorator that can be used on ES6 or TypeScript derivable class properties to make them observable.
The <code>@computed</code> can only be used on <code>get</code> functions for instance properties.</p>
<p>Use <code>@computed</code> if you have a value that can be derived in a pure manner from other observables.</p>
<p>Don&apos;t confuse <code>@computed</code> with <code>autorun</code>. They are both reactively invoked expressions,
but use <code>@computed</code> if you want to reactively produce a new value that can be used by other observers and
<code>autorun</code> if you don&apos;t want to produce a new value but rather invoke some imperative code like logging, network requests etc.</p>
<p>Computed properties can be optimized away in many cases by MobX as they are assumed to be pure.
So they will not be invoked when their input parameters didn&apos;t modifiy or if they are not observed by some other computed value or autorun.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">import</span> {observable, computed} <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx&quot;</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderLine</span> </span>{
    @observable price:number = <span class="hljs-number">0</span>;
    @observable amount:number = <span class="hljs-number">1</span>;

    constructor(price) {
        <span class="hljs-keyword">this</span>.price = price;
    }

    @computed get total() {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.price * <span class="hljs-keyword">this</span>.amount;
    }
}
</code></pre>
<p>If your environment doesn&apos;t support decorators or field initializers,
<code>@computed get funcName() { }</code> is sugar for <a href="https://mobxjs.github.io/mobx/refguide/extend-observable.html"><code>extendObservable(this, { funcName: func })</code></a></p>
<p><code>@computed</code> can be parameterized. <code>@computed({asStructure: true})</code> makes sure that the result of a derivation is compared structurally instead of referentially with its preview value. This makes sure that observers of the computation don&apos;t re-evaluate if new structures are returned that are structurally equal to the original ones. This is very useful when working with point, vector or color structures for example. It behaves the same as the <code>asStructure</code> modifier for observable values.</p>
<p><code>@computed</code> properties are not enumerable.</p>
<h3 id="enabling-decorators-in-your-transpiler">Enabling decorators in your transpiler</h3>
<p>Decorators are not supported by default when using TypeScript or Babel pending a definitive definition in the ES standard.</p>
<ul>
<li>For <em>typescript</em>, enable the <code>--experimentalDecorators</code> compiler flag or set the compiler option <code>experimentalDecorators</code> to <code>true</code> in <code>tsconfig.json</code> (Recommended)</li>
<li>For <em>babel5</em>, make sure <code>--stage 0</code> is passed to the Babel CLI</li>
<li>For <em>babel6</em>, see the example configuration as suggested in this <a href="https://github.com/mobxjs/mobx/issues/105" target="_blank">issue</a></li>
</ul>
<h1 id="-computed-expression"><code>computed(expression)</code></h1>
<p><code>computed</code> can also be invoked directly as function.
Just like <code>observable(primitive value)</code> it will create a stand-alone observable.
Use <code>.get()</code> on the returned object to get the current value of the computation, or <code>.observe(callback)</code> to observe it&apos;s changes.</p>
<p>Example:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">import</span> {observable, computed} <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx&quot;</span>;
<span class="hljs-keyword">var</span> name = observable(<span class="hljs-string">&quot;John&quot;</span>);
<span class="hljs-keyword">var</span> age = observable(<span class="hljs-number">42</span>);
<span class="hljs-keyword">var</span> showAge = observable(<span class="hljs-literal">false</span>);

<span class="hljs-keyword">var</span> labelText = computed(() =&gt;
    showAge.get() ? <span class="hljs-string">`<span class="hljs-subst">${name.get()}</span> (age: <span class="hljs-subst">${age.get()}</span>)`</span> : name.get();
);

<span class="hljs-keyword">var</span> disposer = labelText.observe(newLabel =&gt; <span class="hljs-built_in">console</span>.log(newLabel));

name.set(<span class="hljs-string">&quot;Dave&quot;</span>);


age.set(<span class="hljs-number">21</span>);


showAge.set(<span class="hljs-literal">true</span>);


age.set(<span class="hljs-number">42</span>);



disposer();

name.set(<span class="hljs-string">&quot;Matthew&quot;</span>);



<span class="hljs-built_in">console</span>.log(labelText.get());
</code></pre>
<p>Note how the function now automatically reacts to data changes,
but only if they occurred in data that was actually used to produce the output.
Hence the first change to <code>age</code> didn&apos;t result in a re-evaluation of the <code>labelText</code> function.
MobX will automatically determine whether the function should run <em>eagerly</em> or <em>lazily</em> based on how the views are used throughout your application,
so make sure your code doesn&apos;t rely on any side effects in those functions.</p>
<hr>
<p>These two forms of <code>observable</code>, one for primitives and references, and one for functions, form the core of MobX.
The rest of the API is just syntactic sugar around these two core operations.
Nonetheless, you will rarely use these forms; using objects is just a tat more convenient.</p>

                    
                    </section></div>
        </article>
      
        <article>
          <h3>autorun | MobX</h3>
          <div><div class="page-inner"><span>
                
                
                    </span><section class="normal" id="section-">
                    
                        <a id="edit-link" href="https://github.com/mobxjs/mobx/tree/gh-pages/docs/refguide/autorun.md" class="btn fa fa-edit pull-left">&#xA0;&#xA0;Edit This Page</a>
<p><code>mobx.autorun</code> can be used in those cases where you want to create a reactive function that will never have observers itself.
This is usually the case when you need to bridge from reactive to imperative code, for example for logging, persistence or UI-updating code.
When <code>autorun</code> is used, the provided function will always be triggered when one of its dependencies changes.
In contrast, <code>computed(function)</code> creates functions that only re-evaluate if it has
observers on its own, otherwise its value is considered to be irrelevant.
As a rule of thumb: use <code>autorun</code> if you have a function that should run automatically but that doesn&apos;t result in a new value.
Use <code>computed</code> for everything else. Autoruns are about initiating <em>effects</em>, not about producing new values.
If a string is passed as first argument to <code>autorun</code>, it will be used as debug name.</p>
<p>The function passed to autorun will receive one argument when invoked, the current reaction (autorun), which can be used to dispose the autorun during execution.</p>
<p>Just like the <a href="https://mobxjs.github.io/mobx/refguide/observer-component.html"><code>@observer</code> decorator/function</a>, <code>autorun</code> will only observe data that is used during the execution of the provided function.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> numbers = observable([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]);
<span class="hljs-keyword">var</span> sum = computed(() =&gt; numbers.reduce((a, b) =&gt; a + b, <span class="hljs-number">0</span>));

<span class="hljs-keyword">var</span> disposer = autorun(() =&gt; <span class="hljs-built_in">console</span>.log(sum.get()));

numbers.push(<span class="hljs-number">4</span>);


disposer();
numbers.push(<span class="hljs-number">5</span>);

</code></pre>

                    
                    </section><span>
                
                
                </span></div></div>
        </article>
      
        <article>
          <h3>(@)observer</h3>
          <div><section class="normal" id="section-">
                    
                        <a id="edit-link" href="https://github.com/mobxjs/mobx/tree/gh-pages/docs/refguide/observer-component.md" class="btn fa fa-edit pull-left">&#xA0;&#xA0;Edit This Page</a>
<p>The <code>observer</code> function / decorator can be used to turn ReactJS components into reactive components.
It wraps the component&apos;s render function in <code>mobx.autorun</code> to make sure that any data that is used during the rendering of a component forces a re-rendering upon change.
It is available through the separate <code>mobx-react</code> package.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">import</span> {observer} <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx-react&quot;</span>

var timerData = observable({
    secondsPassed: 0
})

setInterval(() =&gt; {
    timerData.secondsPassed++
}, 1000)

@observer class Timer extends React.Component {
    render() {
        return (&lt;span&gt;Seconds passed: { this.props.timerData.secondsPassed } &lt;/span&gt; )
    }
})

React.render(&lt;Timer timerData={timerData} /&gt;, document.body)
</code></pre>
<p>Tip: when <code>observer</code> needs to be combined with other decorators or higher-order-components, make sure that <code>observer</code> is the innermost (first applied) decorator;
otherwise it might do nothing at all.</p>
<p>Note that using <code>@observer</code> as decorator is optional, <code>observer(class Timer ... { })</code> achieves exactly the same.</p>
<h2 id="gotcha-dereference-values-inside-your-components">Gotcha: dereference values <em>inside</em> your components</h2>
<p>MobX can do a lot, but it cannot make primitive values observable (although it can wrap them in an object see <a href="https://mobxjs.github.io/mobx/refguide/boxed.html">boxed observables</a>).
So not the <em>values</em> that are observable, but the <em>properties</em> of an object. This means that <code>@observer</code> actually reacts to the fact that you dereference a value.
So in our above example, the <code>Timer</code> component would <strong>not</strong> react if it was initialized as follows:</p>
<pre><code class="lang-javascript">React.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">Timer</span> <span class="hljs-attribute">timerData</span>=<span class="hljs-value">{timerData.secondsPassed}</span> /&gt;</span>, document.body)
</span></code></pre>
<p>In this snippet just the current value of <code>secondsPassed</code> is passed to the <code>Timer</code>, which is the immutable value <code>0</code> (all primitives are immutable in JS).
That number won&apos;t change anymore in the future, so <code>Timer</code> will never update. It is the property <code>secondsPassed</code> that will change in the future,
so we need to access it <em>in</em> the component. Or in other words: values need to be passed <em>by reference</em> and not by value.</p>
<h2 id="es5-support">ES5 support</h2>
<p>In ES5 environments, observer components can be simple declared using <code>observer(React.createClass({ ...</code>. See also the <a href="https://mobxjs.github.io/mobx/best/syntax.html">syntax guide</a></p>
<h2 id="stateless-function-components">Stateless function components</h2>
<p>The above timer widget could also be written using stateless function components that are passed through <code>observer</code>:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">import</span> {observer} <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx-react&quot;</span>

const Timer = observer(({ timerData }) =&gt;
    &lt;span&gt;Seconds passed: { timerData.secondsPassed } &lt;/span&gt;
)
</code></pre>
<h2 id="observable-local-component-state">Observable local component state</h2>
<p>Just like normal classes, you can introduce observable properties on a component by using the <code>@observable</code> decorator.
This means that you can have local state in components that doesn&apos;t need to be manged by React&apos;s verbose and imperative <code>setState</code> mechanism, but is as powerful.
The reactive state will be picked up by <code>render</code> but will not explicitly invoke other React lifecycle methods like <code>componentShouldUpdate</code> or <code>componentWillUpdate</code>.
If you need those, just use the normal React <code>state</code> based APIs.</p>
<p>The example above could also have been written as:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">import</span> {observer} <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx-react&quot;</span>
<span class="hljs-keyword">import</span> {observable} <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx&quot;</span>

@observer class Timer extends React.Component {
    @observable secondsPassed = 0

    componentWillMount() {
        setInterval(() =&gt; {
            this.secondsPassed++
        }, 1000)
    }

    render() {
        return (&lt;span&gt;Seconds passed: { this.secondsPassed } &lt;/span&gt; )
    }
})

React.render(&lt;Timer /&gt;, document.body)
</code></pre>
<p>For more advantages of using observable local component state, see <a href="https://medium.com/@mweststrate/3-reasons-why-i-stopped-using-react-setstate-ab73fc67a42e" target="_blank">3 reasons why I stopped using <code>setState</code></a>.</p>
<h2 id="connect-observer-to-stores">Connect <code>observer</code> to stores</h2>
<p>The <code>mobx-react</code> package also provides the <code>Provider</code> component that can be used to pass down stores using React&apos;s context mechanism.
To connect to those stores, pass an array of store names to <code>observer</code>, which will make the stores available as props.
This is supported when using the decorator (<code>@observer([&quot;store&quot;]) class ...</code>, or the function `observer([&quot;store&quot;], React.createClass({ ...``.</p>
<p>Example:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> colors = observable({
   foreground: <span class="hljs-string">&apos;#000&apos;</span>,
   background: <span class="hljs-string">&apos;#fff&apos;</span>
})

<span class="hljs-keyword">const</span> App = () =&gt;
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">Provider</span> <span class="hljs-attribute">colors</span>=<span class="hljs-value">{colors}</span>&gt;</span>
     <span class="hljs-tag">&lt;<span class="hljs-title">app</span> <span class="hljs-attribute">stuff...</span> /&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-title">Provider</span>&gt;</span>

const Button = observer([&quot;colors&quot;], ({ colors, label, onClick }) =&gt;
  <span class="hljs-tag">&lt;<span class="hljs-title">button</span> <span class="hljs-attribute">style</span>=<span class="hljs-value">{{</span>
      <span class="hljs-attribute">color:</span> <span class="hljs-attribute">colors.foreground</span>,
      <span class="hljs-attribute">backgroundColor:</span> <span class="hljs-attribute">colors.background</span>
    }}
    <span class="hljs-attribute">onClick</span>=<span class="hljs-value">{onClick}</span>
  &gt;</span>{label}<span class="hljs-tag">&lt;<span class="hljs-title">button</span>&gt;</span>
)</span>


colors.foreground = <span class="hljs-string">&apos;blue&apos;</span>;

</code></pre>
<p>See for more information the <a href="https://github.com/mobxjs/mobx-react#provider-experimental" target="_blank"><code>mobx-react</code> docs</a>.</p>
<h2 id="when-to-apply-observer">When to apply <code>observer</code>?</h2>
<p>The simple rule of thumb is: <em>all components that render observable data</em>.
If you don&apos;t want to mark a component as observer, for example to reduce the dependencies of a generic component package, make sure you only pass it plain data.</p>
<p>With <code>@observer</code> there is no need to distinguish &apos;smart&apos; components from &apos;dumb&apos; components for the purpose of rendering.
It is still a good separation of concerns for where to handle events, make requests etc.
All components become responsible for updating when their <em>own</em> dependencies change.
Its overhead is neglectable and it makes sure that whenever you start using observable data the component will respond to it.
See this <a href="https://www.reddit.com/r/reactjs/comments/4vnxg5/free_eggheadio_course_learn_mobx_react_in_30/d61oh0l" target="_blank">thread</a> for more details.</p>
<h2 id="-observer-and-purerendermixin"><code>observer</code> and <code>PureRenderMixin</code></h2>
<p><code>observer</code> also prevents re-renderings when the <em>props</em> of the component have only shallowly changed, which makes a lot of sense if the data passed into the component is reactive.
This behavior is similar to <a href="https://facebook.github.io/react/docs/pure-render-mixin.html" target="_blank">React PureRender mixin</a>, except that <em>state</em> changes are still always processed.
If a component provides its own <code>shouldComponentUpdate</code>, that one takes precedence.
See for an explanation this <a href="https://github.com/mobxjs/mobx/issues/101" target="_blank">github issue</a></p>
<h2 id="-componentwillreact-lifecycle-hook"><code>componentWillReact</code> (lifecycle hook)</h2>
<p>React components usually render on a fresh stack, so that makes it often hard to figure out what <em>caused</em> a component to re-render.
When using <code>mobx-react</code> you can define a new life cycle hook, <code>componentWillReact</code> (pun intended) that will be triggered when a component will be scheduled to re-render because
data it observes has changed. This makes it easy to trace renders back to the action that caused the rendering.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">import</span> {observer} <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx-react&quot;</span>;

@observer <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TodoView</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
    componentWillReact() {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;I will re-render, since the todo has changed!&quot;</span>);
    }

    render() {
        <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">div</span>&gt;</span>this.props.todo.title<span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
    }
}
</span></code></pre>
<ul>
<li><code>componentWillReact</code> doesn&apos;t take arguments</li>
<li><code>componentWillReact</code> won&apos;t fire before the initial render (use <code>componentWillMount</code> instead)</li>
<li><code>componentWillReact</code> won&apos;t fire when receiving new props or after <code>setState</code> calls (use <code>componentWillUpdate</code> instead)</li>
</ul>
<h2 id="optimizing-components">Optimizing components</h2>
<p>See the relevant <a href="https://mobxjs.github.io/mobx/best/react-performance.html">section</a>.</p>
<h2 id="mobx-react-devtools">MobX-React-DevTools</h2>
<p>In combination with <code>@observer</code> you can use the MobX-React-DevTools, it shows exactly when your components are re-rendered and you can inspect the data dependencies of your components.
See the <a href="https://mobxjs.github.io/mobx/best/devtools.html">DevTools</a> section.</p>
<h2 id="characteristics-of-observer-components">Characteristics of observer components</h2>
<ul>
<li>Observer only subscribe to the data structures that were actively used during the last render. This means that you cannot under-subscribe or over-subscribe. You can even use data in your rendering that will only be available at later moment in time. This is ideal for asynchronously loading data.</li>
<li>You are not required to declare what data a component will use. Instead, dependencies are determined at runtime and tracked in a very fine-grained manner.</li>
<li>Usually reactive components have no or little state, as it is often more convenient to encapsulate (view) state in objects that are shared with other component. But you are still free to use state.</li>
<li><code>@observer</code> implements <code>shouldComponentUpdate</code> in the same way as <code>PureRenderMixin</code> so that children are not re-rendered unnecessary.</li>
<li>Reactive components sideways load data; parent components won&apos;t re-render unnecessarily even when child components will.</li>
<li><code>@observer</code> does not depend on React&apos;s context system.</li>
</ul>
<h2 id="enabling-es6-decorators-in-your-transpiler">Enabling ES6 decorators in your transpiler</h2>
<p>Decorators are not supported by default when using TypeScript or Babel pending a definitive definition in the ES standard.</p>
<ul>
<li>For <em>typescript</em>, enable the <code>--experimentalDecorators</code> compiler flag or set the compiler option <code>experimentalDecorators</code> to <code>true</code> in <code>tsconfig.json</code> (Recommended)</li>
<li>For <em>babel5</em>, make sure <code>--stage 0</code> is passed to the Babel CLI</li>
<li>For <em>babel6</em>, see the example configuration as suggested in this <a href="https://github.com/mobxjs/mobx/issues/105" target="_blank">issue</a></li>
</ul>

                    
                    </section></div>
        </article>
      
        <article>
          <h3>action | MobX</h3>
          <div><div class="page-inner"><span>
                
                
                    </span><section class="normal" id="section-">
                    
                        <a id="edit-link" href="https://github.com/mobxjs/mobx/tree/gh-pages/docs/refguide/action.md" class="btn fa fa-edit pull-left">&#xA0;&#xA0;Edit This Page</a>
<p>Usage:</p>
<ul>
<li><code>action(fn)</code></li>
<li><code>action(name, fn)</code></li>
<li><code>@action classMethod</code></li>
<li><code>@action(name) classMethod</code></li>
<li><code>@action boundClassMethod = (args) =&gt; { body }</code></li>
<li><code>@action(name) boundClassMethod = (args) =&gt; { body }</code></li>
</ul>
<p>Any application has actions. Actions are anything that modify the state.
With MobX you can make it explicit in your code where your actions live by marking them.
Actions help you to structure your code better.
It takes a function and returns it after wrapping it with <code>untracked</code>, <code>transaction</code> and <code>allowStateChanges</code>.
It is advised to use them on any function that modifies observables or has side effects.
<code>action</code> also provides useful debugging information in combination with the devtools.
Note: using <code>action</code> is mandatory when <em>strict mode</em> is enabled, see <a href="https://github.com/mobxjs/mobx/blob/gh-pages/docs/refguide/api.md#usestrict" target="_blank"><code>useStrict</code></a>. Using the <code>@action</code> decorator with <a href="http://www.ecma-international.org/ecma-262/5.1/#sec-11.1.5" target="_blank">ES 5.1 setters</a> (i.e. <code>@action set propertyName</code>) is not supported.</p>
<p>For an extensive introduction to <code>action</code> see also the <a href="https://medium.com/p/45cdc73c7c8d/" target="_blank">MobX 2.2 release notes</a>.</p>
<p>Two example actions from the <code>contact-list</code> project:</p>
<pre><code class="lang-javascript">    @action    createRandomContact() {
        <span class="hljs-keyword">this</span>.pendingRequestCount++;
        superagent
            .get(<span class="hljs-string">&apos;https://randomuser.me/api/&apos;</span>)
            .set(<span class="hljs-string">&apos;Accept&apos;</span>, <span class="hljs-string">&apos;application/json&apos;</span>)
            .end(action(<span class="hljs-string">&quot;createRandomContact-callback&quot;</span>, (error, results) =&gt; {
                <span class="hljs-keyword">if</span> (error)
                    <span class="hljs-built_in">console</span>.error(error);
                <span class="hljs-keyword">else</span> {
                    <span class="hljs-keyword">const</span> data = <span class="hljs-built_in">JSON</span>.parse(results.text).results[<span class="hljs-number">0</span>];
                    <span class="hljs-keyword">const</span> contact = <span class="hljs-keyword">new</span> Contact(<span class="hljs-keyword">this</span>, data.dob, data.name, data.login.username, data.picture)
                    contact.addTag(<span class="hljs-string">&apos;random-user&apos;</span>);
                    <span class="hljs-keyword">this</span>.contacts.push(contact);
                    <span class="hljs-keyword">this</span>.pendingRequestCount--;
                }
            }));
    }
</code></pre>

<p><code>action</code> only affects the currently running function, not functions that are scheduled (but not invoked) by the current function!
This means that if you have a <code>setTimeout</code>, promise<code>.then</code> or <code>async</code> construction, and in that callback some more state is changed, those callbacks should be wrapped in <code>action</code> as well!
This is demonstrated above with the <code>&quot;createRandomContact-callback&quot;</code> action.</p>
<p>If you use <code>async</code> / <code>await</code>, this is a bit trickier as you cannot just wrap the async function body in <code>action</code>.
In this situation <code>runInAction</code> can come in handy, wrap this around the places where you intend to update the state.
(But don&apos;t make <code>await</code> calls in these blocks).</p>
<p>Example:</p>
<pre><code class="lang-javascript">@action  updateDocument = <span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> fetchDataFromUrl();
    
    runInAction(<span class="hljs-string">&quot;update state after fetching data&quot;</span>, () =&gt; {
        <span class="hljs-keyword">this</span>.data.replace(data);
        <span class="hljs-keyword">this</span>.isSaving = <span class="hljs-literal">true</span>;
    })
}
</code></pre>
<p>The usage of <code>runInAction</code> is: <code>runInAction(name?, fn, scope?)</code>.</p>

                    
                    </section><span>
                
                
                </span></div></div>
        </article>
      <h2></h2>
        <article>
          <h3>observable | MobX</h3>
          <div><div class="page-inner"><span>
                
                
                    </span><section class="normal" id="section-">
                    
                        <a id="edit-link" href="https://github.com/mobxjs/mobx/tree/gh-pages/docs/refguide/observable.md" class="btn fa fa-edit pull-left">&#xA0;&#xA0;Edit This Page</a>
<p>Usage: </p>
<ul>
<li><code>observable(value)</code></li>
<li><code>@observable classProperty = value</code> </li>
</ul>
<p>Observable values can be JS primitives, references, plain objects, class instances, arrays and maps.
The following conversion rules are applied, but can be fine-tuned by using <em>modifiers</em>. See below.</p>
<ol>
<li>If <em>value</em> is wrapped in the <em>modifier</em> <code>asMap</code>: a new <a href="https://mobxjs.github.io/mobx/refguide/map.html">Observable Map</a> will be returned. Observable maps are very useful if you don&apos;t want to react just to the change of a specific entry, but also to the addition or removal of entries.</li>
<li>If <em>value</em> is an array, a new <a href="https://mobxjs.github.io/mobx/refguide/array.html">Observable Array</a> will be returned.</li>
<li>If <em>value</em> is an object <em>without</em> prototype, all its current properties will be made observable. See <a href="https://mobxjs.github.io/mobx/refguide/object.html">Observable Object</a></li>
<li>If <em>value</em> is an object <em>with</em> a prototype, a JavaScript primitive or function, a <a href="https://mobxjs.github.io/mobx/refguide/boxed.html">Boxed Observable</a> will be returned. MobX will not make objects with a prototype automatically observable; as that is the responsibility of its constructor function. Use <code>extendObservable</code> in the constructor, or <code>@observable</code> in its class definition instead.</li>
</ol>
<p>These rules might seem complicated at first sight, but you will notice that in practice they are very intuitive to work with.
Some notes:</p>
<ul>
<li>To create dynamically keyed objects use the <code>asMap</code> modifier! Only initially existing properties on an object will be made observable, although new ones can be added using <code>extendObservable</code>.</li>
<li>To use the <code>@observable</code> decorator, make sure that <a href="http://mobxjs.github.io/mobx/refguide/observable-decorator.html" target="_blank">decorators are enabled</a> in your transpiler (babel or typescript).</li>
<li>By default, making a data structure observable is <em>infective</em>; that means that <code>observable</code> is applied automatically to any value that is contained by the data structure, or will be contained by the data structure in the future. This behavior can be changed by using <em>modifiers</em>.</li>
</ul>
<p>Some examples:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> map = observable(asMap({ key: <span class="hljs-string">&quot;value&quot;</span>}));
map.set(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;new value&quot;</span>);

<span class="hljs-keyword">const</span> list = observable([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>]);
list[<span class="hljs-number">2</span>] = <span class="hljs-number">3</span>;

<span class="hljs-keyword">const</span> person = observable({
    firstName: <span class="hljs-string">&quot;Clive Staples&quot;</span>,
    lastName: <span class="hljs-string">&quot;Lewis&quot;</span>
});
person.firstName = <span class="hljs-string">&quot;C.S.&quot;</span>;

<span class="hljs-keyword">const</span> temperature = observable(<span class="hljs-number">20</span>);
temperature.set(<span class="hljs-number">25</span>);
</code></pre>

                    
                    </section><span>
                
                
                </span></div></div>
        </article>
      <h2></h2>
        <article>
          <h3>@observable</h3>
          <div><div class="page-inner"><span>
                
                
                    </span><section class="normal" id="section-">
                    
                        <a id="edit-link" href="https://github.com/mobxjs/mobx/tree/gh-pages/docs/refguide/observable-decorator.md" class="btn fa fa-edit pull-left">&#xA0;&#xA0;Edit This Page</a>
<p>Decorator that can be used on ES7- or TypeScript class properties to make them observable.
The @observable can be used on instance fields and property getters.
This offers fine-grained control on which parts of your object become observable.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">import</span> {observable} <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx&quot;</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderLine</span> </span>{
    @observable price:number = <span class="hljs-number">0</span>;
    @observable amount:number = <span class="hljs-number">1</span>;

    constructor(price) {
        <span class="hljs-keyword">this</span>.price = price;
    }

    @computed get total() {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.price * <span class="hljs-keyword">this</span>.amount;
    }
}
</code></pre>
<p>If your environment doesn&apos;t support decorators or field initializers,
<code>@observable key = value;</code> is sugar for <a href="https://mobxjs.github.io/mobx/refguide/extend-observable.html"><code>extendObservable(this, { key: value })</code></a></p>
<p>Enumerability: properties decorator with <code>@observable</code> are enumerable, but defined on the class prototype and not on the class instances.
In other words:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> line = <span class="hljs-keyword">new</span> OrderLine();
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;price&quot;</span> <span class="hljs-keyword">in</span> line) 
<span class="hljs-built_in">console</span>.log(line.hasOwnProperty(<span class="hljs-string">&quot;price&quot;</span>)) 
</code></pre>
<p>The <code>@observable</code> decorator can be combined with modifiers like <code>asStructure</code>:</p>
<pre><code class="lang-javascript">@observable position = asStructure({ x: <span class="hljs-number">0</span>, y: <span class="hljs-number">0</span>})
</code></pre>
<h3 id="enabling-decorators-in-your-transpiler">Enabling decorators in your transpiler</h3>
<p>Decorators are not supported by default when using TypeScript or Babel pending a definitive definition in the ES standard.</p>
<ul>
<li>For <em>typescript</em>, enable the <code>--experimentalDecorators</code> compiler flag or set the compiler option <code>experimentalDecorators</code> to <code>true</code> in <code>tsconfig.json</code> (Recommended)</li>
<li>For <em>babel5</em>, make sure <code>--stage 0</code> is passed to the Babel CLI</li>
<li>For <em>babel6</em>, see the example configuration as suggested in this <a href="https://github.com/mobxjs/mobx/issues/105" target="_blank">issue</a></li>
</ul>

                    
                    </section><span>
                
                
                </span></div></div>
        </article>
      <h2></h2>
        <article>
          <h3>(@)computed</h3>
          <div><section class="normal" id="section-">
                    
                        <a id="edit-link" href="https://github.com/mobxjs/mobx/tree/gh-pages/docs/refguide/computed-decorator.md" class="btn fa fa-edit pull-left">&#xA0;&#xA0;Edit This Page</a><h1 id="-computed">@computed</h1>
<p>Decorator that can be used on ES6 or TypeScript derivable class properties to make them observable.
The <code>@computed</code> can only be used on <code>get</code> functions for instance properties.</p>
<p>Use <code>@computed</code> if you have a value that can be derived in a pure manner from other observables.</p>
<p>Don&apos;t confuse <code>@computed</code> with <code>autorun</code>. They are both reactively invoked expressions,
but use <code>@computed</code> if you want to reactively produce a new value that can be used by other observers and
<code>autorun</code> if you don&apos;t want to produce a new value but rather invoke some imperative code like logging, network requests etc.</p>
<p>Computed properties can be optimized away in many cases by MobX as they are assumed to be pure.
So they will not be invoked when their input parameters didn&apos;t modifiy or if they are not observed by some other computed value or autorun.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">import</span> {observable, computed} <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx&quot;</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderLine</span> </span>{
    @observable price:number = <span class="hljs-number">0</span>;
    @observable amount:number = <span class="hljs-number">1</span>;

    constructor(price) {
        <span class="hljs-keyword">this</span>.price = price;
    }

    @computed get total() {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.price * <span class="hljs-keyword">this</span>.amount;
    }
}
</code></pre>
<p>If your environment doesn&apos;t support decorators or field initializers,
<code>@computed get funcName() { }</code> is sugar for <a href="https://mobxjs.github.io/mobx/refguide/extend-observable.html"><code>extendObservable(this, { funcName: func })</code></a></p>
<p><code>@computed</code> can be parameterized. <code>@computed({asStructure: true})</code> makes sure that the result of a derivation is compared structurally instead of referentially with its preview value. This makes sure that observers of the computation don&apos;t re-evaluate if new structures are returned that are structurally equal to the original ones. This is very useful when working with point, vector or color structures for example. It behaves the same as the <code>asStructure</code> modifier for observable values.</p>
<p><code>@computed</code> properties are not enumerable.</p>
<h3 id="enabling-decorators-in-your-transpiler">Enabling decorators in your transpiler</h3>
<p>Decorators are not supported by default when using TypeScript or Babel pending a definitive definition in the ES standard.</p>
<ul>
<li>For <em>typescript</em>, enable the <code>--experimentalDecorators</code> compiler flag or set the compiler option <code>experimentalDecorators</code> to <code>true</code> in <code>tsconfig.json</code> (Recommended)</li>
<li>For <em>babel5</em>, make sure <code>--stage 0</code> is passed to the Babel CLI</li>
<li>For <em>babel6</em>, see the example configuration as suggested in this <a href="https://github.com/mobxjs/mobx/issues/105" target="_blank">issue</a></li>
</ul>
<h1 id="-computed-expression"><code>computed(expression)</code></h1>
<p><code>computed</code> can also be invoked directly as function.
Just like <code>observable(primitive value)</code> it will create a stand-alone observable.
Use <code>.get()</code> on the returned object to get the current value of the computation, or <code>.observe(callback)</code> to observe it&apos;s changes.</p>
<p>Example:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">import</span> {observable, computed} <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx&quot;</span>;
<span class="hljs-keyword">var</span> name = observable(<span class="hljs-string">&quot;John&quot;</span>);
<span class="hljs-keyword">var</span> age = observable(<span class="hljs-number">42</span>);
<span class="hljs-keyword">var</span> showAge = observable(<span class="hljs-literal">false</span>);

<span class="hljs-keyword">var</span> labelText = computed(() =&gt;
    showAge.get() ? <span class="hljs-string">`<span class="hljs-subst">${name.get()}</span> (age: <span class="hljs-subst">${age.get()}</span>)`</span> : name.get();
);

<span class="hljs-keyword">var</span> disposer = labelText.observe(newLabel =&gt; <span class="hljs-built_in">console</span>.log(newLabel));

name.set(<span class="hljs-string">&quot;Dave&quot;</span>);


age.set(<span class="hljs-number">21</span>);


showAge.set(<span class="hljs-literal">true</span>);


age.set(<span class="hljs-number">42</span>);



disposer();

name.set(<span class="hljs-string">&quot;Matthew&quot;</span>);



<span class="hljs-built_in">console</span>.log(labelText.get());
</code></pre>
<p>Note how the function now automatically reacts to data changes,
but only if they occurred in data that was actually used to produce the output.
Hence the first change to <code>age</code> didn&apos;t result in a re-evaluation of the <code>labelText</code> function.
MobX will automatically determine whether the function should run <em>eagerly</em> or <em>lazily</em> based on how the views are used throughout your application,
so make sure your code doesn&apos;t rely on any side effects in those functions.</p>
<hr>
<p>These two forms of <code>observable</code>, one for primitives and references, and one for functions, form the core of MobX.
The rest of the API is just syntactic sugar around these two core operations.
Nonetheless, you will rarely use these forms; using objects is just a tat more convenient.</p>

                    
                    </section></div>
        </article>
      <h2></h2>
        <article>
          <h3>autorun | MobX</h3>
          <div><div class="page-inner"><span>
                
                
                    </span><section class="normal" id="section-">
                    
                        <a id="edit-link" href="https://github.com/mobxjs/mobx/tree/gh-pages/docs/refguide/autorun.md" class="btn fa fa-edit pull-left">&#xA0;&#xA0;Edit This Page</a>
<p><code>mobx.autorun</code> can be used in those cases where you want to create a reactive function that will never have observers itself.
This is usually the case when you need to bridge from reactive to imperative code, for example for logging, persistence or UI-updating code.
When <code>autorun</code> is used, the provided function will always be triggered when one of its dependencies changes.
In contrast, <code>computed(function)</code> creates functions that only re-evaluate if it has
observers on its own, otherwise its value is considered to be irrelevant.
As a rule of thumb: use <code>autorun</code> if you have a function that should run automatically but that doesn&apos;t result in a new value.
Use <code>computed</code> for everything else. Autoruns are about initiating <em>effects</em>, not about producing new values.
If a string is passed as first argument to <code>autorun</code>, it will be used as debug name.</p>
<p>The function passed to autorun will receive one argument when invoked, the current reaction (autorun), which can be used to dispose the autorun during execution.</p>
<p>Just like the <a href="https://mobxjs.github.io/mobx/refguide/observer-component.html"><code>@observer</code> decorator/function</a>, <code>autorun</code> will only observe data that is used during the execution of the provided function.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> numbers = observable([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]);
<span class="hljs-keyword">var</span> sum = computed(() =&gt; numbers.reduce((a, b) =&gt; a + b, <span class="hljs-number">0</span>));

<span class="hljs-keyword">var</span> disposer = autorun(() =&gt; <span class="hljs-built_in">console</span>.log(sum.get()));

numbers.push(<span class="hljs-number">4</span>);


disposer();
numbers.push(<span class="hljs-number">5</span>);

</code></pre>

                    
                    </section><span>
                
                
                </span></div></div>
        </article>
      <h2></h2>
        <article>
          <h3>(@)observer</h3>
          <div><section class="normal" id="section-">
                    
                        <a id="edit-link" href="https://github.com/mobxjs/mobx/tree/gh-pages/docs/refguide/observer-component.md" class="btn fa fa-edit pull-left">&#xA0;&#xA0;Edit This Page</a>
<p>The <code>observer</code> function / decorator can be used to turn ReactJS components into reactive components.
It wraps the component&apos;s render function in <code>mobx.autorun</code> to make sure that any data that is used during the rendering of a component forces a re-rendering upon change.
It is available through the separate <code>mobx-react</code> package.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">import</span> {observer} <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx-react&quot;</span>

var timerData = observable({
    secondsPassed: 0
})

setInterval(() =&gt; {
    timerData.secondsPassed++
}, 1000)

@observer class Timer extends React.Component {
    render() {
        return (&lt;span&gt;Seconds passed: { this.props.timerData.secondsPassed } &lt;/span&gt; )
    }
})

React.render(&lt;Timer timerData={timerData} /&gt;, document.body)
</code></pre>
<p>Tip: when <code>observer</code> needs to be combined with other decorators or higher-order-components, make sure that <code>observer</code> is the innermost (first applied) decorator;
otherwise it might do nothing at all.</p>
<p>Note that using <code>@observer</code> as decorator is optional, <code>observer(class Timer ... { })</code> achieves exactly the same.</p>
<h2 id="gotcha-dereference-values-inside-your-components">Gotcha: dereference values <em>inside</em> your components</h2>
<p>MobX can do a lot, but it cannot make primitive values observable (although it can wrap them in an object see <a href="https://mobxjs.github.io/mobx/refguide/boxed.html">boxed observables</a>).
So not the <em>values</em> that are observable, but the <em>properties</em> of an object. This means that <code>@observer</code> actually reacts to the fact that you dereference a value.
So in our above example, the <code>Timer</code> component would <strong>not</strong> react if it was initialized as follows:</p>
<pre><code class="lang-javascript">React.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">Timer</span> <span class="hljs-attribute">timerData</span>=<span class="hljs-value">{timerData.secondsPassed}</span> /&gt;</span>, document.body)
</span></code></pre>
<p>In this snippet just the current value of <code>secondsPassed</code> is passed to the <code>Timer</code>, which is the immutable value <code>0</code> (all primitives are immutable in JS).
That number won&apos;t change anymore in the future, so <code>Timer</code> will never update. It is the property <code>secondsPassed</code> that will change in the future,
so we need to access it <em>in</em> the component. Or in other words: values need to be passed <em>by reference</em> and not by value.</p>
<h2 id="es5-support">ES5 support</h2>
<p>In ES5 environments, observer components can be simple declared using <code>observer(React.createClass({ ...</code>. See also the <a href="https://mobxjs.github.io/mobx/best/syntax.html">syntax guide</a></p>
<h2 id="stateless-function-components">Stateless function components</h2>
<p>The above timer widget could also be written using stateless function components that are passed through <code>observer</code>:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">import</span> {observer} <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx-react&quot;</span>

const Timer = observer(({ timerData }) =&gt;
    &lt;span&gt;Seconds passed: { timerData.secondsPassed } &lt;/span&gt;
)
</code></pre>
<h2 id="observable-local-component-state">Observable local component state</h2>
<p>Just like normal classes, you can introduce observable properties on a component by using the <code>@observable</code> decorator.
This means that you can have local state in components that doesn&apos;t need to be manged by React&apos;s verbose and imperative <code>setState</code> mechanism, but is as powerful.
The reactive state will be picked up by <code>render</code> but will not explicitly invoke other React lifecycle methods like <code>componentShouldUpdate</code> or <code>componentWillUpdate</code>.
If you need those, just use the normal React <code>state</code> based APIs.</p>
<p>The example above could also have been written as:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">import</span> {observer} <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx-react&quot;</span>
<span class="hljs-keyword">import</span> {observable} <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx&quot;</span>

@observer class Timer extends React.Component {
    @observable secondsPassed = 0

    componentWillMount() {
        setInterval(() =&gt; {
            this.secondsPassed++
        }, 1000)
    }

    render() {
        return (&lt;span&gt;Seconds passed: { this.secondsPassed } &lt;/span&gt; )
    }
})

React.render(&lt;Timer /&gt;, document.body)
</code></pre>
<p>For more advantages of using observable local component state, see <a href="https://medium.com/@mweststrate/3-reasons-why-i-stopped-using-react-setstate-ab73fc67a42e" target="_blank">3 reasons why I stopped using <code>setState</code></a>.</p>
<h2 id="connect-observer-to-stores">Connect <code>observer</code> to stores</h2>
<p>The <code>mobx-react</code> package also provides the <code>Provider</code> component that can be used to pass down stores using React&apos;s context mechanism.
To connect to those stores, pass an array of store names to <code>observer</code>, which will make the stores available as props.
This is supported when using the decorator (<code>@observer([&quot;store&quot;]) class ...</code>, or the function `observer([&quot;store&quot;], React.createClass({ ...``.</p>
<p>Example:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> colors = observable({
   foreground: <span class="hljs-string">&apos;#000&apos;</span>,
   background: <span class="hljs-string">&apos;#fff&apos;</span>
})

<span class="hljs-keyword">const</span> App = () =&gt;
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">Provider</span> <span class="hljs-attribute">colors</span>=<span class="hljs-value">{colors}</span>&gt;</span>
     <span class="hljs-tag">&lt;<span class="hljs-title">app</span> <span class="hljs-attribute">stuff...</span> /&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-title">Provider</span>&gt;</span>

const Button = observer([&quot;colors&quot;], ({ colors, label, onClick }) =&gt;
  <span class="hljs-tag">&lt;<span class="hljs-title">button</span> <span class="hljs-attribute">style</span>=<span class="hljs-value">{{</span>
      <span class="hljs-attribute">color:</span> <span class="hljs-attribute">colors.foreground</span>,
      <span class="hljs-attribute">backgroundColor:</span> <span class="hljs-attribute">colors.background</span>
    }}
    <span class="hljs-attribute">onClick</span>=<span class="hljs-value">{onClick}</span>
  &gt;</span>{label}<span class="hljs-tag">&lt;<span class="hljs-title">button</span>&gt;</span>
)</span>


colors.foreground = <span class="hljs-string">&apos;blue&apos;</span>;

</code></pre>
<p>See for more information the <a href="https://github.com/mobxjs/mobx-react#provider-experimental" target="_blank"><code>mobx-react</code> docs</a>.</p>
<h2 id="when-to-apply-observer">When to apply <code>observer</code>?</h2>
<p>The simple rule of thumb is: <em>all components that render observable data</em>.
If you don&apos;t want to mark a component as observer, for example to reduce the dependencies of a generic component package, make sure you only pass it plain data.</p>
<p>With <code>@observer</code> there is no need to distinguish &apos;smart&apos; components from &apos;dumb&apos; components for the purpose of rendering.
It is still a good separation of concerns for where to handle events, make requests etc.
All components become responsible for updating when their <em>own</em> dependencies change.
Its overhead is neglectable and it makes sure that whenever you start using observable data the component will respond to it.
See this <a href="https://www.reddit.com/r/reactjs/comments/4vnxg5/free_eggheadio_course_learn_mobx_react_in_30/d61oh0l" target="_blank">thread</a> for more details.</p>
<h2 id="-observer-and-purerendermixin"><code>observer</code> and <code>PureRenderMixin</code></h2>
<p><code>observer</code> also prevents re-renderings when the <em>props</em> of the component have only shallowly changed, which makes a lot of sense if the data passed into the component is reactive.
This behavior is similar to <a href="https://facebook.github.io/react/docs/pure-render-mixin.html" target="_blank">React PureRender mixin</a>, except that <em>state</em> changes are still always processed.
If a component provides its own <code>shouldComponentUpdate</code>, that one takes precedence.
See for an explanation this <a href="https://github.com/mobxjs/mobx/issues/101" target="_blank">github issue</a></p>
<h2 id="-componentwillreact-lifecycle-hook"><code>componentWillReact</code> (lifecycle hook)</h2>
<p>React components usually render on a fresh stack, so that makes it often hard to figure out what <em>caused</em> a component to re-render.
When using <code>mobx-react</code> you can define a new life cycle hook, <code>componentWillReact</code> (pun intended) that will be triggered when a component will be scheduled to re-render because
data it observes has changed. This makes it easy to trace renders back to the action that caused the rendering.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">import</span> {observer} <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx-react&quot;</span>;

@observer <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TodoView</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
    componentWillReact() {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;I will re-render, since the todo has changed!&quot;</span>);
    }

    render() {
        <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">div</span>&gt;</span>this.props.todo.title<span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
    }
}
</span></code></pre>
<ul>
<li><code>componentWillReact</code> doesn&apos;t take arguments</li>
<li><code>componentWillReact</code> won&apos;t fire before the initial render (use <code>componentWillMount</code> instead)</li>
<li><code>componentWillReact</code> won&apos;t fire when receiving new props or after <code>setState</code> calls (use <code>componentWillUpdate</code> instead)</li>
</ul>
<h2 id="optimizing-components">Optimizing components</h2>
<p>See the relevant <a href="https://mobxjs.github.io/mobx/best/react-performance.html">section</a>.</p>
<h2 id="mobx-react-devtools">MobX-React-DevTools</h2>
<p>In combination with <code>@observer</code> you can use the MobX-React-DevTools, it shows exactly when your components are re-rendered and you can inspect the data dependencies of your components.
See the <a href="https://mobxjs.github.io/mobx/best/devtools.html">DevTools</a> section.</p>
<h2 id="characteristics-of-observer-components">Characteristics of observer components</h2>
<ul>
<li>Observer only subscribe to the data structures that were actively used during the last render. This means that you cannot under-subscribe or over-subscribe. You can even use data in your rendering that will only be available at later moment in time. This is ideal for asynchronously loading data.</li>
<li>You are not required to declare what data a component will use. Instead, dependencies are determined at runtime and tracked in a very fine-grained manner.</li>
<li>Usually reactive components have no or little state, as it is often more convenient to encapsulate (view) state in objects that are shared with other component. But you are still free to use state.</li>
<li><code>@observer</code> implements <code>shouldComponentUpdate</code> in the same way as <code>PureRenderMixin</code> so that children are not re-rendered unnecessary.</li>
<li>Reactive components sideways load data; parent components won&apos;t re-render unnecessarily even when child components will.</li>
<li><code>@observer</code> does not depend on React&apos;s context system.</li>
</ul>
<h2 id="enabling-es6-decorators-in-your-transpiler">Enabling ES6 decorators in your transpiler</h2>
<p>Decorators are not supported by default when using TypeScript or Babel pending a definitive definition in the ES standard.</p>
<ul>
<li>For <em>typescript</em>, enable the <code>--experimentalDecorators</code> compiler flag or set the compiler option <code>experimentalDecorators</code> to <code>true</code> in <code>tsconfig.json</code> (Recommended)</li>
<li>For <em>babel5</em>, make sure <code>--stage 0</code> is passed to the Babel CLI</li>
<li>For <em>babel6</em>, see the example configuration as suggested in this <a href="https://github.com/mobxjs/mobx/issues/105" target="_blank">issue</a></li>
</ul>

                    
                    </section></div>
        </article>
      <h2></h2>
        <article>
          <h3>action | MobX</h3>
          <div><div class="page-inner"><span>
                
                
                    </span><section class="normal" id="section-">
                    
                        <a id="edit-link" href="https://github.com/mobxjs/mobx/tree/gh-pages/docs/refguide/action.md" class="btn fa fa-edit pull-left">&#xA0;&#xA0;Edit This Page</a>
<p>Usage:</p>
<ul>
<li><code>action(fn)</code></li>
<li><code>action(name, fn)</code></li>
<li><code>@action classMethod</code></li>
<li><code>@action(name) classMethod</code></li>
<li><code>@action boundClassMethod = (args) =&gt; { body }</code></li>
<li><code>@action(name) boundClassMethod = (args) =&gt; { body }</code></li>
</ul>
<p>Any application has actions. Actions are anything that modify the state.
With MobX you can make it explicit in your code where your actions live by marking them.
Actions help you to structure your code better.
It takes a function and returns it after wrapping it with <code>untracked</code>, <code>transaction</code> and <code>allowStateChanges</code>.
It is advised to use them on any function that modifies observables or has side effects.
<code>action</code> also provides useful debugging information in combination with the devtools.
Note: using <code>action</code> is mandatory when <em>strict mode</em> is enabled, see <a href="https://github.com/mobxjs/mobx/blob/gh-pages/docs/refguide/api.md#usestrict" target="_blank"><code>useStrict</code></a>. Using the <code>@action</code> decorator with <a href="http://www.ecma-international.org/ecma-262/5.1/#sec-11.1.5" target="_blank">ES 5.1 setters</a> (i.e. <code>@action set propertyName</code>) is not supported.</p>
<p>For an extensive introduction to <code>action</code> see also the <a href="https://medium.com/p/45cdc73c7c8d/" target="_blank">MobX 2.2 release notes</a>.</p>
<p>Two example actions from the <code>contact-list</code> project:</p>
<pre><code class="lang-javascript">    @action    createRandomContact() {
        <span class="hljs-keyword">this</span>.pendingRequestCount++;
        superagent
            .get(<span class="hljs-string">&apos;https://randomuser.me/api/&apos;</span>)
            .set(<span class="hljs-string">&apos;Accept&apos;</span>, <span class="hljs-string">&apos;application/json&apos;</span>)
            .end(action(<span class="hljs-string">&quot;createRandomContact-callback&quot;</span>, (error, results) =&gt; {
                <span class="hljs-keyword">if</span> (error)
                    <span class="hljs-built_in">console</span>.error(error);
                <span class="hljs-keyword">else</span> {
                    <span class="hljs-keyword">const</span> data = <span class="hljs-built_in">JSON</span>.parse(results.text).results[<span class="hljs-number">0</span>];
                    <span class="hljs-keyword">const</span> contact = <span class="hljs-keyword">new</span> Contact(<span class="hljs-keyword">this</span>, data.dob, data.name, data.login.username, data.picture)
                    contact.addTag(<span class="hljs-string">&apos;random-user&apos;</span>);
                    <span class="hljs-keyword">this</span>.contacts.push(contact);
                    <span class="hljs-keyword">this</span>.pendingRequestCount--;
                }
            }));
    }
</code></pre>

<p><code>action</code> only affects the currently running function, not functions that are scheduled (but not invoked) by the current function!
This means that if you have a <code>setTimeout</code>, promise<code>.then</code> or <code>async</code> construction, and in that callback some more state is changed, those callbacks should be wrapped in <code>action</code> as well!
This is demonstrated above with the <code>&quot;createRandomContact-callback&quot;</code> action.</p>
<p>If you use <code>async</code> / <code>await</code>, this is a bit trickier as you cannot just wrap the async function body in <code>action</code>.
In this situation <code>runInAction</code> can come in handy, wrap this around the places where you intend to update the state.
(But don&apos;t make <code>await</code> calls in these blocks).</p>
<p>Example:</p>
<pre><code class="lang-javascript">@action  updateDocument = <span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> fetchDataFromUrl();
    
    runInAction(<span class="hljs-string">&quot;update state after fetching data&quot;</span>, () =&gt; {
        <span class="hljs-keyword">this</span>.data.replace(data);
        <span class="hljs-keyword">this</span>.isSaving = <span class="hljs-literal">true</span>;
    })
}
</code></pre>
<p>The usage of <code>runInAction</code> is: <code>runInAction(name?, fn, scope?)</code>.</p>

                    
                    </section><span>
                
                
                </span></div></div>
        </article>
      <h2>3. Observable Types</h2>
        <article>
          <h3>objects | MobX</h3>
          <div><div class="page-inner"><span>
                
                
                    </span><section class="normal" id="section-">
                    
                        <a id="edit-link" href="https://github.com/mobxjs/mobx/tree/gh-pages/docs/refguide/object.md" class="btn fa fa-edit pull-left">&#xA0;&#xA0;Edit This Page</a>
<p>If a plain JavaScript object is passed to <code>observable</code> all properties inside that object will be made observable. 
(A plain object is an object that wasn&apos;t created using a constructor function)
<code>observable</code> is by default applied recursively, so if one of the encoutered values is an object or array, that value will be passed through <code>observable</code> as well.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">import</span> {observable, autorun, action} <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx&quot;</span>;

<span class="hljs-keyword">var</span> person = observable({
    
    name: <span class="hljs-string">&quot;John&quot;</span>,
    age: <span class="hljs-number">42</span>,
    showAge: <span class="hljs-literal">false</span>,
    
    labelText: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.showAge ? <span class="hljs-string">`<span class="hljs-subst">${this.name}</span> (age: <span class="hljs-subst">${this.age}</span>)`</span> : <span class="hljs-keyword">this</span>.name;
    },
    
    setAge: action(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">this</span>.age = <span class="hljs-number">21</span>;
    })
});



autorun(() =&gt; <span class="hljs-built_in">console</span>.log(person.labelText));

person.name = <span class="hljs-string">&quot;Dave&quot;</span>;


person.setAge(<span class="hljs-number">21</span>);

</code></pre>
<p>Some things to keep in mind when making objects observable:</p>
<ul>
<li>When passing objects through <code>observable</code>, only the properties that exist at the time of making the object observable will be observable.
Properties that are added to the object at a later time won&apos;t become observable, unless <a href="https://mobxjs.github.io/mobx/refguide/extend-observable.html"><code>extendObservable</code></a> is used.</li>
<li>Only plain objects will be made observable. For non-plain objects it is considered the responsibility of the constructor to initialize the observable properties.
Either use the <a href="https://mobxjs.github.io/mobx/refguide/observable.html"><code>@observable</code></a> annotation or the <a href="https://mobxjs.github.io/mobx/refguide/extend-observable.html"><code>extendObservable</code></a> function.</li>
<li>Argumentless functions will be automatically turned into views, just like <a href="https://mobxjs.github.io/mobx/refguide/computed-decorator"><code>@computed</code></a> would do. For view <code>this</code> will be automatically bound to the object it is defined on.
However, if a function expression (ES6 / TypeScript) is used, <code>this</code> will be bound to <code>undefined</code>, so you probably want to either to refer to the object directly, or to use a classic function.</li>
<li>However (argumentless) functions that are declared as <code>action</code> will not be converted into computed views, but will keep their semantics.</li>
<li><code>observable</code> is applied recursively to a whole object graph automatically. Both on instantiation and to any new values that will be assigned to observable properties in the future. Observable will not recurse into non-plain objects.</li>
<li>These defaults are fine in 95% of the cases, but for more fine-grained on how and which properties should be made observable, see the <a href="https://mobxjs.github.io/mobx/refguide/modifiers.html">modifiers</a> section.</li>
</ul>

                    
                    </section><span>
                
                
                </span></div></div>
        </article>
      
        <article>
          <h3>arrays | MobX</h3>
          <div><div class="page-inner"><span>
                
                
                    </span><section class="normal" id="section-">
                    
                        <a id="edit-link" href="https://github.com/mobxjs/mobx/tree/gh-pages/docs/refguide/array.md" class="btn fa fa-edit pull-left">&#xA0;&#xA0;Edit This Page</a>
<p>Similar to objects, arrays can be made observable using <code>observable</code>.
This works recursively as well, so all (future) values of the array will also be observable.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">import</span> {observable, autorun} <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx&quot;</span>;

<span class="hljs-keyword">var</span> todos = observable([
    { title: <span class="hljs-string">&quot;Spoil tea&quot;</span>, completed: <span class="hljs-literal">true</span> },
    { title: <span class="hljs-string">&quot;Make coffee&quot;</span>, completed: <span class="hljs-literal">false</span> }
]);

autorun(() =&gt; {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Remaining:&quot;</span>, todos
        .filter(todo =&gt; !todo.completed)
        .map(todo =&gt; todo.title)
        .join(<span class="hljs-string">&quot;, &quot;</span>)
    );
});


todos[<span class="hljs-number">0</span>].completed = <span class="hljs-literal">false</span>;


todos[<span class="hljs-number">2</span>] = { title: <span class="hljs-string">&apos;Take a nap&apos;</span>, completed: <span class="hljs-literal">false</span> };


todos.shift();

</code></pre>
<p>Due to limitations of native arrays in ES5 (<code>array.observe</code> is only available in ES7, and arrays cannot be extend),
<code>observable</code> will instrument a clone of the provided array instead of the original one.
In practice, these arrays work just as fine as native arrays and all native methods are supported, including index assignments, up-to and including the length of the array.</p>
<p>Bear in mind however that <code>Array.isArray(observable([]))</code> will yield <code>false</code>, so whenever you need to pass an observable array to an external library,
it is a good idea to <em>create a shallow copy before passing it to other libraries or built-in functions</em> (which is good practice anyway) by using <code>array.slice()</code>.
In other words, <code>Array.isArray(observable([]).slice())</code> will yield <code>true</code>.</p>
<p>Unlike the built-in implementation of the functions <code>sort</code> and <code>reverse</code>, observableArray.sort and reverse  will not change the array in-place, but only will return a sorted / reversed copy.</p>
<p>Besides all built-in functions, the following goodies are available as well on observable arrays:</p>
<ul>
<li><code>intercept(interceptor)</code>. Can be used to intercept any change before it is applied to the array. See <a href="https://mobxjs.github.io/mobx/refguide/observe.html">observe &amp; intercept</a> </li>
<li><code>observe(listener, fireImmediately? = false)</code> Listen to changes in this array. The callback will receive arguments that express an array splice or array change, conforming to <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/observe" target="_blank">ES7 proposal</a>. It returns a disposer function to stop the listener.</li>
<li><code>clear()</code> Remove all current entries from the array.</li>
<li><code>replace(newItems)</code> Replaces all existing entries in the array with new ones.</li>
<li><code>find(predicate: (item, index, array) =&gt; boolean, thisArg?, fromIndex?)</code> Basically the same as the ES7 <code>Array.find</code> proposal, except for the additional <code>fromIndex</code> parameter.</li>
<li><code>remove(value)</code> Remove a single item by value from the array. Returns <code>true</code> if the item was found and removed.</li>
<li><code>peek()</code> Returns an array with all the values which can safely be passed to other libraries, similar to <code>slice()</code>.
In contrast to <code>slice</code>, <code>peek</code> doesn&apos;t create a defensive copy. Use this in performance critical applications if you know for sure that you use the array in a read-only manner.
In performance critical sections it is recommended to use a flat observable array as well.</li>
</ul>

                    
                    </section><span>
                
                
                </span></div></div>
        </article>
      
        <article>
          <h3>maps | MobX</h3>
          <div><div class="page-inner"><span>
                
                
                    </span><section class="normal" id="section-">
                    
                        <a id="edit-link" href="https://github.com/mobxjs/mobx/tree/gh-pages/docs/refguide/map.md" class="btn fa fa-edit pull-left">&#xA0;&#xA0;Edit This Page</a>
<p><code>observable(asMap(values?, modifier?))</code> (and <code>map(values?, modifier?)</code>) creates a dynamic keyed observable map.
Observable maps are very useful if you don&apos;t want to react just to the change of a specific entry, but also to the addition or removal of entries.
Optionally takes an object or entries array with initial values.
Unlike ES6 maps, only strings are accepted as keys.
The modifier param can be one of the MobX <a href="https://mobxjs.github.io/mobx/refguide/modifiers.html">modifiers</a>, such as <code>asReference</code>.</p>
<p>The following methods are exposed according to the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map" target="_blank">ES6 Map spec</a>:</p>
<ul>
<li><code>has(key)</code> Returns whether this map has an entry the provided key. Note that the presence of a key is an observable fact in itself.</li>
<li><code>set(key, value)</code>. Sets the given <code>key</code> to <code>value</code>. The provided key will be added to the map if it didn&apos;t exist yet.</li>
<li><code>delete(key)</code>. Deletes the given key and its value from the map.</li>
<li><code>get(key)</code>. Returns the value at the given key (or <code>undefined</code>). Make sure that you guard <code>get</code> calls with <code>has</code>.</li>
<li><code>keys()</code>. Returns all keys present in this map. The insertion order is preserved.</li>
<li><code>values()</code>. Returns all values present in this map. Insertion order is preserved.</li>
<li><code>entries()</code>. Returns an (insertion ordered) array that for each key/value pair in the map contains an array <code>[key, value]</code>.</li>
<li><code>forEach(callback:(value, key, map) =&gt; void, thisArg?)</code>. Invokes the given callback for each key / value pair in the map.</li>
<li><code>clear()</code>. Removes all entries from this map.</li>
<li><code>size</code>. Returns the amount of entries in this map.</li>
</ul>
<p>The following functions are not in the ES6 spec but are available in MobX:</p>
<ul>
<li><p><code>toJS()</code>. Returns a shallow plain object representation of this map. (For a deep copy use <code>mobx.toJS(map)</code>).</p>
</li>
<li><p><code>intercept(interceptor)</code>. Registers an interceptor that will be triggered before any changes are applied to the map. See <a href="https://mobxjs.github.io/mobx/refguide/observe.html">observe &amp; intercept</a>. </p>
</li>
<li><code>observe(listener, fireImmediately?)</code>. Registers a listener that fires upon each change in this map, similarly to the events that are emitted for <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/observe" target="_blank">Object.observe</a>. See <a href="https://mobxjs.github.io/mobx/refguide/observe.html">observe &amp; intercept</a> for more details.</li>
<li><code>merge(object | map)</code>. Copies all entries from the provided object into this map.</li>
</ul>

                    
                    </section><span>
                
                
                </span></div></div>
        </article>
      
        <article>
          <h3>boxed values</h3>
          <div><div class="page-inner"><span>
                
                
                    </span><section class="normal" id="section-">
                    
                        <a id="edit-link" href="https://github.com/mobxjs/mobx/tree/gh-pages/docs/refguide/boxed.md" class="btn fa fa-edit pull-left">&#xA0;&#xA0;Edit This Page</a>
<p>All primitive values in JavaScript are immutable and hence per definition not observable.
Usually that is fine, as MobX usually can just make the <em>property</em> that contains the value observable.
See also <a href="https://mobxjs.github.io/mobx/refguide/object.html">observable objects</a>.
In rare cases it can be convenient to have an observable &quot;primitive&quot; that is not owned by an object.
For these cases it is possible to create an observable box that manages such a primitive. </p>
<p>So <code>observable</code> accepts scalar values as well and returns an object with a getter / setter function that holds this value.
Furthermore you can register a callback using its <code>.observe</code> method to listen to changes on the stored value.
But in most cases it is better to use <a href="https://mobxjs.github.io/mobx/refguide/autorun.html"><code>mobx.autorun</code></a> instead.</p>
<p>So the signature of object returned by <code>observable(scalar)</code> is:</p>
<ul>
<li><code>.get()</code> Returns the current value.</li>
<li><code>.set(value)</code> Replaces the currently stored value. Notifies all observers.</li>
<li><code>intercept(interceptor)</code>. Can be used to intercept changes before they are applied. See <a href="https://mobxjs.github.io/mobx/refguide/observe.html">observe &amp; intercept</a></li>
<li><code>.observe(callback: (newValue, previousValue) =&gt; void, fireImmediately = false): disposerFunction</code>. Registers an observer function that will fire each time the stored value is replaced. Returns a function to cancel the observer. See <a href="https://mobxjs.github.io/mobx/refguide/observe.html">observe &amp; intercept</a></li>
</ul>
<p>Example:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">import</span> {observable} <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx&quot;</span>;

<span class="hljs-keyword">const</span> cityName = observable(<span class="hljs-string">&quot;Vienna&quot;</span>);

<span class="hljs-built_in">console</span>.log(cityName.get());


cityName.observe(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">newCity, oldCity</span>) </span>{
    <span class="hljs-built_in">console</span>.log(oldCity, <span class="hljs-string">&quot;-&gt;&quot;</span>, newCity);
});

cityName.set(<span class="hljs-string">&quot;Amsterdam&quot;</span>);

</code></pre>

                    
                    </section><span>
                
                
                </span></div></div>
        </article>
      <h2></h2>
        <article>
          <h3>objects | MobX</h3>
          <div><div class="page-inner"><span>
                
                
                    </span><section class="normal" id="section-">
                    
                        <a id="edit-link" href="https://github.com/mobxjs/mobx/tree/gh-pages/docs/refguide/object.md" class="btn fa fa-edit pull-left">&#xA0;&#xA0;Edit This Page</a>
<p>If a plain JavaScript object is passed to <code>observable</code> all properties inside that object will be made observable. 
(A plain object is an object that wasn&apos;t created using a constructor function)
<code>observable</code> is by default applied recursively, so if one of the encoutered values is an object or array, that value will be passed through <code>observable</code> as well.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">import</span> {observable, autorun, action} <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx&quot;</span>;

<span class="hljs-keyword">var</span> person = observable({
    
    name: <span class="hljs-string">&quot;John&quot;</span>,
    age: <span class="hljs-number">42</span>,
    showAge: <span class="hljs-literal">false</span>,
    
    labelText: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.showAge ? <span class="hljs-string">`<span class="hljs-subst">${this.name}</span> (age: <span class="hljs-subst">${this.age}</span>)`</span> : <span class="hljs-keyword">this</span>.name;
    },
    
    setAge: action(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">this</span>.age = <span class="hljs-number">21</span>;
    })
});



autorun(() =&gt; <span class="hljs-built_in">console</span>.log(person.labelText));

person.name = <span class="hljs-string">&quot;Dave&quot;</span>;


person.setAge(<span class="hljs-number">21</span>);

</code></pre>
<p>Some things to keep in mind when making objects observable:</p>
<ul>
<li>When passing objects through <code>observable</code>, only the properties that exist at the time of making the object observable will be observable.
Properties that are added to the object at a later time won&apos;t become observable, unless <a href="https://mobxjs.github.io/mobx/refguide/extend-observable.html"><code>extendObservable</code></a> is used.</li>
<li>Only plain objects will be made observable. For non-plain objects it is considered the responsibility of the constructor to initialize the observable properties.
Either use the <a href="https://mobxjs.github.io/mobx/refguide/observable.html"><code>@observable</code></a> annotation or the <a href="https://mobxjs.github.io/mobx/refguide/extend-observable.html"><code>extendObservable</code></a> function.</li>
<li>Argumentless functions will be automatically turned into views, just like <a href="https://mobxjs.github.io/mobx/refguide/computed-decorator"><code>@computed</code></a> would do. For view <code>this</code> will be automatically bound to the object it is defined on.
However, if a function expression (ES6 / TypeScript) is used, <code>this</code> will be bound to <code>undefined</code>, so you probably want to either to refer to the object directly, or to use a classic function.</li>
<li>However (argumentless) functions that are declared as <code>action</code> will not be converted into computed views, but will keep their semantics.</li>
<li><code>observable</code> is applied recursively to a whole object graph automatically. Both on instantiation and to any new values that will be assigned to observable properties in the future. Observable will not recurse into non-plain objects.</li>
<li>These defaults are fine in 95% of the cases, but for more fine-grained on how and which properties should be made observable, see the <a href="https://mobxjs.github.io/mobx/refguide/modifiers.html">modifiers</a> section.</li>
</ul>

                    
                    </section><span>
                
                
                </span></div></div>
        </article>
      <h2></h2>
        <article>
          <h3>arrays | MobX</h3>
          <div><div class="page-inner"><span>
                
                
                    </span><section class="normal" id="section-">
                    
                        <a id="edit-link" href="https://github.com/mobxjs/mobx/tree/gh-pages/docs/refguide/array.md" class="btn fa fa-edit pull-left">&#xA0;&#xA0;Edit This Page</a>
<p>Similar to objects, arrays can be made observable using <code>observable</code>.
This works recursively as well, so all (future) values of the array will also be observable.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">import</span> {observable, autorun} <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx&quot;</span>;

<span class="hljs-keyword">var</span> todos = observable([
    { title: <span class="hljs-string">&quot;Spoil tea&quot;</span>, completed: <span class="hljs-literal">true</span> },
    { title: <span class="hljs-string">&quot;Make coffee&quot;</span>, completed: <span class="hljs-literal">false</span> }
]);

autorun(() =&gt; {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Remaining:&quot;</span>, todos
        .filter(todo =&gt; !todo.completed)
        .map(todo =&gt; todo.title)
        .join(<span class="hljs-string">&quot;, &quot;</span>)
    );
});


todos[<span class="hljs-number">0</span>].completed = <span class="hljs-literal">false</span>;


todos[<span class="hljs-number">2</span>] = { title: <span class="hljs-string">&apos;Take a nap&apos;</span>, completed: <span class="hljs-literal">false</span> };


todos.shift();

</code></pre>
<p>Due to limitations of native arrays in ES5 (<code>array.observe</code> is only available in ES7, and arrays cannot be extend),
<code>observable</code> will instrument a clone of the provided array instead of the original one.
In practice, these arrays work just as fine as native arrays and all native methods are supported, including index assignments, up-to and including the length of the array.</p>
<p>Bear in mind however that <code>Array.isArray(observable([]))</code> will yield <code>false</code>, so whenever you need to pass an observable array to an external library,
it is a good idea to <em>create a shallow copy before passing it to other libraries or built-in functions</em> (which is good practice anyway) by using <code>array.slice()</code>.
In other words, <code>Array.isArray(observable([]).slice())</code> will yield <code>true</code>.</p>
<p>Unlike the built-in implementation of the functions <code>sort</code> and <code>reverse</code>, observableArray.sort and reverse  will not change the array in-place, but only will return a sorted / reversed copy.</p>
<p>Besides all built-in functions, the following goodies are available as well on observable arrays:</p>
<ul>
<li><code>intercept(interceptor)</code>. Can be used to intercept any change before it is applied to the array. See <a href="https://mobxjs.github.io/mobx/refguide/observe.html">observe &amp; intercept</a> </li>
<li><code>observe(listener, fireImmediately? = false)</code> Listen to changes in this array. The callback will receive arguments that express an array splice or array change, conforming to <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/observe" target="_blank">ES7 proposal</a>. It returns a disposer function to stop the listener.</li>
<li><code>clear()</code> Remove all current entries from the array.</li>
<li><code>replace(newItems)</code> Replaces all existing entries in the array with new ones.</li>
<li><code>find(predicate: (item, index, array) =&gt; boolean, thisArg?, fromIndex?)</code> Basically the same as the ES7 <code>Array.find</code> proposal, except for the additional <code>fromIndex</code> parameter.</li>
<li><code>remove(value)</code> Remove a single item by value from the array. Returns <code>true</code> if the item was found and removed.</li>
<li><code>peek()</code> Returns an array with all the values which can safely be passed to other libraries, similar to <code>slice()</code>.
In contrast to <code>slice</code>, <code>peek</code> doesn&apos;t create a defensive copy. Use this in performance critical applications if you know for sure that you use the array in a read-only manner.
In performance critical sections it is recommended to use a flat observable array as well.</li>
</ul>

                    
                    </section><span>
                
                
                </span></div></div>
        </article>
      <h2></h2>
        <article>
          <h3>maps | MobX</h3>
          <div><div class="page-inner"><span>
                
                
                    </span><section class="normal" id="section-">
                    
                        <a id="edit-link" href="https://github.com/mobxjs/mobx/tree/gh-pages/docs/refguide/map.md" class="btn fa fa-edit pull-left">&#xA0;&#xA0;Edit This Page</a>
<p><code>observable(asMap(values?, modifier?))</code> (and <code>map(values?, modifier?)</code>) creates a dynamic keyed observable map.
Observable maps are very useful if you don&apos;t want to react just to the change of a specific entry, but also to the addition or removal of entries.
Optionally takes an object or entries array with initial values.
Unlike ES6 maps, only strings are accepted as keys.
The modifier param can be one of the MobX <a href="https://mobxjs.github.io/mobx/refguide/modifiers.html">modifiers</a>, such as <code>asReference</code>.</p>
<p>The following methods are exposed according to the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map" target="_blank">ES6 Map spec</a>:</p>
<ul>
<li><code>has(key)</code> Returns whether this map has an entry the provided key. Note that the presence of a key is an observable fact in itself.</li>
<li><code>set(key, value)</code>. Sets the given <code>key</code> to <code>value</code>. The provided key will be added to the map if it didn&apos;t exist yet.</li>
<li><code>delete(key)</code>. Deletes the given key and its value from the map.</li>
<li><code>get(key)</code>. Returns the value at the given key (or <code>undefined</code>). Make sure that you guard <code>get</code> calls with <code>has</code>.</li>
<li><code>keys()</code>. Returns all keys present in this map. The insertion order is preserved.</li>
<li><code>values()</code>. Returns all values present in this map. Insertion order is preserved.</li>
<li><code>entries()</code>. Returns an (insertion ordered) array that for each key/value pair in the map contains an array <code>[key, value]</code>.</li>
<li><code>forEach(callback:(value, key, map) =&gt; void, thisArg?)</code>. Invokes the given callback for each key / value pair in the map.</li>
<li><code>clear()</code>. Removes all entries from this map.</li>
<li><code>size</code>. Returns the amount of entries in this map.</li>
</ul>
<p>The following functions are not in the ES6 spec but are available in MobX:</p>
<ul>
<li><p><code>toJS()</code>. Returns a shallow plain object representation of this map. (For a deep copy use <code>mobx.toJS(map)</code>).</p>
</li>
<li><p><code>intercept(interceptor)</code>. Registers an interceptor that will be triggered before any changes are applied to the map. See <a href="https://mobxjs.github.io/mobx/refguide/observe.html">observe &amp; intercept</a>. </p>
</li>
<li><code>observe(listener, fireImmediately?)</code>. Registers a listener that fires upon each change in this map, similarly to the events that are emitted for <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/observe" target="_blank">Object.observe</a>. See <a href="https://mobxjs.github.io/mobx/refguide/observe.html">observe &amp; intercept</a> for more details.</li>
<li><code>merge(object | map)</code>. Copies all entries from the provided object into this map.</li>
</ul>

                    
                    </section><span>
                
                
                </span></div></div>
        </article>
      <h2></h2>
        <article>
          <h3>boxed values</h3>
          <div><div class="page-inner"><span>
                
                
                    </span><section class="normal" id="section-">
                    
                        <a id="edit-link" href="https://github.com/mobxjs/mobx/tree/gh-pages/docs/refguide/boxed.md" class="btn fa fa-edit pull-left">&#xA0;&#xA0;Edit This Page</a>
<p>All primitive values in JavaScript are immutable and hence per definition not observable.
Usually that is fine, as MobX usually can just make the <em>property</em> that contains the value observable.
See also <a href="https://mobxjs.github.io/mobx/refguide/object.html">observable objects</a>.
In rare cases it can be convenient to have an observable &quot;primitive&quot; that is not owned by an object.
For these cases it is possible to create an observable box that manages such a primitive. </p>
<p>So <code>observable</code> accepts scalar values as well and returns an object with a getter / setter function that holds this value.
Furthermore you can register a callback using its <code>.observe</code> method to listen to changes on the stored value.
But in most cases it is better to use <a href="https://mobxjs.github.io/mobx/refguide/autorun.html"><code>mobx.autorun</code></a> instead.</p>
<p>So the signature of object returned by <code>observable(scalar)</code> is:</p>
<ul>
<li><code>.get()</code> Returns the current value.</li>
<li><code>.set(value)</code> Replaces the currently stored value. Notifies all observers.</li>
<li><code>intercept(interceptor)</code>. Can be used to intercept changes before they are applied. See <a href="https://mobxjs.github.io/mobx/refguide/observe.html">observe &amp; intercept</a></li>
<li><code>.observe(callback: (newValue, previousValue) =&gt; void, fireImmediately = false): disposerFunction</code>. Registers an observer function that will fire each time the stored value is replaced. Returns a function to cancel the observer. See <a href="https://mobxjs.github.io/mobx/refguide/observe.html">observe &amp; intercept</a></li>
</ul>
<p>Example:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">import</span> {observable} <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx&quot;</span>;

<span class="hljs-keyword">const</span> cityName = observable(<span class="hljs-string">&quot;Vienna&quot;</span>);

<span class="hljs-built_in">console</span>.log(cityName.get());


cityName.observe(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">newCity, oldCity</span>) </span>{
    <span class="hljs-built_in">console</span>.log(oldCity, <span class="hljs-string">&quot;-&gt;&quot;</span>, newCity);
});

cityName.set(<span class="hljs-string">&quot;Amsterdam&quot;</span>);

</code></pre>

                    
                    </section><span>
                
                
                </span></div></div>
        </article>
      <h2></h2>
        <article>
          <h3>Understanding what MobX reacts to</h3>
          <div><section class="normal" id="section-">
                    
                        <a id="edit-link" href="https://github.com/mobxjs/mobx/tree/gh-pages/docs/best/react.md" class="btn fa fa-edit pull-left">&#xA0;&#xA0;Edit This Page</a>
<p>MobX usually reacts to exactly the things you expect it to.
Which means that in 90% of your use cases mobx &quot;just works&quot;.
However, at some point you will encounter a case where it might not do what you expected.
At that point it is invaluable to understand how MobX determines what to react to.</p>
<blockquote>
<p>MobX reacts to any an <em>existing</em> <strong>observable</strong> <em>property</em> that is read during the execution of a tracked function.</p>
</blockquote>
<ul>
<li><em>&quot;reading&quot;</em> is &quot;dotting into&quot; an observable property, also called dereferencing.</li>
<li><em>&quot;trackable functions&quot;</em> are the expression of <code>computed</code>, the <code>render()</code> method of an observer component, and the functions that are passed as the first param to <code>when</code>, <code>reaction</code> and <code>autorun</code>.</li>
<li><em>&quot;during&quot;</em> means that only those observables that are being read while the function is executing are tracked. It doesn&apos;t matter whether these values are used directly or indirectly by the tracked function.  </li>
</ul>
<p>In other words, MobX will not react to:</p>
<ul>
<li>Values that are obtained from observables, but outside a tracked function</li>
<li>Observables that are read in an asynchronously invoked code block</li>
</ul>
<h2 id="mobx-tracks-property-access-not-values">MobX tracks property access, not values</h2>
<p>To elaborate on the above rules with an example, suppose that you have the following observable data structure (<code>observable</code> applies itself recursively by default, so all fields in this example are observable):</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">let</span> message = observable({
    title: <span class="hljs-string">&quot;Foo&quot;</span>,
    author: {
        name: <span class="hljs-string">&quot;Michel&quot;</span>
    },
    likes: [
        <span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-string">&quot;Sara&quot;</span>
    ]
})
</code></pre>
<p>In memory that looks as follows. The green boxes indicate <em>observable</em> properties. Note that the <em>values</em> themselves are not observable!</p>
<p><img src="https://mobxjs.github.io/mobx/images/observed-refs.png" alt="MobX reacts to changing references"></p>
<p>Now what MobX basically does is recording which <em>arrows</em> you use in your function. After that, it will re-run whenever one of this <em>arrows</em> changes; when they start to refer to something else.</p>
<h2 id="examples">Examples</h2>
<p>Lets show that with a bunch of examples (based on the <code>message</code> variable defined above):</p>
<h4 id="correct-dereference-inside-the-tracked-function">Correct: dereference inside the tracked function</h4>
<pre><code class="lang-javascript">autorun(() =&gt; {
    <span class="hljs-built_in">console</span>.log(message.title)
})
message.title = <span class="hljs-string">&quot;Bar&quot;</span>
</code></pre>
<p>This will react as expected, the <code>.title</code> property was dereferenced by the autorun, and changed afterwards, so this change is detected.</p>
<p>You can verify what MobX will track by calling <code>whyRun()</code> inside the tracked function. In the case of the above function it will output the following:</p>
<pre><code class="lang-javascript">autorun(() =&gt; {
    <span class="hljs-built_in">console</span>.log(message.title)
    whyRun() 
})


WhyRun? reaction <span class="hljs-string">&apos;Autorun@1&apos;</span>:
 * Status: [running]
 * This reaction will re-run <span class="hljs-keyword">if</span> any <span class="hljs-keyword">of</span> the following observables changes:
    ObservableObject@<span class="hljs-number">1.</span>title
</code></pre>
<h4 id="incorrect-changing-a-non-observable-reference">Incorrect: changing a non-observable reference</h4>
<pre><code class="lang-javascript">autorun(() =&gt; {
    <span class="hljs-built_in">console</span>.log(message.title)
})
message = observable({ title: <span class="hljs-string">&quot;Bar&quot;</span> })
</code></pre>
<p>This will <strong>not</strong> react. <code>message</code> was changed, but <code>message</code> is not an observable, just a variable which <em>refers to</em> an observable,
but the variable (reference) itself is not observable.   </p>
<h4 id="incorrect-dereference-outside-a-tracked-function">Incorrect: dereference outside a tracked function</h4>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> title = message.title;
autorun(() =&gt; {
    <span class="hljs-built_in">console</span>.log(title)
})
message.title = <span class="hljs-string">&quot;Bar&quot;</span>
</code></pre>
<p>This will <strong>not</strong> react. <code>message.title</code> was dereferenced outside the <code>autorun</code>, and just contains the value of <code>message.title</code> at the  moment of dereferencing (the string <code>&quot;Foo&quot;</code>).
<code>title</code> is not an observable so <code>autorun</code> will never react.  </p>
<h4 id="correct-dereference-inside-the-tracked-function">Correct: dereference inside the tracked function</h4>
<pre><code class="lang-javascript">autorun(() =&gt; {
    <span class="hljs-built_in">console</span>.log(message.author.name)
})
message.author.name = <span class="hljs-string">&quot;Sara&quot;</span>;
message.author = { name: <span class="hljs-string">&quot;John&quot;</span> };
</code></pre>
<p>This will react to both changes. Both <code>author</code> and <code>author.name</code> are dotted into, allowing MobX to track these references.</p>
<h4 id="incorrect-store-a-local-reference-to-an-observable-object-without-tracking">Incorrect: store a local reference to an observable object without tracking</h4>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> author = message.author;
autorun(() =&gt; {
    <span class="hljs-built_in">console</span>.log(author.name)
})
message.author.name = <span class="hljs-string">&quot;Sara&quot;</span>;
message.author = { name: <span class="hljs-string">&quot;John&quot;</span> };
</code></pre>
<p>The first change will be picked up, <code>message.author</code> and <code>author</code> are the same object, and the <code>.name</code> property is dereferenced in the autorun.
However the second change will <strong>not</strong> be picked up, the <code>message.author</code> relation is not tracked by the <code>autorun</code>. Autorun is still using the &quot;old&quot; <code>author</code>.</p>
<h4 id="correct-access-array-properties-in-tracked-function">Correct: access array properties in tracked function</h4>
<pre><code class="lang-javascript">autorun(() =&gt; {
    <span class="hljs-built_in">console</span>.log(message.likes.length);
})
message.likes.push(<span class="hljs-string">&quot;Jennifer&quot;</span>);
</code></pre>
<p>This will react as expected. <code>.length</code> counts towards a property.
Note that this will react to <em>any</em> change in the array.
Arrays are not tracked per index / property (like observable objects and maps) but as a whole.</p>
<h4 id="incorrect-access-out-of-bounds-indices-in-tracked-function">Incorrect: access out-of-bounds indices in tracked function</h4>
<pre><code class="lang-javascript">autorun(() =&gt; {
    <span class="hljs-built_in">console</span>.log(message.likes[<span class="hljs-number">0</span>]);
})
message.likes.push(<span class="hljs-string">&quot;Jennifer&quot;</span>);
</code></pre>
<p>This will react with the above sample data, array indexers count as property access. But <strong>only</strong> if the provided <code>index &lt; length</code>.
MobX will not track not-yet-existing indices or object properties (except when using maps).
So always guard your array index based access with a <code>.length</code> check.</p>
<h4 id="correct-access-array-functions-in-tracked-function">Correct: access array functions in tracked function</h4>
<pre><code class="lang-javascript">autorun(() =&gt; {
    <span class="hljs-built_in">console</span>.log(message.likes.join(<span class="hljs-string">&quot;, &quot;</span>));
})
message.likes.push(<span class="hljs-string">&quot;Jennifer&quot;</span>);
</code></pre>
<p>This will react as expected. All array functions that do not mutate the array are tracked automatically. </p>
<hr>
<pre><code class="lang-javascript">autorun(() =&gt; {
    <span class="hljs-built_in">console</span>.log(message.likes.join(<span class="hljs-string">&quot;, &quot;</span>));
})
message.likes[<span class="hljs-number">2</span>] = <span class="hljs-string">&quot;Jennifer&quot;</span>;
</code></pre>
<p>This will react as expected. All array index assignments are detected, but only if <code>index &lt;= length</code>.</p>
<h4 id="incorrect-use-an-observable-but-without-accessing-any-of-its-properties">Incorrect: &quot;use&quot; an observable but without accessing any of its properties</h4>
<pre><code class="lang-javascript">autorun(() =&gt; {
    message.likes;
})
message.likes.push(<span class="hljs-string">&quot;Jennifer&quot;</span>);
</code></pre>
<p>This will <strong>not</strong> react. Simply because the <code>likes</code> array itself is not being used by the <code>autorun</code>, only the reference to the array.
So in contrast, <code>messages.likes = [&quot;Jennifer&quot;]</code> would be picked up; that statement does not modify the array, but the <code>likes</code> property itself.</p>
<h4 id="incorrect-using-non-observable-object-properties">Incorrect: using non-observable object properties</h4>
<pre><code class="lang-javascript">autorun(() =&gt; {
    <span class="hljs-built_in">console</span>.log(message.postDate)
})
message.postDate = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()
</code></pre>
<p>This will <strong>not</strong> react. MobX can only track observable properties.</p>
<h4 id="incorrect-using-not-yet-existing-observable-object-properties">Incorrect: using not yet existing observable object properties</h4>
<pre><code class="lang-javascript">autorun(() =&gt; {
    <span class="hljs-built_in">console</span>.log(message.postDate)
})
extendObservable(message, {
    postDate: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()
})
</code></pre>
<p>This will <strong>not</strong> react. MobX will not react to observable properties that did not exist when tracking started. 
If the two statements are swapped, or if any other observable causes the <code>autorun</code> to re-run, the <code>autorun</code> will start tracking the <code>postDate</code> as well.</p>
<h4 id="correct-using-not-yet-existing-map-entries">Correct: using not yet existing map entries</h4>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> twitterUrls = observable(asMap({
    <span class="hljs-string">&quot;John&quot;</span>: <span class="hljs-string">&quot;twitter.com/johnny&quot;</span>
}))

autorun(() =&gt; {
    <span class="hljs-built_in">console</span>.log(twitterUrls.get(<span class="hljs-string">&quot;Sara&quot;</span>))
})
twitterUrls.set(<span class="hljs-string">&quot;Sara&quot;</span>, <span class="hljs-string">&quot;twitter.com/horsejs&quot;</span>)
</code></pre>
<p>This <strong>will</strong> react. Observable maps support observing entries that may not exist.
Note that this will initially print <code>undefined</code>.
You can check for the existence of an entry first by using <code>twitterUrls.has(&quot;Sara&quot;)</code>.
So for dynamically keyed collections, always use observable maps.</p>
<h2 id="mobx-only-tracks-synchronously-accessed-data">MobX only tracks synchronously accessed data</h2>
<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">upperCaseAuthorName</span>(<span class="hljs-params">author</span>) </span>{
    <span class="hljs-keyword">const</span> baseName = author.name;
    <span class="hljs-keyword">return</span> baseName.toUpperCase();
}
autorun(() =&gt; {
    <span class="hljs-built_in">console</span>.log(upperCaseAuthorName(message.author))
})
message.author.name = <span class="hljs-string">&quot;Chesterton&quot;</span>
</code></pre>
<p>This will react. Even though <code>author.name</code> is not dereferenced by the thunk passed to <code>autorun</code> itself,
MobX will still track the dereferencing that happens in <code>upperCaseAuthorName</code>,
because it happens <em>during</em> the execution of the autorun.</p>
<hr>
<pre><code class="lang-javascript">autorun(() =&gt; {
    setTimeout(
        () =&gt; <span class="hljs-built_in">console</span>.log(message.likes.join(<span class="hljs-string">&quot;, &quot;</span>)),
        <span class="hljs-number">10</span>
    )
})
message.likes.push(<span class="hljs-string">&quot;Jennifer&quot;</span>);
</code></pre>
<p>This will <strong>not</strong> react, during the execution of the <code>autorun</code> no observables where accessed, only during the <code>setTimeout</code>.
In general this is quite obvious and rarely causes issues. 
The notable caveat here is passing renderable callbacks to React components, take for example the following example:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> MyComponent = observer(({ message }) =&gt; 
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">SomeContainer</span>
        <span class="hljs-attribute">title</span> = {() =&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-title">div</span>&gt;</span>{message.title}<span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>}
    /&gt;
)</span>

message.title = <span class="hljs-string">&quot;Bar&quot;</span>
</code></pre>
<p>At first glance everything might seem ok here, except that the <code>&lt;div&gt;</code> is actually not rendered by <code>MyComponent</code> (which has a tracked rendering), but by <code>SomeContainer</code>.
So to make sure that the title of <code>SomeContainer</code> correctly reacts to a new <code>message.title</code>, <code>SomeContainer</code> should be an <code>observer</code> as well.
If <code>SomeContainer</code> comes from an external lib, you can also fix this by wrapping the <code>div</code> in it&apos;s own stateless <code>observer</code> based component, and instantiating that one in the callback:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> MyComponent = observer(({ message }) =&gt; 
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">SomeContainer</span>
        <span class="hljs-attribute">title</span> = {() =&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-title">TitleRenderer</span> <span class="hljs-attribute">message</span>=<span class="hljs-value">{message}</span> /&gt;</span>}
    /&gt;
)</span>

<span class="hljs-keyword">const</span> TitleRenderer = observer(({ message }) =&gt; 
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">div</span>&gt;</span>{message.title}<span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>}
)

message.title = &quot;Bar&quot;
</span></code></pre>
<h2 id="avoid-caching-observables-in-local-fields">Avoid caching observables in local fields</h2>
<p>A common mistake is to store local variables that dereference observables, and then expect components to react. For example:</p>
<pre><code class="lang-javascript">@observer <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">component</span> </span>{
    author;
    constructor(props) {
        <span class="hljs-keyword">super</span>(props)
        <span class="hljs-keyword">this</span>.author = props.message.author;
    }

    render() {
        <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">div</span>&gt;</span>{author.name}<span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
    }
}
</span></code></pre>
<p>This component will react to changes in the <code>author</code>&apos;s name, but it won&apos;t react to changing the <code>.author</code> of the <code>message</code> itself! Because that dereferencing happened outside <code>render()</code>,
which is the only tracked function of an <code>observer</code> component.
Note that even marking the <code>author</code> component field as <code>@observable</code> field does not solve this; that field is still assigned only once. 
This can simply be solved by doing the dereferencing inside <code>render()</code>, or by introducing a computed property on the component instance:</p>
<pre><code class="lang-javascript">@observer <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">component</span> </span>{
    @computed get author() {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.props.message.author
    }

</code></pre>
<h2 id="how-multiple-components-will-render">How multiple components will render</h2>
<p>Suppose that we use the following components are used to render our above <code>message</code> object.</p>
<pre><code class="lang-javascript">const Message = observer(({ message }) =&gt; 
    &lt;div&gt;
        {message.title}
        &lt;Author author={ message.author } /&gt;
        &lt;Likes likes={ message.likes } /&gt;
    &lt;/div&gt;
)

const Author = observer(({ author }) =&gt; 
    &lt;span&gt;{author.name}&lt;/span&gt;
)

const Likes = observer(({ likes }) =&gt; 
    &lt;ul&gt;
        {likes.map(like =&gt;
            &lt;li&gt;{like}&lt;/li&gt;
        )}
    &lt;/ul&gt;
)
</code></pre>
<table>
<thead>
<tr>
<th>change</th>
<th>re-rendering component</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>message.title = &quot;Bar&quot;</code></td>
<td><code>Message</code></td>
</tr>
<tr>
<td><code>message.author.name = &quot;Susan&quot;</code></td>
<td><code>Author</code> (<code>.author</code> is dereferenced in <code>Message</code>, but didn&apos;t change)*</td>
</tr>
<tr>
<td><code>message.author = { name: &quot;Susan&quot;}</code></td>
<td><code>Message</code>, <code>Author</code></td>
</tr>
<tr>
<td><code>message.likes[0] = &quot;Michel&quot;</code></td>
<td><code>Likes</code></td>
</tr>
</tbody>
</table>
<p>Notes:</p>
<ol>
<li>* If the <code>Author</code> component was invoked like: <code>&lt;Author author={ message.author.name} /&gt;</code>. Then <code>Message</code> would be the dereferencing component and react to changes to <code>message.author.name</code>. Nonetheless <code>&lt;Author&gt;</code> would rerender as well, because it receives a new value. So performance wise it is best to dereference as late as possible.</li>
<li>** If likes where objects instead of strings, and if they were rendered by their own <code>Like</code> component, the <code>Likes</code> component would not rerender for changes happening inside a specific like.</li>
</ol>
<h2 id="tl-dr">TL;DR</h2>
<blockquote>
<p>MobX reacts to any an <em>existing</em> <strong>observable</strong> <em>property</em> that is read during the execution of a tracked function.</p>
</blockquote>

                    
                    </section></div>
        </article>
      <h2>5. Resources</h2>
        <article>
          <h3>Tutorials, videos and blogs</h3>
          <div><div class="page-inner"><span>
                
                
                    </span><section class="normal" id="section-">
                    
                        <a id="edit-link" href="https://github.com/mobxjs/mobx/tree/gh-pages/docs/faq/blogs.md" class="btn fa fa-edit pull-left">&#xA0;&#xA0;Edit This Page</a><h2 id="blogs-tutorials-videos">Blogs, tutorials, videos</h2>
<h2 id="videos">Videos</h2>

<h2 id="tutorials">Tutorials</h2>

<h2 id="articles-blogs-explaining-the-inner-working-of-mobx">Articles / blogs explaining the inner working of MobX:</h2>

<h2 id="blogs">Blogs</h2>

<h2 id="testimonials">Testimonials</h2>
<p>Want to know how people experience starting or porting projects to MobX? Besides the above listed blogs, the following threads might shed some light:</p>


                    
                    </section><span>
                
                
                </span></div></div>
        </article>
      
        <article>
          <h3>Related Projects</h3>
          <div><div class="dropdown-menu font-settings dropdown-left"><span>
            </span><span>
            </span><p>
                <button type="button" data-sharing="twitter" class="button">
                    Share on Twitter
                </button>
                <button type="button" data-sharing="google-plus" class="button">
                    Share on Google
                </button>
                <button type="button" data-sharing="facebook" class="button">
                    Share on Facebook
                </button>
                <button type="button" data-sharing="weibo" class="button">
                    Share on Weibo
                </button>
                <button type="button" data-sharing="instapaper" class="button">
                    Share on Instapaper
                </button>
            </p><span>
        </span></div></div>
        </article>
      
        <article>
          <h3>Examples projects</h3>
          <div><div>
        
        
    <div class="book" data-level="5.3" data-basepath=".." data-revision="Mon Aug 29 2016 13:33:21 GMT+0200 (CEST)"><span>
    

</span><span>

    </span><div class="book-body"><span>
        </span><div class="body-inner"><span>
            </span><span>

            </span><div class="page-wrapper" tabindex="-1" role="main"><span>
                </span><div class="page-inner"><span>
                
                
                    </span><section class="normal" id="section-">
                    
                        <a id="edit-link" href="https://github.com/mobxjs/mobx/tree/gh-pages/docs/faq/examples.md" class="btn fa fa-edit pull-left">&#xA0;&#xA0;Edit This Page</a>
<ul>
<li><a href="https://github.com/mattruby/mobx-examples" target="_blank">Simple ES5 MobX examples</a> Bite sized MobX examples all setup to run in jsFiddle.</li>
<li>TodoMVC application, including Server Side Rendering: <a href="https://github.com/mobxjs/mobx-react-todomvc" target="_blank">https://github.com/mobxjs/mobx-react-todomvc</a></li>
<li>Spectacle editor: Official editor for building presentations using the Spectacle library: <a href="https://github.com/FormidableLabs/spectacle-editor" target="_blank">https://github.com/FormidableLabs/spectacle-editor</a></li>
<li><a href="https://github.com/iam4x/pokemongo-webspoof/" target="_blank">PokemonGo webspoof</a> Play PokemonGo on your Mac</li>
<li>Contact list application (simple data fetching, routing, complex components, material UI): <a href="https://github.com/mobxjs/mobx-contacts-list" target="_blank">https://github.com/mobxjs/mobx-contacts-list</a></li>
<li>DWatch - docker container manager, Electron, typescript, inversifyJS: <a href="https://github.com/Mercateo/dwatch" target="_blank">https://github.com/Mercateo/dwatch</a></li>
<li>Kratelabs interactive map / map order service <a href="https://kratelabs.addxy.com/#/" target="_blank">https://kratelabs.addxy.com/#/</a> source: <a href="https://github.com/KrateLabs/KrateLabs-App" target="_blank">https://github.com/KrateLabs/KrateLabs-App</a></li>
<li><a href="https://github.com/jeffijoe/logpipe-server" target="_blank">Logpipe</a>, a dev-logging app using MobX with Socket.IO for <strong>real-time updates</strong></li>
<li><a href="https://github.com/GPMDP/google-play-music-desktop-remote" target="_blank">Google Play Music Desktop Remote</a> A React-Native app for remote controlling Google Play Music Desktop: MobX + WebSocket.</li>
<li>Example with Server Side Rendering, react-router: <a href="https://github.com/kuuup/mobx-ssr-example" target="_blank">https://github.com/kuuup/mobx-ssr-example</a></li>
<li>Server Side Api Mocking made easy with UI: <a href="https://github.com/Raathigesh/Atmo" target="_blank">https://github.com/Raathigesh/Atmo</a></li>
<li>Accounting System built in ASP.NET MVC, ReactJS, MobX <a href="http://www.accountgo.ph/" target="_blank">http://www.accountgo.ph/</a> <a href="https://github.com/AccountGo/accountgo" target="_blank">source</a></li>
<li>Easy MobX example with React, MobX, Cosmic JS, shorti,  <a href="https://github.com/tonyspiro/easy-mobx-example" target="_blank">https://github.com/tonyspiro/easy-mobx-example</a></li>
<li>A simple webshop using <a href="https://jsfiddle.net/mweststrate/46vL0phw" target="_blank">React + mobx</a></li>
<li>A simple webshop using <a href="http://jsfiddle.net/mweststrate/vxn7qgdw" target="_blank">JQuery + mobx</a>.</li>
<li>Simple app with Ajax, authentication, context, routing: <a href="http://stackoverflow.com/a/36164488/1983583" target="_blank">http://stackoverflow.com/a/36164488/1983583</a></li>
<li>Contacts MVC app with Typescript, routing etc. <a href="https://github.com/contacts-mvc/mobx-react-typescript" target="_blank">https://github.com/contacts-mvc/mobx-react-typescript</a>:</li>
<li>React Particles (React, MobX, D3. one app with two architectures in two branches, Flux and MVC: <a href="https://github.com/mobxjs/react-particles-experiment" target="_blank">https://github.com/mobxjs/react-particles-experiment</a>)</li>
<li>Mortgage overpayment calculator using React with MobX: <a href="https://github.com/paulhoughton/mortgage-mobx" target="_blank">https://github.com/paulhoughton/mortgage-mobx</a></li>
<li>Simple drag and drop application. Also provides time travelling <a href="https://github.com/mobxjs/mobx-reactive2015-demo" target="_blank">https://github.com/mobxjs/mobx-reactive2015-demo</a></li>
<li>The <a href="https://github.com/survivejs/mobx-demo" target="_blank">ports of the <em>Notes</em> and <em>Kanban</em> examples</a> from the book &quot;SurviveJS - Webpack and React&quot; to MobX.</li>
<li>Flux challenge, implemeted with MobX: <a href="https://github.com/staltz/flux-challenge/tree/master/submissions/mweststrate" target="_blank">https://github.com/staltz/flux-challenge/tree/master/submissions/mweststrate</a></li>
<li>MobX + D3 codepen: <a href="http://codepen.io/timelyportfolio/pen/zrJwvE" target="_blank">http://codepen.io/timelyportfolio/pen/zrJwvE</a></li>
<li>TypeScript + React + MobX + JSPM - Simple CRUD App example: <a href="https://github.com/piotrwitek/training-management-tool" target="_blank">https://github.com/piotrwitek/training-management-tool</a></li>
<li>Github Note Taker in MobX: <a href="https://github.com/eswat2/egghead-mobx" target="_blank">https://github.com/eswat2/egghead-mobx</a></li>
<li>vcash-electron - Electron UI for the Vcash crypto currency: <a href="https://github.com/whphhg/vcash-electron" target="_blank">https://github.com/whphhg/vcash-electron</a></li>
<li>SoundCloud client, in MobX and React: <a href="https://github.com/rwieruch/react-mobx-soundcloud" target="_blank">React-MobX-SoundCloud</a></li>
</ul>

                    
                    </section><span>
                
                
                </span></div><span>
            </span></div><span>
        </span></div><span>

        
        </span><span>
        
        
        </span><span>
        
    </span></div><span>
</span></div>

        


    
    
    

    
    
    

    
    
    

    
    
    



        
    
    

</div></div>
        </article>
      
        <article>
          <h3>Boilerplates</h3>
          <div><div>
        
        
    <div class="book" data-level="5.4" data-basepath=".." data-revision="Mon Aug 29 2016 13:33:21 GMT+0200 (CEST)"><span>
    

</span><span>

    </span><div class="book-body"><span>
        </span><div class="body-inner"><span>
            </span><span>

            </span><div class="page-wrapper" tabindex="-1" role="main"><span>
                </span><div class="page-inner"><span>
                
                
                    </span><section class="normal" id="section-">
                    
                        <a id="edit-link" href="https://github.com/mobxjs/mobx/tree/gh-pages/docs/faq/boilerplates.md" class="btn fa fa-edit pull-left">&#xA0;&#xA0;Edit This Page</a>
<ul>
<li>React, Babel, Webpack: <a href="https://github.com/mweststrate/react-mobservable-boilerplate" target="_blank">https://github.com/mweststrate/react-mobservable-boilerplate</a></li>
<li>React, Typescript, Webpack: <a href="https://github.com/mobxjs/mobx-react-typescript-boilerplate" target="_blank">https://github.com/mobxjs/mobx-react-typescript-boilerplate</a></li>
<li>MobX + React JSFiddle: <a href="https://jsfiddle.net/mweststrate/wgbe4guu/" target="_blank">https://jsfiddle.net/mweststrate/wgbe4guu/</a></li>
<li>MobX + React JSFiddle with just ES5: <a href="https://jsfiddle.net/rubyred/55oc981v/" target="_blank">https://jsfiddle.net/rubyred/55oc981v/</a></li>
<li><a href="https://www.npmjs.com/package/generator-mobx-react" target="_blank">generator-mobx-react</a> Yeoman MobX, React, Webpack, Babel / Typescript project generator</li>
<li><a href="https://github.com/nightwolfz/mobx-starter" target="_blank">mobx-starter</a>: Starting base for an mobx react project with optional isomorphism. MongoDB auth &amp; sessions, hot reload, react-router</li>
<li><a href="https://github.com/foxhound87/rfx-stack" target="_blank">rfx-stack</a> RFX Stack - Universal App featuring: React + Feathers + MobX</li>
<li><a href="https://github.com/KadoBOT/reaxor" target="_blank">reaxor</a> Boilerplate for better state management, styling, testing and cleaner code</li>
<li><a href="https://github.com/capaj/jspm-react" target="_blank">jspm-react</a> lightweight React.js ES6 boilerplate with JSPM and proper hot reloading modules</li>
<li><a href="https://github.com/vinej/react-portal" target="_blank">react-portal</a> MobX, React with Flux architecture</li>
<li><a href="https://github.com/tapos007/ReactJS-MobX-Webpack-Boilerplate/tree/master/app/store" target="_blank">react-mobx-webpack</a> Quickstart project template for learning React</li>
<li><a href="https://github.com/pixelkritzel/gulp_es6_sass_boilerplate" target="_blank">gulp-es6-sass-mobx</a></li>
<li><a href="https://github.com/osenvosem/react-mobx-boilerplate" target="_blank">react-mobx-boilerplate</a> A small React + React Router + MobX boilerplate with a small example app.</li>
<li><a href="https://github.com/micnews/mobx-deku-boilerplate" target="_blank">Small project to quickly start with deku, MobX, JSX, ES6, Babel</a></li>
<li><a href="https://github.com/sapientglobalmarkets/react-mobx-seed" target="_blank">React MobX Seed: Seed project using a wide set of best practices</a></li>
<li><a href="https://github.com/vinej/react-remux" target="_blank">ReMux - MobX with flux pattern boilerplate</a></li>
<li><a href="https://github.com/tranqy/react-routing-mobx-bootstrap-boilerplate" target="_blank">react-routing-mobx-bootstrap-boilerplate</a> Simple boilerplate with webpack, react, mobx, react router and css modules</li>
<li><a href="https://github.com/iam4x/futureRX" target="_blank">FutureRX</a> The futuristic stack to create universal React applications with MobX as state manager</li>
<li><a href="https://github.com/Xerios/mobx-isomorphic-starter" target="_blank">mobx-isomorphic-starter</a> Clean isomorphic starter-kit using Mobx + React + React-router + Webpack</li>
<li><a href="https://github.com/lostpebble/koa-mobx-react-starter" target="_blank">koa-mobx-react-starter</a> A straightforward starter for Node javascript web projects. Using Koa, MobX, Pug and ReactJS (with universal / isomorphic server rendering)</li>
<li><a href="https://github.com/code-shoily/modular-mobx-boilerplate" target="_blank">modular-mobx-boilerplate</a> This is a boilerplate for developing with React + MobX. It uses a modular structure of folders for larger apps.</li>
</ul>

                    
                    </section><span>
                
                
                </span></div><span>
            </span></div><span>
        </span></div><span>

        
        </span><span>
        
        
        </span><span>
        
    </span></div><span>
</span></div>

        


    
    
    

    
    
    

    
    
    

    
    
    



        
    
    

</div></div>
        </article>
      
        <article>
          <h3>Frequently Asked Questions</h3>
          <div><section class="normal" id="section-">
                    
                        <a id="edit-link" href="https://github.com/mobxjs/mobx/tree/gh-pages/docs/faq/faq.md" class="btn fa fa-edit pull-left">&#xA0;&#xA0;Edit This Page</a>
<h5 id="which-browsers-are-supported">Which browsers are supported?</h5>
<p>MobX runs on any ES5 environment. That means that Node.js, Rhino and all browsers except for IE8 are supported. See <a href="http://caniuse.com/#feat=es5" target="_blank">caniuse.com</a></p>
<h5 id="can-mobx-be-combined-with-rxjs">Can MobX be combined with RxJS?</h5>
<p>Yes, see the <a href="https://www.npmjs.com/package/rx-mobx" target="_blank">rx-mobx</a> interoperability package.</p>
<h5 id="when-to-use-rxjs-instead-of-mobx">When to use RxJS instead of MobX?</h5>
<p>For anything that involves explictly working with the concept of time,
or when you need to reason about the historical values / events of an observable (and not just the latest), RxJs is recommended as it provides more low-level primitives.
Whenever you want to react to <em>state</em> instead of <em>events</em>, MobX offers an easier and more high-level approach.
In practice, combining RxJS and MobX might result in really powerful constructions.
Use for example RxJS to process and throttle user events and as a result of that update the state.
If the state has been made observable by MobX, it will then take care of updating the UI and other derivations accordingly.</p>
<h5 id="is-react-native-supported">Is React Native supported?</h5>
<p>Yes, <code>mobx</code> and <code>mobx-react</code> will work on React Native. The latter through importing <code>&quot;mobx-react/native&quot;</code>.
The devtools don&apos;t support React Native. Note that if you indend to store state in a component that you want to be able to use with hot reloading, do not use decorators (annotations) in the component, use the functions instead (eg. <code>action(fn)</code> instead of <code>@action</code>).</p>
<h5 id="how-does-mobx-compare-to-other-reactive-frameworks">How does MobX compare to other Reactive frameworks?</h5>
<p>See this <a href="https://github.com/mobxjs/mobx/issues/18" target="_blank">issue</a> for some considerations.</p>
<h5 id="is-mobx-a-framework">Is MobX a framework?</h5>
<p>MobX is <em>not</em> a framework. It does not tell you how to structure your code, where to store state or how to process events. Yet it might free you from frameworks that poses all kinds of restrictions on your code in the name of performance.</p>
<h5 id="can-i-combine-mobx-with-flux">Can I combine MobX with Flux?</h5>
<p>Flux implementations that do not work on the assumption that the data in their stores is immutable should work well with MobX.
However, the need for Flux is reduced when using MobX.
MobX already optimizes rendering, and it works with most kinds of data, including cycles and classes.
So other programming paradigms like classic MVC can now be easily applied in applications that combine ReactJS with MobX.</p>
<h5 id="can-i-use-mobx-together-with-framework-x">Can I use MobX together with framework X?</h5>
<p>Probably.
MobX is framework agnostic and can be applied in any modern JS environment.
It just ships with a small function to transform ReactJS components into reactive view functions for convenience.
MobX works just as well server side, and is already combined with jQuery (see this <a href="http://jsfiddle.net/mweststrate/vxn7qgdw" target="_blank">Fiddle</a>) and <a href="https://gist.github.com/mattmccray/d8740ea97013c7505a9b" target="_blank">Deku</a>.</p>
<h5 id="can-i-record-states-and-re-hydrate-them">Can I record states and re-hydrate them?</h5>
<p>Yes, see <a href="http://mobxjs.github.io/mobx/refguide/create-transformer.html" target="_blank">createTransformer</a> for some examples.</p>
<h5 id="can-you-tell-me-how-it-works">Can you tell me how it works?</h5>
<p>Sure, join the reactiflux channel or checkout the code. Or, submit an issue to motivate me to make some nice drawings :).
And look at this <a href="https://medium.com/@mweststrate/becoming-fully-reactive-an-in-depth-explanation-of-mobservable-55995262a254" target="_blank">Medium article</a>.</p>

                    
                    </section></div>
        </article>
      <h2></h2>
        <article>
          <h3>Tutorials, videos and blogs</h3>
          <div><div class="page-inner"><span>
                
                
                    </span><section class="normal" id="section-">
                    
                        <a id="edit-link" href="https://github.com/mobxjs/mobx/tree/gh-pages/docs/faq/blogs.md" class="btn fa fa-edit pull-left">&#xA0;&#xA0;Edit This Page</a><h2 id="blogs-tutorials-videos">Blogs, tutorials, videos</h2>
<h2 id="videos">Videos</h2>

<h2 id="tutorials">Tutorials</h2>

<h2 id="articles-blogs-explaining-the-inner-working-of-mobx">Articles / blogs explaining the inner working of MobX:</h2>

<h2 id="blogs">Blogs</h2>

<h2 id="testimonials">Testimonials</h2>
<p>Want to know how people experience starting or porting projects to MobX? Besides the above listed blogs, the following threads might shed some light:</p>


                    
                    </section><span>
                
                
                </span></div></div>
        </article>
      <h2></h2>
        <article>
          <h3>Related Projects</h3>
          <div><div class="dropdown-menu font-settings dropdown-left"><span>
            </span><span>
            </span><p>
                <button type="button" data-sharing="twitter" class="button">
                    Share on Twitter
                </button>
                <button type="button" data-sharing="google-plus" class="button">
                    Share on Google
                </button>
                <button type="button" data-sharing="facebook" class="button">
                    Share on Facebook
                </button>
                <button type="button" data-sharing="weibo" class="button">
                    Share on Weibo
                </button>
                <button type="button" data-sharing="instapaper" class="button">
                    Share on Instapaper
                </button>
            </p><span>
        </span></div></div>
        </article>
      <h2></h2>
        <article>
          <h3>Examples projects</h3>
          <div><div>
        
        
    <div class="book" data-level="5.3" data-basepath=".." data-revision="Mon Aug 29 2016 13:33:21 GMT+0200 (CEST)"><span>
    

</span><span>

    </span><div class="book-body"><span>
        </span><div class="body-inner"><span>
            </span><span>

            </span><div class="page-wrapper" tabindex="-1" role="main"><span>
                </span><div class="page-inner"><span>
                
                
                    </span><section class="normal" id="section-">
                    
                        <a id="edit-link" href="https://github.com/mobxjs/mobx/tree/gh-pages/docs/faq/examples.md" class="btn fa fa-edit pull-left">&#xA0;&#xA0;Edit This Page</a>
<ul>
<li><a href="https://github.com/mattruby/mobx-examples" target="_blank">Simple ES5 MobX examples</a> Bite sized MobX examples all setup to run in jsFiddle.</li>
<li>TodoMVC application, including Server Side Rendering: <a href="https://github.com/mobxjs/mobx-react-todomvc" target="_blank">https://github.com/mobxjs/mobx-react-todomvc</a></li>
<li>Spectacle editor: Official editor for building presentations using the Spectacle library: <a href="https://github.com/FormidableLabs/spectacle-editor" target="_blank">https://github.com/FormidableLabs/spectacle-editor</a></li>
<li><a href="https://github.com/iam4x/pokemongo-webspoof/" target="_blank">PokemonGo webspoof</a> Play PokemonGo on your Mac</li>
<li>Contact list application (simple data fetching, routing, complex components, material UI): <a href="https://github.com/mobxjs/mobx-contacts-list" target="_blank">https://github.com/mobxjs/mobx-contacts-list</a></li>
<li>DWatch - docker container manager, Electron, typescript, inversifyJS: <a href="https://github.com/Mercateo/dwatch" target="_blank">https://github.com/Mercateo/dwatch</a></li>
<li>Kratelabs interactive map / map order service <a href="https://kratelabs.addxy.com/#/" target="_blank">https://kratelabs.addxy.com/#/</a> source: <a href="https://github.com/KrateLabs/KrateLabs-App" target="_blank">https://github.com/KrateLabs/KrateLabs-App</a></li>
<li><a href="https://github.com/jeffijoe/logpipe-server" target="_blank">Logpipe</a>, a dev-logging app using MobX with Socket.IO for <strong>real-time updates</strong></li>
<li><a href="https://github.com/GPMDP/google-play-music-desktop-remote" target="_blank">Google Play Music Desktop Remote</a> A React-Native app for remote controlling Google Play Music Desktop: MobX + WebSocket.</li>
<li>Example with Server Side Rendering, react-router: <a href="https://github.com/kuuup/mobx-ssr-example" target="_blank">https://github.com/kuuup/mobx-ssr-example</a></li>
<li>Server Side Api Mocking made easy with UI: <a href="https://github.com/Raathigesh/Atmo" target="_blank">https://github.com/Raathigesh/Atmo</a></li>
<li>Accounting System built in ASP.NET MVC, ReactJS, MobX <a href="http://www.accountgo.ph/" target="_blank">http://www.accountgo.ph/</a> <a href="https://github.com/AccountGo/accountgo" target="_blank">source</a></li>
<li>Easy MobX example with React, MobX, Cosmic JS, shorti,  <a href="https://github.com/tonyspiro/easy-mobx-example" target="_blank">https://github.com/tonyspiro/easy-mobx-example</a></li>
<li>A simple webshop using <a href="https://jsfiddle.net/mweststrate/46vL0phw" target="_blank">React + mobx</a></li>
<li>A simple webshop using <a href="http://jsfiddle.net/mweststrate/vxn7qgdw" target="_blank">JQuery + mobx</a>.</li>
<li>Simple app with Ajax, authentication, context, routing: <a href="http://stackoverflow.com/a/36164488/1983583" target="_blank">http://stackoverflow.com/a/36164488/1983583</a></li>
<li>Contacts MVC app with Typescript, routing etc. <a href="https://github.com/contacts-mvc/mobx-react-typescript" target="_blank">https://github.com/contacts-mvc/mobx-react-typescript</a>:</li>
<li>React Particles (React, MobX, D3. one app with two architectures in two branches, Flux and MVC: <a href="https://github.com/mobxjs/react-particles-experiment" target="_blank">https://github.com/mobxjs/react-particles-experiment</a>)</li>
<li>Mortgage overpayment calculator using React with MobX: <a href="https://github.com/paulhoughton/mortgage-mobx" target="_blank">https://github.com/paulhoughton/mortgage-mobx</a></li>
<li>Simple drag and drop application. Also provides time travelling <a href="https://github.com/mobxjs/mobx-reactive2015-demo" target="_blank">https://github.com/mobxjs/mobx-reactive2015-demo</a></li>
<li>The <a href="https://github.com/survivejs/mobx-demo" target="_blank">ports of the <em>Notes</em> and <em>Kanban</em> examples</a> from the book &quot;SurviveJS - Webpack and React&quot; to MobX.</li>
<li>Flux challenge, implemeted with MobX: <a href="https://github.com/staltz/flux-challenge/tree/master/submissions/mweststrate" target="_blank">https://github.com/staltz/flux-challenge/tree/master/submissions/mweststrate</a></li>
<li>MobX + D3 codepen: <a href="http://codepen.io/timelyportfolio/pen/zrJwvE" target="_blank">http://codepen.io/timelyportfolio/pen/zrJwvE</a></li>
<li>TypeScript + React + MobX + JSPM - Simple CRUD App example: <a href="https://github.com/piotrwitek/training-management-tool" target="_blank">https://github.com/piotrwitek/training-management-tool</a></li>
<li>Github Note Taker in MobX: <a href="https://github.com/eswat2/egghead-mobx" target="_blank">https://github.com/eswat2/egghead-mobx</a></li>
<li>vcash-electron - Electron UI for the Vcash crypto currency: <a href="https://github.com/whphhg/vcash-electron" target="_blank">https://github.com/whphhg/vcash-electron</a></li>
<li>SoundCloud client, in MobX and React: <a href="https://github.com/rwieruch/react-mobx-soundcloud" target="_blank">React-MobX-SoundCloud</a></li>
</ul>

                    
                    </section><span>
                
                
                </span></div><span>
            </span></div><span>
        </span></div><span>

        
        </span><span>
        
        
        </span><span>
        
    </span></div><span>
</span></div>

        


    
    
    

    
    
    

    
    
    

    
    
    



        
    
    

</div></div>
        </article>
      <h2></h2>
        <article>
          <h3>Boilerplates</h3>
          <div><div>
        
        
    <div class="book" data-level="5.4" data-basepath=".." data-revision="Mon Aug 29 2016 13:33:21 GMT+0200 (CEST)"><span>
    

</span><span>

    </span><div class="book-body"><span>
        </span><div class="body-inner"><span>
            </span><span>

            </span><div class="page-wrapper" tabindex="-1" role="main"><span>
                </span><div class="page-inner"><span>
                
                
                    </span><section class="normal" id="section-">
                    
                        <a id="edit-link" href="https://github.com/mobxjs/mobx/tree/gh-pages/docs/faq/boilerplates.md" class="btn fa fa-edit pull-left">&#xA0;&#xA0;Edit This Page</a>
<ul>
<li>React, Babel, Webpack: <a href="https://github.com/mweststrate/react-mobservable-boilerplate" target="_blank">https://github.com/mweststrate/react-mobservable-boilerplate</a></li>
<li>React, Typescript, Webpack: <a href="https://github.com/mobxjs/mobx-react-typescript-boilerplate" target="_blank">https://github.com/mobxjs/mobx-react-typescript-boilerplate</a></li>
<li>MobX + React JSFiddle: <a href="https://jsfiddle.net/mweststrate/wgbe4guu/" target="_blank">https://jsfiddle.net/mweststrate/wgbe4guu/</a></li>
<li>MobX + React JSFiddle with just ES5: <a href="https://jsfiddle.net/rubyred/55oc981v/" target="_blank">https://jsfiddle.net/rubyred/55oc981v/</a></li>
<li><a href="https://www.npmjs.com/package/generator-mobx-react" target="_blank">generator-mobx-react</a> Yeoman MobX, React, Webpack, Babel / Typescript project generator</li>
<li><a href="https://github.com/nightwolfz/mobx-starter" target="_blank">mobx-starter</a>: Starting base for an mobx react project with optional isomorphism. MongoDB auth &amp; sessions, hot reload, react-router</li>
<li><a href="https://github.com/foxhound87/rfx-stack" target="_blank">rfx-stack</a> RFX Stack - Universal App featuring: React + Feathers + MobX</li>
<li><a href="https://github.com/KadoBOT/reaxor" target="_blank">reaxor</a> Boilerplate for better state management, styling, testing and cleaner code</li>
<li><a href="https://github.com/capaj/jspm-react" target="_blank">jspm-react</a> lightweight React.js ES6 boilerplate with JSPM and proper hot reloading modules</li>
<li><a href="https://github.com/vinej/react-portal" target="_blank">react-portal</a> MobX, React with Flux architecture</li>
<li><a href="https://github.com/tapos007/ReactJS-MobX-Webpack-Boilerplate/tree/master/app/store" target="_blank">react-mobx-webpack</a> Quickstart project template for learning React</li>
<li><a href="https://github.com/pixelkritzel/gulp_es6_sass_boilerplate" target="_blank">gulp-es6-sass-mobx</a></li>
<li><a href="https://github.com/osenvosem/react-mobx-boilerplate" target="_blank">react-mobx-boilerplate</a> A small React + React Router + MobX boilerplate with a small example app.</li>
<li><a href="https://github.com/micnews/mobx-deku-boilerplate" target="_blank">Small project to quickly start with deku, MobX, JSX, ES6, Babel</a></li>
<li><a href="https://github.com/sapientglobalmarkets/react-mobx-seed" target="_blank">React MobX Seed: Seed project using a wide set of best practices</a></li>
<li><a href="https://github.com/vinej/react-remux" target="_blank">ReMux - MobX with flux pattern boilerplate</a></li>
<li><a href="https://github.com/tranqy/react-routing-mobx-bootstrap-boilerplate" target="_blank">react-routing-mobx-bootstrap-boilerplate</a> Simple boilerplate with webpack, react, mobx, react router and css modules</li>
<li><a href="https://github.com/iam4x/futureRX" target="_blank">FutureRX</a> The futuristic stack to create universal React applications with MobX as state manager</li>
<li><a href="https://github.com/Xerios/mobx-isomorphic-starter" target="_blank">mobx-isomorphic-starter</a> Clean isomorphic starter-kit using Mobx + React + React-router + Webpack</li>
<li><a href="https://github.com/lostpebble/koa-mobx-react-starter" target="_blank">koa-mobx-react-starter</a> A straightforward starter for Node javascript web projects. Using Koa, MobX, Pug and ReactJS (with universal / isomorphic server rendering)</li>
<li><a href="https://github.com/code-shoily/modular-mobx-boilerplate" target="_blank">modular-mobx-boilerplate</a> This is a boilerplate for developing with React + MobX. It uses a modular structure of folders for larger apps.</li>
</ul>

                    
                    </section><span>
                
                
                </span></div><span>
            </span></div><span>
        </span></div><span>

        
        </span><span>
        
        
        </span><span>
        
    </span></div><span>
</span></div>

        


    
    
    

    
    
    

    
    
    

    
    
    



        
    
    

</div></div>
        </article>
      <h2></h2>
        <article>
          <h3>Frequently Asked Questions</h3>
          <div><section class="normal" id="section-">
                    
                        <a id="edit-link" href="https://github.com/mobxjs/mobx/tree/gh-pages/docs/faq/faq.md" class="btn fa fa-edit pull-left">&#xA0;&#xA0;Edit This Page</a>
<h5 id="which-browsers-are-supported">Which browsers are supported?</h5>
<p>MobX runs on any ES5 environment. That means that Node.js, Rhino and all browsers except for IE8 are supported. See <a href="http://caniuse.com/#feat=es5" target="_blank">caniuse.com</a></p>
<h5 id="can-mobx-be-combined-with-rxjs">Can MobX be combined with RxJS?</h5>
<p>Yes, see the <a href="https://www.npmjs.com/package/rx-mobx" target="_blank">rx-mobx</a> interoperability package.</p>
<h5 id="when-to-use-rxjs-instead-of-mobx">When to use RxJS instead of MobX?</h5>
<p>For anything that involves explictly working with the concept of time,
or when you need to reason about the historical values / events of an observable (and not just the latest), RxJs is recommended as it provides more low-level primitives.
Whenever you want to react to <em>state</em> instead of <em>events</em>, MobX offers an easier and more high-level approach.
In practice, combining RxJS and MobX might result in really powerful constructions.
Use for example RxJS to process and throttle user events and as a result of that update the state.
If the state has been made observable by MobX, it will then take care of updating the UI and other derivations accordingly.</p>
<h5 id="is-react-native-supported">Is React Native supported?</h5>
<p>Yes, <code>mobx</code> and <code>mobx-react</code> will work on React Native. The latter through importing <code>&quot;mobx-react/native&quot;</code>.
The devtools don&apos;t support React Native. Note that if you indend to store state in a component that you want to be able to use with hot reloading, do not use decorators (annotations) in the component, use the functions instead (eg. <code>action(fn)</code> instead of <code>@action</code>).</p>
<h5 id="how-does-mobx-compare-to-other-reactive-frameworks">How does MobX compare to other Reactive frameworks?</h5>
<p>See this <a href="https://github.com/mobxjs/mobx/issues/18" target="_blank">issue</a> for some considerations.</p>
<h5 id="is-mobx-a-framework">Is MobX a framework?</h5>
<p>MobX is <em>not</em> a framework. It does not tell you how to structure your code, where to store state or how to process events. Yet it might free you from frameworks that poses all kinds of restrictions on your code in the name of performance.</p>
<h5 id="can-i-combine-mobx-with-flux">Can I combine MobX with Flux?</h5>
<p>Flux implementations that do not work on the assumption that the data in their stores is immutable should work well with MobX.
However, the need for Flux is reduced when using MobX.
MobX already optimizes rendering, and it works with most kinds of data, including cycles and classes.
So other programming paradigms like classic MVC can now be easily applied in applications that combine ReactJS with MobX.</p>
<h5 id="can-i-use-mobx-together-with-framework-x">Can I use MobX together with framework X?</h5>
<p>Probably.
MobX is framework agnostic and can be applied in any modern JS environment.
It just ships with a small function to transform ReactJS components into reactive view functions for convenience.
MobX works just as well server side, and is already combined with jQuery (see this <a href="http://jsfiddle.net/mweststrate/vxn7qgdw" target="_blank">Fiddle</a>) and <a href="https://gist.github.com/mattmccray/d8740ea97013c7505a9b" target="_blank">Deku</a>.</p>
<h5 id="can-i-record-states-and-re-hydrate-them">Can I record states and re-hydrate them?</h5>
<p>Yes, see <a href="http://mobxjs.github.io/mobx/refguide/create-transformer.html" target="_blank">createTransformer</a> for some examples.</p>
<h5 id="can-you-tell-me-how-it-works">Can you tell me how it works?</h5>
<p>Sure, join the reactiflux channel or checkout the code. Or, submit an issue to motivate me to make some nice drawings :).
And look at this <a href="https://medium.com/@mweststrate/becoming-fully-reactive-an-in-depth-explanation-of-mobservable-55995262a254" target="_blank">Medium article</a>.</p>

                    
                    </section></div>
        </article>
      <h2>6. Tips & Tricks</h2>
        <article>
          <h3>Common Pitfalls & Best Practices</h3>
          <div><section class="normal" id="section-">
                    
                        <a id="edit-link" href="https://github.com/mobxjs/mobx/tree/gh-pages/docs/best/pitfalls.md" class="btn fa fa-edit pull-left">&#xA0;&#xA0;Edit This Page</a>
<p>Stuck with MobX? This section contains a list of common issues people new to MobX might run into.</p>
<h4 id="-array-isarray-observable-1-2-3-false"><code>Array.isArray(observable([1,2,3])) === false</code></h4>
<p>In ES5 there is no way to reliably inherit from arrays, and hence observable arrays inherit from objects.
This means that regularly libraries are not able to recognize observable arrays as normal arrays (like lodash, or built-in operations like <code>Array.concat</code>).
This can simply be fixed by passing calling <code>observable.toJS()</code> or <code>observable.slice()</code> before passing the array to another library.
As long as the external library has no intent to modify the array, this will further work completely as expected.
You can use <code>isObservableArray(observable)</code> to check whether something is an observable array.</p>
<h4 id="-object-somenewprop-value-is-not-picked-up"><code>object.someNewProp = value</code> is not picked up</h4>
<p>MobX observable <em>objects</em> do not detect or react to property assignments that weren&apos;t declared observable before.
So MobX observable objects act as records with predefined keys.
You can use <code>extendObservable(target, props)</code> to introduce new observable properties to an object.
However object iterators like <code>for .. in</code> or <code>Object.keys()</code> won&apos;t react to this automatically.
If you need a dynamically keyed object, for example to store users by id, create observable _map_s using <code>asMap</code>.
More info on <a href="https://github.com/mobxjs/mobx/issues/219#issuecomment-220224813" target="_blank">asMap</a>.
For more info see <a href="https://mobxjs.github.io/mobx/best/react.html">what will MobX react to?</a>.</p>
<h3 id="use-observer-on-all-components-that-render-observable-s">Use <code>@observer</code> on all components that render <code>@observable</code>&apos;s.</h3>
<p><code>@observer</code> only enhances the component you are decorating, not the components used inside it.
So usually all your components should be decorated. Don&apos;t worry, this is not inefficient, in contrast, more <code>observer</code> components make rendering more efficient.</p>
<h3 id="dereference-values-as-lately-as-possible">Dereference values as lately as possible</h3>
<p>MobX can do a lot, but it cannot make primitive values observable (although it can wrap them in an object see <a href="https://mobxjs.github.io/mobx/refguide/boxed.html">boxed observables</a>).
So it is not the <em>values</em> that are observable, but the <em>properties</em> of an object. This means that <code>@observer</code> actually reacts to the fact that you dereference a value.
So in our above example, the <code>Timer</code> component would <strong>not</strong> react if it was initialized as follows:</p>
<pre><code class="lang-javascript">React.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">Timer</span> <span class="hljs-attribute">timerData</span>=<span class="hljs-value">{timerData.secondsPassed}</span> /&gt;</span>, document.body)
</span></code></pre>
<p>In this snippet just the current value of <code>secondsPassed</code> is passed to the <code>Timer</code>, which is the immutable value <code>0</code> (all primitives are immutable in JS).
That number won&apos;t change anymore in the future, so <code>Timer</code> will never update. It is the property <code>secondsPassed</code> that will change in the future,
so we need to access it <em>in</em> the component. Or in other words: always try to pass the owning object of an observable property.
For more info see <a href="https://mobxjs.github.io/mobx/best/react.html">what will MobX react to?</a>.</p>
<h4 id="computed-values-run-more-often-then-expected">Computed values run more often then expected</h4>
<p>If a computed property is <em>not</em> in use by some reaction (<code>autorun</code>, <code>observer</code> etc), computed expressions will be evaluated lazily; each time their value is requested (so they just act as normal property).
Computed values will only track their dependencies if they are observed.
This allows MobX to automatically suspend computations that are not actively in use.
See this <a href="https://medium.com/@mweststrate/becoming-fully-reactive-an-in-depth-explanation-of-mobservable-55995262a254" target="_blank">blog</a> or <a href="https://github.com/mobxjs/mobx/issues/356" target="_blank">issue #356</a> for an explanation.
So if you fiddle arounds, computed properties might not seem efficient. But when applied in a project that uses <code>observer</code>, <code>autorun</code> etc, they become very efficient.</p>
<p><em>N.B. in a next version of MobX computeds will automatically be kept alive during transactions as well, see PR: #452</em></p>
<h4 id="always-dispose-reactions">Always dispose reactions</h4>
<p>all forms of <code>autorun</code>, <code>observe</code> and <code>intercept</code> will only be garbage collected if all objects they observe are garbage collection themselves.
So it is recommend to use the disposer function that is returned from these methods to stop them when you no longer need them.
Usually for <code>observe</code> and <code>intercept</code> it is not strictly necessary to dispose them if when targed <code>this</code>.
For reactions like <code>autorun</code> it is more tricky, as they might observe many different observables, and as long as one of them is still in scope,
the reaction will remain in scope which means that all other observables it uses are also kept alive to support future recomputions.
So make sure to always dispose your reactions when you no longer need them!</p>
<p>Example:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> VAT = observable(<span class="hljs-number">1.20</span>)

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderLIne</span> </span>{
    @observable price = <span class="hljs-number">10</span>;
    @observable amount = <span class="hljs-number">1</span>;
    constructor() {
        
        <span class="hljs-keyword">this</span>.handler = autorun(() =&gt; {
            doSomethingWith(<span class="hljs-keyword">this</span>.price * <span class="hljs-keyword">this</span>.amount)
        })
        
        
        
        <span class="hljs-keyword">this</span>.handler = autorun(() =&gt; {
            doSomethingWith(<span class="hljs-keyword">this</span>.price * <span class="hljs-keyword">this</span>.amount * VAT.get())
        })
        
        <span class="hljs-keyword">this</span>.handler()
        
    }
}
</code></pre>
<h4 id="i-have-a-weird-exception-when-using-observable-in-a-react-component">I have a weird exception when using <code>@observable</code> in a React component.</h4>
<p>The following exception: <code>Uncaught TypeError: Cannot assign to read only property &apos;__mobxLazyInitializers&apos; of object</code> occurs when using a <code>react-hot-loader</code> that does not support decorators.
Either use <code>extendObservable</code> in <code>componentWillMount</code> instead of <code>@observable</code>, or upgrade to <code>react-hot-loader</code> <code>&quot;^3.0.0-beta.2&quot;</code> or higher.</p>
<h4 id="the-display-name-of-react-components-is-not-set">The display name of react components is not set</h4>
<p>If you use <code>export const MyComponent = observer((props =&gt; &lt;div&gt;hi&lt;/div&gt;))</code>, no display name will be visible in the devtools.
The following approaches can be used to fix this:</p>
<pre><code class="lang-javascript">
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> MyComponent = observer((props =&gt; <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">div</span>&gt;</span>hi<span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>)</span>)
myComponent.displayName = <span class="hljs-string">&quot;MyComponent&quot;</span>


<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> MyComponent = observer(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MyComponent</span>(<span class="hljs-params">props</span>) </span>{ <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">div</span>&gt;</span>hi<span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span> })

// 3 (transpiler will infer component name from variable name)
const _MyComponent = observer((props =&gt; <span class="hljs-tag">&lt;<span class="hljs-title">div</span>&gt;</span>hi<span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>)</span>) 
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> MyComponent = observer(_MyComponent)


<span class="hljs-keyword">const</span> MyComponent = observer((props =&gt; <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">div</span>&gt;</span>hi<span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>)</span>)
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> observer(MyComponent)
</code></pre>
<p>See also: <a href="http://mobxjs.github.io/mobx/best/stateless-HMR.html" target="_blank">http://mobxjs.github.io/mobx/best/stateless-HMR.html</a> or <a href="https://github.com/mobxjs/mobx/issues/141#issuecomment-228457886" target="_blank">#141</a>.</p>
<h4 id="the-proptype-of-an-observable-array-is-object">The propType of an observable array is object</h4>
<p>Observable arrays are actually objects, so they comply to <code>propTypes.object</code> instead of <code>array</code>.
<code>mobx-react</code> will <a href="https://github.com/mobxjs/mobx-react/pull/59" target="_blank">soon</a> provide explicit propTypes for observable data structures.</p>
<h4 id="declaring-proptypes-might-cause-unnecessary-renders-in-dev-mode">Declaring propTypes might cause unnecessary renders in dev mode</h4>
<p>See: <a href="https://github.com/mobxjs/mobx-react/issues/56" target="_blank">https://github.com/mobxjs/mobx-react/issues/56</a></p>
<h4 id="-observable-properties-initialize-lazily-when-using-babel"><code>@observable</code> properties initialize lazily when using Babel</h4>
<p>This issue only occurs when transpiling with Babel and not with Typescript (in which decorator support is more mature).
Observable properties will not be instantiated upon an instance until the first read / write to a property (at that point they all will be initialized).
This results in the following subtle bug:</p>
<pre><code class="lang-javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Todo</span> </span>{
    @observable done = <span class="hljs-literal">true</span>
    @observable title = <span class="hljs-string">&quot;test&quot;</span>
}
<span class="hljs-keyword">const</span> todo = <span class="hljs-keyword">new</span> Todo()

<span class="hljs-string">&quot;done&quot;</span> <span class="hljs-keyword">in</span> todo 
todo.hasOwnProperty(<span class="hljs-string">&quot;done&quot;</span>) 
<span class="hljs-built_in">Object</span>.keys(todo) 

<span class="hljs-built_in">console</span>.log(todo.title)
<span class="hljs-string">&quot;done&quot;</span> <span class="hljs-keyword">in</span> todo 
todo.hasOwnProperty(<span class="hljs-string">&quot;done&quot;</span>) 
<span class="hljs-built_in">Object</span>.keys(todo) 
</code></pre>
<p>In practice this is rarely an issue, only when using generic methods like <code>Object.assign(target, todo)</code> or <code>assert.deepEquals</code> <em>before</em> reading or writing any property of the object.
If you want to make sure that this issue doesn&apos;t occur, just initialize the fields in the constructor instead of at the field declaration or use <code>extendObservable</code> to create the observable properties.</p>

                    
                    </section></div>
        </article>
      
        <article>
          <h3>Defining data stores</h3>
          <div><section class="normal" id="section-">
                    
                        <a id="edit-link" href="https://github.com/mobxjs/mobx/tree/gh-pages/docs/best/store.md" class="btn fa fa-edit pull-left">&#xA0;&#xA0;Edit This Page</a><h1 id="best-practices-for-building-large-scale-maintainable-projects">Best Practices for building large scale maintainable projects</h1>
<p>This section contains some best practices we discovered at Mendix while working with MobX.
This section is opinionated and you are in no way forced to apply these practices.
There are many ways of working with MobX and React, and this is just one of them.</p>
<h1 id="stores">Stores</h1>
<p>Let&apos;s start with <em>stores</em>.
In the next sections we will discuss <em>actions</em> and React <em>components</em> as well.
Stores can be found in any Flux architecture and can be compared a bit with controllers in the MVC pattern.
The main responsibility of stores is to move <em>logic</em> and <em>state</em> out of your components into a standalone testable unit that can be used in both frontend and backend JavaScript.</p>
<h2 id="stores-for-the-user-interface-state">Stores for the user interface state</h2>
<p>Most applications benefit from having at least two stores.
One for the <em>UI state</em> and one or more for the <em>domain state</em>.
The advantage of separating those two is you can reuse and test <em>domain state</em> universally, and you might very well reuse it in other applications.
The <em>ui-state-store</em> however is often very specific for your application.
But usually very simple as well.
This store typically doesn&apos;t have much logic in it, but will store a plethora of loosely coupled pieces of information about the UI.
This is ideal as most applications will change the UI state often during the development process.</p>
<p>Things you will typically find in UI stores:</p>
<ul>
<li>Session information</li>
<li>Information about how far your application has loaded</li>
<li>Information that will not be stored in the backend</li>
<li>Information that affects the UI globally<ul>
<li>Window dimensions</li>
<li>Accessibility information</li>
<li>Current language</li>
<li>Currently active theme</li>
</ul>
</li>
<li>User interface state as soon as it effects multiple, further unrelated components:<ul>
<li>Current selection</li>
<li>Visibility of toolbars, etc.</li>
<li>State of a wizard</li>
<li>State of a global overlay</li>
</ul>
</li>
</ul>
<p>It might very well be that these pieces of information start as internal state of a specific component (for example the visibility of a toolbar).
But after a while you discover that you need this information somewhere else in your application.
Instead of pushing state in such a case upwards in the component tree, like you would do in plain React apps, you just move that state to the <em>ui-state-store</em>.</p>
<p>Make sure this state is a singleton.
For isomorphic applications you might also want to provide a stub implementation of this store with sane defaults so that all components render as expected.
You might distribute the <em>ui-state-store</em> through your application by passing it as a property through your component tree.
You can also pass this store by using context or make it globally available as a module.
For testing purposes, I recommend to just pass it through the component tree.</p>
<p>Example of a store (using ES6 syntax):</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">import</span> {observable, computed, asStructure} <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;mobx&apos;</span>;
<span class="hljs-keyword">import</span> jquery <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;jquery&apos;</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UiState</span> </span>{
    @observable language = <span class="hljs-string">&quot;en_US&quot;</span>;
    @observable pendingRequestCount = <span class="hljs-number">0</span>;

    
    
    @observable windowDimensions = asStructure({
        width: jquery(<span class="hljs-built_in">window</span>).width(),
        height: jquery(<span class="hljs-built_in">window</span>).height()
    });

    constructor() {
        jquery.resize(() =&gt; {
            <span class="hljs-keyword">this</span>.windowDimensions = getWindowDimensions();
        });
    }

    @computed get appIsInSync() {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.pendingRequestCount === <span class="hljs-number">0</span>
    }
}

singleton = <span class="hljs-keyword">new</span> UiState();
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> singleton;
</code></pre>
<h2 id="domain-stores">Domain Stores</h2>
<p>Your application will contain one or multiple <em>domain</em> stores.
These stores store the data your application is all about.
Todo items, users, books, movies, orders, you name it.
Your application will most probably have at least one domain store.</p>
<p>A single domain store should be responsible for a single concept in your application.
However a single concept might take the form of multiple subtypes and it is often a (cyclic) tree structure.
For example: one domain store for your products, and one for our orders and orderlines.
As a rule of thumb: if the nature of the relationship between two items is containment, they should typically be in the same store.
So a store just manages <em>domain objects</em>.</p>
<p>These are the responsibility of a store:</p>
<ul>
<li>Instantiate domain objects. Make sure domain objects know the store they belong to.</li>
<li>Make sure there is only one instance of each of your domain objects.
The same user, order or todo should not be twice in your memory.
This way you can safely use references and also be sure you are looking at the latest instance, without ever having to resolve a reference.
This is fast, straightforward and convenient when debugging.</li>
<li>Provide backend integration. Store data when needed.</li>
<li>Update existing instances if updates are received from the backend.</li>
<li>Provide a stand-alone, universal, testable component of your application.</li>
<li>To make sure your store is testable and can be run server-side, you probably will move doing actual websocket / http requests to a separate object so that you can abstract over your communication layer.</li>
<li>There should be only one instance of a store.</li>
</ul>
<h3 id="domain-objects">Domain objects</h3>
<p>Each domain object should be expressed using its own class (or constructor function).
It is recommended to store your data in <em>denormalized</em> form.
There is no need to treat your client-side application state as some kind of database.
Real references, cyclic data structures and instance methods are powerful concepts in JavaScript.
Domain objects are allowed to refer directly to domain objects from other stores.
Remember: we want to keep our actions and views as simple as possible and needing to manage references and doing garbage collection yourself might be a step backward.
Unlike many Flux architectures, with MobX there is no need to normalize your data, and this makes it a lot simpler to build the <em>essentially</em> complex parts of your application:
your business rules, actions and user interface.</p>
<p>Domain objects can delegate all their logic to the store they belong to if that suits your application well.
It is possible to express your domain objects as plain objects, but classes have some important advantages over plain objects:</p>
<ul>
<li>They can have methods.
This makes your domain concepts easier to use stand-alone and reduces the amount of contextual awareness that is needed in your application.
Just pass objects around.
You don&apos;t have to pass stores around, or have to figure out which actions can be applied to an object if they are just available as instance methods.
Especially in large applications this is important.</li>
<li>They offer fine grained control over the visibility of attributes and methods.</li>
<li>Objects created using a constructor function can freely mix observable properties and functions, and non-observable properties and methods.</li>
<li>They are easily recognizable and can strictly be type-checked.</li>
</ul>
<h3 id="example-domain-store">Example domain store</h3>
<pre><code class="lang-javascript"><span class="hljs-keyword">import</span> {observable, autorun} <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;mobx&apos;</span>;
<span class="hljs-keyword">import</span> uuid <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;node-uuid&apos;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TodoStore</span> </span>{
    authorStore;
    transportLayer;
    @observable todos = [];
    @observable isLoading = <span class="hljs-literal">true</span>;

    constructor(transportLayer, authorStore) {
        <span class="hljs-keyword">this</span>.authorStore = authorStore; 
        <span class="hljs-keyword">this</span>.transportLayer = transportLayer; 
        <span class="hljs-keyword">this</span>.transportLayer.onReceiveTodoUpdate(updatedTodo =&gt; <span class="hljs-keyword">this</span>.updateTodoFromServer(updatedTodo));
        <span class="hljs-keyword">this</span>.loadTodos();
    }

    
    loadTodos() {
        <span class="hljs-keyword">this</span>.isLoading = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">this</span>.transportLayer.fetchTodos().then(fetchedTodos =&gt; {
            fetchedTodos.forEach(json =&gt; <span class="hljs-keyword">this</span>.updateTodoFromServer(json));
            <span class="hljs-keyword">this</span>.isLoading = <span class="hljs-literal">false</span>;
        });
    }

    
    updateTodoFromServer(json) {
        <span class="hljs-keyword">var</span> todo = <span class="hljs-keyword">this</span>.todos.find(todo =&gt; todo.id === json.id);
        <span class="hljs-keyword">if</span> (!todo) {
            todo = <span class="hljs-keyword">new</span> Todo(<span class="hljs-keyword">this</span>, json.id);
            <span class="hljs-keyword">this</span>.todos.push(todo);
        }
        <span class="hljs-keyword">if</span> (json.isDeleted) {
            <span class="hljs-keyword">this</span>.removeTodo(todo);
        } <span class="hljs-keyword">else</span> {
            todo.updateFromJson(json);
        }
    }

    
    createTodo() {
        <span class="hljs-keyword">var</span> todo = <span class="hljs-keyword">new</span> Todo(<span class="hljs-keyword">this</span>);
        <span class="hljs-keyword">this</span>.todos.push(todo);
        <span class="hljs-keyword">return</span> todo;
    }

    
    removeTodo(todo) {
        <span class="hljs-keyword">this</span>.todos.splice(<span class="hljs-keyword">this</span>.todos.indexOf(todo), <span class="hljs-number">1</span>);
        todo.dispose();
    }
}

<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Todo</span> </span>{

    
    id = <span class="hljs-literal">null</span>;

    @observable completed = <span class="hljs-literal">false</span>;
    @observable task = <span class="hljs-string">&quot;&quot;</span>;

    
    @observable author = <span class="hljs-literal">null</span>;

    store = <span class="hljs-literal">null</span>;

    
    autoSave = <span class="hljs-literal">true</span>;

    
    saveHandler = <span class="hljs-literal">null</span>;

    constructor(store, id=uuid.v4()) {
        <span class="hljs-keyword">this</span>.store = store;
        <span class="hljs-keyword">this</span>.id = id;

        <span class="hljs-keyword">this</span>.saveHandler = reaction(
            
            () =&gt; <span class="hljs-keyword">this</span>.asJson,
            
            (json) =&gt; {
                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.autoSave) {
                    <span class="hljs-keyword">this</span>.store.transportLayer.saveTodo(json);
                }
            }
        });
    }

    
    <span class="hljs-keyword">delete</span>() {
        <span class="hljs-keyword">this</span>.store.transportLayer.deleteTodo(<span class="hljs-keyword">this</span>.id);
        <span class="hljs-keyword">this</span>.store.removeTodo(<span class="hljs-keyword">this</span>);
    }

    @computed get asJson() {
        <span class="hljs-keyword">return</span> {
            id: <span class="hljs-keyword">this</span>.id,
            completed: <span class="hljs-keyword">this</span>.completed,
            task: <span class="hljs-keyword">this</span>.task,
            authorId: <span class="hljs-keyword">this</span>.author ? <span class="hljs-keyword">this</span>.author.id : <span class="hljs-literal">null</span>
        };
    }

    
    updateFromJson(json) {
        
        <span class="hljs-keyword">this</span>.autoSave = <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">this</span>.completed = json.completed;
        <span class="hljs-keyword">this</span>.task = json.task;
        <span class="hljs-keyword">this</span>.author = <span class="hljs-keyword">this</span>.store.authorStore.resolveAuthor(json.authorId);
        <span class="hljs-keyword">this</span>.autoSave = <span class="hljs-literal">true</span>;
    }

    dispose() {
        
        <span class="hljs-keyword">this</span>.saveHandler();
    }
}
</code></pre>

                    
                    </section></div>
        </article>
      
        <article>
          <h3>Writing (async) actions</h3>
          <div><div class="page-inner"><span>
                
                
                    </span><section class="normal" id="section-">
                    
                        <a id="edit-link" href="https://github.com/mobxjs/mobx/tree/gh-pages/docs/best/actions.md" class="btn fa fa-edit pull-left">&#xA0;&#xA0;Edit This Page</a>
<p>Writing actions is straight-forward when using MobX.
Just create, change or delete data and MobX will make sure that changes are picked up by the store and the components that depend on your data.
Based on the store we have created in the previous section, actions become as simple as:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> todo = todoStore.createTodo();
todo.task = <span class="hljs-string">&quot;make coffee&quot;</span>;
</code></pre>
<p>That is enough to create a todo, submit it to the server and update our user interface accordingly.</p>

<p>Writing asynchronous actions is pretty simple as well.
You can use observable data structures as a promise.
This is what happens with the <code>isLoading</code> property in the <code>todoStore</code> for example:</p>
<pre><code class="lang-javascript">
    <span class="hljs-keyword">this</span>.isLoading = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">this</span>.transportLayer.fetchTodos().then(fetchedTodos =&gt; {
        fetchedTodos.forEach(json =&gt; <span class="hljs-keyword">this</span>.updateTodoFromServer(json));
        <span class="hljs-keyword">this</span>.isLoading = <span class="hljs-literal">false</span>;
    });

</code></pre>
<p>After completing the asynchronous action, just update your data and your views will update.
The render function of a React component could become as simple as:</p>
<pre><code class="lang-javascript">import {observer} from &quot;mobx-react&quot;;

var TodoOverview = observer(function(props) {
    var todoStore = props.todoStore;
    if (todoStore.isLoading) {
        return &lt;div&gt;Loading...&lt;/div&gt;;
    } else {
        return &lt;div&gt;{
            todoStore.todos.map(todo =&gt; &lt;TodoItem key={todo.id} todo={todo} /&gt;)
        }&lt;/div&gt;
    }
});
</code></pre>
<p>The above <code>TodoOverview</code> component will now update whenever <code>isLoading</code> changes, or when <code>isLoading</code> is true and the <code>todos</code> list changes.
Note that we could have expressed <code>todoStore.isLoading</code> as <code>todoStore.todos.length</code> as well.
The result would be exactly the same.</p>

                    
                    </section><span>
                
                
                </span></div></div>
        </article>
      
        <article>
          <h3>Optimizing React components</h3>
          <div><section class="normal" id="section-">
                    
                        <a id="edit-link" href="https://github.com/mobxjs/mobx/tree/gh-pages/docs/best/react-performance.md" class="btn fa fa-edit pull-left">&#xA0;&#xA0;Edit This Page</a>
<p>MobX is very fast, <a href="https://twitter.com/mweststrate/status/718444275239882753" target="_blank">often even faster than Redux</a>. But here are some tips to get most out of React and MobX. Note that most tips apply to React in general and are not specific for MobX.</p>
<h2 id="use-many-small-components">Use many small components</h2>
<p><code>@observer</code> components will track all values they use and re-render if any of them changes.
So the smaller your components are, the smaller the change they have to re-render; it means that more parts of your user interface have the possibility to render independently of each other.</p>
<h2 id="render-lists-in-dedicated-components">Render lists in dedicated components</h2>
<p>This is especially true when rendering big collections.
React is notoriously bad at rendering large collections as the reconciler has to evaluate the components produced by a collection on each collection change.
It is therefore recommended to have components that just map over a collection and render it, and render nothing else:</p>
<p>Bad:</p>
<pre><code class="lang-javascript">@observer class MyComponent extends Component {
    render() {
        const {todos, user} = this.props;
        return (&lt;div&gt;
            {user.name}
            &lt;ul&gt;
                {todos.map(todo =&gt; &lt;TodoView todo={todo} key={todo.id} /&gt;)}
            &lt;/ul&gt;
        &lt;/div&gt;)
    }
}
</code></pre>
<p>In the above listing React will unnecessarily need to reconcile all TodoView components when the <code>user.name</code> changes. They won&apos;t re-render, but the reconcile process is expensive in itself.</p>
<p>Good:</p>
<pre><code class="lang-javascript">@observer class MyComponent extends Component {
    render() {
        const {todos, user} = this.props;
        return (&lt;div&gt;
            {user.name}
            &lt;TodosView todos={todos} /&gt;
        &lt;/div&gt;)
    }
}

@observer class TodosView extends Component {
    render() {
        const {todos} = this.props;
        return &lt;ul&gt;
            {todos.map(todo =&gt; &lt;TodoView todo={todo} key={todo.id} /&gt;)}
        &lt;/ul&gt;)
    }
}
</code></pre>
<h2 id="don-t-use-array-indexes-as-keys">Don&apos;t use array indexes as keys</h2>
<p>Don&apos;t use array indexes or any value that might change in the future as key. Generate id&apos;s for your objects if needed.
See also this <a href="https://medium.com/@robinpokorny/index-as-a-key-is-an-anti-pattern-e0349aece318" target="_blank">blog</a>.</p>
<h2 id="dereference-values-lately">Dereference values lately</h2>
<p>When using <code>mobx-react</code> it is recommended to dereference values as late as possible.
This is because MobX will re-render components that dereference observable values automatically.
If this happens deeper in your component tree, less components have to re-render.</p>
<p>Fast:</p>
<p><code>&lt;DisplayName person={person} /&gt;</code></p>
<p>Slower:</p>
<p><code>&lt;DisplayName name={person.name} /&gt;</code>.</p>
<p>There is nothing wrong to the latter.
But a change in the <code>name</code> property will, in the first case, trigger the <code>DisplayName</code> to re-render, while in the latter, the owner of the component has to re-render.
However, it is more important for your components to have a comprehensible API than applying this optimization.
To have the best of both worlds, consider making smaller components:</p>
<p><code>const PersonNameDisplayer = observer(({ props }) =&gt; &lt;DisplayName name={props.person.name} /&gt;)</code></p>
<h2 id="bind-functions-early">Bind functions early</h2>
<p>This tip applies to React in general and libraries using <code>PureRenderMixin</code> especially, try to avoid creating new closures in render methods.</p>
<p>See also these resources:</p>

<p>Bad:</p>
<pre><code class="lang-javascript">render() {
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">MyWidget</span> <span class="hljs-attribute">onClick</span>=<span class="hljs-value">{()</span> =&gt;</span> { alert(&apos;hi&apos;) }} /&gt;
}
</span></code></pre>
<p>Good:</p>
<pre><code class="lang-javascript">render() {
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">MyWidget</span> <span class="hljs-attribute">onClick</span>=<span class="hljs-value">{this.handleClick}</span> /&gt;</span>
}

handleClick = () =&gt; {
    alert(&apos;hi&apos;)
}
</span></code></pre>
<p>The bad example will always yield the <code>shouldComponent</code> of <code>PureRenderMixin</code> used in <code>MyWidget</code> to always yield false as you pass a new function each time the parent is re-rendered.</p>

                    
                    </section></div>
        </article>
      
        <article>
          <h3>DevTools | MobX</h3>
          <div><div class="page-inner"><span>
                
                
                    </span><section class="normal" id="section-">
                    
                        <a id="edit-link" href="https://github.com/mobxjs/mobx/tree/gh-pages/docs/best/devtools.md" class="btn fa fa-edit pull-left">&#xA0;&#xA0;Edit This Page</a>
<p>MobX ships with DevTools that can be used to track the rendering behavior and data depenencies of your app.</p>
<p><img src="https://mobxjs.github.io/mobx/images/devtools.gif" alt="devtools"></p>

<p>Install:</p>
<p><code>npm install mobx-react-devtools</code></p>
<p>To enable devtools, require the devtools somewhere in your code-base.</p>
<p><code>require(&apos;mobx-react-devtools&apos;)</code></p>
<p>For more details check the <a href="https://github.com/mobxjs/mobx-react-devtools" target="_blank">mobx-react-devtools</a> repository.</p>

                    
                    </section><span>
                
                
                </span></div></div>
        </article>
      
        <article>
          <h3>ES5 / ES6 / TypeScript syntax</h3>
          <div><div class="page-inner"><span>
                
                
                    </span><section class="normal" id="section-">
                    
                        <a id="edit-link" href="https://github.com/mobxjs/mobx/tree/gh-pages/docs/best/syntax.md" class="btn fa fa-edit pull-left">&#xA0;&#xA0;Edit This Page</a>
<p>Here are some examples show you how you can make the state of a simple todo application observable,
using either plain objects or classes.
MobX ships with TypeScript typings in the package (supported in TypeScript 1.6 and higher).
So <code>import * as mobx from &quot;mobx&quot;</code> gives access to the strongly typed API without further imports.</p>
<h2 id="creating-objects">Creating objects</h2>
<h3 id="es5-es6-ts-making-plain-objects-observable">ES5 / ES6 / TS: Making plain objects observable</h3>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> todoStore = mobx.observable({
    todos: [{
          title: <span class="hljs-string">&apos;Find a clean mug&apos;</span>,
          completed: <span class="hljs-literal">true</span>
    }],
    completedCount: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.todos.filter(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">todo</span>) </span>{
            <span class="hljs-keyword">return</span> todo.completed;
        }).length;
    }
});
</code></pre>
<h3 id="es5-constructor-functions">ES5 constructor functions</h3>
<p>If <code>TodoStore</code> is a constructor function that is typically invoked using the <code>new</code> keyword,
<code>extendObservable</code> can be used to add observable properties to the object during creation:</p>
<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">TodoStore</span>(<span class="hljs-params"></span>) </span>{
    mobx.extendObservable(<span class="hljs-keyword">this</span>, {
        todos: [{
            title: <span class="hljs-string">&apos;Find a clean mug&apos;</span>,
            completed: <span class="hljs-literal">true</span>
        }],
        completedCount: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.todos.filter(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">todo</span>) </span>{
                <span class="hljs-keyword">return</span> todo.completed;
            }).length;
        }
    });
}
</code></pre>
<h3 id="es6-typescript-classes">ES6 / TypeScript classes</h3>
<p>When using ES6 or TypeScript it is recommended to use the <code>@observable</code> decorator to make observable properties and <code>@computed</code> for derivations.
Note that getters should be used to define observable functions on a class.This is to keep the type of a derived value consistent between ES5 / ES6 and TypeScript:
Use <code>store.completedCount</code> to obtain a derived value; not <code>store.completedCount()</code>.
In contrast, <code>@observable someFunction() {}</code> will just create an observable reference to <code>someFunction</code>, but <code>someFunction</code> itself won&apos;t become reactive.</p>
<pre><code class="lang-javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TodoStore</span> </span>{
    @observable todos = [{
        title: <span class="hljs-string">&apos;Find a clean mug&apos;</span>,
        completed: <span class="hljs-literal">true</span>
    }];

    @computed get completedCount() {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.todos.filter((todo) =&gt; todo.completed).length;
    }
}
</code></pre>
<h2 id="react-components">React components</h2>
<p>In combination with <code>@observer</code> decorator from the <code>mobx-react</code> package:</p>
<h2 id="components-in-es5">Components in ES5</h2>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> MyComponent = observer(React.createClass({
    componentWillMount: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        mobx.extendObservable(<span class="hljs-keyword">this</span>, {
            greeting: <span class="hljs-string">&quot;Hello&quot;</span>
        });
    },
    render: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">button</span> <span class="hljs-attribute">onClick</span>=<span class="hljs-value">{this.onButtonClick}</span>&gt;</span>{this.greeting}, world<span class="hljs-tag">&lt;/<span class="hljs-title">button</span>&gt;</span>
    },
    onButtonClick: function(e) {
        this.greeting = &quot;Hi&quot;
    }
});
</span></code></pre>
<p>If stateless component functions are used:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> MyOtherComponent = observer(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">props</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">div</span>&gt;</span>{props.user.name}<span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>;</span>
});
</code></pre>
<h2 id="components-in-es6-typescript">Components in ES6 / TypeScript</h2>
<pre><code class="lang-javascript">@observer <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
    render() {
        
        <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">button</span> <span class="hljs-attribute">onClick</span>=<span class="hljs-value">{this.onButtonClick}</span>&gt;</span>Hi<span class="hljs-tag">&lt;/<span class="hljs-title">button</span>&gt;</span>
    }

    onButtonClick = (e) =&gt; {
        // bound function
    }
}
</span></code></pre>
<p>If stateless component functions are used:</p>
<pre><code class="lang-javascript">const MyOtherComponent = observer(props =&gt; // ..or with destructuring: ({user}) =&gt; ..
    &lt;div&gt;{props.user.name{/div}
);
</code></pre>
<p>Please note that <code>onButtonClick</code> is not just a class method, but an instance field which gets a bound function.
This is the most convenient and the fastest way to create bound event handlers.
If <code>{this.onButtonClick.bind(this)}</code> or <code>{(e) =&gt; this.onButtonClick(e)}</code> was used instead in the rendering, each render invocation would create a new closures.
That is not only slightly slower in itself,
but it will also cause the <code>button</code> (or any other component) to be always re-rendered because you are effectively passing a new event handler to the button each time <code>MyComponent</code> is rendered.</p>
<h2 id="enabling-decorators-in-your-transpiler">Enabling decorators in your transpiler</h2>
<p>Decorators are not supported by default when using TypeScript or Babel pending a definitive definition in the ES standard.</p>
<ul>
<li>For <em>typescript</em>, enable the <code>--experimentalDecorators</code> compiler flag or set the compiler option <code>experimentalDecorators</code> to <code>true</code> in <code>tsconfig.json</code> (Recommended)</li>
<li>For <em>babel5</em>, make sure <code>--stage 0</code> is passed to the Babel CLI</li>
<li>For <em>babel6</em>, see the example configuration as suggested in this <a href="https://github.com/mobxjs/mobx/issues/105" target="_blank">issue</a>. In short, use the transform plugin <code>transform-decorators-legacy</code> and make sure it is first in the plugins list!</li>
</ul>

                    
                    </section><span>
                
                
                </span></div></div>
        </article>
      
        <article>
          <h3>Stateless Components and Hot Module Reloading</h3>
          <div><section class="normal" id="section-">
                    
                        <a id="edit-link" href="https://github.com/mobxjs/mobx/tree/gh-pages/docs/best/stateless-HMR.md" class="btn fa fa-edit pull-left">&#xA0;&#xA0;Edit This Page</a>
<p>One thing that can be a challenge when getting started with MobX (and React in general) is understanding why Hot Module Reloading (HMR) sometimes breaks. When you initially get it working, it seems like magic (and it kind of is), however there&apos;s at least one rough edge with regard to HMR and React: stateless components. Since stateless components don&apos;t explicitly identify themselves as React components, HMR doesn&apos;t quite know what to do with them, and so you&apos;ll often see warnings in your console like this:</p>
<pre><code>[HMR] The following modules couldn&apos;t be hot updated: (Full reload needed)
This is usually because the modules which have changed (and their parents) do not know how to hot reload themselves. See http://webpack.github.io/docs/hot-module-replacement-with-webpack.html for more details.
[HMR]  - ./src/ToDoItem.jsx
</code></pre><p>This is especially apparent when you start working with MobX since observables make it really easy to create a lot of stateless components. Here are some tips for how to build your stateless components and still get all the advantages of HMR:</p>
<h2 id="use-function-declarations-instead-of-arrow-functions">Use function declarations instead of arrow functions</h2>
<p>Function declarations still do the exact same thing as arrow functions, but they have the key advantage of actually having names inside of the React DevTools.</p>
<p>For instance, here&apos;s a stateless component built with an arrow function:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> ToDoItem = observer(props =&gt; <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">div</span>&gt;</span>{props.item}<span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>)</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> ToDoItem;
</code></pre>
<p>And here&apos;s how that will appear in the React DevTools:</p>
<p><img src="https://mobxjs.github.io/mobx/images/devtools-noDisplayName.png" alt="devtools-noname"></p>
<p>On the other hand, using a function declaration will allow you to build the same stateless component AND see it in the DevTools:</p>
<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ToDoItem</span>(<span class="hljs-params">props</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">div</span>&gt;</span>{props.item}<span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
}

export default observer(ToDoItem);
</span></code></pre>
<p>And now the component shows up correctly in the DevTools:</p>
<p><img src="https://mobxjs.github.io/mobx/images/devtools-withDisplayName.png" alt="devtools-withname"></p>
<h2 id="make-sure-your-top-level-component-is-a-stateful-observer">Make sure your top-level component is a stateful observer</h2>
<p>By &quot;stateful observer&quot;, all I really mean is a component created with <code>React.Component</code> or <code>React.createClass</code> and which uses the <code>@observer</code> decorator, like so:</p>
<pre><code class="lang-javascript">import { observer } from &apos;mobx-react&apos;;

@observer
class App extends React.Component {
  constructor(props) {
    super(props);
    this.store = props.store;
  }

  render() {
    return (
      &lt;div className=&quot;container&quot;&gt;
        &lt;h2&gt;Todos:&lt;/h2&gt;
        {
          this.store.todos.map((t, idx) =&gt; &lt;ToDoItem key={idx} item={t}/&gt;)
        }
      &lt;/div&gt;
    );
  }
}
</code></pre>
<p>In this case, <code>ToDoItem</code> is stateless, but will still work with HMR because the root-level of the UI tree is a stateful observer. As a result, whenever we change <strong>any</strong> stateless component, it will be hot-reloaded because the observers will trigger computations in the root-level component as well. And since the root-level component is a good old-fashioned React component, it&apos;ll trigger the HMR for all of its children and voila! All the magic of stateless components, observables, and hot module reloading working together beautifully.</p>

                    
                    </section></div>
        </article>
      <h2></h2>
        <article>
          <h3>Common Pitfalls & Best Practices</h3>
          <div><section class="normal" id="section-">
                    
                        <a id="edit-link" href="https://github.com/mobxjs/mobx/tree/gh-pages/docs/best/pitfalls.md" class="btn fa fa-edit pull-left">&#xA0;&#xA0;Edit This Page</a>
<p>Stuck with MobX? This section contains a list of common issues people new to MobX might run into.</p>
<h4 id="-array-isarray-observable-1-2-3-false"><code>Array.isArray(observable([1,2,3])) === false</code></h4>
<p>In ES5 there is no way to reliably inherit from arrays, and hence observable arrays inherit from objects.
This means that regularly libraries are not able to recognize observable arrays as normal arrays (like lodash, or built-in operations like <code>Array.concat</code>).
This can simply be fixed by passing calling <code>observable.toJS()</code> or <code>observable.slice()</code> before passing the array to another library.
As long as the external library has no intent to modify the array, this will further work completely as expected.
You can use <code>isObservableArray(observable)</code> to check whether something is an observable array.</p>
<h4 id="-object-somenewprop-value-is-not-picked-up"><code>object.someNewProp = value</code> is not picked up</h4>
<p>MobX observable <em>objects</em> do not detect or react to property assignments that weren&apos;t declared observable before.
So MobX observable objects act as records with predefined keys.
You can use <code>extendObservable(target, props)</code> to introduce new observable properties to an object.
However object iterators like <code>for .. in</code> or <code>Object.keys()</code> won&apos;t react to this automatically.
If you need a dynamically keyed object, for example to store users by id, create observable _map_s using <code>asMap</code>.
More info on <a href="https://github.com/mobxjs/mobx/issues/219#issuecomment-220224813" target="_blank">asMap</a>.
For more info see <a href="https://mobxjs.github.io/mobx/best/react.html">what will MobX react to?</a>.</p>
<h3 id="use-observer-on-all-components-that-render-observable-s">Use <code>@observer</code> on all components that render <code>@observable</code>&apos;s.</h3>
<p><code>@observer</code> only enhances the component you are decorating, not the components used inside it.
So usually all your components should be decorated. Don&apos;t worry, this is not inefficient, in contrast, more <code>observer</code> components make rendering more efficient.</p>
<h3 id="dereference-values-as-lately-as-possible">Dereference values as lately as possible</h3>
<p>MobX can do a lot, but it cannot make primitive values observable (although it can wrap them in an object see <a href="https://mobxjs.github.io/mobx/refguide/boxed.html">boxed observables</a>).
So it is not the <em>values</em> that are observable, but the <em>properties</em> of an object. This means that <code>@observer</code> actually reacts to the fact that you dereference a value.
So in our above example, the <code>Timer</code> component would <strong>not</strong> react if it was initialized as follows:</p>
<pre><code class="lang-javascript">React.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">Timer</span> <span class="hljs-attribute">timerData</span>=<span class="hljs-value">{timerData.secondsPassed}</span> /&gt;</span>, document.body)
</span></code></pre>
<p>In this snippet just the current value of <code>secondsPassed</code> is passed to the <code>Timer</code>, which is the immutable value <code>0</code> (all primitives are immutable in JS).
That number won&apos;t change anymore in the future, so <code>Timer</code> will never update. It is the property <code>secondsPassed</code> that will change in the future,
so we need to access it <em>in</em> the component. Or in other words: always try to pass the owning object of an observable property.
For more info see <a href="https://mobxjs.github.io/mobx/best/react.html">what will MobX react to?</a>.</p>
<h4 id="computed-values-run-more-often-then-expected">Computed values run more often then expected</h4>
<p>If a computed property is <em>not</em> in use by some reaction (<code>autorun</code>, <code>observer</code> etc), computed expressions will be evaluated lazily; each time their value is requested (so they just act as normal property).
Computed values will only track their dependencies if they are observed.
This allows MobX to automatically suspend computations that are not actively in use.
See this <a href="https://medium.com/@mweststrate/becoming-fully-reactive-an-in-depth-explanation-of-mobservable-55995262a254" target="_blank">blog</a> or <a href="https://github.com/mobxjs/mobx/issues/356" target="_blank">issue #356</a> for an explanation.
So if you fiddle arounds, computed properties might not seem efficient. But when applied in a project that uses <code>observer</code>, <code>autorun</code> etc, they become very efficient.</p>
<p><em>N.B. in a next version of MobX computeds will automatically be kept alive during transactions as well, see PR: #452</em></p>
<h4 id="always-dispose-reactions">Always dispose reactions</h4>
<p>all forms of <code>autorun</code>, <code>observe</code> and <code>intercept</code> will only be garbage collected if all objects they observe are garbage collection themselves.
So it is recommend to use the disposer function that is returned from these methods to stop them when you no longer need them.
Usually for <code>observe</code> and <code>intercept</code> it is not strictly necessary to dispose them if when targed <code>this</code>.
For reactions like <code>autorun</code> it is more tricky, as they might observe many different observables, and as long as one of them is still in scope,
the reaction will remain in scope which means that all other observables it uses are also kept alive to support future recomputions.
So make sure to always dispose your reactions when you no longer need them!</p>
<p>Example:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> VAT = observable(<span class="hljs-number">1.20</span>)

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderLIne</span> </span>{
    @observable price = <span class="hljs-number">10</span>;
    @observable amount = <span class="hljs-number">1</span>;
    constructor() {
        
        <span class="hljs-keyword">this</span>.handler = autorun(() =&gt; {
            doSomethingWith(<span class="hljs-keyword">this</span>.price * <span class="hljs-keyword">this</span>.amount)
        })
        
        
        
        <span class="hljs-keyword">this</span>.handler = autorun(() =&gt; {
            doSomethingWith(<span class="hljs-keyword">this</span>.price * <span class="hljs-keyword">this</span>.amount * VAT.get())
        })
        
        <span class="hljs-keyword">this</span>.handler()
        
    }
}
</code></pre>
<h4 id="i-have-a-weird-exception-when-using-observable-in-a-react-component">I have a weird exception when using <code>@observable</code> in a React component.</h4>
<p>The following exception: <code>Uncaught TypeError: Cannot assign to read only property &apos;__mobxLazyInitializers&apos; of object</code> occurs when using a <code>react-hot-loader</code> that does not support decorators.
Either use <code>extendObservable</code> in <code>componentWillMount</code> instead of <code>@observable</code>, or upgrade to <code>react-hot-loader</code> <code>&quot;^3.0.0-beta.2&quot;</code> or higher.</p>
<h4 id="the-display-name-of-react-components-is-not-set">The display name of react components is not set</h4>
<p>If you use <code>export const MyComponent = observer((props =&gt; &lt;div&gt;hi&lt;/div&gt;))</code>, no display name will be visible in the devtools.
The following approaches can be used to fix this:</p>
<pre><code class="lang-javascript">
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> MyComponent = observer((props =&gt; <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">div</span>&gt;</span>hi<span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>)</span>)
myComponent.displayName = <span class="hljs-string">&quot;MyComponent&quot;</span>


<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> MyComponent = observer(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MyComponent</span>(<span class="hljs-params">props</span>) </span>{ <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">div</span>&gt;</span>hi<span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span> })

// 3 (transpiler will infer component name from variable name)
const _MyComponent = observer((props =&gt; <span class="hljs-tag">&lt;<span class="hljs-title">div</span>&gt;</span>hi<span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>)</span>) 
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> MyComponent = observer(_MyComponent)


<span class="hljs-keyword">const</span> MyComponent = observer((props =&gt; <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">div</span>&gt;</span>hi<span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>)</span>)
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> observer(MyComponent)
</code></pre>
<p>See also: <a href="http://mobxjs.github.io/mobx/best/stateless-HMR.html" target="_blank">http://mobxjs.github.io/mobx/best/stateless-HMR.html</a> or <a href="https://github.com/mobxjs/mobx/issues/141#issuecomment-228457886" target="_blank">#141</a>.</p>
<h4 id="the-proptype-of-an-observable-array-is-object">The propType of an observable array is object</h4>
<p>Observable arrays are actually objects, so they comply to <code>propTypes.object</code> instead of <code>array</code>.
<code>mobx-react</code> will <a href="https://github.com/mobxjs/mobx-react/pull/59" target="_blank">soon</a> provide explicit propTypes for observable data structures.</p>
<h4 id="declaring-proptypes-might-cause-unnecessary-renders-in-dev-mode">Declaring propTypes might cause unnecessary renders in dev mode</h4>
<p>See: <a href="https://github.com/mobxjs/mobx-react/issues/56" target="_blank">https://github.com/mobxjs/mobx-react/issues/56</a></p>
<h4 id="-observable-properties-initialize-lazily-when-using-babel"><code>@observable</code> properties initialize lazily when using Babel</h4>
<p>This issue only occurs when transpiling with Babel and not with Typescript (in which decorator support is more mature).
Observable properties will not be instantiated upon an instance until the first read / write to a property (at that point they all will be initialized).
This results in the following subtle bug:</p>
<pre><code class="lang-javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Todo</span> </span>{
    @observable done = <span class="hljs-literal">true</span>
    @observable title = <span class="hljs-string">&quot;test&quot;</span>
}
<span class="hljs-keyword">const</span> todo = <span class="hljs-keyword">new</span> Todo()

<span class="hljs-string">&quot;done&quot;</span> <span class="hljs-keyword">in</span> todo 
todo.hasOwnProperty(<span class="hljs-string">&quot;done&quot;</span>) 
<span class="hljs-built_in">Object</span>.keys(todo) 

<span class="hljs-built_in">console</span>.log(todo.title)
<span class="hljs-string">&quot;done&quot;</span> <span class="hljs-keyword">in</span> todo 
todo.hasOwnProperty(<span class="hljs-string">&quot;done&quot;</span>) 
<span class="hljs-built_in">Object</span>.keys(todo) 
</code></pre>
<p>In practice this is rarely an issue, only when using generic methods like <code>Object.assign(target, todo)</code> or <code>assert.deepEquals</code> <em>before</em> reading or writing any property of the object.
If you want to make sure that this issue doesn&apos;t occur, just initialize the fields in the constructor instead of at the field declaration or use <code>extendObservable</code> to create the observable properties.</p>

                    
                    </section></div>
        </article>
      <h2></h2>
        <article>
          <h3>Defining data stores</h3>
          <div><section class="normal" id="section-">
                    
                        <a id="edit-link" href="https://github.com/mobxjs/mobx/tree/gh-pages/docs/best/store.md" class="btn fa fa-edit pull-left">&#xA0;&#xA0;Edit This Page</a><h1 id="best-practices-for-building-large-scale-maintainable-projects">Best Practices for building large scale maintainable projects</h1>
<p>This section contains some best practices we discovered at Mendix while working with MobX.
This section is opinionated and you are in no way forced to apply these practices.
There are many ways of working with MobX and React, and this is just one of them.</p>
<h1 id="stores">Stores</h1>
<p>Let&apos;s start with <em>stores</em>.
In the next sections we will discuss <em>actions</em> and React <em>components</em> as well.
Stores can be found in any Flux architecture and can be compared a bit with controllers in the MVC pattern.
The main responsibility of stores is to move <em>logic</em> and <em>state</em> out of your components into a standalone testable unit that can be used in both frontend and backend JavaScript.</p>
<h2 id="stores-for-the-user-interface-state">Stores for the user interface state</h2>
<p>Most applications benefit from having at least two stores.
One for the <em>UI state</em> and one or more for the <em>domain state</em>.
The advantage of separating those two is you can reuse and test <em>domain state</em> universally, and you might very well reuse it in other applications.
The <em>ui-state-store</em> however is often very specific for your application.
But usually very simple as well.
This store typically doesn&apos;t have much logic in it, but will store a plethora of loosely coupled pieces of information about the UI.
This is ideal as most applications will change the UI state often during the development process.</p>
<p>Things you will typically find in UI stores:</p>
<ul>
<li>Session information</li>
<li>Information about how far your application has loaded</li>
<li>Information that will not be stored in the backend</li>
<li>Information that affects the UI globally<ul>
<li>Window dimensions</li>
<li>Accessibility information</li>
<li>Current language</li>
<li>Currently active theme</li>
</ul>
</li>
<li>User interface state as soon as it effects multiple, further unrelated components:<ul>
<li>Current selection</li>
<li>Visibility of toolbars, etc.</li>
<li>State of a wizard</li>
<li>State of a global overlay</li>
</ul>
</li>
</ul>
<p>It might very well be that these pieces of information start as internal state of a specific component (for example the visibility of a toolbar).
But after a while you discover that you need this information somewhere else in your application.
Instead of pushing state in such a case upwards in the component tree, like you would do in plain React apps, you just move that state to the <em>ui-state-store</em>.</p>
<p>Make sure this state is a singleton.
For isomorphic applications you might also want to provide a stub implementation of this store with sane defaults so that all components render as expected.
You might distribute the <em>ui-state-store</em> through your application by passing it as a property through your component tree.
You can also pass this store by using context or make it globally available as a module.
For testing purposes, I recommend to just pass it through the component tree.</p>
<p>Example of a store (using ES6 syntax):</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">import</span> {observable, computed, asStructure} <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;mobx&apos;</span>;
<span class="hljs-keyword">import</span> jquery <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;jquery&apos;</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UiState</span> </span>{
    @observable language = <span class="hljs-string">&quot;en_US&quot;</span>;
    @observable pendingRequestCount = <span class="hljs-number">0</span>;

    
    
    @observable windowDimensions = asStructure({
        width: jquery(<span class="hljs-built_in">window</span>).width(),
        height: jquery(<span class="hljs-built_in">window</span>).height()
    });

    constructor() {
        jquery.resize(() =&gt; {
            <span class="hljs-keyword">this</span>.windowDimensions = getWindowDimensions();
        });
    }

    @computed get appIsInSync() {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.pendingRequestCount === <span class="hljs-number">0</span>
    }
}

singleton = <span class="hljs-keyword">new</span> UiState();
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> singleton;
</code></pre>
<h2 id="domain-stores">Domain Stores</h2>
<p>Your application will contain one or multiple <em>domain</em> stores.
These stores store the data your application is all about.
Todo items, users, books, movies, orders, you name it.
Your application will most probably have at least one domain store.</p>
<p>A single domain store should be responsible for a single concept in your application.
However a single concept might take the form of multiple subtypes and it is often a (cyclic) tree structure.
For example: one domain store for your products, and one for our orders and orderlines.
As a rule of thumb: if the nature of the relationship between two items is containment, they should typically be in the same store.
So a store just manages <em>domain objects</em>.</p>
<p>These are the responsibility of a store:</p>
<ul>
<li>Instantiate domain objects. Make sure domain objects know the store they belong to.</li>
<li>Make sure there is only one instance of each of your domain objects.
The same user, order or todo should not be twice in your memory.
This way you can safely use references and also be sure you are looking at the latest instance, without ever having to resolve a reference.
This is fast, straightforward and convenient when debugging.</li>
<li>Provide backend integration. Store data when needed.</li>
<li>Update existing instances if updates are received from the backend.</li>
<li>Provide a stand-alone, universal, testable component of your application.</li>
<li>To make sure your store is testable and can be run server-side, you probably will move doing actual websocket / http requests to a separate object so that you can abstract over your communication layer.</li>
<li>There should be only one instance of a store.</li>
</ul>
<h3 id="domain-objects">Domain objects</h3>
<p>Each domain object should be expressed using its own class (or constructor function).
It is recommended to store your data in <em>denormalized</em> form.
There is no need to treat your client-side application state as some kind of database.
Real references, cyclic data structures and instance methods are powerful concepts in JavaScript.
Domain objects are allowed to refer directly to domain objects from other stores.
Remember: we want to keep our actions and views as simple as possible and needing to manage references and doing garbage collection yourself might be a step backward.
Unlike many Flux architectures, with MobX there is no need to normalize your data, and this makes it a lot simpler to build the <em>essentially</em> complex parts of your application:
your business rules, actions and user interface.</p>
<p>Domain objects can delegate all their logic to the store they belong to if that suits your application well.
It is possible to express your domain objects as plain objects, but classes have some important advantages over plain objects:</p>
<ul>
<li>They can have methods.
This makes your domain concepts easier to use stand-alone and reduces the amount of contextual awareness that is needed in your application.
Just pass objects around.
You don&apos;t have to pass stores around, or have to figure out which actions can be applied to an object if they are just available as instance methods.
Especially in large applications this is important.</li>
<li>They offer fine grained control over the visibility of attributes and methods.</li>
<li>Objects created using a constructor function can freely mix observable properties and functions, and non-observable properties and methods.</li>
<li>They are easily recognizable and can strictly be type-checked.</li>
</ul>
<h3 id="example-domain-store">Example domain store</h3>
<pre><code class="lang-javascript"><span class="hljs-keyword">import</span> {observable, autorun} <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;mobx&apos;</span>;
<span class="hljs-keyword">import</span> uuid <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;node-uuid&apos;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TodoStore</span> </span>{
    authorStore;
    transportLayer;
    @observable todos = [];
    @observable isLoading = <span class="hljs-literal">true</span>;

    constructor(transportLayer, authorStore) {
        <span class="hljs-keyword">this</span>.authorStore = authorStore; 
        <span class="hljs-keyword">this</span>.transportLayer = transportLayer; 
        <span class="hljs-keyword">this</span>.transportLayer.onReceiveTodoUpdate(updatedTodo =&gt; <span class="hljs-keyword">this</span>.updateTodoFromServer(updatedTodo));
        <span class="hljs-keyword">this</span>.loadTodos();
    }

    
    loadTodos() {
        <span class="hljs-keyword">this</span>.isLoading = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">this</span>.transportLayer.fetchTodos().then(fetchedTodos =&gt; {
            fetchedTodos.forEach(json =&gt; <span class="hljs-keyword">this</span>.updateTodoFromServer(json));
            <span class="hljs-keyword">this</span>.isLoading = <span class="hljs-literal">false</span>;
        });
    }

    
    updateTodoFromServer(json) {
        <span class="hljs-keyword">var</span> todo = <span class="hljs-keyword">this</span>.todos.find(todo =&gt; todo.id === json.id);
        <span class="hljs-keyword">if</span> (!todo) {
            todo = <span class="hljs-keyword">new</span> Todo(<span class="hljs-keyword">this</span>, json.id);
            <span class="hljs-keyword">this</span>.todos.push(todo);
        }
        <span class="hljs-keyword">if</span> (json.isDeleted) {
            <span class="hljs-keyword">this</span>.removeTodo(todo);
        } <span class="hljs-keyword">else</span> {
            todo.updateFromJson(json);
        }
    }

    
    createTodo() {
        <span class="hljs-keyword">var</span> todo = <span class="hljs-keyword">new</span> Todo(<span class="hljs-keyword">this</span>);
        <span class="hljs-keyword">this</span>.todos.push(todo);
        <span class="hljs-keyword">return</span> todo;
    }

    
    removeTodo(todo) {
        <span class="hljs-keyword">this</span>.todos.splice(<span class="hljs-keyword">this</span>.todos.indexOf(todo), <span class="hljs-number">1</span>);
        todo.dispose();
    }
}

<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Todo</span> </span>{

    
    id = <span class="hljs-literal">null</span>;

    @observable completed = <span class="hljs-literal">false</span>;
    @observable task = <span class="hljs-string">&quot;&quot;</span>;

    
    @observable author = <span class="hljs-literal">null</span>;

    store = <span class="hljs-literal">null</span>;

    
    autoSave = <span class="hljs-literal">true</span>;

    
    saveHandler = <span class="hljs-literal">null</span>;

    constructor(store, id=uuid.v4()) {
        <span class="hljs-keyword">this</span>.store = store;
        <span class="hljs-keyword">this</span>.id = id;

        <span class="hljs-keyword">this</span>.saveHandler = reaction(
            
            () =&gt; <span class="hljs-keyword">this</span>.asJson,
            
            (json) =&gt; {
                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.autoSave) {
                    <span class="hljs-keyword">this</span>.store.transportLayer.saveTodo(json);
                }
            }
        });
    }

    
    <span class="hljs-keyword">delete</span>() {
        <span class="hljs-keyword">this</span>.store.transportLayer.deleteTodo(<span class="hljs-keyword">this</span>.id);
        <span class="hljs-keyword">this</span>.store.removeTodo(<span class="hljs-keyword">this</span>);
    }

    @computed get asJson() {
        <span class="hljs-keyword">return</span> {
            id: <span class="hljs-keyword">this</span>.id,
            completed: <span class="hljs-keyword">this</span>.completed,
            task: <span class="hljs-keyword">this</span>.task,
            authorId: <span class="hljs-keyword">this</span>.author ? <span class="hljs-keyword">this</span>.author.id : <span class="hljs-literal">null</span>
        };
    }

    
    updateFromJson(json) {
        
        <span class="hljs-keyword">this</span>.autoSave = <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">this</span>.completed = json.completed;
        <span class="hljs-keyword">this</span>.task = json.task;
        <span class="hljs-keyword">this</span>.author = <span class="hljs-keyword">this</span>.store.authorStore.resolveAuthor(json.authorId);
        <span class="hljs-keyword">this</span>.autoSave = <span class="hljs-literal">true</span>;
    }

    dispose() {
        
        <span class="hljs-keyword">this</span>.saveHandler();
    }
}
</code></pre>

                    
                    </section></div>
        </article>
      <h2></h2>
        <article>
          <h3>Writing (async) actions</h3>
          <div><div class="page-inner"><span>
                
                
                    </span><section class="normal" id="section-">
                    
                        <a id="edit-link" href="https://github.com/mobxjs/mobx/tree/gh-pages/docs/best/actions.md" class="btn fa fa-edit pull-left">&#xA0;&#xA0;Edit This Page</a>
<p>Writing actions is straight-forward when using MobX.
Just create, change or delete data and MobX will make sure that changes are picked up by the store and the components that depend on your data.
Based on the store we have created in the previous section, actions become as simple as:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> todo = todoStore.createTodo();
todo.task = <span class="hljs-string">&quot;make coffee&quot;</span>;
</code></pre>
<p>That is enough to create a todo, submit it to the server and update our user interface accordingly.</p>

<p>Writing asynchronous actions is pretty simple as well.
You can use observable data structures as a promise.
This is what happens with the <code>isLoading</code> property in the <code>todoStore</code> for example:</p>
<pre><code class="lang-javascript">
    <span class="hljs-keyword">this</span>.isLoading = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">this</span>.transportLayer.fetchTodos().then(fetchedTodos =&gt; {
        fetchedTodos.forEach(json =&gt; <span class="hljs-keyword">this</span>.updateTodoFromServer(json));
        <span class="hljs-keyword">this</span>.isLoading = <span class="hljs-literal">false</span>;
    });

</code></pre>
<p>After completing the asynchronous action, just update your data and your views will update.
The render function of a React component could become as simple as:</p>
<pre><code class="lang-javascript">import {observer} from &quot;mobx-react&quot;;

var TodoOverview = observer(function(props) {
    var todoStore = props.todoStore;
    if (todoStore.isLoading) {
        return &lt;div&gt;Loading...&lt;/div&gt;;
    } else {
        return &lt;div&gt;{
            todoStore.todos.map(todo =&gt; &lt;TodoItem key={todo.id} todo={todo} /&gt;)
        }&lt;/div&gt;
    }
});
</code></pre>
<p>The above <code>TodoOverview</code> component will now update whenever <code>isLoading</code> changes, or when <code>isLoading</code> is true and the <code>todos</code> list changes.
Note that we could have expressed <code>todoStore.isLoading</code> as <code>todoStore.todos.length</code> as well.
The result would be exactly the same.</p>

                    
                    </section><span>
                
                
                </span></div></div>
        </article>
      <h2></h2>
        <article>
          <h3>Optimizing React components</h3>
          <div><section class="normal" id="section-">
                    
                        <a id="edit-link" href="https://github.com/mobxjs/mobx/tree/gh-pages/docs/best/react-performance.md" class="btn fa fa-edit pull-left">&#xA0;&#xA0;Edit This Page</a>
<p>MobX is very fast, <a href="https://twitter.com/mweststrate/status/718444275239882753" target="_blank">often even faster than Redux</a>. But here are some tips to get most out of React and MobX. Note that most tips apply to React in general and are not specific for MobX.</p>
<h2 id="use-many-small-components">Use many small components</h2>
<p><code>@observer</code> components will track all values they use and re-render if any of them changes.
So the smaller your components are, the smaller the change they have to re-render; it means that more parts of your user interface have the possibility to render independently of each other.</p>
<h2 id="render-lists-in-dedicated-components">Render lists in dedicated components</h2>
<p>This is especially true when rendering big collections.
React is notoriously bad at rendering large collections as the reconciler has to evaluate the components produced by a collection on each collection change.
It is therefore recommended to have components that just map over a collection and render it, and render nothing else:</p>
<p>Bad:</p>
<pre><code class="lang-javascript">@observer class MyComponent extends Component {
    render() {
        const {todos, user} = this.props;
        return (&lt;div&gt;
            {user.name}
            &lt;ul&gt;
                {todos.map(todo =&gt; &lt;TodoView todo={todo} key={todo.id} /&gt;)}
            &lt;/ul&gt;
        &lt;/div&gt;)
    }
}
</code></pre>
<p>In the above listing React will unnecessarily need to reconcile all TodoView components when the <code>user.name</code> changes. They won&apos;t re-render, but the reconcile process is expensive in itself.</p>
<p>Good:</p>
<pre><code class="lang-javascript">@observer class MyComponent extends Component {
    render() {
        const {todos, user} = this.props;
        return (&lt;div&gt;
            {user.name}
            &lt;TodosView todos={todos} /&gt;
        &lt;/div&gt;)
    }
}

@observer class TodosView extends Component {
    render() {
        const {todos} = this.props;
        return &lt;ul&gt;
            {todos.map(todo =&gt; &lt;TodoView todo={todo} key={todo.id} /&gt;)}
        &lt;/ul&gt;)
    }
}
</code></pre>
<h2 id="don-t-use-array-indexes-as-keys">Don&apos;t use array indexes as keys</h2>
<p>Don&apos;t use array indexes or any value that might change in the future as key. Generate id&apos;s for your objects if needed.
See also this <a href="https://medium.com/@robinpokorny/index-as-a-key-is-an-anti-pattern-e0349aece318" target="_blank">blog</a>.</p>
<h2 id="dereference-values-lately">Dereference values lately</h2>
<p>When using <code>mobx-react</code> it is recommended to dereference values as late as possible.
This is because MobX will re-render components that dereference observable values automatically.
If this happens deeper in your component tree, less components have to re-render.</p>
<p>Fast:</p>
<p><code>&lt;DisplayName person={person} /&gt;</code></p>
<p>Slower:</p>
<p><code>&lt;DisplayName name={person.name} /&gt;</code>.</p>
<p>There is nothing wrong to the latter.
But a change in the <code>name</code> property will, in the first case, trigger the <code>DisplayName</code> to re-render, while in the latter, the owner of the component has to re-render.
However, it is more important for your components to have a comprehensible API than applying this optimization.
To have the best of both worlds, consider making smaller components:</p>
<p><code>const PersonNameDisplayer = observer(({ props }) =&gt; &lt;DisplayName name={props.person.name} /&gt;)</code></p>
<h2 id="bind-functions-early">Bind functions early</h2>
<p>This tip applies to React in general and libraries using <code>PureRenderMixin</code> especially, try to avoid creating new closures in render methods.</p>
<p>See also these resources:</p>

<p>Bad:</p>
<pre><code class="lang-javascript">render() {
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">MyWidget</span> <span class="hljs-attribute">onClick</span>=<span class="hljs-value">{()</span> =&gt;</span> { alert(&apos;hi&apos;) }} /&gt;
}
</span></code></pre>
<p>Good:</p>
<pre><code class="lang-javascript">render() {
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">MyWidget</span> <span class="hljs-attribute">onClick</span>=<span class="hljs-value">{this.handleClick}</span> /&gt;</span>
}

handleClick = () =&gt; {
    alert(&apos;hi&apos;)
}
</span></code></pre>
<p>The bad example will always yield the <code>shouldComponent</code> of <code>PureRenderMixin</code> used in <code>MyWidget</code> to always yield false as you pass a new function each time the parent is re-rendered.</p>

                    
                    </section></div>
        </article>
      <h2></h2>
        <article>
          <h3>DevTools | MobX</h3>
          <div><div class="page-inner"><span>
                
                
                    </span><section class="normal" id="section-">
                    
                        <a id="edit-link" href="https://github.com/mobxjs/mobx/tree/gh-pages/docs/best/devtools.md" class="btn fa fa-edit pull-left">&#xA0;&#xA0;Edit This Page</a>
<p>MobX ships with DevTools that can be used to track the rendering behavior and data depenencies of your app.</p>
<p><img src="https://mobxjs.github.io/mobx/images/devtools.gif" alt="devtools"></p>

<p>Install:</p>
<p><code>npm install mobx-react-devtools</code></p>
<p>To enable devtools, require the devtools somewhere in your code-base.</p>
<p><code>require(&apos;mobx-react-devtools&apos;)</code></p>
<p>For more details check the <a href="https://github.com/mobxjs/mobx-react-devtools" target="_blank">mobx-react-devtools</a> repository.</p>

                    
                    </section><span>
                
                
                </span></div></div>
        </article>
      <h2></h2>
        <article>
          <h3>ES5 / ES6 / TypeScript syntax</h3>
          <div><div class="page-inner"><span>
                
                
                    </span><section class="normal" id="section-">
                    
                        <a id="edit-link" href="https://github.com/mobxjs/mobx/tree/gh-pages/docs/best/syntax.md" class="btn fa fa-edit pull-left">&#xA0;&#xA0;Edit This Page</a>
<p>Here are some examples show you how you can make the state of a simple todo application observable,
using either plain objects or classes.
MobX ships with TypeScript typings in the package (supported in TypeScript 1.6 and higher).
So <code>import * as mobx from &quot;mobx&quot;</code> gives access to the strongly typed API without further imports.</p>
<h2 id="creating-objects">Creating objects</h2>
<h3 id="es5-es6-ts-making-plain-objects-observable">ES5 / ES6 / TS: Making plain objects observable</h3>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> todoStore = mobx.observable({
    todos: [{
          title: <span class="hljs-string">&apos;Find a clean mug&apos;</span>,
          completed: <span class="hljs-literal">true</span>
    }],
    completedCount: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.todos.filter(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">todo</span>) </span>{
            <span class="hljs-keyword">return</span> todo.completed;
        }).length;
    }
});
</code></pre>
<h3 id="es5-constructor-functions">ES5 constructor functions</h3>
<p>If <code>TodoStore</code> is a constructor function that is typically invoked using the <code>new</code> keyword,
<code>extendObservable</code> can be used to add observable properties to the object during creation:</p>
<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">TodoStore</span>(<span class="hljs-params"></span>) </span>{
    mobx.extendObservable(<span class="hljs-keyword">this</span>, {
        todos: [{
            title: <span class="hljs-string">&apos;Find a clean mug&apos;</span>,
            completed: <span class="hljs-literal">true</span>
        }],
        completedCount: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.todos.filter(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">todo</span>) </span>{
                <span class="hljs-keyword">return</span> todo.completed;
            }).length;
        }
    });
}
</code></pre>
<h3 id="es6-typescript-classes">ES6 / TypeScript classes</h3>
<p>When using ES6 or TypeScript it is recommended to use the <code>@observable</code> decorator to make observable properties and <code>@computed</code> for derivations.
Note that getters should be used to define observable functions on a class.This is to keep the type of a derived value consistent between ES5 / ES6 and TypeScript:
Use <code>store.completedCount</code> to obtain a derived value; not <code>store.completedCount()</code>.
In contrast, <code>@observable someFunction() {}</code> will just create an observable reference to <code>someFunction</code>, but <code>someFunction</code> itself won&apos;t become reactive.</p>
<pre><code class="lang-javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TodoStore</span> </span>{
    @observable todos = [{
        title: <span class="hljs-string">&apos;Find a clean mug&apos;</span>,
        completed: <span class="hljs-literal">true</span>
    }];

    @computed get completedCount() {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.todos.filter((todo) =&gt; todo.completed).length;
    }
}
</code></pre>
<h2 id="react-components">React components</h2>
<p>In combination with <code>@observer</code> decorator from the <code>mobx-react</code> package:</p>
<h2 id="components-in-es5">Components in ES5</h2>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> MyComponent = observer(React.createClass({
    componentWillMount: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        mobx.extendObservable(<span class="hljs-keyword">this</span>, {
            greeting: <span class="hljs-string">&quot;Hello&quot;</span>
        });
    },
    render: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">button</span> <span class="hljs-attribute">onClick</span>=<span class="hljs-value">{this.onButtonClick}</span>&gt;</span>{this.greeting}, world<span class="hljs-tag">&lt;/<span class="hljs-title">button</span>&gt;</span>
    },
    onButtonClick: function(e) {
        this.greeting = &quot;Hi&quot;
    }
});
</span></code></pre>
<p>If stateless component functions are used:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> MyOtherComponent = observer(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">props</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">div</span>&gt;</span>{props.user.name}<span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>;</span>
});
</code></pre>
<h2 id="components-in-es6-typescript">Components in ES6 / TypeScript</h2>
<pre><code class="lang-javascript">@observer <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
    render() {
        
        <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">button</span> <span class="hljs-attribute">onClick</span>=<span class="hljs-value">{this.onButtonClick}</span>&gt;</span>Hi<span class="hljs-tag">&lt;/<span class="hljs-title">button</span>&gt;</span>
    }

    onButtonClick = (e) =&gt; {
        // bound function
    }
}
</span></code></pre>
<p>If stateless component functions are used:</p>
<pre><code class="lang-javascript">const MyOtherComponent = observer(props =&gt; // ..or with destructuring: ({user}) =&gt; ..
    &lt;div&gt;{props.user.name{/div}
);
</code></pre>
<p>Please note that <code>onButtonClick</code> is not just a class method, but an instance field which gets a bound function.
This is the most convenient and the fastest way to create bound event handlers.
If <code>{this.onButtonClick.bind(this)}</code> or <code>{(e) =&gt; this.onButtonClick(e)}</code> was used instead in the rendering, each render invocation would create a new closures.
That is not only slightly slower in itself,
but it will also cause the <code>button</code> (or any other component) to be always re-rendered because you are effectively passing a new event handler to the button each time <code>MyComponent</code> is rendered.</p>
<h2 id="enabling-decorators-in-your-transpiler">Enabling decorators in your transpiler</h2>
<p>Decorators are not supported by default when using TypeScript or Babel pending a definitive definition in the ES standard.</p>
<ul>
<li>For <em>typescript</em>, enable the <code>--experimentalDecorators</code> compiler flag or set the compiler option <code>experimentalDecorators</code> to <code>true</code> in <code>tsconfig.json</code> (Recommended)</li>
<li>For <em>babel5</em>, make sure <code>--stage 0</code> is passed to the Babel CLI</li>
<li>For <em>babel6</em>, see the example configuration as suggested in this <a href="https://github.com/mobxjs/mobx/issues/105" target="_blank">issue</a>. In short, use the transform plugin <code>transform-decorators-legacy</code> and make sure it is first in the plugins list!</li>
</ul>

                    
                    </section><span>
                
                
                </span></div></div>
        </article>
      <h2></h2>
        <article>
          <h3>Stateless Components and Hot Module Reloading</h3>
          <div><section class="normal" id="section-">
                    
                        <a id="edit-link" href="https://github.com/mobxjs/mobx/tree/gh-pages/docs/best/stateless-HMR.md" class="btn fa fa-edit pull-left">&#xA0;&#xA0;Edit This Page</a>
<p>One thing that can be a challenge when getting started with MobX (and React in general) is understanding why Hot Module Reloading (HMR) sometimes breaks. When you initially get it working, it seems like magic (and it kind of is), however there&apos;s at least one rough edge with regard to HMR and React: stateless components. Since stateless components don&apos;t explicitly identify themselves as React components, HMR doesn&apos;t quite know what to do with them, and so you&apos;ll often see warnings in your console like this:</p>
<pre><code>[HMR] The following modules couldn&apos;t be hot updated: (Full reload needed)
This is usually because the modules which have changed (and their parents) do not know how to hot reload themselves. See http://webpack.github.io/docs/hot-module-replacement-with-webpack.html for more details.
[HMR]  - ./src/ToDoItem.jsx
</code></pre><p>This is especially apparent when you start working with MobX since observables make it really easy to create a lot of stateless components. Here are some tips for how to build your stateless components and still get all the advantages of HMR:</p>
<h2 id="use-function-declarations-instead-of-arrow-functions">Use function declarations instead of arrow functions</h2>
<p>Function declarations still do the exact same thing as arrow functions, but they have the key advantage of actually having names inside of the React DevTools.</p>
<p>For instance, here&apos;s a stateless component built with an arrow function:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> ToDoItem = observer(props =&gt; <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">div</span>&gt;</span>{props.item}<span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>)</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> ToDoItem;
</code></pre>
<p>And here&apos;s how that will appear in the React DevTools:</p>
<p><img src="https://mobxjs.github.io/mobx/images/devtools-noDisplayName.png" alt="devtools-noname"></p>
<p>On the other hand, using a function declaration will allow you to build the same stateless component AND see it in the DevTools:</p>
<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ToDoItem</span>(<span class="hljs-params">props</span>) </span>{
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">div</span>&gt;</span>{props.item}<span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
}

export default observer(ToDoItem);
</span></code></pre>
<p>And now the component shows up correctly in the DevTools:</p>
<p><img src="https://mobxjs.github.io/mobx/images/devtools-withDisplayName.png" alt="devtools-withname"></p>
<h2 id="make-sure-your-top-level-component-is-a-stateful-observer">Make sure your top-level component is a stateful observer</h2>
<p>By &quot;stateful observer&quot;, all I really mean is a component created with <code>React.Component</code> or <code>React.createClass</code> and which uses the <code>@observer</code> decorator, like so:</p>
<pre><code class="lang-javascript">import { observer } from &apos;mobx-react&apos;;

@observer
class App extends React.Component {
  constructor(props) {
    super(props);
    this.store = props.store;
  }

  render() {
    return (
      &lt;div className=&quot;container&quot;&gt;
        &lt;h2&gt;Todos:&lt;/h2&gt;
        {
          this.store.todos.map((t, idx) =&gt; &lt;ToDoItem key={idx} item={t}/&gt;)
        }
      &lt;/div&gt;
    );
  }
}
</code></pre>
<p>In this case, <code>ToDoItem</code> is stateless, but will still work with HMR because the root-level of the UI tree is a stateful observer. As a result, whenever we change <strong>any</strong> stateless component, it will be hot-reloaded because the observers will trigger computations in the root-level component as well. And since the root-level component is a good old-fashioned React component, it&apos;ll trigger the HMR for all of its children and voila! All the magic of stateless components, observables, and hot module reloading working together beautifully.</p>

                    
                    </section></div>
        </article>
      <h2>7. Utility functions</h2>
        <article>
          <h3>autorunAsync</h3>
          <div><div class="page-inner"><span>
                
                
                    </span><section class="normal" id="section-">
                    
                        <a id="edit-link" href="https://github.com/mobxjs/mobx/tree/gh-pages/docs/refguide/autorun-async.md" class="btn fa fa-edit pull-left">&#xA0;&#xA0;Edit This Page</a>
<p><code>autorunAsync(action: () =&gt; void, minimumDelay?: number, scope?)</code></p>
<p>Just like <code>autorun</code> except that the action won&apos;t be invoked synchronously but asynchronously after the minimum amount of milliseconds has passed.
The <code>action</code> will be run and observed.
However, instead of running the action immediately when the values it observes have changed, the <code>minimumDelay</code> will be awaited before re-execution the <code>action</code> again.</p>
<p>If observed values are changed multiple times while waiting, the action is still triggered only once, so in a sense it achieves a similar effect than a transaction.
This might be useful for stuff that is expensive and doesn&apos;t need to happen synchronously; such as debouncing server communication.
If a string is passed as first argument to <code>autorun</code>, it will be used as debug name.</p>
<p><code>autorunAsync</code> returns a disposer to cancel the autorun.</p>
<pre><code class="lang-javascript">autorunAsync(() =&gt; {
    
    
    
    sendProfileToServer(profile.asJson);
}, <span class="hljs-number">300</span>);
</code></pre>

                    
                    </section><span>
                
                
                </span></div></div>
        </article>
      
        <article>
          <h3>Atom & Reaction</h3>
          <div><div class="page-inner"><span>
                
                
                    </span><section class="normal" id="section-">
                    
                        <a id="edit-link" href="https://github.com/mobxjs/mobx/tree/gh-pages/docs/refguide/extending.md" class="btn fa fa-edit pull-left">&#xA0;&#xA0;Edit This Page</a>
<h2 id="atoms">Atoms</h2>
<p>At some point you might want to have more data structures or other things (like streams) that can be used in reactive computations.
Achieving that is pretty simple by using the <code>Atom</code> class.
Atoms can be used to signal MobX that some observable data source has been observed or changed.
And MobX will signal the atom whenever it is used or no longer in use.</p>
<p>The following example demonstrates how you can create an observable <code>Clock</code>, which can be used in reactive functions,
and returns the current date-time.
This clock will only actually tick if it is observed by someone.</p>
<p>The complete API of the <code>Atom</code> class is demonstrated by this example.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">import</span> {Atom, autorun} <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx&quot;</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Clock</span> </span>{
    atom;
    intervalHandler = <span class="hljs-literal">null</span>;
    currentDateTime;

    constructor() {
        
        <span class="hljs-keyword">this</span>.atom =    <span class="hljs-keyword">new</span> Atom(
            
            <span class="hljs-string">&quot;Clock&quot;</span>,
            
            () =&gt; <span class="hljs-keyword">this</span>.startTicking(),
            
            
            () =&gt; <span class="hljs-keyword">this</span>.stopTicking()
        );
    }

    getTime() {
        
        
        
        
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.atom.reportObserved()) {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.currentDateTime;
        } <span class="hljs-keyword">else</span> {
            
            
            
            
            
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();
        }
    }

    tick() {
        <span class="hljs-keyword">this</span>.currentDateTime = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();
        
        <span class="hljs-keyword">this</span>.atom.reportChanged();
    }

    startTicking() {
        <span class="hljs-keyword">this</span>.tick(); 
        <span class="hljs-keyword">this</span>.intervalHandler = setInterval(
            () =&gt; <span class="hljs-keyword">this</span>.tick(),
            <span class="hljs-number">1000</span>
        );
    }

    stopTicking() {
        clearInterval(<span class="hljs-keyword">this</span>.intervalHandler);
        <span class="hljs-keyword">this</span>.intervalHandler = <span class="hljs-literal">null</span>;
    }
}

<span class="hljs-keyword">const</span> clock = <span class="hljs-keyword">new</span> Clock();

<span class="hljs-keyword">const</span> disposer = autorun(() =&gt; <span class="hljs-built_in">console</span>.log(clock.getTime()));



disposer();


</code></pre>
<h2 id="reactions">Reactions</h2>
<p><code>Reaction</code> allows you to create your own &apos;auto runner&apos;.
Reactions track a function and signal when the function should be executed again because one or more dependencies have changed.</p>
<p>This is how <code>autorun</code> is defined using <code>Reaction</code>:</p>
<pre><code class="lang-typescript"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">autorun</span>(<span class="hljs-params">view: Lambda, scope?: <span class="hljs-built_in">any</span></span>) </span>{
    <span class="hljs-keyword">if</span> (scope)
        view = view.bind(scope);

    <span class="hljs-keyword">const</span> reaction = <span class="hljs-keyword">new</span> Reaction(view.name || <span class="hljs-string">&quot;Autorun&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">this</span>.track(view);
    });

    
    <span class="hljs-keyword">if</span> (isComputingDerivation() || globalState.inTransaction &gt; <span class="hljs-number">0</span>)
        globalState.pendingReactions.push(reaction);
    <span class="hljs-keyword">else</span>
        reaction.runReaction();

    <span class="hljs-keyword">return</span> reaction.getDisposer();
}
</code></pre>

                    
                    </section><span>
                
                
                </span></div></div>
        </article>
      
        <article>
          <h3>createTransformer</h3>
          <div><section class="normal" id="section-">
                    
                        <a id="edit-link" href="https://github.com/mobxjs/mobx/tree/gh-pages/docs/refguide/create-transformer.md" class="btn fa fa-edit pull-left">&#xA0;&#xA0;Edit This Page</a>
<p><code>createTransformer&lt;A, B&gt;(transformation: (value: A) =&gt; B, onCleanup?: (result: B, value?: A) =&gt; void): (value: A) =&gt; B</code></p>
<p><code>createTransformer</code> turns a function (that should transform one value into another value) into a reactive and memoizing function.
In other words, if the <code>transformation</code> function computes B given a specific A, the same B will be returned for all other future invocations of the transformation with the same A.
However, if A changes, the transformation will be re-applied so that B is updated accordingly.
And last but not least, if nobody is using the transformation of a specific A anymore, it&apos;s entry will be removed from the memoization table.</p>
<p>With <code>createTransformer</code> it is very easy to transform a complete data graph into another data graph.
Transformation functions can be composed so that you can build a tree using lots of small transformations.
The resulting data graph will never be stale, it will be kept in sync with the source by applying small patches to the result graph.
This makes it very easy to achieve powerful patterns similar to sideways data loading, map-reduce, tracking state history using immutable data structures etc.</p>
<p>The optional <code>onCleanup</code> function can be used to get a notification when a transformation of an object is no longer needed.
This can be used to dispose resources attached to the result object if needed.</p>
<p>Always use transformations inside a reaction like <code>@observer</code> or <code>autorun</code>.
Transformations will, like any other computed value, fall back to lazy evaluation if not observed by something, which sort of defeats their purpose.</p>
<p>This all might still be a bit vague, so here are two examples that explain this whole idea of transforming one data structure into another by using small, reactive functions:</p>
<h2 id="tracking-mutable-state-using-immutable-shared-data-structures">Tracking mutable state using immutable, shared data structures.</h2>
<p>This example is taken from the <a href="https://github.com/mobxjs/mobx-reactive2015-demo" target="_blank">Reactive2015 conference demo</a>:</p>
<pre><code class="lang-javascript">
<span class="hljs-keyword">const</span> store = observable({
    boxes: [],
    arrows: [],
    selection: <span class="hljs-literal">null</span>
});


<span class="hljs-keyword">const</span> states = [];

autorun(() =&gt; {
    states.push(serializeState(store));
});

<span class="hljs-keyword">const</span> serializeState = createTransformer(store =&gt; ({
    boxes: store.boxes.map(serializeBox),
    arrows: store.arrows.map(serializeArrow),
    selection: store.selection ? store.selection.id : <span class="hljs-literal">null</span>
}));

<span class="hljs-keyword">const</span> serializeBox = createTransformer(box =&gt; ({...box}));

<span class="hljs-keyword">const</span> serializeArrow = createTransformer(arrow =&gt; ({
    id: arrow.id,
    to: arrow.to.id,
    from: arrow.from.id
}));
</code></pre>
<p>In this example the state is serialized by composing three different transformation functions.
The autorunner triggers the serialization of the <code>store</code> object, which in turn serializes all boxes and arrows.
Let&apos;s take closer look at the life of an imaginary example box#3.</p>
<ol>
<li>The first time box#3 is passed by <code>map</code> to <code>serializeBox</code>,
the serializeBox transformation is executed and an entry containing box#3 and its serialized representation is added to the internal memoization table of <code>serializeBox</code>.</li>
<li>Imagine that another box is added to the <code>store.boxes</code> list.
This would cause the <code>serializeState</code> function to re-compute, resulting in a complete remapping of all the boxes.
However, all the invocations of <code>serializeBox</code> will now return their old values from the memoization tables since their transformation functions didn&apos;t (need to) run again.</li>
<li>Secondly, if somebody changes a property of box#3 this will cause the application of the <code>serializeBox</code> to box#3 to re-compute, just like any other reactive function in MobX.
Since the transformation will now produce a new Json object based on box#3, all observers of that specific transformation will be forced to run again as well.
That&apos;s the <code>serializeState</code> transformation in this case.
<code>serializeState</code> will now produce a new value in turn and map all the boxes again. But except for box#3, all other boxes will be returned from the memoization table.</li>
<li>Finally, if box#3 is removed from <code>store.boxes</code>, <code>serializeState</code> will compute again.
But since it will no longer be using the application of <code>serializeBox</code> to box#3,
that reactive function will go back to non-reactive mode.
This signals the memoization table that the entry can be removed so that it is ready for GC.</li>
</ol>
<p>So effectively we have achieved state tracking using immutable, shared datas structures here.
All boxes and arrows are mapped and reduced into single state tree.
Each change will result in a new entry in the <code>states</code> array, but the different entries will share almost all of their box and arrow representations.</p>
<h2 id="transforming-a-datagraph-into-another-reactive-data-graph">Transforming a datagraph into another reactive data graph</h2>
<p>Instead of returning plain values from a transformation function, it is also possible to return observable objects.
This can be used to transform an observable data graph into a another observable data graph, which can be used to transform... you get the idea.</p>
<p>Here is a small example that encodes a reactive file explorer that will update its representation upon each change.
Data graphs that are built this way will in general react a lot faster and will consist of much more straight-forward code,
compared to derived data graph that are updated using your own code. See the <a href="https://github.com/mobxjs/mobx/blob/3ea1f4af20a51a1cb30be3e4a55ec8f964a8c495/test/perf/transform-perf.js#L4" target="_blank">performance tests</a> for some examples.</p>
<p>Unlike the previous example, the <code>transformFolder</code> will only run once as long as a folder remains visible;
the <code>DisplayFolder</code> objects track the associated <code>Folder</code> objects themselves.</p>
<p>In the following example all mutations to the <code>state</code> graph will be processed automatically.
Some examples:</p>
<ol>
<li>Changing the name of a folder will update it&apos;s own <code>path</code> property and the <code>path</code> property of all its descendants.</li>
<li>Collapsing a folder will remove all descendant <code>DisplayFolders</code> from the tree.</li>
<li>Expanding a folder will restore them again.</li>
<li>Setting a search filter will remove all nodes that do not match the filter, unless they have a descendant that matches the filter.</li>
<li>Etc.</li>
</ol>
<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Folder</span>(<span class="hljs-params">parent, name</span>) </span>{
    <span class="hljs-keyword">this</span>.parent = parent;
    m.extendObservable(<span class="hljs-keyword">this</span>, {
        name: name,
        children: m.asFlat([]),
    });
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">DisplayFolder</span>(<span class="hljs-params">folder, state</span>) </span>{
    <span class="hljs-keyword">this</span>.state = state;
    <span class="hljs-keyword">this</span>.folder = folder;
    m.extendObservable(<span class="hljs-keyword">this</span>, {
        collapsed: <span class="hljs-literal">false</span>,
        name: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.folder.name;
        },
        isVisible: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">return</span> !<span class="hljs-keyword">this</span>.state.filter || <span class="hljs-keyword">this</span>.name.indexOf(<span class="hljs-keyword">this</span>.state.filter) !== -<span class="hljs-number">1</span> || <span class="hljs-keyword">this</span>.children.some(child =&gt; child.isVisible);
        },
        children: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.collapsed)
                <span class="hljs-keyword">return</span> [];
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.folder.children.map(transformFolder).filter(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">child</span>) </span>{
                <span class="hljs-keyword">return</span> child.isVisible;
            })
        },
        path: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.folder.parent === <span class="hljs-literal">null</span> ? <span class="hljs-keyword">this</span>.name : transformFolder(<span class="hljs-keyword">this</span>.folder.parent).path + <span class="hljs-string">&quot;/&quot;</span> + <span class="hljs-keyword">this</span>.name;
        }
    });
}

<span class="hljs-keyword">var</span> state = m.observable({
    root: <span class="hljs-keyword">new</span> Folder(<span class="hljs-literal">null</span>, <span class="hljs-string">&quot;root&quot;</span>),
    filter: <span class="hljs-literal">null</span>,
    displayRoot: <span class="hljs-literal">null</span>
});

<span class="hljs-keyword">var</span> transformFolder = m.createTransformer(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">folder</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DisplayFolder(folder, state);
});

m.autorun(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    state.displayRoot = transformFolder(state.root);
});
</code></pre>

                    
                    </section></div>
        </article>
      
        <article>
          <h3>expr | MobX</h3>
          <div><div class="page-inner"><span>
                
                
                    </span><section class="normal" id="section-">
                    
                        <a id="edit-link" href="https://github.com/mobxjs/mobx/tree/gh-pages/docs/refguide/expr.md" class="btn fa fa-edit pull-left">&#xA0;&#xA0;Edit This Page</a>
<p><code>expr</code> can be used to create temporarily computed values inside computed values.
Nesting computed values is useful to create cheap computations to prevent expensive computations to run.</p>
<p>In the following example the expression prevents that the <code>TodoView</code> component is re-rendered if the selection changes elsewhere.
Instead the component will only re-render when the relevant todo is (de)selected.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> TodoView = observer(({todo, editorState}) =&gt; {
    <span class="hljs-keyword">const</span> isSelected = mobx.expr(() =&gt; editorState.selection === todo);
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">className</span>=<span class="hljs-value">{isSelected</span> ? &quot;<span class="hljs-attribute">todo</span> <span class="hljs-attribute">todo-selected</span>&quot; <span class="hljs-attribute">:</span> &quot;<span class="hljs-attribute">todo</span>&quot;}&gt;</span>{todo.title}<span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>;</span>
});
</code></pre>
<p><code>expr(func)</code> is an alias for <code>computed(func).get()</code>.</p>

                    
                    </section><span>
                
                
                </span></div></div>
        </article>
      
        <article>
          <h3>extendObservable</h3>
          <div><div class="page-inner"><span>
                
                
                    </span><section class="normal" id="section-">
                    
                        <a id="edit-link" href="https://github.com/mobxjs/mobx/tree/gh-pages/docs/refguide/extend-observable.md" class="btn fa fa-edit pull-left">&#xA0;&#xA0;Edit This Page</a>
<p>Quite similar to <code>Object.assign</code>, <code>extendObservable</code> takes two or more arguments, a <code>target</code> object and one or more <code>properties</code> maps.
It adds all key-value pairs from the properties to the <code>target</code> as observable properties.</p>
<p>If an argumentless function is passed as value of a property, <code>extendObservable</code> will introduce a <a href="https://mobxjs.github.io/mobx/refguide/computed-decorator.html"><code>computed</code></a> property instead of an observable property.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> Person = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">firstName, lastName</span>) </span>{
    
    extendObservable(<span class="hljs-keyword">this</span>, {
        firstName: firstName,
        lastName: lastName
    });
}

<span class="hljs-keyword">var</span> matthew = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Matthew&quot;</span>, <span class="hljs-string">&quot;Henry&quot;</span>);


extendObservable(matthew, {
    age: <span class="hljs-number">353</span>
});
</code></pre>
<p>(N.b:  <code>observable(object)</code> is actually an alias for <code>extendObservable(object, object)</code>)</p>

                    
                    </section><span>
                
                
                </span></div></div>
        </article>
      
        <article>
          <h3>isObservable</h3>
          <div><div class="page-inner"><span>
                
                
                    </span><section class="normal" id="section-">
                    
                        <a id="edit-link" href="https://github.com/mobxjs/mobx/tree/gh-pages/docs/refguide/is-observable.md" class="btn fa fa-edit pull-left">&#xA0;&#xA0;Edit This Page</a><h1 id="isobservable">isObservable</h1>
<p>Returns true if the given value was made observable by MobX.
Optionally accepts a second string parameter to see whether a specific property is observable.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> person = observable({
    firstName: <span class="hljs-string">&quot;Sherlock&quot;</span>,
    lastName: <span class="hljs-string">&quot;Holmes&quot;</span>
});

person.age = <span class="hljs-number">3</span>;

isObservable(person); 
isObservable(person, <span class="hljs-string">&quot;firstName&quot;</span>); 
isObservable(person.firstName); 
isObservable(person, <span class="hljs-string">&quot;age&quot;</span>); 
</code></pre>
<h1 id="isobservablemap">isObservableMap</h1>
<p>Returns true if the given object is created using <code>mobx.map</code>.</p>
<h1 id="isobservablearray">isObservableArray</h1>
<p>Returns true if the given object is an array that was made observable using <code>mobx.observable(array)</code>.</p>
<h1 id="isobservableobject">isObservableObject</h1>
<p>Returns true if the given object is an object that was made observable using <code>mobx.observable(object)</code>.</p>

                    
                    </section><span>
                
                
                </span></div></div>
        </article>
      
        <article>
          <h3>modifiers | MobX</h3>
          <div><section class="normal" id="section-">
                    
                        <a id="edit-link" href="https://github.com/mobxjs/mobx/tree/gh-pages/docs/refguide/modifiers.md" class="btn fa fa-edit pull-left">&#xA0;&#xA0;Edit This Page</a>
<p>By default, <code>observable</code> recursively makes all the values of <em>plain</em> objects and arrays recursively observable.
Besides that, it automatically converts functions without arguments into reactive views or derived properties.
For all other types of values just a reference is stored.
In general, this should just do what you need, but if you want you can override the default behavior using <em>modifiers</em>.
Note that modifiers are &apos;sticky&apos;, they are interpreted as being annotations.
They do not only apply to the current value, but also to all values that are assigned in the future to the same attribute.</p>
<p>Note that the attributes class instances (all objects that have a prototype) will not be made observable automatically by <code>observable</code>.
It is considered to be the responsibility of the class definition / constructor function to mark the necessary attributes of a class instance observable / computed.</p>
<h2 id="asmap">asMap</h2>
<p>Creates a new Observable Map instead of an Observable Object. See <a href="https://mobxjs.github.io/mobx/refguide/map.html"><code>asMap</code></a></p>
<h2 id="asreference">asReference</h2>
<p>The most common modifier is <code>asReference</code>.
If this modifier is used, <code>observable</code> will not attempt to make the value observable.
Use this for example if you want to store a reference to a function, instead of creating a view based on that function.
You can also use it to prevent that plain objects or arrays are made observable automatically.</p>
<pre><code class="lang-javascript">
<span class="hljs-keyword">var</span> test = observable({
    x : <span class="hljs-number">3</span>,
    doubler: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.x*<span class="hljs-number">2</span>;
    },
    someFunc: asReference(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.x;
    })
});

<span class="hljs-built_in">console</span>.log(test.doubler); 
<span class="hljs-built_in">console</span>.log(test.someFunc); 
</code></pre>
<h2 id="asstructure">asStructure</h2>
<p>Can be used on non-cyclic, plain JavaScript values.
Instead of comparing old values with new values based on whether the reference has changed, values are compared using deep equality before notifying any observers.
This is useful if you are working with &apos;struct&apos; like objects like colors or coordinates and each time return fresh objects with possibly the same values.
<code>asStructure</code> can be used on reactive functions, plain objects and arrays.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> ViewPort = mobxReact.observer(React.createClass({
    displayName: <span class="hljs-string">&apos;ViewPort&apos;</span>,

    componentWillMount: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        mobx.extendObservable({
            screenSize: {
                width: <span class="hljs-number">0</span>,
                height: <span class="hljs-number">0</span>
            },
            minSize: {
                width: <span class="hljs-number">400</span>,
                height: <span class="hljs-number">300</span>
            },
            viewPortSize: mobx.asStructure(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">return</span> {
                    width: <span class="hljs-built_in">Math</span>.max(screenSize.width, minSize.width),
                    height: <span class="hljs-built_in">Math</span>.max(screenSize.height, minSize.height)
                }
            }
        });

        <span class="hljs-built_in">window</span>.onresize = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            mobx.transaction(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">this</span>.screenSize.width = <span class="hljs-built_in">window</span>.clientWidth;
                <span class="hljs-keyword">this</span>.screenSize.height = <span class="hljs-built_in">window</span>.clientHeight;
            });
        }.bind(<span class="hljs-keyword">this</span>);
    },

    render: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> (
            <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">style</span>=<span class="hljs-value">{{</span>
                <span class="hljs-attribute">width:</span> <span class="hljs-attribute">this.viewPortSize.width</span>,
                <span class="hljs-attribute">height:</span> <span class="hljs-attribute">this.viewPortSize.height</span>
            }}&gt;</span>
                test
            <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
        )</span>;
    }
}));
</code></pre>
<p>In the above example, the computed method <code>viewPortSize</code> returns a fresh object on each re-computation.
So MobX considers it to have changed always. This means that each <code>resize</code> event of the browser will trigger a re-render of the
<code>ViewPort</code> component.</p>
<p>However, if the window size is smaller that the <code>minSize</code>, the resize doesn&apos;t need to influence the rendering anymore, as the computed 
will return the same dimensions after each run. <code>asStructure</code> signals to MobX that observers of this computation should only be triggered
if the value returned by the computed has <em>structurally</em> changed (by default strict equality is used to determine whether observers need to be notified).
This means that a new object that is returned from <code>viewPortSize</code> won&apos;t trigger a <code>render</code> if its contents are (structurally) the same as the previous value.   </p>
<p>To use the <code>asStructure</code> modifier in combination with the <code>@computed</code> decorator, use the following:</p>
<pre><code class="lang-javascript">@computed({ asStructure: <span class="hljs-literal">true</span> }) get viewPortSize() {
    <span class="hljs-keyword">return</span> {
        width: <span class="hljs-built_in">Math</span>.max(screenSize.width, minSize.width),
        height: <span class="hljs-built_in">Math</span>.max(screenSize.height, minSize.height)
    }
}
</code></pre>
<h2 id="asflat">asFlat</h2>
<p>Similar to <code>asReference</code>, except that <code>asFlat</code> does not prevent its value from becoming observable, but only the children of the value.
It can be used for example to create an observable array or object that should not automatically make its children observable.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> todos = observable(asFlat([{
    title: <span class="hljs-string">&quot;make coffee&quot;</span>,
    completed: <span class="hljs-literal">false</span>
}]));

isObservable(todos); 
isObservable(todos[<span class="hljs-number">0</span>]); 
isObservable(todos[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;title&quot;</span>); 
</code></pre>

                    
                    </section></div>
        </article>
      
        <article>
          <h3>observe | MobX</h3>
          <div><div class="page-inner"><span>
                
                
                    </span><section class="normal" id="section-">
                    
                        <a id="edit-link" href="https://github.com/mobxjs/mobx/tree/gh-pages/docs/refguide/observe.md" class="btn fa fa-edit pull-left">&#xA0;&#xA0;Edit This Page</a>
<p><code>observe</code> and <code>intercept</code> can be used to monitor the changes of a single observable (they <strong><em>don&apos;t</em></strong> track nested observables).
<code>intercept</code> can be used to detect and modify mutations before they are applied to the observable.
<code>observe</code> allows you to intercept changes after they have been made.</p>
<h2 id="intercept">Intercept</h2>
<p>Usage: <code>intercept(target, propertyName?, interceptor)</code></p>
<ul>
<li><code>target</code>: the observable to guard</li>
<li><code>propertyName</code>: optional parameter to specify a specific property to intercept. Note that <code>intercept(user.name, interceptor)</code> is fundamentally different from <code>intercept(user, &quot;name&quot;, interceptor)</code>. The first tries to add an interceptor to the <em>current</em> <code>value</code> inside <code>user.name</code> (which might not be an observable at all), the latter intercepts changes to the <code>name</code> <em>property</em> of <code>user</code>.</li>
<li><code>interceptor</code>: callback that will be invoked for <em>each</em> change that is made to the observable. Receives a single change object describing the mutation.</li>
</ul>
<p>The <code>intercept</code> should tell MobX what needs to happen with the current change.
Therefore it should do one of the following things:</p>
<ol>
<li>Return the received <code>change</code> object as-is from the function, in wich case the mutation will be applied.   </li>
<li>Modify the <code>change</code> object and return it, for example to normalize the data. Not all fields are modifiable, see below.</li>
<li>Return <code>null</code>, this indicates that the change can be ignored and shouldn&apos;t be applied. This is a powerful concept to make your objects for example temporarily immutable.</li>
<li>Throw an exception, for example if some invariant isn&apos;t met.</li>
</ol>
<p>The function returns a <code>disposer</code> function that can be used to cancel the interceptor.
It is possible to register multiple interceptors to the same observable.
They will be chained in registration order.
If one of the interceptors returns <code>null</code> or throw an exception, the other interceptors won&apos;t be evaluated anymore.
It is also possible to register an interceptor both on a parent object and on an individual property.
In that case the parent object interceptors are run before the property interceptors. </p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> theme = observable({
  backgroundColor: <span class="hljs-string">&quot;#ffffff&quot;</span>
})

intercept(theme, <span class="hljs-string">&quot;backgroundColor&quot;</span>, change =&gt; {
  <span class="hljs-keyword">if</span> (!change.newValue) {
    
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;   
  }
  <span class="hljs-keyword">if</span> (change.newValue.length === <span class="hljs-number">6</span>) {
    
    change.newValue = <span class="hljs-string">&apos;#&apos;</span> + change.newValue;
    <span class="hljs-keyword">return</span> change;   
  }
  <span class="hljs-keyword">if</span> (change.newValue.length === <span class="hljs-number">7</span>) {
      
      <span class="hljs-keyword">return</span> change;
  }
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;This doesn&apos;t like a color at all: &quot;</span> + change.newValue);
})
</code></pre>
<h2 id="observe">Observe</h2>
<p>Usage: <code>observe(target, propertyName?, listener, invokeImmediately?)</code></p>
<ul>
<li><code>target</code>: the observable to observe</li>
<li><code>propertyName</code>: optional parameter to specify a specific property to observe. Note that <code>observe(user.name, listener)</code> is fundamentally different from <code>observe(user, &quot;name&quot;, listener)</code>. The first observes the <em>current</em> <code>value</code> inside <code>user.name</code> (which might not be an observable at all), the latter observes the <code>name</code> <em>property</em> of <code>user</code>.</li>
<li><code>listener</code>: callback that will be invoked for <em>each</em> change that is made to the observable. Receives a single change object describing the mutation, except for boxed observables, which will invoke the <code>listener</code> two parameters: <code>newValue, oldValue</code>. </li>
<li><code>invokeImmediately</code>: by default false. Set it to true if you want <code>observe</code> to invoke <code>listener</code> directly with the state of the observable (instead of waiting for the first change). Not supported (yet) by all kinds of observables.</li>
</ul>
<p>The function returns a <code>disposer</code> function that can be used to cancel the observer.
Note that <code>transaction</code> does not affect the working of the <code>observe</code> method(s).
This means that even inside a transaction <code>observe</code> will fire its listeners for each mutation.
Hence <code>autorun</code> is usually a more powerful and declarative alternative to <code>observe</code>.</p>
<p>Example:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">import</span> {observable, observe} <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;mobx&apos;</span>;

<span class="hljs-keyword">const</span> person = observable({
    firstName: <span class="hljs-string">&quot;Maarten&quot;</span>,
    lastName: <span class="hljs-string">&quot;Luther&quot;</span>
});

<span class="hljs-keyword">const</span> disposer = observe(person, (change) =&gt; {
    <span class="hljs-built_in">console</span>.log(change.type, change.name, <span class="hljs-string">&quot;from&quot;</span>, change.oldValue, <span class="hljs-string">&quot;to&quot;</span>, change.object[change.name]);
});

person.firstName =  <span class="hljs-string">&quot;Martin&quot;</span>;


disposer();



<span class="hljs-keyword">const</span> disposer2 = observe(person, <span class="hljs-string">&quot;lastName&quot;</span>, (newValue, oldValue) =&gt; {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;LastName changed to &quot;</span>, newValue);
});
</code></pre>
<p>Related blog: <a href="https://medium.com/@mweststrate/object-observe-is-dead-long-live-mobservable-observe-ad96930140c5" target="_blank">Object.observe is dead. Long live mobx.observe</a></p>
<h2 id="event-overview">Event overview</h2>
<p>The callbacks of <code>intercept</code> and <code>observe</code> will receive an event object which has at least the following properties:</p>
<ul>
<li><code>object</code>: the observable triggering the event</li>
<li><code>type</code>: (string) the type of the current event</li>
</ul>
<p>These are the additional fields that are available per type:</p>
<table>
<thead>
<tr>
<th>observable type</th>
<th>event type</th>
<th>property</th>
<th>description</th>
<th>available during intercept</th>
<th>can be modified by intercept</th>
</tr>
</thead>
<tbody>
<tr>
<td>Object</td>
<td>add</td>
<td>name</td>
<td>name of the property being added</td>
<td>&#x221A;</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>newValue</td>
<td>the new value being assigned</td>
<td>&#x221A;</td>
<td>&#x221A;</td>
</tr>
<tr>
<td></td>
<td>update</td>
<td>name</td>
<td>name of the property being updated</td>
<td>&#x221A;</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>newValue</td>
<td>the new value being assigned</td>
<td>&#x221A;</td>
<td>&#x221A;</td>
</tr>
<tr>
<td></td>
<td></td>
<td>oldValue</td>
<td>the value that is replaced</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Array</td>
<td>splice</td>
<td>index</td>
<td>starting index of the splice. Splices are also fired by <code>push</code>, <code>unshift</code>, <code>replace</code> etc.</td>
<td>&#x221A;</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>removedCount</td>
<td>amount of items being removed</td>
<td>&#x221A;</td>
<td>&#x221A;</td>
</tr>
<tr>
<td></td>
<td></td>
<td>added</td>
<td>array with items being added</td>
<td>&#x221A;</td>
<td>&#x221A;</td>
</tr>
<tr>
<td></td>
<td></td>
<td>removed</td>
<td>array with items that where removed</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>addCount</td>
<td>amount of items that where added</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>update</td>
<td>index</td>
<td>index of the single entry that is being updated</td>
<td>&#x221A;</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>newValue</td>
<td>the newValue that is / will be assigned</td>
<td>&#x221A;</td>
<td>&#x221A;</td>
</tr>
<tr>
<td></td>
<td></td>
<td>oldValue</td>
<td>the old value that was replaced</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Map</td>
<td>add</td>
<td>name</td>
<td>the name of the entry that was added</td>
<td>&#x221A;</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>newValue</td>
<td>the new value that is being assigned</td>
<td>&#x221A;</td>
<td>&#x221A;</td>
</tr>
<tr>
<td></td>
<td>update</td>
<td>name</td>
<td>the name of the entry that is being updated</td>
<td>&#x221A;</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>newValue</td>
<td>the new value that is being assigned</td>
<td>&#x221A;</td>
<td>&#x221A;</td>
</tr>
<tr>
<td></td>
<td></td>
<td>oldValue</td>
<td>the value that has been replaced</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>delete</td>
<td>name</td>
<td>the name of the entry that is being removed</td>
<td>&#x221A;</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>oldValue</td>
<td>the value of the entry that was removed</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Boxed observable</td>
<td>create</td>
<td>newValue</td>
<td>the value that was assigned during creation. Only observable by <code>spy</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>update</td>
<td>newValue</td>
<td>the new value being assigned (only available in <code>intercept</code> and <code>spy</code>)</td>
<td>&#x221A;</td>
<td>&#x221A;</td>
</tr>
<tr>
<td></td>
<td></td>
<td>oldValue</td>
<td>.. the old value. Only available in <code>spy</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>(observe callback)</td>
<td>newValue</td>
<td>first param of the <code>observe</code> callback</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>(observe callback)</td>
<td>oldValue</td>
<td>second param of the <code>observe</code> callback previous value</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Computed observable</td>
<td>(observe callback)</td>
<td>newValue</td>
<td>first param of the <code>observe</code> callback</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>(observe callback)</td>
<td>oldValue</td>
<td>second param of the <code>observe</code> callback</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>

                    
                    </section><span>
                
                
                </span></div></div>
        </article>
      
        <article>
          <h3>reaction | MobX</h3>
          <div><div class="page-inner"><span>
                
                
                    </span><section class="normal" id="section-">
                    
                        <a id="edit-link" href="https://github.com/mobxjs/mobx/tree/gh-pages/docs/refguide/reaction.md" class="btn fa fa-edit pull-left">&#xA0;&#xA0;Edit This Page</a>
<p>Usage: <code>reaction(() =&gt; data, data =&gt; { sideEffect }, fireImmediately = false, delay = 0)</code>.</p>
<p>A variation on <code>autorun</code> that gives more fine grained control on which observables will be tracked.
It takes two functions, the first one is tracked and returns data that is used as input for the second one, the side effect.
Unlike <code>autorun</code> the side effect won&apos;t be run directly when created, but only when the data expression returns a new value for the first time.
Any observables that are accessed while executing the side effect will not be tracked.
The side effect can be debounced, just like <code>autorunAsync</code>.
<code>reaction</code> returns a disposer function.
If a string is passed as first argument to <code>reaction</code>, it will be used as debug name.
The functions passed to <code>when</code> will receive one argument when invoked, the current reaction, which can be used to dispose the when during execution.</p>
<p>It is important to notice that the side effect will <em>only</em> react to data that was <em>accessed</em> in the data expression, which might be less then the data that is actually used in the effect.
Also, the side effect will only be triggered when the data returned by the expression has changed (the <code>asStructure</code> modifier can be used to enforce deep comparison).
In other words: reaction requires you to produce the things you need in your side effect.</p>
<p>In the following example both <code>reaction1</code>, <code>reaction2</code> and <code>autorun1</code> will react to the addition, removal or replacement of todo&apos;s in the <code>todos</code> array.
But only <code>reaction2</code> and <code>autorun</code> will react to the change of a <code>title</code> in one of the todo items, because <code>title</code> is used in the data expression of reaction 2, while it isn&apos;t in the data expression of reaction 1.
<code>autorun</code> tracks the complete side effect, hence it will always trigger correctly, but is also more suspectible to accidentally accessing unrelevant data.
See also <a href="https://mobxjs.github.io/mobx/best/react">what will MobX React to?</a>.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> todos = observable([
    {
        title: <span class="hljs-string">&quot;Make coffee&quot;</span>,
        done: <span class="hljs-literal">true</span>,
    },
    {
        title: <span class="hljs-string">&quot;Find biscuit&quot;</span>,
        done: <span class="hljs-literal">false</span>
    }
]);

<span class="hljs-keyword">const</span> reaction1 = reaction(
    () =&gt; todos.length,
    todos =&gt; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;reaction 1:&quot;</span>, todos.map(todo =&gt; todo.title).join(<span class="hljs-string">&quot;, &quot;</span>))
);

<span class="hljs-keyword">const</span> reaction2 = reaction(
    () =&gt; todos.map(todo =&gt; todo.title),
    titles =&gt; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;reaction 2:&quot;</span>, titles.join(<span class="hljs-string">&quot;, &quot;</span>))
);

<span class="hljs-keyword">const</span> autorun1 = autorun(
    () =&gt; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;autorun 1:&quot;</span>, todos.map(todo =&gt; todo.title).join(<span class="hljs-string">&quot;, &quot;</span>))
);

todos.push({ title: <span class="hljs-string">&quot;explain reactions&quot;</span>, done: <span class="hljs-literal">false</span> });





todos[<span class="hljs-number">0</span>].title = <span class="hljs-string">&quot;Make tea&quot;</span>



</code></pre>
<p>Reaction is roughly speaking sugar for: <code>computed(expression).observe(action(sideEffect))</code> or <code>autorun(() =&gt; action(sideEffect)(expression)</code></p>

                    
                    </section><span>
                
                
                </span></div></div>
        </article>
      
        <article>
          <h3>spy | MobX</h3>
          <div><div class="page-inner"><span>
                
                
                    </span><section class="normal" id="section-">
                    
                        <a id="edit-link" href="https://github.com/mobxjs/mobx/tree/gh-pages/docs/refguide/spy.md" class="btn fa fa-edit pull-left">&#xA0;&#xA0;Edit This Page</a>
<p>Usage: <code>spy(listener)</code>.
Registers a global spy listener that listens to all events that happen in MobX.
It is similar to attaching an <code>observe</code> listener to <em>all</em> observables at once, but also notifies about running (trans/re)actions and computations.
Used for example by the <code>mobx-react-devtools</code>.</p>
<p>Spy listeners always receive one object, which usually has at least a <code>type</code> field. The following events are emitted by default by spy.</p>
<table>
<thead>
<tr>
<th>event</th>
<th>fields</th>
<th>nested</th>
</tr>
</thead>
<tbody>
<tr>
<td>action</td>
<td>name, target (scope), arguments, fn (source function of the action</td>
<td>yes</td>
</tr>
<tr>
<td>transaction</td>
<td>name, target (scope)</td>
<td>yes</td>
</tr>
<tr>
<td>scheduled-reaction</td>
<td>object (Reaction instance)</td>
<td>no</td>
</tr>
<tr>
<td>reaction</td>
<td>object (Reaction instance), fn (source of the reaction)</td>
<td>yes</td>
</tr>
<tr>
<td>compute</td>
<td>object (ComputedValue instance), target (scope), fn (source)</td>
<td>no</td>
</tr>
<tr>
<td>error</td>
<td>message</td>
<td>no</td>
</tr>
<tr>
<td>update (array)</td>
<td>object (the array), index, newValue, oldValue</td>
<td>yes</td>
</tr>
<tr>
<td>update (map)</td>
<td>object (observable map instance), name, newValue, oldValue</td>
<td>yes</td>
</tr>
<tr>
<td>update (object)</td>
<td>object (instance), name, newValue, oldValue</td>
<td>yes</td>
</tr>
<tr>
<td>splice (array)</td>
<td>object (the array), index, added, removed, addedCount, removedCount</td>
<td>yes</td>
</tr>
<tr>
<td>add (map)</td>
<td>object, name, newValue</td>
<td>yes</td>
</tr>
<tr>
<td>add (object)</td>
<td>object, name, newValue</td>
<td>yes</td>
</tr>
<tr>
<td>delete (map)</td>
<td>object, name, oldValue</td>
<td>yes</td>
</tr>
<tr>
<td>create (boxed observable)</td>
<td>object (ObservableValue instance), newValue</td>
<td>yes</td>
</tr>
</tbody>
</table>
<p>Note that there are events with the signature <code>{ spyReportEnd: true, time? }</code>.
These events might not have a <code>type</code> field, but they are part of an earlier fired event that had <code>spyReportStart: true</code>.
This event indicates the end of an event and this way groups of events with sub-events are created.
This event might report the total execution time as well.</p>
<p>The spy events for observable values are identical to the events passed to <code>observe</code>. See <a href="https://mobxjs.github.io/mobx/refguide/observe.html">intercept &amp; observe</a> for an extensive overview.</p>
<p>It is possible to emit your own spy events as well. See <code>extras.spyReport</code>, <code>extras.spyReportStart</code> and <code>extras.spyReportEnd</code></p>

                    
                    </section><span>
                
                
                </span></div></div>
        </article>
      
        <article>
          <h3>toJS | MobX</h3>
          <div><div class="page-inner"><span>
                
                
                    </span><section class="normal" id="section-">
                    
                        <a id="edit-link" href="https://github.com/mobxjs/mobx/tree/gh-pages/docs/refguide/tojson.md" class="btn fa fa-edit pull-left">&#xA0;&#xA0;Edit This Page</a>
<p><code>toJS(value, supportCycles = true)</code></p>
<p>Recursively converts an (observable) object to a javascript <em>structure</em>.
Supports observable arrays, objects, maps and primitives.
Computed values and other non-enumerable properties won&apos;t be part of the result.
Cycles are detected and properly supported by default, but this can be disabled to improve performance.</p>
<p>For more complex (de)serialization scenario&apos;s, one can use <a href="https://github.com/mobxjs/serializr" target="_blank">serializr</a></p>
<pre><code>var obj = mobx.observable({
    x: 1
});

var clone = mobx.toJS(obj);

console.log(mobx.isObservableObject(obj)); // true
console.log(mobx.isObservableObject(clone)); // false
</code></pre><p>Note: this method was named <code>toJSON</code> before MobX 2.2</p>

                    
                    </section><span>
                
                
                </span></div></div>
        </article>
      
        <article>
          <h3>transaction</h3>
          <div><div class="page-inner"><span>
                
                
                    </span><section class="normal" id="section-">
                    
                        <a id="edit-link" href="https://github.com/mobxjs/mobx/tree/gh-pages/docs/refguide/transaction.md" class="btn fa fa-edit pull-left">&#xA0;&#xA0;Edit This Page</a>
<p><code>transaction(worker: () =&gt; void)</code> can be used to batch a bunch of updates without notifying any observers until the end of the transaction.
<code>transaction</code> takes a single, parameterless <code>worker</code> function as argument and runs it.
No observers are notified until this function has completed.
<code>transaction</code> returns any value that was returned by the <code>worker</code> function.
Note that <code>transaction</code> runs completely synchronously.
Transactions can be nested. Only after completing the outermost <code>transaction</code> pending reactions will be run.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">import</span> {observable, transaction, autorun} <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx&quot;</span>;

<span class="hljs-keyword">const</span> numbers = observable([]);

autorun(() =&gt; <span class="hljs-built_in">console</span>.log(numbers.length, <span class="hljs-string">&quot;numbers!&quot;</span>));


transaction(() =&gt; {
    transaction(() =&gt; {
        numbers.push(<span class="hljs-number">1</span>);
        numbers.push(<span class="hljs-number">2</span>);
    });
    numbers.push(<span class="hljs-number">3</span>);
});

</code></pre>

                    
                    </section><span>
                
                
                </span></div></div>
        </article>
      
        <article>
          <h3>untracked | MobX</h3>
          <div><div class="page-inner"><span>
                
                
                    </span><section class="normal" id="section-">
                    
                        <a id="edit-link" href="https://github.com/mobxjs/mobx/tree/gh-pages/docs/refguide/untracked.md" class="btn fa fa-edit pull-left">&#xA0;&#xA0;Edit This Page</a>
<p>Untracked allows you to run a piece of code without establishing observers.
Like <code>transaction</code>, <code>untracked</code> is automatically applied by <code>(@)action</code>, so usually it makes more sense to use actions then <code>untracked</code> directly.
Example:</p>
<pre><code class="lang-javascript">
<span class="hljs-keyword">const</span> person = observable({
    firstName: <span class="hljs-string">&quot;Michel&quot;</span>,
    lastName: <span class="hljs-string">&quot;Weststrate&quot;</span>
});

autorun(() =&gt; {
    <span class="hljs-built_in">console</span>.log(
        person.lastName,
        <span class="hljs-string">&quot;,&quot;</span>,
        
        untracked(() =&gt; person.firstName)
    );
});


person.firstName = <span class="hljs-string">&quot;G.K.&quot;</span>;


person.lastName = <span class="hljs-string">&quot;Chesterton&quot;</span>;

</code></pre>

                    
                    </section><span>
                
                
                </span></div></div>
        </article>
      
        <article>
          <h3>when | MobX</h3>
          <div><div class="page-inner"><span>
                
                
                    </span><section class="normal" id="section-">
                    
                        <a id="edit-link" href="https://github.com/mobxjs/mobx/tree/gh-pages/docs/refguide/when.md" class="btn fa fa-edit pull-left">&#xA0;&#xA0;Edit This Page</a>
<p><code>when(debugName?, predicate: () =&gt; boolean, effect: () =&gt; void, scope?)</code></p>
<p><code>when</code> observes &amp; runs the given <code>predicate</code> until it returns true.
Once that happens, the given <code>effect</code> is executed and the autorunner is disposed.
The function returns a disposer to cancel the autorunner prematurely.</p>
<p>This function is really useful to dispose or cancel stuff in a reactive way.
For example:</p>
<pre><code class="lang-javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyResource</span> </span>{
    constructor() {
        when(
            
            () =&gt; !<span class="hljs-keyword">this</span>.isVisible,
            
            () =&gt; <span class="hljs-keyword">this</span>.dispose()
        );
    }

    @computed get isVisible() {
        
    }

    dispose() {
        
    }
}
</code></pre>
<p><em>In MobX 1.0 this method was called <code>autorunUntil</code>.</em></p>

                    
                    </section><span>
                
                
                </span></div></div>
        </article>
      <h2></h2>
        <article>
          <h3>autorunAsync</h3>
          <div><div class="page-inner"><span>
                
                
                    </span><section class="normal" id="section-">
                    
                        <a id="edit-link" href="https://github.com/mobxjs/mobx/tree/gh-pages/docs/refguide/autorun-async.md" class="btn fa fa-edit pull-left">&#xA0;&#xA0;Edit This Page</a>
<p><code>autorunAsync(action: () =&gt; void, minimumDelay?: number, scope?)</code></p>
<p>Just like <code>autorun</code> except that the action won&apos;t be invoked synchronously but asynchronously after the minimum amount of milliseconds has passed.
The <code>action</code> will be run and observed.
However, instead of running the action immediately when the values it observes have changed, the <code>minimumDelay</code> will be awaited before re-execution the <code>action</code> again.</p>
<p>If observed values are changed multiple times while waiting, the action is still triggered only once, so in a sense it achieves a similar effect than a transaction.
This might be useful for stuff that is expensive and doesn&apos;t need to happen synchronously; such as debouncing server communication.
If a string is passed as first argument to <code>autorun</code>, it will be used as debug name.</p>
<p><code>autorunAsync</code> returns a disposer to cancel the autorun.</p>
<pre><code class="lang-javascript">autorunAsync(() =&gt; {
    
    
    
    sendProfileToServer(profile.asJson);
}, <span class="hljs-number">300</span>);
</code></pre>

                    
                    </section><span>
                
                
                </span></div></div>
        </article>
      <h2></h2>
        <article>
          <h3>Atom & Reaction</h3>
          <div><div class="page-inner"><span>
                
                
                    </span><section class="normal" id="section-">
                    
                        <a id="edit-link" href="https://github.com/mobxjs/mobx/tree/gh-pages/docs/refguide/extending.md" class="btn fa fa-edit pull-left">&#xA0;&#xA0;Edit This Page</a>
<h2 id="atoms">Atoms</h2>
<p>At some point you might want to have more data structures or other things (like streams) that can be used in reactive computations.
Achieving that is pretty simple by using the <code>Atom</code> class.
Atoms can be used to signal MobX that some observable data source has been observed or changed.
And MobX will signal the atom whenever it is used or no longer in use.</p>
<p>The following example demonstrates how you can create an observable <code>Clock</code>, which can be used in reactive functions,
and returns the current date-time.
This clock will only actually tick if it is observed by someone.</p>
<p>The complete API of the <code>Atom</code> class is demonstrated by this example.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">import</span> {Atom, autorun} <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx&quot;</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Clock</span> </span>{
    atom;
    intervalHandler = <span class="hljs-literal">null</span>;
    currentDateTime;

    constructor() {
        
        <span class="hljs-keyword">this</span>.atom =    <span class="hljs-keyword">new</span> Atom(
            
            <span class="hljs-string">&quot;Clock&quot;</span>,
            
            () =&gt; <span class="hljs-keyword">this</span>.startTicking(),
            
            
            () =&gt; <span class="hljs-keyword">this</span>.stopTicking()
        );
    }

    getTime() {
        
        
        
        
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.atom.reportObserved()) {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.currentDateTime;
        } <span class="hljs-keyword">else</span> {
            
            
            
            
            
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();
        }
    }

    tick() {
        <span class="hljs-keyword">this</span>.currentDateTime = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();
        
        <span class="hljs-keyword">this</span>.atom.reportChanged();
    }

    startTicking() {
        <span class="hljs-keyword">this</span>.tick(); 
        <span class="hljs-keyword">this</span>.intervalHandler = setInterval(
            () =&gt; <span class="hljs-keyword">this</span>.tick(),
            <span class="hljs-number">1000</span>
        );
    }

    stopTicking() {
        clearInterval(<span class="hljs-keyword">this</span>.intervalHandler);
        <span class="hljs-keyword">this</span>.intervalHandler = <span class="hljs-literal">null</span>;
    }
}

<span class="hljs-keyword">const</span> clock = <span class="hljs-keyword">new</span> Clock();

<span class="hljs-keyword">const</span> disposer = autorun(() =&gt; <span class="hljs-built_in">console</span>.log(clock.getTime()));



disposer();


</code></pre>
<h2 id="reactions">Reactions</h2>
<p><code>Reaction</code> allows you to create your own &apos;auto runner&apos;.
Reactions track a function and signal when the function should be executed again because one or more dependencies have changed.</p>
<p>This is how <code>autorun</code> is defined using <code>Reaction</code>:</p>
<pre><code class="lang-typescript"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">autorun</span>(<span class="hljs-params">view: Lambda, scope?: <span class="hljs-built_in">any</span></span>) </span>{
    <span class="hljs-keyword">if</span> (scope)
        view = view.bind(scope);

    <span class="hljs-keyword">const</span> reaction = <span class="hljs-keyword">new</span> Reaction(view.name || <span class="hljs-string">&quot;Autorun&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">this</span>.track(view);
    });

    
    <span class="hljs-keyword">if</span> (isComputingDerivation() || globalState.inTransaction &gt; <span class="hljs-number">0</span>)
        globalState.pendingReactions.push(reaction);
    <span class="hljs-keyword">else</span>
        reaction.runReaction();

    <span class="hljs-keyword">return</span> reaction.getDisposer();
}
</code></pre>

                    
                    </section><span>
                
                
                </span></div></div>
        </article>
      <h2></h2>
        <article>
          <h3>createTransformer</h3>
          <div><section class="normal" id="section-">
                    
                        <a id="edit-link" href="https://github.com/mobxjs/mobx/tree/gh-pages/docs/refguide/create-transformer.md" class="btn fa fa-edit pull-left">&#xA0;&#xA0;Edit This Page</a>
<p><code>createTransformer&lt;A, B&gt;(transformation: (value: A) =&gt; B, onCleanup?: (result: B, value?: A) =&gt; void): (value: A) =&gt; B</code></p>
<p><code>createTransformer</code> turns a function (that should transform one value into another value) into a reactive and memoizing function.
In other words, if the <code>transformation</code> function computes B given a specific A, the same B will be returned for all other future invocations of the transformation with the same A.
However, if A changes, the transformation will be re-applied so that B is updated accordingly.
And last but not least, if nobody is using the transformation of a specific A anymore, it&apos;s entry will be removed from the memoization table.</p>
<p>With <code>createTransformer</code> it is very easy to transform a complete data graph into another data graph.
Transformation functions can be composed so that you can build a tree using lots of small transformations.
The resulting data graph will never be stale, it will be kept in sync with the source by applying small patches to the result graph.
This makes it very easy to achieve powerful patterns similar to sideways data loading, map-reduce, tracking state history using immutable data structures etc.</p>
<p>The optional <code>onCleanup</code> function can be used to get a notification when a transformation of an object is no longer needed.
This can be used to dispose resources attached to the result object if needed.</p>
<p>Always use transformations inside a reaction like <code>@observer</code> or <code>autorun</code>.
Transformations will, like any other computed value, fall back to lazy evaluation if not observed by something, which sort of defeats their purpose.</p>
<p>This all might still be a bit vague, so here are two examples that explain this whole idea of transforming one data structure into another by using small, reactive functions:</p>
<h2 id="tracking-mutable-state-using-immutable-shared-data-structures">Tracking mutable state using immutable, shared data structures.</h2>
<p>This example is taken from the <a href="https://github.com/mobxjs/mobx-reactive2015-demo" target="_blank">Reactive2015 conference demo</a>:</p>
<pre><code class="lang-javascript">
<span class="hljs-keyword">const</span> store = observable({
    boxes: [],
    arrows: [],
    selection: <span class="hljs-literal">null</span>
});


<span class="hljs-keyword">const</span> states = [];

autorun(() =&gt; {
    states.push(serializeState(store));
});

<span class="hljs-keyword">const</span> serializeState = createTransformer(store =&gt; ({
    boxes: store.boxes.map(serializeBox),
    arrows: store.arrows.map(serializeArrow),
    selection: store.selection ? store.selection.id : <span class="hljs-literal">null</span>
}));

<span class="hljs-keyword">const</span> serializeBox = createTransformer(box =&gt; ({...box}));

<span class="hljs-keyword">const</span> serializeArrow = createTransformer(arrow =&gt; ({
    id: arrow.id,
    to: arrow.to.id,
    from: arrow.from.id
}));
</code></pre>
<p>In this example the state is serialized by composing three different transformation functions.
The autorunner triggers the serialization of the <code>store</code> object, which in turn serializes all boxes and arrows.
Let&apos;s take closer look at the life of an imaginary example box#3.</p>
<ol>
<li>The first time box#3 is passed by <code>map</code> to <code>serializeBox</code>,
the serializeBox transformation is executed and an entry containing box#3 and its serialized representation is added to the internal memoization table of <code>serializeBox</code>.</li>
<li>Imagine that another box is added to the <code>store.boxes</code> list.
This would cause the <code>serializeState</code> function to re-compute, resulting in a complete remapping of all the boxes.
However, all the invocations of <code>serializeBox</code> will now return their old values from the memoization tables since their transformation functions didn&apos;t (need to) run again.</li>
<li>Secondly, if somebody changes a property of box#3 this will cause the application of the <code>serializeBox</code> to box#3 to re-compute, just like any other reactive function in MobX.
Since the transformation will now produce a new Json object based on box#3, all observers of that specific transformation will be forced to run again as well.
That&apos;s the <code>serializeState</code> transformation in this case.
<code>serializeState</code> will now produce a new value in turn and map all the boxes again. But except for box#3, all other boxes will be returned from the memoization table.</li>
<li>Finally, if box#3 is removed from <code>store.boxes</code>, <code>serializeState</code> will compute again.
But since it will no longer be using the application of <code>serializeBox</code> to box#3,
that reactive function will go back to non-reactive mode.
This signals the memoization table that the entry can be removed so that it is ready for GC.</li>
</ol>
<p>So effectively we have achieved state tracking using immutable, shared datas structures here.
All boxes and arrows are mapped and reduced into single state tree.
Each change will result in a new entry in the <code>states</code> array, but the different entries will share almost all of their box and arrow representations.</p>
<h2 id="transforming-a-datagraph-into-another-reactive-data-graph">Transforming a datagraph into another reactive data graph</h2>
<p>Instead of returning plain values from a transformation function, it is also possible to return observable objects.
This can be used to transform an observable data graph into a another observable data graph, which can be used to transform... you get the idea.</p>
<p>Here is a small example that encodes a reactive file explorer that will update its representation upon each change.
Data graphs that are built this way will in general react a lot faster and will consist of much more straight-forward code,
compared to derived data graph that are updated using your own code. See the <a href="https://github.com/mobxjs/mobx/blob/3ea1f4af20a51a1cb30be3e4a55ec8f964a8c495/test/perf/transform-perf.js#L4" target="_blank">performance tests</a> for some examples.</p>
<p>Unlike the previous example, the <code>transformFolder</code> will only run once as long as a folder remains visible;
the <code>DisplayFolder</code> objects track the associated <code>Folder</code> objects themselves.</p>
<p>In the following example all mutations to the <code>state</code> graph will be processed automatically.
Some examples:</p>
<ol>
<li>Changing the name of a folder will update it&apos;s own <code>path</code> property and the <code>path</code> property of all its descendants.</li>
<li>Collapsing a folder will remove all descendant <code>DisplayFolders</code> from the tree.</li>
<li>Expanding a folder will restore them again.</li>
<li>Setting a search filter will remove all nodes that do not match the filter, unless they have a descendant that matches the filter.</li>
<li>Etc.</li>
</ol>
<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Folder</span>(<span class="hljs-params">parent, name</span>) </span>{
    <span class="hljs-keyword">this</span>.parent = parent;
    m.extendObservable(<span class="hljs-keyword">this</span>, {
        name: name,
        children: m.asFlat([]),
    });
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">DisplayFolder</span>(<span class="hljs-params">folder, state</span>) </span>{
    <span class="hljs-keyword">this</span>.state = state;
    <span class="hljs-keyword">this</span>.folder = folder;
    m.extendObservable(<span class="hljs-keyword">this</span>, {
        collapsed: <span class="hljs-literal">false</span>,
        name: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.folder.name;
        },
        isVisible: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">return</span> !<span class="hljs-keyword">this</span>.state.filter || <span class="hljs-keyword">this</span>.name.indexOf(<span class="hljs-keyword">this</span>.state.filter) !== -<span class="hljs-number">1</span> || <span class="hljs-keyword">this</span>.children.some(child =&gt; child.isVisible);
        },
        children: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.collapsed)
                <span class="hljs-keyword">return</span> [];
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.folder.children.map(transformFolder).filter(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">child</span>) </span>{
                <span class="hljs-keyword">return</span> child.isVisible;
            })
        },
        path: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.folder.parent === <span class="hljs-literal">null</span> ? <span class="hljs-keyword">this</span>.name : transformFolder(<span class="hljs-keyword">this</span>.folder.parent).path + <span class="hljs-string">&quot;/&quot;</span> + <span class="hljs-keyword">this</span>.name;
        }
    });
}

<span class="hljs-keyword">var</span> state = m.observable({
    root: <span class="hljs-keyword">new</span> Folder(<span class="hljs-literal">null</span>, <span class="hljs-string">&quot;root&quot;</span>),
    filter: <span class="hljs-literal">null</span>,
    displayRoot: <span class="hljs-literal">null</span>
});

<span class="hljs-keyword">var</span> transformFolder = m.createTransformer(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">folder</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DisplayFolder(folder, state);
});

m.autorun(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    state.displayRoot = transformFolder(state.root);
});
</code></pre>

                    
                    </section></div>
        </article>
      <h2></h2>
        <article>
          <h3>expr | MobX</h3>
          <div><div class="page-inner"><span>
                
                
                    </span><section class="normal" id="section-">
                    
                        <a id="edit-link" href="https://github.com/mobxjs/mobx/tree/gh-pages/docs/refguide/expr.md" class="btn fa fa-edit pull-left">&#xA0;&#xA0;Edit This Page</a>
<p><code>expr</code> can be used to create temporarily computed values inside computed values.
Nesting computed values is useful to create cheap computations to prevent expensive computations to run.</p>
<p>In the following example the expression prevents that the <code>TodoView</code> component is re-rendered if the selection changes elsewhere.
Instead the component will only re-render when the relevant todo is (de)selected.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> TodoView = observer(({todo, editorState}) =&gt; {
    <span class="hljs-keyword">const</span> isSelected = mobx.expr(() =&gt; editorState.selection === todo);
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">className</span>=<span class="hljs-value">{isSelected</span> ? &quot;<span class="hljs-attribute">todo</span> <span class="hljs-attribute">todo-selected</span>&quot; <span class="hljs-attribute">:</span> &quot;<span class="hljs-attribute">todo</span>&quot;}&gt;</span>{todo.title}<span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>;</span>
});
</code></pre>
<p><code>expr(func)</code> is an alias for <code>computed(func).get()</code>.</p>

                    
                    </section><span>
                
                
                </span></div></div>
        </article>
      <h2></h2>
        <article>
          <h3>extendObservable</h3>
          <div><div class="page-inner"><span>
                
                
                    </span><section class="normal" id="section-">
                    
                        <a id="edit-link" href="https://github.com/mobxjs/mobx/tree/gh-pages/docs/refguide/extend-observable.md" class="btn fa fa-edit pull-left">&#xA0;&#xA0;Edit This Page</a>
<p>Quite similar to <code>Object.assign</code>, <code>extendObservable</code> takes two or more arguments, a <code>target</code> object and one or more <code>properties</code> maps.
It adds all key-value pairs from the properties to the <code>target</code> as observable properties.</p>
<p>If an argumentless function is passed as value of a property, <code>extendObservable</code> will introduce a <a href="https://mobxjs.github.io/mobx/refguide/computed-decorator.html"><code>computed</code></a> property instead of an observable property.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> Person = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">firstName, lastName</span>) </span>{
    
    extendObservable(<span class="hljs-keyword">this</span>, {
        firstName: firstName,
        lastName: lastName
    });
}

<span class="hljs-keyword">var</span> matthew = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Matthew&quot;</span>, <span class="hljs-string">&quot;Henry&quot;</span>);


extendObservable(matthew, {
    age: <span class="hljs-number">353</span>
});
</code></pre>
<p>(N.b:  <code>observable(object)</code> is actually an alias for <code>extendObservable(object, object)</code>)</p>

                    
                    </section><span>
                
                
                </span></div></div>
        </article>
      <h2></h2>
        <article>
          <h3>isObservable</h3>
          <div><div class="page-inner"><span>
                
                
                    </span><section class="normal" id="section-">
                    
                        <a id="edit-link" href="https://github.com/mobxjs/mobx/tree/gh-pages/docs/refguide/is-observable.md" class="btn fa fa-edit pull-left">&#xA0;&#xA0;Edit This Page</a><h1 id="isobservable">isObservable</h1>
<p>Returns true if the given value was made observable by MobX.
Optionally accepts a second string parameter to see whether a specific property is observable.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> person = observable({
    firstName: <span class="hljs-string">&quot;Sherlock&quot;</span>,
    lastName: <span class="hljs-string">&quot;Holmes&quot;</span>
});

person.age = <span class="hljs-number">3</span>;

isObservable(person); 
isObservable(person, <span class="hljs-string">&quot;firstName&quot;</span>); 
isObservable(person.firstName); 
isObservable(person, <span class="hljs-string">&quot;age&quot;</span>); 
</code></pre>
<h1 id="isobservablemap">isObservableMap</h1>
<p>Returns true if the given object is created using <code>mobx.map</code>.</p>
<h1 id="isobservablearray">isObservableArray</h1>
<p>Returns true if the given object is an array that was made observable using <code>mobx.observable(array)</code>.</p>
<h1 id="isobservableobject">isObservableObject</h1>
<p>Returns true if the given object is an object that was made observable using <code>mobx.observable(object)</code>.</p>

                    
                    </section><span>
                
                
                </span></div></div>
        </article>
      <h2></h2>
        <article>
          <h3>modifiers | MobX</h3>
          <div><section class="normal" id="section-">
                    
                        <a id="edit-link" href="https://github.com/mobxjs/mobx/tree/gh-pages/docs/refguide/modifiers.md" class="btn fa fa-edit pull-left">&#xA0;&#xA0;Edit This Page</a>
<p>By default, <code>observable</code> recursively makes all the values of <em>plain</em> objects and arrays recursively observable.
Besides that, it automatically converts functions without arguments into reactive views or derived properties.
For all other types of values just a reference is stored.
In general, this should just do what you need, but if you want you can override the default behavior using <em>modifiers</em>.
Note that modifiers are &apos;sticky&apos;, they are interpreted as being annotations.
They do not only apply to the current value, but also to all values that are assigned in the future to the same attribute.</p>
<p>Note that the attributes class instances (all objects that have a prototype) will not be made observable automatically by <code>observable</code>.
It is considered to be the responsibility of the class definition / constructor function to mark the necessary attributes of a class instance observable / computed.</p>
<h2 id="asmap">asMap</h2>
<p>Creates a new Observable Map instead of an Observable Object. See <a href="https://mobxjs.github.io/mobx/refguide/map.html"><code>asMap</code></a></p>
<h2 id="asreference">asReference</h2>
<p>The most common modifier is <code>asReference</code>.
If this modifier is used, <code>observable</code> will not attempt to make the value observable.
Use this for example if you want to store a reference to a function, instead of creating a view based on that function.
You can also use it to prevent that plain objects or arrays are made observable automatically.</p>
<pre><code class="lang-javascript">
<span class="hljs-keyword">var</span> test = observable({
    x : <span class="hljs-number">3</span>,
    doubler: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.x*<span class="hljs-number">2</span>;
    },
    someFunc: asReference(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.x;
    })
});

<span class="hljs-built_in">console</span>.log(test.doubler); 
<span class="hljs-built_in">console</span>.log(test.someFunc); 
</code></pre>
<h2 id="asstructure">asStructure</h2>
<p>Can be used on non-cyclic, plain JavaScript values.
Instead of comparing old values with new values based on whether the reference has changed, values are compared using deep equality before notifying any observers.
This is useful if you are working with &apos;struct&apos; like objects like colors or coordinates and each time return fresh objects with possibly the same values.
<code>asStructure</code> can be used on reactive functions, plain objects and arrays.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> ViewPort = mobxReact.observer(React.createClass({
    displayName: <span class="hljs-string">&apos;ViewPort&apos;</span>,

    componentWillMount: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        mobx.extendObservable({
            screenSize: {
                width: <span class="hljs-number">0</span>,
                height: <span class="hljs-number">0</span>
            },
            minSize: {
                width: <span class="hljs-number">400</span>,
                height: <span class="hljs-number">300</span>
            },
            viewPortSize: mobx.asStructure(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">return</span> {
                    width: <span class="hljs-built_in">Math</span>.max(screenSize.width, minSize.width),
                    height: <span class="hljs-built_in">Math</span>.max(screenSize.height, minSize.height)
                }
            }
        });

        <span class="hljs-built_in">window</span>.onresize = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            mobx.transaction(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
                <span class="hljs-keyword">this</span>.screenSize.width = <span class="hljs-built_in">window</span>.clientWidth;
                <span class="hljs-keyword">this</span>.screenSize.height = <span class="hljs-built_in">window</span>.clientHeight;
            });
        }.bind(<span class="hljs-keyword">this</span>);
    },

    render: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> (
            <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">style</span>=<span class="hljs-value">{{</span>
                <span class="hljs-attribute">width:</span> <span class="hljs-attribute">this.viewPortSize.width</span>,
                <span class="hljs-attribute">height:</span> <span class="hljs-attribute">this.viewPortSize.height</span>
            }}&gt;</span>
                test
            <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
        )</span>;
    }
}));
</code></pre>
<p>In the above example, the computed method <code>viewPortSize</code> returns a fresh object on each re-computation.
So MobX considers it to have changed always. This means that each <code>resize</code> event of the browser will trigger a re-render of the
<code>ViewPort</code> component.</p>
<p>However, if the window size is smaller that the <code>minSize</code>, the resize doesn&apos;t need to influence the rendering anymore, as the computed 
will return the same dimensions after each run. <code>asStructure</code> signals to MobX that observers of this computation should only be triggered
if the value returned by the computed has <em>structurally</em> changed (by default strict equality is used to determine whether observers need to be notified).
This means that a new object that is returned from <code>viewPortSize</code> won&apos;t trigger a <code>render</code> if its contents are (structurally) the same as the previous value.   </p>
<p>To use the <code>asStructure</code> modifier in combination with the <code>@computed</code> decorator, use the following:</p>
<pre><code class="lang-javascript">@computed({ asStructure: <span class="hljs-literal">true</span> }) get viewPortSize() {
    <span class="hljs-keyword">return</span> {
        width: <span class="hljs-built_in">Math</span>.max(screenSize.width, minSize.width),
        height: <span class="hljs-built_in">Math</span>.max(screenSize.height, minSize.height)
    }
}
</code></pre>
<h2 id="asflat">asFlat</h2>
<p>Similar to <code>asReference</code>, except that <code>asFlat</code> does not prevent its value from becoming observable, but only the children of the value.
It can be used for example to create an observable array or object that should not automatically make its children observable.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> todos = observable(asFlat([{
    title: <span class="hljs-string">&quot;make coffee&quot;</span>,
    completed: <span class="hljs-literal">false</span>
}]));

isObservable(todos); 
isObservable(todos[<span class="hljs-number">0</span>]); 
isObservable(todos[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;title&quot;</span>); 
</code></pre>

                    
                    </section></div>
        </article>
      <h2></h2>
        <article>
          <h3>observe | MobX</h3>
          <div><div class="page-inner"><span>
                
                
                    </span><section class="normal" id="section-">
                    
                        <a id="edit-link" href="https://github.com/mobxjs/mobx/tree/gh-pages/docs/refguide/observe.md" class="btn fa fa-edit pull-left">&#xA0;&#xA0;Edit This Page</a>
<p><code>observe</code> and <code>intercept</code> can be used to monitor the changes of a single observable (they <strong><em>don&apos;t</em></strong> track nested observables).
<code>intercept</code> can be used to detect and modify mutations before they are applied to the observable.
<code>observe</code> allows you to intercept changes after they have been made.</p>
<h2 id="intercept">Intercept</h2>
<p>Usage: <code>intercept(target, propertyName?, interceptor)</code></p>
<ul>
<li><code>target</code>: the observable to guard</li>
<li><code>propertyName</code>: optional parameter to specify a specific property to intercept. Note that <code>intercept(user.name, interceptor)</code> is fundamentally different from <code>intercept(user, &quot;name&quot;, interceptor)</code>. The first tries to add an interceptor to the <em>current</em> <code>value</code> inside <code>user.name</code> (which might not be an observable at all), the latter intercepts changes to the <code>name</code> <em>property</em> of <code>user</code>.</li>
<li><code>interceptor</code>: callback that will be invoked for <em>each</em> change that is made to the observable. Receives a single change object describing the mutation.</li>
</ul>
<p>The <code>intercept</code> should tell MobX what needs to happen with the current change.
Therefore it should do one of the following things:</p>
<ol>
<li>Return the received <code>change</code> object as-is from the function, in wich case the mutation will be applied.   </li>
<li>Modify the <code>change</code> object and return it, for example to normalize the data. Not all fields are modifiable, see below.</li>
<li>Return <code>null</code>, this indicates that the change can be ignored and shouldn&apos;t be applied. This is a powerful concept to make your objects for example temporarily immutable.</li>
<li>Throw an exception, for example if some invariant isn&apos;t met.</li>
</ol>
<p>The function returns a <code>disposer</code> function that can be used to cancel the interceptor.
It is possible to register multiple interceptors to the same observable.
They will be chained in registration order.
If one of the interceptors returns <code>null</code> or throw an exception, the other interceptors won&apos;t be evaluated anymore.
It is also possible to register an interceptor both on a parent object and on an individual property.
In that case the parent object interceptors are run before the property interceptors. </p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> theme = observable({
  backgroundColor: <span class="hljs-string">&quot;#ffffff&quot;</span>
})

intercept(theme, <span class="hljs-string">&quot;backgroundColor&quot;</span>, change =&gt; {
  <span class="hljs-keyword">if</span> (!change.newValue) {
    
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;   
  }
  <span class="hljs-keyword">if</span> (change.newValue.length === <span class="hljs-number">6</span>) {
    
    change.newValue = <span class="hljs-string">&apos;#&apos;</span> + change.newValue;
    <span class="hljs-keyword">return</span> change;   
  }
  <span class="hljs-keyword">if</span> (change.newValue.length === <span class="hljs-number">7</span>) {
      
      <span class="hljs-keyword">return</span> change;
  }
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;This doesn&apos;t like a color at all: &quot;</span> + change.newValue);
})
</code></pre>
<h2 id="observe">Observe</h2>
<p>Usage: <code>observe(target, propertyName?, listener, invokeImmediately?)</code></p>
<ul>
<li><code>target</code>: the observable to observe</li>
<li><code>propertyName</code>: optional parameter to specify a specific property to observe. Note that <code>observe(user.name, listener)</code> is fundamentally different from <code>observe(user, &quot;name&quot;, listener)</code>. The first observes the <em>current</em> <code>value</code> inside <code>user.name</code> (which might not be an observable at all), the latter observes the <code>name</code> <em>property</em> of <code>user</code>.</li>
<li><code>listener</code>: callback that will be invoked for <em>each</em> change that is made to the observable. Receives a single change object describing the mutation, except for boxed observables, which will invoke the <code>listener</code> two parameters: <code>newValue, oldValue</code>. </li>
<li><code>invokeImmediately</code>: by default false. Set it to true if you want <code>observe</code> to invoke <code>listener</code> directly with the state of the observable (instead of waiting for the first change). Not supported (yet) by all kinds of observables.</li>
</ul>
<p>The function returns a <code>disposer</code> function that can be used to cancel the observer.
Note that <code>transaction</code> does not affect the working of the <code>observe</code> method(s).
This means that even inside a transaction <code>observe</code> will fire its listeners for each mutation.
Hence <code>autorun</code> is usually a more powerful and declarative alternative to <code>observe</code>.</p>
<p>Example:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">import</span> {observable, observe} <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;mobx&apos;</span>;

<span class="hljs-keyword">const</span> person = observable({
    firstName: <span class="hljs-string">&quot;Maarten&quot;</span>,
    lastName: <span class="hljs-string">&quot;Luther&quot;</span>
});

<span class="hljs-keyword">const</span> disposer = observe(person, (change) =&gt; {
    <span class="hljs-built_in">console</span>.log(change.type, change.name, <span class="hljs-string">&quot;from&quot;</span>, change.oldValue, <span class="hljs-string">&quot;to&quot;</span>, change.object[change.name]);
});

person.firstName =  <span class="hljs-string">&quot;Martin&quot;</span>;


disposer();



<span class="hljs-keyword">const</span> disposer2 = observe(person, <span class="hljs-string">&quot;lastName&quot;</span>, (newValue, oldValue) =&gt; {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;LastName changed to &quot;</span>, newValue);
});
</code></pre>
<p>Related blog: <a href="https://medium.com/@mweststrate/object-observe-is-dead-long-live-mobservable-observe-ad96930140c5" target="_blank">Object.observe is dead. Long live mobx.observe</a></p>
<h2 id="event-overview">Event overview</h2>
<p>The callbacks of <code>intercept</code> and <code>observe</code> will receive an event object which has at least the following properties:</p>
<ul>
<li><code>object</code>: the observable triggering the event</li>
<li><code>type</code>: (string) the type of the current event</li>
</ul>
<p>These are the additional fields that are available per type:</p>
<table>
<thead>
<tr>
<th>observable type</th>
<th>event type</th>
<th>property</th>
<th>description</th>
<th>available during intercept</th>
<th>can be modified by intercept</th>
</tr>
</thead>
<tbody>
<tr>
<td>Object</td>
<td>add</td>
<td>name</td>
<td>name of the property being added</td>
<td>&#x221A;</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>newValue</td>
<td>the new value being assigned</td>
<td>&#x221A;</td>
<td>&#x221A;</td>
</tr>
<tr>
<td></td>
<td>update</td>
<td>name</td>
<td>name of the property being updated</td>
<td>&#x221A;</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>newValue</td>
<td>the new value being assigned</td>
<td>&#x221A;</td>
<td>&#x221A;</td>
</tr>
<tr>
<td></td>
<td></td>
<td>oldValue</td>
<td>the value that is replaced</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Array</td>
<td>splice</td>
<td>index</td>
<td>starting index of the splice. Splices are also fired by <code>push</code>, <code>unshift</code>, <code>replace</code> etc.</td>
<td>&#x221A;</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>removedCount</td>
<td>amount of items being removed</td>
<td>&#x221A;</td>
<td>&#x221A;</td>
</tr>
<tr>
<td></td>
<td></td>
<td>added</td>
<td>array with items being added</td>
<td>&#x221A;</td>
<td>&#x221A;</td>
</tr>
<tr>
<td></td>
<td></td>
<td>removed</td>
<td>array with items that where removed</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>addCount</td>
<td>amount of items that where added</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>update</td>
<td>index</td>
<td>index of the single entry that is being updated</td>
<td>&#x221A;</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>newValue</td>
<td>the newValue that is / will be assigned</td>
<td>&#x221A;</td>
<td>&#x221A;</td>
</tr>
<tr>
<td></td>
<td></td>
<td>oldValue</td>
<td>the old value that was replaced</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Map</td>
<td>add</td>
<td>name</td>
<td>the name of the entry that was added</td>
<td>&#x221A;</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>newValue</td>
<td>the new value that is being assigned</td>
<td>&#x221A;</td>
<td>&#x221A;</td>
</tr>
<tr>
<td></td>
<td>update</td>
<td>name</td>
<td>the name of the entry that is being updated</td>
<td>&#x221A;</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>newValue</td>
<td>the new value that is being assigned</td>
<td>&#x221A;</td>
<td>&#x221A;</td>
</tr>
<tr>
<td></td>
<td></td>
<td>oldValue</td>
<td>the value that has been replaced</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>delete</td>
<td>name</td>
<td>the name of the entry that is being removed</td>
<td>&#x221A;</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>oldValue</td>
<td>the value of the entry that was removed</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Boxed observable</td>
<td>create</td>
<td>newValue</td>
<td>the value that was assigned during creation. Only observable by <code>spy</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>update</td>
<td>newValue</td>
<td>the new value being assigned (only available in <code>intercept</code> and <code>spy</code>)</td>
<td>&#x221A;</td>
<td>&#x221A;</td>
</tr>
<tr>
<td></td>
<td></td>
<td>oldValue</td>
<td>.. the old value. Only available in <code>spy</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>(observe callback)</td>
<td>newValue</td>
<td>first param of the <code>observe</code> callback</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>(observe callback)</td>
<td>oldValue</td>
<td>second param of the <code>observe</code> callback previous value</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Computed observable</td>
<td>(observe callback)</td>
<td>newValue</td>
<td>first param of the <code>observe</code> callback</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>(observe callback)</td>
<td>oldValue</td>
<td>second param of the <code>observe</code> callback</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>

                    
                    </section><span>
                
                
                </span></div></div>
        </article>
      <h2></h2>
        <article>
          <h3>reaction | MobX</h3>
          <div><div class="page-inner"><span>
                
                
                    </span><section class="normal" id="section-">
                    
                        <a id="edit-link" href="https://github.com/mobxjs/mobx/tree/gh-pages/docs/refguide/reaction.md" class="btn fa fa-edit pull-left">&#xA0;&#xA0;Edit This Page</a>
<p>Usage: <code>reaction(() =&gt; data, data =&gt; { sideEffect }, fireImmediately = false, delay = 0)</code>.</p>
<p>A variation on <code>autorun</code> that gives more fine grained control on which observables will be tracked.
It takes two functions, the first one is tracked and returns data that is used as input for the second one, the side effect.
Unlike <code>autorun</code> the side effect won&apos;t be run directly when created, but only when the data expression returns a new value for the first time.
Any observables that are accessed while executing the side effect will not be tracked.
The side effect can be debounced, just like <code>autorunAsync</code>.
<code>reaction</code> returns a disposer function.
If a string is passed as first argument to <code>reaction</code>, it will be used as debug name.
The functions passed to <code>when</code> will receive one argument when invoked, the current reaction, which can be used to dispose the when during execution.</p>
<p>It is important to notice that the side effect will <em>only</em> react to data that was <em>accessed</em> in the data expression, which might be less then the data that is actually used in the effect.
Also, the side effect will only be triggered when the data returned by the expression has changed (the <code>asStructure</code> modifier can be used to enforce deep comparison).
In other words: reaction requires you to produce the things you need in your side effect.</p>
<p>In the following example both <code>reaction1</code>, <code>reaction2</code> and <code>autorun1</code> will react to the addition, removal or replacement of todo&apos;s in the <code>todos</code> array.
But only <code>reaction2</code> and <code>autorun</code> will react to the change of a <code>title</code> in one of the todo items, because <code>title</code> is used in the data expression of reaction 2, while it isn&apos;t in the data expression of reaction 1.
<code>autorun</code> tracks the complete side effect, hence it will always trigger correctly, but is also more suspectible to accidentally accessing unrelevant data.
See also <a href="https://mobxjs.github.io/mobx/best/react">what will MobX React to?</a>.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> todos = observable([
    {
        title: <span class="hljs-string">&quot;Make coffee&quot;</span>,
        done: <span class="hljs-literal">true</span>,
    },
    {
        title: <span class="hljs-string">&quot;Find biscuit&quot;</span>,
        done: <span class="hljs-literal">false</span>
    }
]);

<span class="hljs-keyword">const</span> reaction1 = reaction(
    () =&gt; todos.length,
    todos =&gt; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;reaction 1:&quot;</span>, todos.map(todo =&gt; todo.title).join(<span class="hljs-string">&quot;, &quot;</span>))
);

<span class="hljs-keyword">const</span> reaction2 = reaction(
    () =&gt; todos.map(todo =&gt; todo.title),
    titles =&gt; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;reaction 2:&quot;</span>, titles.join(<span class="hljs-string">&quot;, &quot;</span>))
);

<span class="hljs-keyword">const</span> autorun1 = autorun(
    () =&gt; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;autorun 1:&quot;</span>, todos.map(todo =&gt; todo.title).join(<span class="hljs-string">&quot;, &quot;</span>))
);

todos.push({ title: <span class="hljs-string">&quot;explain reactions&quot;</span>, done: <span class="hljs-literal">false</span> });





todos[<span class="hljs-number">0</span>].title = <span class="hljs-string">&quot;Make tea&quot;</span>



</code></pre>
<p>Reaction is roughly speaking sugar for: <code>computed(expression).observe(action(sideEffect))</code> or <code>autorun(() =&gt; action(sideEffect)(expression)</code></p>

                    
                    </section><span>
                
                
                </span></div></div>
        </article>
      <h2></h2>
        <article>
          <h3>spy | MobX</h3>
          <div><div class="page-inner"><span>
                
                
                    </span><section class="normal" id="section-">
                    
                        <a id="edit-link" href="https://github.com/mobxjs/mobx/tree/gh-pages/docs/refguide/spy.md" class="btn fa fa-edit pull-left">&#xA0;&#xA0;Edit This Page</a>
<p>Usage: <code>spy(listener)</code>.
Registers a global spy listener that listens to all events that happen in MobX.
It is similar to attaching an <code>observe</code> listener to <em>all</em> observables at once, but also notifies about running (trans/re)actions and computations.
Used for example by the <code>mobx-react-devtools</code>.</p>
<p>Spy listeners always receive one object, which usually has at least a <code>type</code> field. The following events are emitted by default by spy.</p>
<table>
<thead>
<tr>
<th>event</th>
<th>fields</th>
<th>nested</th>
</tr>
</thead>
<tbody>
<tr>
<td>action</td>
<td>name, target (scope), arguments, fn (source function of the action</td>
<td>yes</td>
</tr>
<tr>
<td>transaction</td>
<td>name, target (scope)</td>
<td>yes</td>
</tr>
<tr>
<td>scheduled-reaction</td>
<td>object (Reaction instance)</td>
<td>no</td>
</tr>
<tr>
<td>reaction</td>
<td>object (Reaction instance), fn (source of the reaction)</td>
<td>yes</td>
</tr>
<tr>
<td>compute</td>
<td>object (ComputedValue instance), target (scope), fn (source)</td>
<td>no</td>
</tr>
<tr>
<td>error</td>
<td>message</td>
<td>no</td>
</tr>
<tr>
<td>update (array)</td>
<td>object (the array), index, newValue, oldValue</td>
<td>yes</td>
</tr>
<tr>
<td>update (map)</td>
<td>object (observable map instance), name, newValue, oldValue</td>
<td>yes</td>
</tr>
<tr>
<td>update (object)</td>
<td>object (instance), name, newValue, oldValue</td>
<td>yes</td>
</tr>
<tr>
<td>splice (array)</td>
<td>object (the array), index, added, removed, addedCount, removedCount</td>
<td>yes</td>
</tr>
<tr>
<td>add (map)</td>
<td>object, name, newValue</td>
<td>yes</td>
</tr>
<tr>
<td>add (object)</td>
<td>object, name, newValue</td>
<td>yes</td>
</tr>
<tr>
<td>delete (map)</td>
<td>object, name, oldValue</td>
<td>yes</td>
</tr>
<tr>
<td>create (boxed observable)</td>
<td>object (ObservableValue instance), newValue</td>
<td>yes</td>
</tr>
</tbody>
</table>
<p>Note that there are events with the signature <code>{ spyReportEnd: true, time? }</code>.
These events might not have a <code>type</code> field, but they are part of an earlier fired event that had <code>spyReportStart: true</code>.
This event indicates the end of an event and this way groups of events with sub-events are created.
This event might report the total execution time as well.</p>
<p>The spy events for observable values are identical to the events passed to <code>observe</code>. See <a href="https://mobxjs.github.io/mobx/refguide/observe.html">intercept &amp; observe</a> for an extensive overview.</p>
<p>It is possible to emit your own spy events as well. See <code>extras.spyReport</code>, <code>extras.spyReportStart</code> and <code>extras.spyReportEnd</code></p>

                    
                    </section><span>
                
                
                </span></div></div>
        </article>
      <h2></h2>
        <article>
          <h3>toJS | MobX</h3>
          <div><div class="page-inner"><span>
                
                
                    </span><section class="normal" id="section-">
                    
                        <a id="edit-link" href="https://github.com/mobxjs/mobx/tree/gh-pages/docs/refguide/tojson.md" class="btn fa fa-edit pull-left">&#xA0;&#xA0;Edit This Page</a>
<p><code>toJS(value, supportCycles = true)</code></p>
<p>Recursively converts an (observable) object to a javascript <em>structure</em>.
Supports observable arrays, objects, maps and primitives.
Computed values and other non-enumerable properties won&apos;t be part of the result.
Cycles are detected and properly supported by default, but this can be disabled to improve performance.</p>
<p>For more complex (de)serialization scenario&apos;s, one can use <a href="https://github.com/mobxjs/serializr" target="_blank">serializr</a></p>
<pre><code>var obj = mobx.observable({
    x: 1
});

var clone = mobx.toJS(obj);

console.log(mobx.isObservableObject(obj)); // true
console.log(mobx.isObservableObject(clone)); // false
</code></pre><p>Note: this method was named <code>toJSON</code> before MobX 2.2</p>

                    
                    </section><span>
                
                
                </span></div></div>
        </article>
      <h2></h2>
        <article>
          <h3>transaction</h3>
          <div><div class="page-inner"><span>
                
                
                    </span><section class="normal" id="section-">
                    
                        <a id="edit-link" href="https://github.com/mobxjs/mobx/tree/gh-pages/docs/refguide/transaction.md" class="btn fa fa-edit pull-left">&#xA0;&#xA0;Edit This Page</a>
<p><code>transaction(worker: () =&gt; void)</code> can be used to batch a bunch of updates without notifying any observers until the end of the transaction.
<code>transaction</code> takes a single, parameterless <code>worker</code> function as argument and runs it.
No observers are notified until this function has completed.
<code>transaction</code> returns any value that was returned by the <code>worker</code> function.
Note that <code>transaction</code> runs completely synchronously.
Transactions can be nested. Only after completing the outermost <code>transaction</code> pending reactions will be run.</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">import</span> {observable, transaction, autorun} <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;mobx&quot;</span>;

<span class="hljs-keyword">const</span> numbers = observable([]);

autorun(() =&gt; <span class="hljs-built_in">console</span>.log(numbers.length, <span class="hljs-string">&quot;numbers!&quot;</span>));


transaction(() =&gt; {
    transaction(() =&gt; {
        numbers.push(<span class="hljs-number">1</span>);
        numbers.push(<span class="hljs-number">2</span>);
    });
    numbers.push(<span class="hljs-number">3</span>);
});

</code></pre>

                    
                    </section><span>
                
                
                </span></div></div>
        </article>
      <h2></h2>
        <article>
          <h3>untracked | MobX</h3>
          <div><div class="page-inner"><span>
                
                
                    </span><section class="normal" id="section-">
                    
                        <a id="edit-link" href="https://github.com/mobxjs/mobx/tree/gh-pages/docs/refguide/untracked.md" class="btn fa fa-edit pull-left">&#xA0;&#xA0;Edit This Page</a>
<p>Untracked allows you to run a piece of code without establishing observers.
Like <code>transaction</code>, <code>untracked</code> is automatically applied by <code>(@)action</code>, so usually it makes more sense to use actions then <code>untracked</code> directly.
Example:</p>
<pre><code class="lang-javascript">
<span class="hljs-keyword">const</span> person = observable({
    firstName: <span class="hljs-string">&quot;Michel&quot;</span>,
    lastName: <span class="hljs-string">&quot;Weststrate&quot;</span>
});

autorun(() =&gt; {
    <span class="hljs-built_in">console</span>.log(
        person.lastName,
        <span class="hljs-string">&quot;,&quot;</span>,
        
        untracked(() =&gt; person.firstName)
    );
});


person.firstName = <span class="hljs-string">&quot;G.K.&quot;</span>;


person.lastName = <span class="hljs-string">&quot;Chesterton&quot;</span>;

</code></pre>

                    
                    </section><span>
                
                
                </span></div></div>
        </article>
      <h2></h2>
        <article>
          <h3>when | MobX</h3>
          <div><div class="page-inner"><span>
                
                
                    </span><section class="normal" id="section-">
                    
                        <a id="edit-link" href="https://github.com/mobxjs/mobx/tree/gh-pages/docs/refguide/when.md" class="btn fa fa-edit pull-left">&#xA0;&#xA0;Edit This Page</a>
<p><code>when(debugName?, predicate: () =&gt; boolean, effect: () =&gt; void, scope?)</code></p>
<p><code>when</code> observes &amp; runs the given <code>predicate</code> until it returns true.
Once that happens, the given <code>effect</code> is executed and the autorunner is disposed.
The function returns a disposer to cancel the autorunner prematurely.</p>
<p>This function is really useful to dispose or cancel stuff in a reactive way.
For example:</p>
<pre><code class="lang-javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyResource</span> </span>{
    constructor() {
        when(
            
            () =&gt; !<span class="hljs-keyword">this</span>.isVisible,
            
            () =&gt; <span class="hljs-keyword">this</span>.dispose()
        );
    }

    @computed get isVisible() {
        
    }

    dispose() {
        
    }
}
</code></pre>
<p><em>In MobX 1.0 this method was called <code>autorunUntil</code>.</em></p>

                    
                    </section><span>
                
                
                </span></div></div>
        </article>
      <h2></h2>
        <article>
          <h3>Donate | MobX</h3>
          <div><div class="dropdown-menu font-settings dropdown-left"><span>
            </span><span>
            </span><p>
                <button type="button" data-sharing="twitter" class="button">
                    Share on Twitter
                </button>
                <button type="button" data-sharing="google-plus" class="button">
                    Share on Google
                </button>
                <button type="button" data-sharing="facebook" class="button">
                    Share on Facebook
                </button>
                <button type="button" data-sharing="weibo" class="button">
                    Share on Weibo
                </button>
                <button type="button" data-sharing="instapaper" class="button">
                    Share on Instapaper
                </button>
            </p><span>
        </span></div></div>
        </article>
      
    </div>
  </body>
</html>
  