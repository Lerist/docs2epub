
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="https://fonts.googleapis.com/css?family=Merriweather:400,400i,700" rel="stylesheet">

    <style>
      body {
        font-family: 'Merriweather', serif;
        background: '#ddd';
        color: '#444';
        font-size: 17px;
        line-height: 1.75;
      }

      code, pre {
        font-family: 'monospace'
        font-size: 15px;
        background: #fafafa;
        padding: 0.5rem;
        margin: 0.5rem 0;
      }

      #main {
        max-width: 740px;
      }

      article {
        margin: 1em 0;
        padding: 1em;
      }
    </style>
  </head>
  <body>
    <div id="main">
      
        <article>
          <h3>angular2 documentation</h3>
          <div>
<div>
  <h3>About this book.</h3>
  <div>
    Documentation generated by <b>docs2epub</b> [http://javier.xyz/docs2epub/] on Fri Sep 02 2016 02:18:40 GMT-0500 (CDT), scrapped from https://angular.io/docs/ts/latest/.
  </div>
  <br /><br />
  <div>
    Find more about this project on https://github.com/angular/angular.
    LICENCE of angular2: https://raw.githubusercontent.com/angular/angular/master/LICENSE
  </div>
</div>
  </div>
        </article>
      <h2></h2><h2></h2>
        <article>
          <h3>Tutorial: Tour of Heroes</h3>
          <div><div class="showcase-content"><!-- #docregion intro--><span>
</span><p>Our grand plan is to build an app to help a staffing agency manage its stable of heroes.
Even heroes need to find work.</p><span>
</span><p>Of course we&apos;ll only make a little progress in this tutorial. What we do build will
have many of the features we expect to find in a full-blown, data-driven application: acquiring and displaying
a list of heroes, editing a selected hero&apos;s detail, and navigating among different
views of heroic data.</p><span>
</span><p>The Tour of Heroes covers the core fundamentals of Angular.
We&#x2019;ll use built-in directives to show/hide elements and display lists of hero data.
We&#x2019;ll create a component to display hero details and another to show an array of heroes.
We&apos;ll use one-way data binding for read-only data. We&apos;ll add editable fields to update a model
with two-way data binding. We&apos;ll bind component methods to user events like key strokes and clicks.
We&#x2019;ll learn to select a hero from a master list and edit that hero in the details view. We&apos;ll
format data with pipes. We&apos;ll create a shared service to assemble our heroes. And we&apos;ll use routing to navigate among different views and their components.</p><span>
</span><p>We&#x2019;ll learn enough core Angular to get started and gain confidence that
Angular can do whatever we need it to do.
We&apos;ll be covering a lot of ground at an introductory level but we&#x2019;ll find plenty of links
to chapters with greater depth.</p><span>
</span><p>Run the <live-example name="toh-6"></live-example>.</p><span>
</span><!-- #enddocregion intro--><!-- #docregion main--><h2 id="the-end-game">The End Game</h2><span>
</span><p>Here&apos;s a visual idea of where we&apos;re going in this tour, beginning with the &quot;Dashboard&quot;
view and our most heroic heroes:</p><span>
</span><figure class="image-display"><img src="https://angular.io/resources/images/devguide/toh/heroes-dashboard-1.png" alt="Output of heroes dashboard"></figure><p>Above the dashboard are two links (&quot;Dashboard&quot; and &quot;Heroes&quot;).
We could click them to navigate between this Dashboard and a Heroes view.</p><span>
</span><p>Instead we click the dashboard hero named &quot;Magneta&quot; and the router takes us to a &quot;Hero Details&quot; view
of that hero where we can change the hero&apos;s name.</p><span>
</span><figure class="image-display"><img src="https://angular.io/resources/images/devguide/toh/hero-details-1.png" alt="Details of hero in app"></figure><p>Clicking the &quot;Back&quot; button would return us to the &quot;Dashboard&quot;.
Links at the top can take us to either of the main views.
We&apos;ll click &quot;Heroes&quot;. The app takes to the &quot;Heroes&quot; master list view.</p><span>
</span><figure class="image-display"><img src="https://angular.io/resources/images/devguide/toh/heroes-list-2.png" alt="Output of heroes list app"></figure><p>We click a different hero and the readonly mini-detail beneath the list reflects our new choice.</p><span>
</span><p>We click the &quot;View Details&quot; button to drill into the
editable details of our selected hero.</p><span>
</span><p>The following diagram captures all of our navigation options.</p><span>
</span><figure class="image-display"><img src="https://angular.io/resources/images/devguide/toh/nav-diagram.png" alt="View navigations"></figure><p>Here&apos;s our app in action</p><span>
</span><figure class="image-display"><img src="https://angular.io/resources/images/devguide/toh/toh-anim.gif" alt="Tour of Heroes in Action"></figure><h2 id="up-next">Up Next</h2><span>
</span><p>We&#x2019;ll build this Tour of Heroes together, step by step.
We&apos;ll motivate each step with a requirement that we&apos;ve
met in countless applications. Everything has a reason.</p><span>
</span><p>And we&#x2019;ll meet many of the core fundamentals of Angular along the way.</p><span>
</span><p><a href="https://angular.io/docs/ts/latest/tutorial/toh-pt1.html">Let&apos;s get started!</a></p><span>
</span><!-- #enddocregion main--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!--NEXT PAGE HAS NOW BEEN SET--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--></div></div>
        </article>
      
        <article>
          <h3>The Hero Editor</h3>
          <div><div class="showcase-content"><span>
</span><p>Every story starts somewhere. Our story starts where the <a href="https://angular.io/docs/ts/latest/quickstart.html">QuickStart</a> ends.</p><span>
</span><p>Run the <live-example></live-example> for this part.</p><span>
</span><p>Create a folder called <code>angular2-tour-of-heroes</code> and follow the <a href="https://angular.io/docs/ts/latest/quickstart.html">QuickStart</a> steps
which provide the prerequisites, the folder structure, and the core files for our Tour of Heroes.</p><span>
</span><p>We should have the following structure:</p><span>
</span><div class="filetree"><p>angular2-tour-of-heroes</p><div class="children"><p>app</p><div class="children"><p>app.component.ts</p><p>app.module.ts</p><p>main.ts</p></div><p>node_modules ...</p><p>typings ...</p><p>index.html</p><p>package.json</p><p>styles.css</p><p>systemjs.config.js</p><p>tsconfig.json</p><p>typings.json</p></div></div><h2 id="keep-the-app-transpiling-and-running">Keep the app transpiling and running</h2><span>
</span><p>We want to start the TypeScript compiler, have it watch for changes, and start our server. We&apos;ll do this by typing</p><span>
</span><code language="bash">npm start
</code><p>This command runs the compiler in watch mode, starts the server, launches the app in a browser,
and keeps the app running while we continue to build the Tour of Heroes.</p><span>
</span><div class="l-main-section"><h2 id="show-our-hero">Show our Hero</h2><span>
</span><p>We want to display Hero data in our app</p><span>
</span><p>Let&apos;s add two properties to our <code>AppComponent</code>, a <code>title</code> property for the application name and a <code>hero</code> property
for a hero named &quot;Windstorm&quot;.</p><span>
</span><p>app.component.ts (AppComponent class)</p><code language="ts" format="">export class AppComponent {
  title = &apos;Tour of Heroes&apos;;
  hero = &apos;Windstorm&apos;;
}
</code><p>Now we update the template in the <code>@Component</code> decoration with data bindings to these new properties.</p><span>
</span><code language="ts" format="">template: &apos;&lt;h1&gt;{{title}}&lt;/h1&gt;&lt;h2&gt;{{hero}} details!&lt;/h2&gt;&apos;
</code><p>The browser should refresh and display our title and hero.</p><span>
</span><p>The double curly braces tell our app to read the <code>title</code> and <code>hero</code> properties from the component and render them.
This is the &quot;interpolation&quot; form of one-way data binding.</p><span>
</span></div><h3 id="hero-object">Hero object</h3><span>
</span><p>At the moment, our hero is just a name.  Our hero needs more properties.
Let&apos;s convert the <code>hero</code> from a literal string to a class.</p><span>
</span><p>Create a <code>Hero</code> class with <code>id</code> and <code>name</code> properties.
For now put this near the top of the <code>app.component.ts</code> file, just below the import statement.</p><span>
</span><p>app.component.ts (Hero class)</p><code language="ts" format="">export class Hero {
  id: number;
  name: string;
}
</code><p>Now that we have a <code>Hero</code> class, let&#x2019;s refactor our component&#x2019;s <code>hero</code> property to be of type <code>Hero</code>.
Then initialize it with an id of <code>1</code> and the name, &quot;Windstorm&quot;.</p><span>
</span><p>app.component.ts (hero property)</p><code language="ts" format="">hero: Hero = {
  id: 1,
  name: &apos;Windstorm&apos;
};
</code><p>Because we changed the hero from a string to an object,
we update the binding in the template to refer to the hero&#x2019;s <code>name</code> property.</p><span>
</span><code language="ts" format="">template: &apos;&lt;h1&gt;{{title}}&lt;/h1&gt;&lt;h2&gt;{{hero.name}} details!&lt;/h2&gt;&apos;
</code><p>The browser refreshes and continues to display our hero&#x2019;s name.</p><span>
</span><h3 id="adding-more-html">Adding more HTML</h3><span>
</span><p>Displaying a name is good, but we want to see all of our hero&#x2019;s properties.
We&#x2019;ll add a <code>&lt;div&gt;</code> for our hero&#x2019;s <code>id</code> property and another <code>&lt;div&gt;</code> for our hero&#x2019;s <code>name</code>.</p><span>
</span><code language="ts" format="">template: &apos;&lt;h1&gt;{{title}}&lt;/h1&gt;&lt;h2&gt;{{hero.name}} details!&lt;/h2&gt;&lt;div&gt;&lt;label&gt;id: &lt;/label&gt;{{hero.id}}&lt;/div&gt;&lt;div&gt;&lt;label&gt;name: &lt;/label&gt;{{hero.name}}&lt;/div&gt;&apos;
</code><p>Uh oh, our template string is getting long. We better take care of that to avoid the risk of making a typo in the template.</p><span>
</span><h3 id="multi-line-template-strings">Multi-line template strings</h3><span>
</span><p>We could make a more readable template with string concatenation
but that gets ugly fast, it is harder to read, and
it is easy to make a spelling error. Instead,
let&#x2019;s take advantage of the template strings feature
in ES2015 and TypeScript to maintain our sanity.</p><span>
</span><p>Change the quotes around the template to back-ticks and
put the <code>&lt;h1&gt;</code>, <code>&lt;h2&gt;</code> and <code>&lt;div&gt;</code> elements on their own lines.</p><span>
</span><p>app.component.ts (AppComponent&apos;s template)</p><code language="ts" format="linenums">template:`
  &lt;h1&gt;{{title}}&lt;/h1&gt;
  &lt;h2&gt;{{hero.name}} details!&lt;/h2&gt;
  &lt;div&gt;&lt;label&gt;id: &lt;/label&gt;{{hero.id}}&lt;/div&gt;
  &lt;div&gt;&lt;label&gt;name: &lt;/label&gt;{{hero.name}}&lt;/div&gt;
  `
</code><h2 id="editing-our-hero">Editing Our Hero</h2><span>
</span><p>We want to be able to edit the hero name in a textbox.</p><span>
</span><p>Refactor the hero name <code>&lt;label&gt;</code> with <code>&lt;label&gt;</code> and <code>&lt;input&gt;</code> elements as shown below:</p><span>
</span><p>app.component.ts (input element)</p><code language="ts" format="linenums">template:`
  &lt;h1&gt;{{title}}&lt;/h1&gt;
  &lt;h2&gt;{{hero.name}} details!&lt;/h2&gt;
  &lt;div&gt;&lt;label&gt;id: &lt;/label&gt;{{hero.id}}&lt;/div&gt;
  &lt;div&gt;
    &lt;label&gt;name: &lt;/label&gt;
    &lt;input value=&quot;{{hero.name}}&quot; placeholder=&quot;name&quot;&gt;
  &lt;/div&gt;
  `
</code><p>We see in the browser that the hero&#x2019;s name does appear in the <code>&lt;input&gt;</code> textbox.
But something doesn&#x2019;t feel right.
When we change the name, we notice that our change
is not reflected in the <code>&lt;h2&gt;</code>. We won&apos;t get the desired behavior
with a one-way binding to <code>&lt;input&gt;</code>.</p><span>
</span><h3 id="two-way-binding">Two-Way Binding</h3><span>
</span><p>We intend to display the name of the hero in the <code>&lt;input&gt;</code>, change it,
and see those changes wherever we bind to the hero&#x2019;s name.
In short, we want two-way data binding.</p><span>
</span><p>Before we can use two-way data binding for <strong>form inputs</strong>, we need to import the <code>FormsModule</code>
package in our Angular module. We add it to the <code>NgModule</code> decorator&apos;s <code>imports</code> array. This array contains the list
of external modules used by our application.
Now we have included the forms package which includes <code>ngModel</code>.</p><span>
</span><p>app.module.ts (FormsModule import)</p><code language="ts" format="linenums">import { NgModule }      from &apos;@angular/core&apos;;
import { BrowserModule } from &apos;@angular/platform-browser&apos;;
import { FormsModule }   from &apos;@angular/forms&apos;;

import { AppComponent }  from &apos;./app.component&apos;;

@NgModule({
  imports: [
    BrowserModule,
    FormsModule
  ],
  declarations: [
    AppComponent
  ],
  bootstrap: [ AppComponent ]
})
export class AppModule { }
</code><p>Let&#x2019;s update the template to use the  <strong><code>ngModel</code></strong> built-in directive for two-way binding.</p><span>
</span><p>Replace the <code>&lt;input&gt;</code> with the following HTML</p><span>
</span><code language="html">&lt;input [(ngModel)]=&quot;hero.name&quot; placeholder=&quot;name&quot;&gt;
</code><p>The browser refreshes. We see our hero again. We can edit the hero&#x2019;s name and
see the changes reflected immediately in the <code>&lt;h2&gt;</code>.</p><span>
</span><h2 id="the-road-we-ve-travelled">The Road We&#x2019;ve Travelled</h2><span>
</span><p>Let&#x2019;s take stock of what we&#x2019;ve built.</p><span>
</span><ul>
<li>Our Tour of Heroes uses the double curly braces of interpolation (a kind of one-way data binding)
to display the application title and properties of a <code>Hero</code> object.</li>
<li>We wrote a multi-line template using ES2015&#x2019;s template strings to make our template readable.</li>
<li>We can both display and change the hero&#x2019;s name after adding a two-way data binding to the <code>&lt;input&gt;</code> element
using the built-in <code>ngModel</code> directive.</li>
<li>The <code>ngModel</code> directive also propagates changes to every other binding of the <code>hero.name</code>.</li>
</ul><span>
</span><p>Run the <live-example></live-example> for this part.</p><span>
</span><p>Here&apos;s the complete <code>app.component.ts</code> as it stands now:</p><span>
</span><p>app.component.ts</p><code language="ts" format="linenums">import { Component } from &apos;@angular/core&apos;;

export class Hero {
  id: number;
  name: string;
}

@Component({
  selector: &apos;my-app&apos;,
  template: `
    &lt;h1&gt;{{title}}&lt;/h1&gt;
    &lt;h2&gt;{{hero.name}} details!&lt;/h2&gt;
    &lt;div&gt;&lt;label&gt;id: &lt;/label&gt;{{hero.id}}&lt;/div&gt;
    &lt;div&gt;
      &lt;label&gt;name: &lt;/label&gt;
      &lt;input [(ngModel)]=&quot;hero.name&quot; placeholder=&quot;name&quot;&gt;
    &lt;/div&gt;
    `
})
export class AppComponent {
  title = &apos;Tour of Heroes&apos;;
  hero: Hero = {
    id: 1,
    name: &apos;Windstorm&apos;
  };
}
</code><h2 id="the-road-ahead">The Road Ahead</h2><span>
</span><p>Our Tour of Heroes only displays one hero and we really want to display a list of heroes.
We also want to allow the user to select a hero and display their details.
We&#x2019;ll learn more about how to retrieve lists, bind them to the
template, and allow a user to select a hero in the
<a href="https://angular.io/docs/ts/latest/tutorial/toh-pt2.html">next tutorial chapter</a>.</p><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!--NEXT PAGE HAS NOW BEEN SET--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--></div></div>
        </article>
      
        <article>
          <h3>Master/Detail</h3>
          <div><div class="showcase-content"><span>
</span><p>Our story needs more heroes.
We&#x2019;ll expand our Tour of Heroes app to display a list of heroes,
allow the user to select a hero, and display the hero&#x2019;s details.</p><span>
</span><p>Run the <live-example></live-example> for this part.</p><span>
</span><p>Let&#x2019;s take stock of what we&#x2019;ll need to display a list of heroes.
First, we need a list of heroes. We want to display those heroes in the view&#x2019;s template,
so we&#x2019;ll need a way to do that.</p><span>
</span><h2 id="where-we-left-off">Where We Left Off</h2><span>
</span><p>Before we continue with Part 2 of the Tour of Heroes,
let&#x2019;s verify we have the following structure after <a href="https://angular.io/docs/ts/latest/tutorial/toh-pt1.html">Part 1</a>.
If not, we&#x2019;ll need to go back to Part 1 and figure out what we missed.</p><span>
</span><div class="filetree"><p>angular2-tour-of-heroes</p><div class="children"><p>app</p><div class="children"><p>app.component.ts</p><p>app.module.ts</p><p>main.ts</p></div><p>node_modules ...</p><p>typings ...      </p><p>index.html</p><p>package.json</p><p>styles.css</p><p>systemjs.config.js</p><p>tsconfig.json</p><p>typings.json</p></div></div><h3 id="keep-the-app-transpiling-and-running">Keep the app transpiling and running</h3><span>
</span><p>We want to start the TypeScript compiler, have it watch for changes, and start our server. We&apos;ll do this by typing</p><span>
</span><code language="bash">npm start
</code><p>This will keep the application running while we continue to build the Tour of Heroes.</p><span>
</span><h2 id="displaying-our-heroes">Displaying Our Heroes</h2><span>
</span><h3 id="creating-heroes">Creating heroes</h3><span>
</span><p>Let&#x2019;s create an array of ten heroes.</p><span>
</span><p>app.component.ts (hero array)</p><code language="ts" format="linenums">const HEROES: Hero[] = [
  { id: 11, name: &apos;Mr. Nice&apos; },
  { id: 12, name: &apos;Narco&apos; },
  { id: 13, name: &apos;Bombasto&apos; },
  { id: 14, name: &apos;Celeritas&apos; },
  { id: 15, name: &apos;Magneta&apos; },
  { id: 16, name: &apos;RubberMan&apos; },
  { id: 17, name: &apos;Dynama&apos; },
  { id: 18, name: &apos;Dr IQ&apos; },
  { id: 19, name: &apos;Magma&apos; },
  { id: 20, name: &apos;Tornado&apos; }
];
</code><p>The <code>HEROES</code> array is of type <code>Hero</code>, the class defined in part one, 
to create an array of heroes.
We aspire to fetch this list of heroes from a web service, but let&#x2019;s take small steps
first and display mock heroes.</p><span>
</span><h3 id="exposing-heroes">Exposing heroes</h3><span>
</span><p>Let&#x2019;s create a public property in <code>AppComponent</code> that exposes the heroes for binding.</p><span>
</span><p>app.component.ts (hero array property)</p><code language="ts" format="">heroes = HEROES;
</code><p>We did not have to define the <code>heroes</code> type.  TypeScript can infer it from the <code>HEROES</code> array.</p><span>
</span><div class="l-sub-section"><p>We could have defined the heroes list here in this component class.
But we know that ultimately we&#x2019;ll get the heroes from a data service.
Because we know where we are heading, it makes sense to separate the hero data
from the class implementation from the start.</p><span>
</span></div><h3 id="displaying-heroes-in-a-template">Displaying heroes in a template</h3><span>
</span><p>Our component has <code>heroes</code>. Let&#x2019;s create an unordered list in our template to display them.
We&#x2019;ll insert the following chunk of HTML below the title and above the hero details.</p><span>
</span><p>app.component.ts (heroes template)</p><code language="ts" format="linenums">&lt;h2&gt;My Heroes&lt;/h2&gt;
&lt;ul class=&quot;heroes&quot;&gt;
  &lt;li&gt;
    &lt;!-- each hero goes here --&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</code><p>Now we have a template that we can fill with our heroes.</p><span>
</span><h3 id="listing-heroes-with-ngfor">Listing heroes with ngFor</h3><span>
</span><p>We want to bind the array of <code>heroes</code> in our component to our template, iterate over them,
and display them individually.
We&#x2019;ll need some help from Angular to do this. Let&#x2019;s do this step by step.</p><span>
</span><p>First modify the <code>&lt;li&gt;</code> tag by adding the built-in directive <code>*ngFor</code>.</p><span>
</span><p>app.component.ts (ngFor)</p><code language="ts" format="">&lt;li *ngFor=&quot;let hero of heroes&quot;&gt;
</code><div class="alert is-critical"><p>The leading asterisk (<code>*</code>) in front of <code>ngFor</code> is a critical part of this syntax.</p><span>
</span></div><div class="l-sub-section"><p>The (<code>*</code>) prefix to <code>ngFor</code> indicates that the <code>&lt;li&gt;</code> element and its children
constitute a master template.</p><span>
</span><p>The <code>ngFor</code> directive iterates over the <code>heroes</code> array returned by the <code>AppComponent.heroes</code> property
and stamps out instances of this template.</p><span>
</span><p>The quoted text assigned to <code>ngFor</code> means
&#x201C;<em>take each hero in the <code>heroes</code> array, store it in the local <code>hero</code> variable,
and make it available to the corresponding template instance</em>&#x201D;.</p><span>
</span><p>The <code>let</code> keyword before &quot;hero&quot; identifies <code>hero</code> as a template input variable.
We can reference this variable within the template to access a hero&#x2019;s properties.</p><span>
</span><p>Learn more about <code>ngFor</code> and template input variables in the
<a href="https://angular.io/docs/ts/latest/guide/displaying-data.html#ngFor">Displaying Data</a> and
<a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#ngFor">Template Syntax</a> chapters.</p><span>
</span></div><p>Now we insert some content between the <code>&lt;li&gt;</code> tags
that uses the <code>hero</code> template variable to display the hero&#x2019;s properties.</p><span>
</span><p>app.component.ts (ngFor template)</p><code language="ts" format="">&lt;li *ngFor=&quot;let hero of heroes&quot;&gt;
  &lt;span class=&quot;badge&quot;&gt;{{hero.id}}&lt;/span&gt; {{hero.name}}
&lt;/li&gt;
</code><p>When the browser refreshes, we see a list of heroes!</p><span>
</span><h3 id="styling-our-heroes">Styling our heroes</h3><span>
</span><p>Our list of heroes looks pretty bland.
We want to make it visually obvious to a user which hero we are hovering over and which hero is selected.</p><span>
</span><p>Let&#x2019;s add some styles to our component by setting the <code>styles</code> property on the <code>@Component</code> decorator
to the following CSS classes:</p><span>
</span><p>app.component.ts (styles)</p><code language="ts" format="">styles: [`
  .selected {
    background-color: #CFD8DC !important;
    color: white;
  }
  .heroes {
    margin: 0 0 2em 0;
    list-style-type: none;
    padding: 0;
    width: 15em;
  }
  .heroes li {
    cursor: pointer;
    position: relative;
    left: 0;
    background-color: #EEE;
    margin: .5em;
    padding: .3em 0;
    height: 1.6em;
    border-radius: 4px;
  }
  .heroes li.selected:hover {
    background-color: #BBD8DC !important;
    color: white;
  }
  .heroes li:hover {
    color: #607D8B;
    background-color: #DDD;
    left: .1em;
  }
  .heroes .text {
    position: relative;
    top: -3px;
  }
  .heroes .badge {
    display: inline-block;
    font-size: small;
    color: white;
    padding: 0.8em 0.7em 0 0.7em;
    background-color: #607D8B;
    line-height: 1em;
    position: relative;
    left: -1px;
    top: -4px;
    height: 1.8em;
    margin-right: .8em;
    border-radius: 4px 0 0 4px;
  }
`]
</code><p>Notice that we again use the back-tick notation for multi-line strings.</p><span>
</span><p>That&apos;s a lot of styles! We can put them inline as shown here, or we can move them out to their own file which will make it easier to code our component. 
We&apos;ll do this in a later chapter. For now let&apos;s keep rolling.</p><span>
</span><p>When we assign styles to a component they are scoped to that specific component.
Our styles will only apply to our <code>AppComponent</code> and won&apos;t &quot;leak&quot; to the outer HTML.</p><span>
</span><p>Our template for displaying the heroes should now look like this:</p><span>
</span><p>app.component.ts (styled heroes)</p><code language="ts" format="linenums">&lt;h2&gt;My Heroes&lt;/h2&gt;
&lt;ul class=&quot;heroes&quot;&gt;
  &lt;li *ngFor=&quot;let hero of heroes&quot;&gt;
    &lt;span class=&quot;badge&quot;&gt;{{hero.id}}&lt;/span&gt; {{hero.name}}
  &lt;/li&gt;
&lt;/ul&gt;
</code><div class="l-main-section"><h2 id="selecting-a-hero">Selecting a Hero</h2><span>
</span><p>We have a list of heroes and we have a single hero displayed in our app.
The list and the single hero are not connected in any way.
We want the user to select a hero from our list, and have the selected hero appear in the details view.
This UI pattern is widely known as &quot;master-detail&quot;.
In our case, the master is the heroes list and the detail is the selected hero.</p><span>
</span><p>Let&#x2019;s connect the master to the detail through a <code>selectedHero</code> component property bound to a click event.</p><span>
</span><h3 id="click-event">Click event</h3><span>
</span><p>We modify the <code>&lt;li&gt;</code> by inserting an Angular event binding to its click event.</p><span>
</span><p>app.component.ts (template excerpt)</p><code language="ts" format="linenums">&lt;li *ngFor=&quot;let hero of heroes&quot; (click)=&quot;onSelect(hero)&quot;&gt;
  &lt;span class=&quot;badge&quot;&gt;{{hero.id}}&lt;/span&gt; {{hero.name}}
&lt;/li&gt;
</code><p>Focus on the event binding</p><span>
</span><code format="." language="bash">(click)=&quot;onSelect(hero)&quot;</code><p>The parenthesis identify the <code>&lt;li&gt;</code> element&#x2019;s  <code>click</code> event as the target.
The expression to the right of the equal sign calls the  <code>AppComponent</code> method, <code>onSelect()</code>,
passing the template input variable <code>hero</code> as an argument.
That&#x2019;s the same <code>hero</code> variable we defined previously in the <code>ngFor</code>.</p><span>
</span><h3 id="add-the-click-handler">Add the click handler</h3><span>
</span><p>Our event binding refers to an <code>onSelect</code> method that doesn&#x2019;t exist yet.
We&#x2019;ll add that method to our component now.</p><span>
</span><p>What should that method do? It should set the component&#x2019;s selected hero to the hero that the user clicked.</p><span>
</span><p>Our component doesn&#x2019;t have a &#x201C;selected hero&#x201D; yet either. We&#x2019;ll start there.</p><span>
</span><h3 id="expose-the-selected-hero">Expose the selected hero</h3><span>
</span><p>We no longer need the static <code>hero</code> property of the <code>AppComponent</code>.
<strong>Replace</strong> it with this simple <code>selectedHero</code> property:</p><span>
</span><p>app.component.ts (selectedHero)</p><code language="ts" format="">selectedHero: Hero;
</code><p>We&#x2019;ve decided that none of the heroes should be selected before the user picks a hero so
we won&#x2019;t initialize the <code>selectedHero</code> as we were doing with <code>hero</code>.</p><span>
</span><p>Now <strong>add an <code>onSelect</code> method</strong> that sets the <code>selectedHero</code> property to the <code>hero</code> the user clicked.</p><span>
</span><p>app.component.ts (onSelect)</p><code language="ts" format="linenums">onSelect(hero: Hero): void {
  this.selectedHero = hero;
}
</code><p>We will be showing the selected hero&apos;s details in our template.
At the moment, it is still referring to the old <code>hero</code> property.
Let&#x2019;s fix the template to bind to the new <code>selectedHero</code> property.</p><span>
</span><p>app.component.ts (template excerpt)</p><code language="ts" format="linenums">&lt;h2&gt;{{selectedHero.name}} details!&lt;/h2&gt;
&lt;div&gt;&lt;label&gt;id: &lt;/label&gt;{{selectedHero.id}}&lt;/div&gt;
&lt;div&gt;
    &lt;label&gt;name: &lt;/label&gt;
    &lt;input [(ngModel)]=&quot;selectedHero.name&quot; placeholder=&quot;name&quot;/&gt;
&lt;/div&gt;
</code><h3 id="hide-the-empty-detail-with-ngif">Hide the empty detail with ngIf</h3><span>
</span><p>When our app loads we see a list of heroes, but a hero is not selected.
The <code>selectedHero</code> is <code>undefined</code>.
That&#x2019;s why we&apos;ll see the following error in the browser&#x2019;s console:</p><span>
</span><code language="html">EXCEPTION: TypeError: Cannot read property &apos;name&apos; of undefined in [null]
</code><p>Remember that we are displaying <code>selectedHero.name</code> in the template.
This name property does not exist because <code>selectedHero</code> itself is undefined.</p><span>
</span><p>We&apos;ll address this problem by keeping the hero detail out of the DOM until there is a selected hero.</p><span>
</span><p>We wrap the HTML hero detail content of our template with a <code>&lt;div&gt;</code>.
Then we add the <code>ngIf</code> built-in directive and set it to the <code>selectedHero</code> property of our component.</p><span>
</span><p>app.component.ts (ngIf)</p><code language="ts" format="linenums">&lt;div *ngIf=&quot;selectedHero&quot;&gt;
  &lt;h2&gt;{{selectedHero.name}} details!&lt;/h2&gt;
  &lt;div&gt;&lt;label&gt;id: &lt;/label&gt;{{selectedHero.id}}&lt;/div&gt;
  &lt;div&gt;
    &lt;label&gt;name: &lt;/label&gt;
    &lt;input [(ngModel)]=&quot;selectedHero.name&quot; placeholder=&quot;name&quot;/&gt;
  &lt;/div&gt;
&lt;/div&gt;
</code><div class="alert is-critical"><p>Remember that the leading asterisk (<code>*</code>) in front of <code>ngIf</code> is
a critical part of this syntax.</p><span>
</span></div><p>When there is no <code>selectedHero</code>, the <code>ngIf</code> directive removes the hero detail HTML from the DOM.
There will be no hero detail elements and no bindings to worry about.</p><span>
</span><p>When the user picks a hero, <code>selectedHero</code> becomes &quot;truthy&quot; and
<code>ngIf</code> puts the hero detail content into the DOM and evaluates the nested bindings.</p><span>
</span><div class="l-sub-section"><p><code>ngIf</code> and <code>ngFor</code> are called &#x201C;structural directives&#x201D; because they can change the
structure of portions of the DOM.
In other words, they give structure to the way Angular displays content in the DOM.</p><span>
</span><p>Learn more about <code>ngIf</code>, <code>ngFor</code> and other structural directives in the
<a href="https://angular.io/docs/ts/latest/guide/structural-directives.html">Structural Directives</a> and
<a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#directives">Template Syntax</a> chapters.</p><span>
</span></div><p>The browser refreshes and we see the list of heroes but not the selected hero detail.
The <code>ngIf</code> keeps it out of the DOM as long as the <code>selectedHero</code> is undefined.
When we click on a hero in the list, the selected hero displays in the hero details.
Everything is working as we expect.</p><span>
</span><h3 id="styling-the-selection">Styling the selection</h3><span>
</span><p>We see the selected hero in the details area below but we can&#x2019;t quickly locate that hero in the list above.
We can fix that by applying the <code>selected</code> CSS class to the appropriate <code>&lt;li&gt;</code> in the master list.
For example, when we select Magneta from the heroes list,
we can make it pop out visually by giving it a subtle background color as shown here.</p><span>
</span><figure class="image-display"><img src="https://angular.io/resources/images/devguide/toh/heroes-list-selected.png" alt="Selected hero"></figure><p>We&#x2019;ll add a property binding on <code>class</code> for the <code>selected</code> class to the template. We&apos;ll set this to an expression that compares the current <code>selectedHero</code> to the <code>hero</code>.</p><span>
</span><p>The key is the name of the CSS class (<code>selected</code>). The value is <code>true</code> if the two heroes match and <code>false</code> otherwise.
We&#x2019;re saying &#x201C;<em>apply the <code>selected</code> class if the heroes match, remove it if they don&#x2019;t</em>&#x201D;.</p><span>
</span><p>app.component.ts (setting the CSS class)</p><code language="ts" format="">[class.selected]=&quot;hero === selectedHero&quot;
</code><p>Notice in the template that the <code>class.selected</code> is surrounded in square brackets (<code>[]</code>).
This is the syntax for a <strong>property binding</strong>, a binding in which data flows one way
from the data source (the expression <code>hero === selectedHero</code>) to a property of <code>class</code>.</p><span>
</span><p>app.component.ts (styling each hero)</p><code language="ts" format="">&lt;li *ngFor=&quot;let hero of heroes&quot;
  [class.selected]=&quot;hero === selectedHero&quot;
  (click)=&quot;onSelect(hero)&quot;&gt;
  &lt;span class=&quot;badge&quot;&gt;{{hero.id}}&lt;/span&gt; {{hero.name}}
&lt;/li&gt;
</code><p>The browser reloads our app.
We select the hero Magneta and the selection is clearly identified by the background color.</p><span>
</span><figure class="image-display"><img src="https://angular.io/resources/images/devguide/toh/heroes-list-1.png" alt="Output of heroes list app"></figure><p>We select a different hero and the tell-tale color switches to that hero.</p><span>
</span><p>Here&apos;s the complete <code>app.component.ts</code> as it stands now:</p><span>
</span><p>app.component.ts</p><code language="ts" format="linenums">import { Component } from &apos;@angular/core&apos;;

export class Hero {
  id: number;
  name: string;
}

const HEROES: Hero[] = [
  { id: 11, name: &apos;Mr. Nice&apos; },
  { id: 12, name: &apos;Narco&apos; },
  { id: 13, name: &apos;Bombasto&apos; },
  { id: 14, name: &apos;Celeritas&apos; },
  { id: 15, name: &apos;Magneta&apos; },
  { id: 16, name: &apos;RubberMan&apos; },
  { id: 17, name: &apos;Dynama&apos; },
  { id: 18, name: &apos;Dr IQ&apos; },
  { id: 19, name: &apos;Magma&apos; },
  { id: 20, name: &apos;Tornado&apos; }
];

@Component({
  selector: &apos;my-app&apos;,
  template: `
    &lt;h1&gt;{{title}}&lt;/h1&gt;
    &lt;h2&gt;My Heroes&lt;/h2&gt;
    &lt;ul class=&quot;heroes&quot;&gt;
      &lt;li *ngFor=&quot;let hero of heroes&quot;
        [class.selected]=&quot;hero === selectedHero&quot;
        (click)=&quot;onSelect(hero)&quot;&gt;
        &lt;span class=&quot;badge&quot;&gt;{{hero.id}}&lt;/span&gt; {{hero.name}}
      &lt;/li&gt;
    &lt;/ul&gt;
    &lt;div *ngIf=&quot;selectedHero&quot;&gt;
      &lt;h2&gt;{{selectedHero.name}} details!&lt;/h2&gt;
      &lt;div&gt;&lt;label&gt;id: &lt;/label&gt;{{selectedHero.id}}&lt;/div&gt;
      &lt;div&gt;
        &lt;label&gt;name: &lt;/label&gt;
        &lt;input [(ngModel)]=&quot;selectedHero.name&quot; placeholder=&quot;name&quot;/&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  `,
  styles: [`
    .selected {
      background-color: #CFD8DC !important;
      color: white;
    }
    .heroes {
      margin: 0 0 2em 0;
      list-style-type: none;
      padding: 0;
      width: 15em;
    }
    .heroes li {
      cursor: pointer;
      position: relative;
      left: 0;
      background-color: #EEE;
      margin: .5em;
      padding: .3em 0;
      height: 1.6em;
      border-radius: 4px;
    }
    .heroes li.selected:hover {
      background-color: #BBD8DC !important;
      color: white;
    }
    .heroes li:hover {
      color: #607D8B;
      background-color: #DDD;
      left: .1em;
    }
    .heroes .text {
      position: relative;
      top: -3px;
    }
    .heroes .badge {
      display: inline-block;
      font-size: small;
      color: white;
      padding: 0.8em 0.7em 0 0.7em;
      background-color: #607D8B;
      line-height: 1em;
      position: relative;
      left: -1px;
      top: -4px;
      height: 1.8em;
      margin-right: .8em;
      border-radius: 4px 0 0 4px;
    }
  `]
})
export class AppComponent {
  title = &apos;Tour of Heroes&apos;;
  heroes = HEROES;
  selectedHero: Hero;

  onSelect(hero: Hero): void {
    this.selectedHero = hero;
  }
}
</code></div><h2 id="the-road-we-ve-travelled">The Road We&#x2019;ve Travelled</h2><span>
</span><p>Here&#x2019;s what we achieved in this chapter:</p><span>
</span><ul>
<li>Our Tour of Heroes now displays a list of selectable heroes</li>
<li>We added the ability to select a hero and show the hero&#x2019;s details</li>
<li>We learned how to use the built-in directives <code>ngIf</code> and <code>ngFor</code> in a component&#x2019;s template</li>
</ul><span>
</span><p>Run the <live-example></live-example> for this part.</p><span>
</span><h3 id="the-road-ahead">The Road Ahead</h3><span>
</span><p>Our Tour of Heroes has grown, but it&#x2019;s far from complete.
We can&apos;t put the entire app into a single component.
We need to break it up into sub-components and teach them to work together
as we learn in the <a href="https://angular.io/docs/ts/latest/tutorial/toh-pt3.html">next chapter</a>.</p><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!--NEXT PAGE HAS NOW BEEN SET--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--></div></div>
        </article>
      
        <article>
          <h3>Multiple Components</h3>
          <div><div class="showcase-content"><p>Our app is growing.
Use cases are flowing in for reusing components, passing data to components, and creating more reusable assets. Let&apos;s separate the heroes list from the hero details and make the details component reusable.</p><span>
</span><p>Run the <live-example></live-example> for this part.</p><span>
</span><h2 id="where-we-left-off">Where We Left Off</h2><span>
</span><p>Before we continue with our Tour of Heroes, let&#x2019;s verify we have the following structure. If not, we&#x2019;ll need to go back and follow the previous chapters.</p><span>
</span><div class="filetree"><p>angular2-tour-of-heroes</p><div class="children"><p>app</p><div class="children"><p>app.component.ts</p><p>app.module.ts</p><p>main.ts</p></div><p>node_modules ...</p><p>typings ...      </p><p>index.html</p><p>package.json</p><p>styles.css</p><p>systemjs.config.js</p><p>tsconfig.json</p><p>typings.json</p></div></div><h3 id="keep-the-app-transpiling-and-running">Keep the app transpiling and running</h3><span>
</span><p>We want to start the TypeScript compiler, have it watch for changes, and start our server. We&apos;ll do this by typing</p><span>
</span><code language="bash">npm start
</code><p>This will keep the application running while we continue to build the Tour of Heroes.</p><span>
</span><h2 id="making-a-hero-detail-component">Making a Hero Detail Component</h2><span>
</span><p>Our heroes list and our hero details are in the same component in the same file.
They&apos;re small now but each could grow. 
We are sure to receive new requirements for one and not the other.
Yet every change puts both components at risk and doubles the testing burden without benefit.
If we had to reuse the hero details elsewhere in our app,
the heroes list would tag along for the ride. </p><span>
</span><p>Our current component violates the 
<a href="https://blog.8thlight.com/uncle-bob/2014/05/08/SingleReponsibilityPrinciple.html">Single Responsibility Principle</a>.
It&apos;s only a tutorial but we can still do things right &#x2014; 
especially if doing them right is easy and we learn how to build Angular apps in the process.</p><span>
</span><p>Let&#x2019;s break the hero details out into its own component.</p><span>
</span><h3 id="separating-the-hero-detail-component">Separating the Hero Detail Component</h3><span>
</span><p>Add a new file named <code>hero-detail.component.ts</code> to the <code>app</code> folder and create <code>HeroDetailComponent</code> as follows.</p><span>
</span><p>app/hero-detail.component.ts (initial version)</p><code language="ts" format="">import { Component, Input } from &apos;@angular/core&apos;;

@Component({
  selector: &apos;my-hero-detail&apos;,
})
export class HeroDetailComponent {
}
</code><div class="l-sub-section"><h3 id="naming-conventions">Naming conventions</h3><span>
</span><p>We like to identify at a glance which classes are components and which files contain components. </p><span>
</span><p>Notice that  we have an <code>AppComponent</code> in a file named <code>app.component.ts</code> and our new
<code>HeroDetailComponent</code> is in a file named <code>hero-detail.component.ts</code>. </p><span>
</span><p>All of our component names end in &quot;Component&quot;.  All of our component file names end in &quot;.component&quot;.</p><span>
</span><p>We spell our file names in lower <strong><a href="https://angular.io/docs/ts/latest/guide/glossary.html#!#dash-case">dash case</a></strong> 
(AKA <strong><a href="https://angular.io/docs/ts/latest/guide/glossary.html#!#kebab-case">kebab-case</a></strong>) so we don&apos;t worry about
case sensitivity on the server or in source control.</p><span>
</span><!-- TODO
.l-sub-section
  :marked
    Learn more about naming conventions in the chapter [Naming Conventions]
:marked
--></div><p>We begin by importing the <code>Component</code> and <code>Input</code> decorators from Angular because we&apos;re going to need them soon.</p><span>
</span><p>We create metadata with the <code>@Component</code> decorator where we 
specify the selector name that identifies this component&apos;s element.
Then we export the class to make it available to other components.</p><span>
</span><p>When we finish here, we&apos;ll import it into <code>AppComponent</code> and create a corresponding <code>&lt;my-hero-detail&gt;</code>  element.</p><span>
</span><h4 id="hero-detail-template">Hero Detail Template</h4><span>
</span><p>At the moment, the <em>Heroes</em> and <em>Hero Detail</em> views are combined in one template in <code>AppComponent</code>.
Let&#x2019;s <strong>cut</strong> the <em>Hero Detail</em> content from <code>AppComponent</code> and <strong>paste</strong> it into the new template property of  <code>HeroDetailComponent</code>.</p><span>
</span><p>We previously bound to the <code>selectedHero.name</code> property of the <code>AppComponent</code>.
Our <code>HeroDetailComponent</code> will have a <code>hero</code> property, not a <code>selectedHero</code> property.
So we replace <code>selectedHero</code> with <code>hero</code> everywhere in our new template. That&apos;s our only change.
The result looks like this:</p><span>
</span><p>app/hero-detail.component.ts (template)</p><code language="ts" format="">template: `
  &lt;div *ngIf=&quot;hero&quot;&gt;
    &lt;h2&gt;{{hero.name}} details!&lt;/h2&gt;
    &lt;div&gt;&lt;label&gt;id: &lt;/label&gt;{{hero.id}}&lt;/div&gt;
    &lt;div&gt;
      &lt;label&gt;name: &lt;/label&gt;
      &lt;input [(ngModel)]=&quot;hero.name&quot; placeholder=&quot;name&quot;/&gt;
    &lt;/div&gt;
  &lt;/div&gt;
`
</code><p>Now our hero detail layout exists only in the <code>HeroDetailComponent</code>.</p><span>
</span><h4 id="add-the-hero-property">Add the <em>hero</em> property</h4><span>
</span><p>Let&#x2019;s add that <code>hero</code> property we were talking about to the component class.</p><span>
</span><code language="ts" format="">hero: Hero;
</code><p>Uh oh. We declared the <code>hero</code> property as type <code>Hero</code> but our <code>Hero</code> class is over in the <code>app.component.ts</code> file. 
We have two components, each in their own file, that need to reference the <code>Hero</code> class. </p><span>
</span><p>We solve the problem by relocating the <code>Hero</code> class from <code>app.component.ts</code> to its own <code>hero.ts</code> file.</p><span>
</span><p>app/hero.ts</p><code language="ts" format="">export class Hero {
  id: number;
  name: string;
}
</code><p>We export the <code>Hero</code> class from <code>hero.ts</code> because we&apos;ll need to reference it in both component files. 
Add the following import statement near the top of <strong>both <code>app.component.ts</code> and <code>hero-detail.component.ts</code></strong>.</p><span>
</span><code language="ts" format="">import { Hero } from &apos;./hero&apos;;
</code><h4 id="the-hero-property-is-an-input-">The <em>hero</em> property is an <strong><em>input</em></strong></h4><span>
</span><p>The <code>HeroDetailComponent</code> must be told what hero to display. Who will tell it? The parent <code>AppComponent</code>! </p><span>
</span><p>The <code>AppComponent</code> knows which hero to show: the hero that the user selected from the list. 
The user&apos;s selection is in its <code>selectedHero</code> property.</p><span>
</span><p>We will soon update the <code>AppComponent</code> template so that it binds its <code>selectedHero</code> property
to the <code>hero</code> property of our <code>HeroDetailComponent</code>. The binding <em>might</em> look like this:</p><span>
</span><code format=".">&lt;my-hero-detail [hero]=&quot;selectedHero&quot;&gt;&lt;/my-hero-detail&gt;</code><p>Notice that the <code>hero</code> property is the <strong><em>target</em></strong> of a property binding &#x2014; it&apos;s in square brackets to the left of the (=).</p><span>
</span><p>Angular insists that we declare a <strong><em>target</em></strong> property to be an <strong><em>input</em></strong> property.
If we don&apos;t, Angular rejects the binding and throws an error.</p><span>
</span><div class="l-sub-section"><p>We explain input properties in more detail <a href="https://angular.io/docs/ts/latest/guide/attribute-directives.html#why-input">here</a> 
where we also explain why <em>target</em> properties require this special treatment and 
<em>source</em> properties do not.</p><span>
</span></div><p>There are a couple of ways we can declare that <code>hero</code> is an <em>input</em>. 
We&apos;ll do it the way we <em>prefer</em>, by annotating the <code>hero</code> property with the <code>@Input</code> decorator that we imported earlier.</p><span>
</span><code language="ts" format="">  @Input()
  hero: Hero;
</code><h2 id="refresh-the-appmodule">Refresh the AppModule</h2><span>
</span><p>We return to the <code>AppModule</code>, the application&apos;s root module, and teach it to use the <code>HeroDetailComponent</code>.</p><span>
</span><p>We begin by importing the <code>HeroDetailComponent</code> so we can refer to it.</p><span>
</span><code language="ts" format="">import { HeroDetailComponent } from &apos;./hero-detail.component&apos;;
</code><p>Then we add <code>HeroDetailComponent</code> to the <code>NgModule</code> decorator&apos;s <code>declarations</code> array.
This array contains the list of all components, pipes, and directives that we created
and that belong in our application&apos;s module.</p><span>
</span><code language="ts" format="linenums">@NgModule({
  imports: [
    BrowserModule,
    FormsModule
  ],
  declarations: [
    AppComponent,
    HeroDetailComponent
  ],
  bootstrap: [ AppComponent ]
})
export class AppModule { }
</code><h2 id="refresh-the-appcomponent">Refresh the AppComponent</h2><span>
</span><p>Now that the application knows about our <code>HeroDetailComponent</code>, 
find the location in the <code>AppComponent</code> template where we removed the <em>Hero Detail</em> content
and add an element tag that represents the <code>HeroDetailComponent</code>.</p><span>
</span><code format=".">&lt;my-hero-detail&gt;&lt;/my-hero-detail&gt;</code><div class="l-sub-section"><p><em>my-hero-detail</em> is the name we set as the  <code>selector</code> in the <code>HeroDetailComponent</code> metadata.</p><span>
</span></div><p>The two components won&apos;t coordinate until we bind the <code>selectedHero</code> property of the <code>AppComponent</code> 
to the <code>HeroDetailComponent</code> element&apos;s <code>hero</code> property  like this:</p><span>
</span><code format=".">&lt;my-hero-detail [hero]=&quot;selectedHero&quot;&gt;&lt;/my-hero-detail&gt;</code><p>The <code>AppComponent</code>&#x2019;s template should now look like this</p><span>
</span><p>app.component.ts (template)</p><code language="ts" format="">template: `
  &lt;h1&gt;{{title}}&lt;/h1&gt;
  &lt;h2&gt;My Heroes&lt;/h2&gt;
  &lt;ul class=&quot;heroes&quot;&gt;
    &lt;li *ngFor=&quot;let hero of heroes&quot;
      [class.selected]=&quot;hero === selectedHero&quot;
      (click)=&quot;onSelect(hero)&quot;&gt;
      &lt;span class=&quot;badge&quot;&gt;{{hero.id}}&lt;/span&gt; {{hero.name}}
    &lt;/li&gt;
  &lt;/ul&gt;
  &lt;my-hero-detail [hero]=&quot;selectedHero&quot;&gt;&lt;/my-hero-detail&gt;
`,
</code><p>Thanks to the binding, the <code>HeroDetailComponent</code> should receive the hero from the <code>AppComponent</code> and display that hero&apos;s detail beneath the list.
The detail should update every time the user picks a new hero.</p><span>
</span><h3 id="it-works-">It works!</h3><span>
</span><p>When we view our app in the browser we see the list of heroes. 
When we select a hero we can see the selected hero&#x2019;s details. </p><span>
</span><p>What&apos;s fundamentally new is that we can use this <code>HeroDetailComponent</code>
to show hero details anywhere in the app.</p><span>
</span><p>We&#x2019;ve created our first reusable component!</p><span>
</span><h3 id="reviewing-the-app-structure">Reviewing the App Structure</h3><span>
</span><p>Let&#x2019;s verify that we have the following structure after all of our good refactoring in this chapter:</p><span>
</span><div class="filetree"><p>angular2-tour-of-heroes</p><div class="children"><p>app</p><div class="children"><p>app.component.ts</p><p>app.module.ts</p><p>hero.ts</p><p>hero-detail.component.ts</p><p>main.ts</p></div><p>node_modules ...</p><p>typings ...</p><p>index.html</p><p>package.json</p><p>tsconfig.json</p><p>typings.json</p></div></div><p>Here are the code files we discussed in this chapter.</p><span>
</span><code-tabs><code language="ts" name="app/hero-detail.component.ts" format="linenums">import { Component, Input } from &apos;@angular/core&apos;;

import { Hero } from &apos;./hero&apos;;

@Component({
  selector: &apos;my-hero-detail&apos;,
  template: `
    &lt;div *ngIf=&quot;hero&quot;&gt;
      &lt;h2&gt;{{hero.name}} details!&lt;/h2&gt;
      &lt;div&gt;&lt;label&gt;id: &lt;/label&gt;{{hero.id}}&lt;/div&gt;
      &lt;div&gt;
        &lt;label&gt;name: &lt;/label&gt;
        &lt;input [(ngModel)]=&quot;hero.name&quot; placeholder=&quot;name&quot;/&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  `
})
export class HeroDetailComponent {
  @Input()
  hero: Hero;
}
</code><code language="ts" name="app/app.component.ts" format="linenums">import { Component } from &apos;@angular/core&apos;;

import { Hero } from &apos;./hero&apos;;

const HEROES: Hero[] = [
  { id: 11, name: &apos;Mr. Nice&apos; },
  { id: 12, name: &apos;Narco&apos; },
  { id: 13, name: &apos;Bombasto&apos; },
  { id: 14, name: &apos;Celeritas&apos; },
  { id: 15, name: &apos;Magneta&apos; },
  { id: 16, name: &apos;RubberMan&apos; },
  { id: 17, name: &apos;Dynama&apos; },
  { id: 18, name: &apos;Dr IQ&apos; },
  { id: 19, name: &apos;Magma&apos; },
  { id: 20, name: &apos;Tornado&apos; }
];

@Component({
  selector: &apos;my-app&apos;,
  template: `
    &lt;h1&gt;{{title}}&lt;/h1&gt;
    &lt;h2&gt;My Heroes&lt;/h2&gt;
    &lt;ul class=&quot;heroes&quot;&gt;
      &lt;li *ngFor=&quot;let hero of heroes&quot;
        [class.selected]=&quot;hero === selectedHero&quot;
        (click)=&quot;onSelect(hero)&quot;&gt;
        &lt;span class=&quot;badge&quot;&gt;{{hero.id}}&lt;/span&gt; {{hero.name}}
      &lt;/li&gt;
    &lt;/ul&gt;
    &lt;my-hero-detail [hero]=&quot;selectedHero&quot;&gt;&lt;/my-hero-detail&gt;
  `,
  styles: [`
    .selected {
      background-color: #CFD8DC !important;
      color: white;
    }
    .heroes {
      margin: 0 0 2em 0;
      list-style-type: none;
      padding: 0;
      width: 15em;
    }
    .heroes li {
      cursor: pointer;
      position: relative;
      left: 0;
      background-color: #EEE;
      margin: .5em;
      padding: .3em 0;
      height: 1.6em;
      border-radius: 4px;
    }
    .heroes li.selected:hover {
      background-color: #BBD8DC !important;
      color: white;
    }
    .heroes li:hover {
      color: #607D8B;
      background-color: #DDD;
      left: .1em;
    }
    .heroes .text {
      position: relative;
      top: -3px;
    }
    .heroes .badge {
      display: inline-block;
      font-size: small;
      color: white;
      padding: 0.8em 0.7em 0 0.7em;
      background-color: #607D8B;
      line-height: 1em;
      position: relative;
      left: -1px;
      top: -4px;
      height: 1.8em;
      margin-right: .8em;
      border-radius: 4px 0 0 4px;
    }
  `]
})
export class AppComponent {
  title = &apos;Tour of Heroes&apos;;
  heroes = HEROES;
  selectedHero: Hero;

  onSelect(hero: Hero): void {
    this.selectedHero = hero;
  }
}
</code><code language="ts" name="app/hero.ts" format="linenums">export class Hero {
  id: number;
  name: string;
}
</code><code language="ts
  " name="app/app.module.ts" format="linenums">import { NgModule }      from &apos;@angular/core&apos;;
import { BrowserModule } from &apos;@angular/platform-browser&apos;;
import { FormsModule }   from &apos;@angular/forms&apos;;

import { AppComponent }  from &apos;./app.component&apos;;
import { HeroDetailComponent } from &apos;./hero-detail.component&apos;;

@NgModule({
  imports: [
    BrowserModule,
    FormsModule
  ],
  declarations: [
    AppComponent,
    HeroDetailComponent
  ],
  bootstrap: [ AppComponent ]
})
export class AppModule { }
</code></code-tabs><h2 id="the-road-we-ve-travelled">The Road We&#x2019;ve Travelled</h2><span>
</span><p>Let&#x2019;s take stock of what we&#x2019;ve built.</p><span>
</span><ul>
<li>We created a reusable component</li>
<li>We learned how to make a component accept input</li>
<li>We learned to declare the application directives we need in an Angular module. We
list the directives in the <code>NgModule</code> decorator&apos;s <code>declarations</code> array.</li>
<li>We learned to bind a parent component to a child component.</li>
</ul><span>
</span><p>Run the <live-example></live-example> for this part.</p><span>
</span><h2 id="the-road-ahead">The Road Ahead</h2><span>
</span><p>Our Tour of Heroes has become more reusable with shared components. </p><span>
</span><p>We&apos;re still getting our (mock) data within the <code>AppComponent</code>.
That&apos;s not sustainable. 
We should refactor data access to a separate service
and share it among the components that need data. </p><span>
</span><p>We&#x2019;ll learn to create services in the <a href="https://angular.io/docs/ts/latest/tutorial/toh-pt4.html">next tutorial</a> chapter.</p><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!--NEXT PAGE HAS NOW BEEN SET--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--></div></div>
        </article>
      
        <article>
          <h3>Services - ts</h3>
          <div><div class="showcase-content"><span>
</span><p>The Tour of Heroes is evolving and we anticipate adding more components in the near future.</p><span>
</span><p>Multiple components will need access to hero data and we don&apos;t want to copy and 
paste the same code over and over.
Instead, we&apos;ll create a single reusable data service and learn to
inject it in the components that need it.</p><span>
</span><p>Refactoring data access to a separate service keeps the component lean and focused on supporting the view.
It also makes it easier to unit test the component with a mock service.</p><span>
</span><p>Because data services are invariably asynchronous, 
we&apos;ll finish the chapter with a <strong>Promise</strong>-based version of the data service.</p><span>
</span><p>Run the <live-example></live-example> for this part.</p><span>
</span><h2 id="where-we-left-off">Where We Left Off</h2><span>
</span><p>Before we continue with our Tour of Heroes, let&#x2019;s verify we have the following structure. 
If not, we&#x2019;ll need to go back and follow the previous chapters.</p><span>
</span><div class="filetree"><p>angular2-tour-of-heroes</p><div class="children"><p>app</p><div class="children"><p>app.component.ts</p><p>app.module.ts</p><p>hero.ts</p><p>hero-detail.component.ts</p><p>main.ts</p></div><p>node_modules ...</p><p>typings ...</p><p>index.html</p><p>package.json</p><p>styles.css</p><p>systemjs.config.js</p><p>tsconfig.json</p><p>typings.json</p></div></div><h3 id="keep-the-app-transpiling-and-running">Keep the app transpiling and running</h3><span>
</span><p>Open a terminal/console window. 
Start the TypeScript compiler, watch for changes, and start our server by entering the command:</p><span>
</span><code language="bash">npm start
</code><p>The application runs and updates automatically as we continue to build the Tour of Heroes.</p><span>
</span><h2 id="creating-a-hero-service">Creating a Hero Service</h2><span>
</span><p>Our stakeholders have shared their larger vision for our app. 
They tell us they want to show the heroes in various ways on different pages. 
We already can select a hero from a list.
Soon we&apos;ll add a dashboard with the top performing heroes and create a separate view for editing hero details.
All three views need hero data. </p><span>
</span><p>At the moment the <code>AppComponent</code> defines mock heroes for display.
We have at least two objections.
First, defining heroes is not the component&apos;s job. 
Second, we can&apos;t easily share that list of heroes with other components and views. </p><span>
</span><p>We can refactor this hero data acquisition business to a single service that provides heroes, and 
share that service with all components that need heroes.</p><span>
</span><h3 id="create-the-heroservice">Create the HeroService</h3><span>
</span><p>Create a file in the <code>app</code> folder called <code>hero.service.ts</code>. </p><span>
</span><div class="l-sub-section"><p>We&apos;ve adopted a convention in which we spell the name of a service in lowercase followed by <code>.service</code>.
If the service name were multi-word, we&apos;d spell the base filename in lower <a href="https://angular.io/docs/ts/latest/guide/glossary.html#!#dash-case">dash-case</a>.
The <code>SpecialSuperHeroService</code> would be defined in the <code>special-super-hero.service.ts</code> file.</p><span>
</span></div><p>We name the class <code>HeroService</code> and export it for others to import.</p><span>
</span><p>app/hero.service.ts (starting point)</p><code language="ts" format="">import { Injectable } from &apos;@angular/core&apos;;

@Injectable()
export class HeroService {
}
</code><h3 id="injectable-services">Injectable Services</h3><span>
</span><p>Notice that we imported the Angular <code>Injectable</code> function and applied that function as an <code>@Injectable()</code> decorator.</p><span>
</span><div class="callout is-helpful"><p><strong>Don&apos;t forget the parentheses!</strong> Neglecting them leads to an error that&apos;s difficult to diagnose.</p><span>
</span></div><p>TypeScript sees the <code>@Injectable()</code> decorator and emits metadata about our service, 
metadata that Angular may need to inject other dependencies into this service.</p><span>
</span><p>The <code>HeroService</code> doesn&apos;t have any dependencies <em>at the moment</em>. Add the decorator anyway.
It is a &quot;best practice&quot; to apply the <code>@Injectable()</code> decorator &#x200B;<em>from the start</em>&#x200B; 
both for consistency and for future-proofing.</p><span>
</span><h3 id="getting-heroes">Getting Heroes</h3><span>
</span><p>Add a <code>getHeroes</code> method stub.</p><span>
</span><p>app/hero.service.ts (getHeroes stub)</p><code language="ts" format="">@Injectable()
export class HeroService {
  getHeroes(): void {} // stub
}
</code><p>We&apos;re holding back on the implementation for a moment to make an important point.</p><span>
</span><p>The consumer of our service doesn&apos;t know how the service gets the data. 
Our <code>HeroService</code> could get <code>Hero</code> data from anywhere. 
It could get the data from a web service or local storage
or from a mock data source.</p><span>
</span><p>That&apos;s the beauty of removing data access from the component.
We can change our minds about the implementation as often as we like,
for whatever reason, without touching any of the components that need heroes.</p><span>
</span><h3 id="mock-heroes">Mock Heroes</h3><span>
</span><p>We already have mock <code>Hero</code> data sitting in the <code>AppComponent</code>.  It doesn&apos;t belong there. It doesn&apos;t belong <em>here</em> either.
We&apos;ll move the mock data to its own file.</p><span>
</span><p>Cut the <code>HEROES</code> array from <code>app.component.ts</code> and paste it to a new file in the <code>app</code> folder named <code>mock-heroes.ts</code>.
We copy the <code>import {Hero} ...</code> statement as well because the heroes array uses the <code>Hero</code> class.</p><span>
</span><p>app/mock-heroes.ts</p><code language="ts" format="linenums">import { Hero } from &apos;./hero&apos;;

export const HEROES: Hero[] = [
  {id: 11, name: &apos;Mr. Nice&apos;},
  {id: 12, name: &apos;Narco&apos;},
  {id: 13, name: &apos;Bombasto&apos;},
  {id: 14, name: &apos;Celeritas&apos;},
  {id: 15, name: &apos;Magneta&apos;},
  {id: 16, name: &apos;RubberMan&apos;},
  {id: 17, name: &apos;Dynama&apos;},
  {id: 18, name: &apos;Dr IQ&apos;},
  {id: 19, name: &apos;Magma&apos;},
  {id: 20, name: &apos;Tornado&apos;}
];
</code><p>We export the <code>HEROES</code> constant so we can import it elsewhere &#x2014; such as our <code>HeroService</code>.</p><span>
</span><p>Meanwhile, back in <code>app.component.ts</code> where we cut away the <code>HEROES</code> array, 
we leave behind an uninitialized <code>heroes</code> property:</p><span>
</span><p>app/app.component.ts (heroes property)</p><code language="ts" format="">heroes: Hero[];
</code><h3 id="return-mocked-heroes">Return Mocked Heroes</h3><span>
</span><p>Back in the <code>HeroService</code>  we import the mock <code>HEROES</code> and return it from the <code>getHeroes</code> method.
Our <code>HeroService</code> looks like this:</p><span>
</span><p>app/hero.service.ts</p><code language="ts" format="">import { Injectable } from &apos;@angular/core&apos;;

import { Hero } from &apos;./hero&apos;;
import { HEROES } from &apos;./mock-heroes&apos;;

@Injectable()
export class HeroService {
  getHeroes(): Hero[] {
    return HEROES;
  }
}
</code><h3 id="use-the-hero-service">Use the Hero Service</h3><span>
</span><p>We&apos;re ready to use the <code>HeroService</code> in other components starting with our <code>AppComponent</code>.</p><span>
</span><p>We begin, as usual, by importing the thing we want to use, the <code>HeroService</code>.</p><span>
</span><code language="ts" format="">import { HeroService } from &apos;./hero.service&apos;;
</code><p>Importing the service allows us to <em>reference</em> it in our code. 
How should the <code>AppComponent</code> acquire a runtime concrete <code>HeroService</code> instance?</p><span>
</span><h3 id="do-we-new-the-heroservice-no-way-">Do we <em>new</em> the <em>HeroService</em>? No way!</h3><span>
</span><p>We could create a new instance  of the <code>HeroService</code> with <code>new</code> like this:</p><span>
</span><code language="ts" format="">heroService = new HeroService(); // don&apos;t do this
</code><p>That&apos;s a bad idea for several reasons including</p><span>
</span><ul>
<li><p>Our component has to know how to create a <code>HeroService</code>. 
If we ever change the <code>HeroService</code> constructor, 
we&apos;ll have to find every place we create the service and fix it.
Running around patching code is error prone and adds to the test burden.</p>
</li>
<li><p>We create a new service each time we use <code>new</code>. 
What if the service should cache heroes and share that cache with others?
We couldn&apos;t do that.</p>
</li>
<li><p>We&apos;re locking the <code>AppComponent</code> into a specific implementation of the <code>HeroService</code>.
It will be hard to switch implementations for different scenarios.
Can we operate offline? 
Will we need different mocked versions under test?
Not easy.</p>
</li>
</ul><span>
</span><p><em>What if ... what if ... Hey, we&apos;ve got work to do!</em></p><span>
</span><p>We get it. Really we do. 
But it is so ridiculously easy to avoid these problems that there is no excuse for doing it wrong.</p><span>
</span><h3 id="inject-the-heroservice-">Inject the <em>HeroService</em></h3><span>
</span><p>Two lines replace the one line that created with <em>new</em>:</p><span>
</span><ol>
<li>We add a constructor that also defines a private property.</li>
<li>We add to the component&apos;s <code>providers</code> metadata.</li>
</ol><span>
</span><p>Here&apos;s the constructor:</p><span>
</span><p>app/app.component.ts (constructor)</p><code language="ts" format="">constructor(private heroService: HeroService) { }
</code><p>The constructor itself does nothing. The parameter simultaneously 
defines a private <code>heroService</code> property and identifies it as a <code>HeroService</code> injection site.</p><span>
</span><p>Now Angular will know to supply an instance of the <code>HeroService</code> when it creates a new <code>AppComponent</code>. </p><span>
</span><p>The <em>injector</em> does not know yet how to create a <code>HeroService</code>. 
If we ran our code now, Angular would fail with an error:</p><span>
</span><code format="nocode">EXCEPTION: No provider for HeroService! (AppComponent -&gt; HeroService)</code><p>We have to teach the <em>injector</em> how to make a <code>HeroService</code> by registering a <code>HeroService</code> <strong>provider</strong>.
Do that by adding the following <code>providers</code> array property to the bottom of the component metadata
in the <code>@Component</code> call.</p><span>
</span><code language="ts" format="">providers: [HeroService]
</code><p>The <code>providers</code> array  tells Angular to create a fresh instance of the <code>HeroService</code> when it creates a new <code>AppComponent</code>.
The <code>AppComponent</code> can use that service to get heroes and so can every child component of its component tree.</p><span>
</span><a id="child-component"></a><h3 id="-getheroes-in-the-appcomponent-"><em>getHeroes</em> in the <em>AppComponent</em></h3><span>
</span><p>We&apos;ve got the service in a <code>heroService</code> private variable. Let&apos;s use it.</p><span>
</span><p>We pause to think. We can call the service and get the data in one line.</p><span>
</span><code language="ts" format="">this.heroes = this.heroService.getHeroes();
</code><p>We don&apos;t really need a dedicated method to wrap one line.  We write it anyway:</p><span>
</span><code language="ts" format="">  getHeroes(): void {
    this.heroes = this.heroService.getHeroes();
  }
</code><a id="oninit"></a><h3 id="the-ngoninit-lifecycle-hook">The <em>ngOnInit</em> Lifecycle Hook</h3><span>
</span><p><code>AppComponent</code> should fetch and display heroes without a fuss.
Where do we call the <code>getHeroes</code> method? In a constructor? We do <em>not</em>!</p><span>
</span><p>Years of experience and bitter tears have taught us to keep complex logic out of the constructor,
especially anything that might call a server as a data access method is sure to do.</p><span>
</span><p>The constructor is for simple initializations like wiring constructor parameters to properties.
It&apos;s not for heavy lifting. We should be able to create a component in a test and not worry that it 
might do real work &#x2014; like calling a server!  &#x2014; before we tell it to do so.</p><span>
</span><p>If not the constructor, something has to call <code>getHeroes</code>.</p><span>
</span><p>Angular will call it if we implement the Angular <strong>ngOnInit</strong> <em>Lifecycle Hook</em>.
Angular offers a number of interfaces for tapping into critical moments in the component lifecycle:
at creation, after each change, and at its eventual destruction.</p><span>
</span><p>Each interface has a single method. When the component implements that method, Angular calls it at the appropriate time.</p><span>
</span><p>Here&apos;s the essential outline for the <code>OnInit</code> interface:</p><span>
</span><p>app/app.component.ts (ngOnInit stub)</p><code language="ts" format="">import { OnInit } from &apos;@angular/core&apos;;

export class AppComponent implements OnInit {
  ngOnInit(): void {
  }
}
</code><p>We write an <code>ngOnInit</code> method with our initialization logic inside and leave it to Angular to call it
at the right time. In our case, we initialize by calling <code>getHeroes</code>.</p><span>
</span><code language="ts" format="">  ngOnInit(): void {
    this.getHeroes();
  }
</code><p>Our application should be running as expected, showing a list of heroes and a hero detail view
when we click on a hero name.</p><span>
</span><p>We&apos;re getting closer. But something isn&apos;t quite right.</p><span>
</span><span>
</span><h2 id="async-services-and-_promise-s">Async Services and Promises</h2><span>
</span><p>Our <code>HeroService</code> returns a list of mock heroes immediately. 
Its <code>getHeroes</code> signature is synchronous</p><span>
</span><code language="ts" format="">this.heroes = this.heroService.getHeroes();
</code><p>Ask for heroes and they are there in the returned result.</p><span>
</span><p>Someday we&apos;re going to get heroes from a remote server. We don&#x2019;t call http yet, but we aspire to in later chapters.</p><span>
</span><p>When we do, we&apos;ll have to wait for the server to respond and we won&apos;t be able to block the UI while we wait, 
even if we want to (which we shouldn&apos;t) because the browser won&apos;t block.</p><span>
</span><p>We&apos;ll have to use some kind of asynchronous technique and that will change the signature of our <code>getHeroes</code> method.</p><span>
</span><p>We&apos;ll use <em>Promises</em>.</p><span>
</span><h3 id="the-hero-service-makes-a-_promise-">The Hero Service makes a Promise</h3><span>
</span><p>A <strong>Promise</strong> is ... well it&apos;s a promise to call us back later when the results are ready. 
We ask an asynchronous service to do some work and give it a callback function. 
It does that work (somewhere) and eventually it calls our function with the results of the work or an error.</p><span>
</span><div class="l-sub-section"><p>We are simplifying. Learn about ES2015 Promises <a href="http://exploringjs.com/es6/ch_promises.html">here</a> and elsewhere on the web.</p><span>
</span></div><p>Update the <code>HeroService</code> with this Promise-returning <code>getHeroes</code> method:</p><span>
</span><p>app/hero.service.ts (excerpt)</p><code language="ts" format="">getHeroes(): Promise&lt;Hero[]&gt; {
  return Promise.resolve(HEROES);
}
</code><p>We&apos;re still mocking the data. We&apos;re simulating the behavior of an ultra-fast, zero-latency server,
by returning an <strong>immediately resolved Promise</strong> with our mock heroes as the result.</p><span>
</span><h3 id="act-on-the-_promise-">Act on the Promise</h3><span>
</span><p>Returning to the <code>AppComponent</code> and its <code>getHeroes</code> method, we see that it still looks like this:</p><span>
</span><p>app/app.component.ts (getHeroes - old)</p><code language="ts" format="">  getHeroes(): void {
    this.heroes = this.heroService.getHeroes();
  }
</code><p>As a result of our change to <code>HeroService</code>, we&apos;re now setting <code>this.heroes</code> to a Promise rather than an array of heroes. </p><span>
</span><p>We have to change our implementation to <em>act on the Promise when it resolves</em>.
When the Promise resolves successfully, <em>then</em> we will have heroes to display.</p><span>
</span><p>We pass our callback function as an argument to the Promise&apos;s <strong>then</strong> method:</p><span>
</span><p>app/app.component.ts (getHeroes - revised)</p><code language="ts" format="">getHeroes(): void {
  this.heroService.getHeroes().then(heroes =&gt; this.heroes = heroes);
}
</code><div class="l-sub-section"><p>The <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions">ES2015 arrow function</a>
in the callback is more succinct than the equivalent function expression and gracefully handles <em>this</em>.</p><span>
</span></div><p>Our callback sets the component&apos;s <code>heroes</code> property to the array of heroes returned by the service. That&apos;s all there is to it!</p><span>
</span><p>Our app should still be running, still showing a list of heroes, and still
responding to a name selection with a detail view.</p><span>
</span><div class="l-sub-section"><p>Checkout the &quot;<a href="https://angular.io/docs/ts/latest/tutorial/toh-pt4.html#slow">Take it slow</a>&quot; appendix to see what the app might be like with a poor connection.</p><span>
</span></div><h3 id="review-the-app-structure">Review the App Structure</h3><span>
</span><p>Let&#x2019;s verify that we have the following structure after all of our good refactoring in this chapter:</p><span>
</span><div class="filetree"><p>angular2-tour-of-heroes</p><div class="children"><p>app</p><div class="children"><p>app.component.ts</p><p>app.module.ts</p><p>hero.ts</p><p>hero-detail.component.ts</p><p>hero.service.ts</p><p>main.ts      </p><p>mock-heroes.ts</p></div><p>node_modules ...</p><p>typings ...      </p><p>index.html</p><p>package.json</p><p>styles.css</p><p>systemjs.config.js</p><p>tsconfig.json</p><p>typings.json</p></div></div><p>Here are the code files we discussed in this chapter.</p><span>
</span><code-tabs><code language="ts" name="app/hero.service.ts" format="linenums">import { Injectable } from &apos;@angular/core&apos;;

import { Hero } from &apos;./hero&apos;;
import { HEROES } from &apos;./mock-heroes&apos;;

@Injectable()
export class HeroService {
  getHeroes(): Promise&lt;Hero[]&gt; {
    return Promise.resolve(HEROES);
  }
}
</code><code language="ts" name="app/app.component.ts" format="linenums">import { Component, OnInit } from &apos;@angular/core&apos;;

import { Hero } from &apos;./hero&apos;;
import { HeroService } from &apos;./hero.service&apos;;

@Component({
  selector: &apos;my-app&apos;,
  template: `
    &lt;h1&gt;{{title}}&lt;/h1&gt;
    &lt;h2&gt;My Heroes&lt;/h2&gt;
    &lt;ul class=&quot;heroes&quot;&gt;
      &lt;li *ngFor=&quot;let hero of heroes&quot;
        [class.selected]=&quot;hero === selectedHero&quot;
        (click)=&quot;onSelect(hero)&quot;&gt;
        &lt;span class=&quot;badge&quot;&gt;{{hero.id}}&lt;/span&gt; {{hero.name}}
      &lt;/li&gt;
    &lt;/ul&gt;
    &lt;my-hero-detail [hero]=&quot;selectedHero&quot;&gt;&lt;/my-hero-detail&gt;
  `,
  styles: [`
    .selected {
      background-color: #CFD8DC !important;
      color: white;
    }
    .heroes {
      margin: 0 0 2em 0;
      list-style-type: none;
      padding: 0;
      width: 15em;
    }
    .heroes li {
      cursor: pointer;
      position: relative;
      left: 0;
      background-color: #EEE;
      margin: .5em;
      padding: .3em 0;
      height: 1.6em;
      border-radius: 4px;
    }
    .heroes li.selected:hover {
      background-color: #BBD8DC !important;
      color: white;
    }
    .heroes li:hover {
      color: #607D8B;
      background-color: #DDD;
      left: .1em;
    }
    .heroes .text {
      position: relative;
      top: -3px;
    }
    .heroes .badge {
      display: inline-block;
      font-size: small;
      color: white;
      padding: 0.8em 0.7em 0 0.7em;
      background-color: #607D8B;
      line-height: 1em;
      position: relative;
      left: -1px;
      top: -4px;
      height: 1.8em;
      margin-right: .8em;
      border-radius: 4px 0 0 4px;
    }
  `],
  providers: [HeroService]
})
export class AppComponent implements OnInit {
  title = &apos;Tour of Heroes&apos;;
  heroes: Hero[];
  selectedHero: Hero;

  constructor(private heroService: HeroService) { }

  getHeroes(): void {
    this.heroService.getHeroes().then(heroes =&gt; this.heroes = heroes);
  }

  ngOnInit(): void {
    this.getHeroes();
  }

  onSelect(hero: Hero): void {
    this.selectedHero = hero;
  }
}
</code><code language="ts
  " name="app/mock-heroes.ts" format="linenums">import { Hero } from &apos;./hero&apos;;

export const HEROES: Hero[] = [
  {id: 11, name: &apos;Mr. Nice&apos;},
  {id: 12, name: &apos;Narco&apos;},
  {id: 13, name: &apos;Bombasto&apos;},
  {id: 14, name: &apos;Celeritas&apos;},
  {id: 15, name: &apos;Magneta&apos;},
  {id: 16, name: &apos;RubberMan&apos;},
  {id: 17, name: &apos;Dynama&apos;},
  {id: 18, name: &apos;Dr IQ&apos;},
  {id: 19, name: &apos;Magma&apos;},
  {id: 20, name: &apos;Tornado&apos;}
];
</code></code-tabs><h2 id="the-road-we-ve-travelled">The Road We&#x2019;ve Travelled</h2><span>
</span><p>Let&#x2019;s take stock of what we&#x2019;ve built.</p><span>
</span><ul>
<li>We created a service class that can be shared by many components.</li>
<li>We used the <code>ngOnInit</code> Lifecycle Hook to get our heroes when our <code>AppComponent</code> activates.</li>
<li>We defined our <code>HeroService</code> as a provider for our <code>AppComponent</code>.</li>
<li>We created mock hero data and imported them into our service.</li>
<li>We designed our service to return a Promise and our component to get our data from the Promise.</li>
</ul><span>
</span><p>Run the <live-example></live-example> for this part.</p><span>
</span><h3 id="the-road-ahead">The Road Ahead</h3><span>
</span><p>Our Tour of Heroes has become more reusable using shared components and services.
We want to create a dashboard, add menu links that route between the views, and format data in a template.
As our app evolves, we&#x2019;ll learn how to design it to make it easier to grow and maintain.</p><span>
</span><p>We learn about Angular Component Router and navigation among the views in the <a href="https://angular.io/docs/ts/latest/tutorial/toh-pt5.html">next tutorial</a> chapter.</p><span>
</span><a id="slow"></a><h3 id="appendix-take-it-slow">Appendix: Take it slow</h3><span>
</span><p>We can simulate a slow connection.</p><span>
</span><p>Import the <code>Hero</code> symbol and add the following <code>getHeroesSlowly</code> method to the <code>HeroService</code></p><span>
</span><p>app/hero.service.ts (getHeroesSlowly)</p><code language="ts" format="">getHeroesSlowly(): Promise&lt;Hero[]&gt; {
  return new Promise&lt;Hero[]&gt;(resolve =&gt;
    setTimeout(resolve, 2000)) // delay 2 seconds
    .then(() =&gt; this.getHeroes());
}
</code><p>Like <code>getHeroes</code>, it also returns a Promise. 
But this Promise waits 2 seconds before resolving the Promise with mock heroes.</p><span>
</span><p>Back in the <code>AppComponent</code>, replace <code>heroService.getHeroes</code> with <code>heroService.getHeroesSlowly</code>
and see how the app behaves.</p><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!--NEXT PAGE HAS NOW BEEN SET--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--></div></div>
        </article>
      
        <article>
          <h3>Routing - ts</h3>
          <div><div class="showcase-content"><span>
</span><p>We received new requirements for our Tour of Heroes application:</p><span>
</span><ul>
<li>Add a <em>Dashboard</em> view.</li>
<li>Navigate between the <em>Heroes</em> and <em>Dashboard</em> views.</li>
<li>Clicking on a hero in either view navigates to a detail view of the selected hero.</li>
<li>Clicking a <em>deep link</em> in an email opens the detail view for a particular hero.</li>
</ul><span>
</span><p>When we&#x2019;re done, users will be able to navigate the app like this:</p><span>
</span><figure class="image-display"><img src="https://angular.io/resources/images/devguide/toh/nav-diagram.png" alt="View navigations"></figure><p>We&apos;ll add Angular&#x2019;s <em>Component Router</em> to our app to satisfy these requirements.</p><span>
</span><p>Run the <live-example></live-example> for this part.</p><span>
</span><div class="l-sub-section"><img src="https://angular.io/resources/images/devguide/plunker-separate-window-button.png" alt="pop out the window" align="right"><p>To see the URL changes in the browser address bar,
pop out the preview window by clicking the blue &apos;X&apos; button in the upper right corner:</p><span>
</span></div><h2 id="where-we-left-off">Where We Left Off</h2><span>
</span><p>Before we continue with our Tour of Heroes, let&#x2019;s verify that
we have the following structure after adding our hero service
and hero detail component. If not, we&#x2019;ll need to go back and follow the previous chapters.</p><span>
</span><div class="filetree"><p>angular2-tour-of-heroes</p><div class="children"><p>app</p><div class="children"><p>app.component.ts</p><p>app.module.ts</p><p>hero.service.ts</p><p>hero.ts</p><p>hero-detail.component.ts</p><p>main.ts</p><p>mock-heroes.ts</p></div><p>node_modules ...</p><p>typings ...</p><p>index.html</p><p>package.json</p><p>styles.css</p><p>systemjs.config.js</p><p>tsconfig.json</p><p>typings.json</p></div></div><h3 id="keep-the-app-transpiling-and-running">Keep the app transpiling and running</h3><span>
</span><p>Open a terminal/console window and enter the following command to
start the TypeScript compiler, start the server, and watch for changes:</p><span>
</span><code language="bash">npm start
</code><p>The application runs and updates automatically as we continue to build the Tour of Heroes.</p><span>
</span><h2 id="action-plan">Action plan</h2><span>
</span><p>Here&apos;s our plan:</p><span>
</span><ul>
<li>Turn <code>AppComponent</code> into an application shell that only handles navigation</li>
<li>Relocate the <em>Heroes</em> concerns within the current <code>AppComponent</code> to a separate <code>HeroesComponent</code></li>
<li>Add routing</li>
<li>Create a new <code>DashboardComponent</code></li>
<li>Tie the <em>Dashboard</em> into the navigation structure</li>
</ul><span>
</span><div class="l-sub-section"><p><em>Routing</em> is another name for <em>navigation</em>. The <em>router</em> is the mechanism for navigating from view to view.</p><span>
</span></div><h2 id="splitting-the-appcomponent-">Splitting the <em>AppComponent</em></h2><span>
</span><p>Our current app loads <code>AppComponent</code> and immediately displays the list of heroes.</p><span>
</span><p>Our revised app should present a shell with a choice of views (<em>Dashboard</em> and <em>Heroes</em>)
and then default to one of them.</p><span>
</span><p>The <code>AppComponent</code> should only handle navigation.
Let&apos;s move the display of <em>Heroes</em> out of <code>AppComponent</code> and into its own <code>HeroesComponent</code>.</p><span>
</span><h3 id="-heroescomponent-"><em>HeroesComponent</em></h3><span>
</span><p><code>AppComponent</code> is already dedicated to <em>Heroes</em>.
Instead of moving anything out of <code>AppComponent</code>, we&apos;ll just rename it <code>HeroesComponent</code>
and create a new <code>AppComponent</code> shell separately.</p><span>
</span><p>The steps are to rename:</p><span>
</span><ul>
<li><span ngio-ex="">app.component.ts</span> file to <span ngio-ex="">heroes.component.ts</span></li>
<li><code>AppComponent</code> class to <code>HeroesComponent</code></li>
<li>Selector <code>my-app</code> to <code>my-heroes</code></li>
</ul><span>
</span><p>app/heroes.component.ts (showing renamings only)</p><code language="ts" format="">@Component({
  selector: &apos;my-heroes&apos;,
})
export class HeroesComponent implements OnInit {
}
</code><h2 id="create-appcomponent-">Create <em>AppComponent</em></h2><span>
</span><p>The new <code>AppComponent</code> will be the application shell.
It will have some navigation links at the top and a display area below for the pages we navigate to.</p><span>
</span><p>The initial steps are:</p><span>
</span><ul>
<li>Create the file <span ngio-ex="">app/app.component.ts</span>.</li>
<li>Define an <span if-docs="ts">exported</span> <code>AppComponent</code> class.</li>
<li>Add an <code>@Component</code> decorator above the class with a <code>my-app</code> selector.</li>
<li>Move the following from <code>HeroesComponent</code> to <code>AppComponent</code>:<ul>
<li><code>title</code> class property</li>
<li><code>@Component</code> template <code>&lt;h1&gt;</code> element, which contains a binding to  <code>title</code></li>
</ul>
</li>
<li>Add a <code>&lt;my-heroes&gt;</code> element to the app template just below the heading so we still see the heroes.</li>
<li>Add <code>HeroesComponent</code> to the <code>declarations</code> array of <code>AppModule</code> so Angular recognizes the <code>&lt;my-heroes&gt;</code> tags.</li>
<li>Add <code>HeroService</code> to the  <code>providers</code> array of <code>AppModule</code> because we&apos;ll need it in every other view.</li>
<li>Remove <code>HeroService</code> from the <code>HeroesComponent</code> <code>providers</code> array since it has been promoted.</li>
<li>Add the supporting <code>import</code> statements for <code>AppComponent</code>.</li>
</ul><span>
</span><p>Our first draft looks like this:</p><span>
</span><code-tabs><code language="ts" name="app/app.component.ts (v1)" format="linenums">import { Component } from &apos;@angular/core&apos;;

@Component({
  selector: &apos;my-app&apos;,
  template: `
    &lt;h1&gt;{{title}}&lt;/h1&gt;
    &lt;my-heroes&gt;&lt;/my-heroes&gt;
  `
})
export class AppComponent {
  title = &apos;Tour of Heroes&apos;;
}
</code><code language="ts" name="app/app.module.ts (v1)" format="linenums">import { NgModule }       from &apos;@angular/core&apos;;
import { BrowserModule }  from &apos;@angular/platform-browser&apos;;
import { FormsModule }    from &apos;@angular/forms&apos;;

import { AppComponent }        from &apos;./app.component&apos;;
import { HeroDetailComponent } from &apos;./hero-detail.component&apos;;
import { HeroesComponent }     from &apos;./heroes.component&apos;;
import { HeroService }         from &apos;./hero.service&apos;;

@NgModule({
  imports: [
    BrowserModule,
    FormsModule
  ],
  declarations: [
    AppComponent,
    HeroDetailComponent,
    HeroesComponent
  ],
  providers: [
    HeroService
  ],
  bootstrap: [ AppComponent ]
})
export class AppModule {
}
</code></code-tabs><p>The app still runs and still displays heroes.
Our refactoring of <code>AppComponent</code> into a new <code>AppComponent</code> and a <code>HeroesComponent</code> worked!
We have done no harm.</p><span>
</span><h2 id="add-routing">Add Routing</h2><span>
</span><p>We&apos;re ready to take the next step.
Instead of displaying heroes automatically, we&apos;d like to show them <em>after</em> the user clicks a button.
In other words, we&apos;d like to navigate to the list of heroes.</p><span>
</span><p>We&apos;ll need the Angular <em>Component Router</em>.</p><span>
</span><p>The Angular router is an external, optional Angular NgModule called <code>RouterModule</code>.
The router is a combination of multiple provided services (<code>RouterModule</code>),
multiple directives (<code>RouterOutlet, RouterLink, RouterLinkActive</code>),
and a configuration (<code>Routes</code>). We&apos;ll configure our routes first.</p><span>
</span><h3 id="add-the-base-tag">Add the base tag</h3><span>
</span><p>Open <code>index.html</code> and add <code>&lt;base href=&quot;/&quot;&gt;</code> at the top of the <code>&lt;head&gt;</code> section.</p><span>
</span><p>index.html (base-href)</p><code language="html" format="">&lt;head&gt;
  &lt;base href=&quot;/&quot;&gt;
</code><div class="callout is-important"><header>base href is essential</header><p>See the <em>base href</em> section of the <a href="https://angular.io/docs/ts/latest/guide/router.html#!#base-href">Router</a>
chapter to learn why this matters.</p><span>
</span></div><a id="configure-routes"></a><h3 id="configure-routes">Configure routes</h3><span>
</span><p>Our application doesn&apos;t have any routes yet.
We&apos;ll start by creating a configuration file for the application routes.</p><span>
</span><p><em>Routes</em> tell the router which views to display when a user clicks a link or
pastes a URL into the browser address bar.</p><span>
</span><p>Let&apos;s define our first route as a route to the heroes component:</p><span>
</span><p>app/app.routing.ts (heroes route)</p><code language="ts" format="">import { ModuleWithProviders }  from &apos;@angular/core&apos;;
import { Routes, RouterModule } from &apos;@angular/router&apos;;

import { HeroesComponent }      from &apos;./heroes.component&apos;;

const appRoutes: Routes = [
  {
    path: &apos;heroes&apos;,
    component: HeroesComponent
  }
];
</code><p>The <code>Routes</code> are an array of <em>route definitions</em>.
We have only one route definition at the moment but rest assured, we&apos;ll add more.</p><span>
</span><p>This <em>route definition</em> has the following parts:</p><span>
</span><ul>
<li><strong>path</strong>: the router matches this route&apos;s path to the URL in the browser address bar (<code>heroes</code>).</li><li if-docs="dart"> <strong>name</strong>: the official name of the route;
it <em>must</em> begin with a capital letter to avoid confusion with the <em>path</em> (<code>Heroes</code>).</li>
<li><strong>component</strong>: the component that the router should create when navigating to this route (<code>HeroesComponent</code>).</li>
</ul><span>
</span><div class="l-sub-section"><p>Learn more about defining routes with <code>Routes</code> in the <a href="https://angular.io/docs/ts/latest/guide/router.html">Routing</a> chapter.</p><span>
</span></div><p>We&apos;ll export a <code>routing</code> constant initialized using the <code>RouterModule.forRoot</code> method applied to our array of routes.
This method returns a <strong>configured router module</strong> that we&apos;ll add to our root NgModule, <code>AppModule</code>.</p><span>
</span><p>app/app.routing.ts (excerpt)</p><code language="ts" format="">export const routing: ModuleWithProviders = RouterModule.forRoot(appRoutes);
</code><div class="l-sub-section"><p>We call the <code>forRoot</code> method because we&apos;re providing a configured router at the <em>root</em> of the application.
The <code>forRoot</code> method gives us the Router service providers and directives needed for routing.</p><span>
</span></div><h3 id="make-the-router-available">Make the router available</h3><span>
</span><p>We&apos;ve setup initial routes in the <code>app.routing.ts</code> file. Now we&apos;ll add it to our root NgModule.</p><span>
</span><p>Import the <code>routing</code> constant from <code>app.routing.ts</code> and add it the <code>imports</code> array of <code>AppModule</code>.</p><span>
</span><p>app/app.module.ts (routing)</p><code language="ts" format="">import { routing } from &apos;./app.routing&apos;;

@NgModule({
  imports: [
    BrowserModule,
    FormsModule,
    routing
  ],
})
export class AppModule {
}
</code><h3 id="router-outlet">Router Outlet</h3><span>
</span><p>If we paste the path, <code>/heroes</code>, into the browser address bar,
the router should match it to the <code>heroes</code> route and display the <code>HeroesComponent</code>.
But where?</p><span>
</span><p>We have to <strong><em>tell it where</em></strong> by adding a <code>&lt;router-outlet&gt;</code> element to the bottom of the template.
<code>RouterOutlet</code> is one of the <span if-docs="ts">directives provided by</span> the <code>RouterModule</code>.
The router displays each component immediately below the <code>&lt;router-outlet&gt;</code> as we navigate through the application.</p><span>
</span><span>
</span><p>We don&apos;t really expect users to paste a route URL into the address bar.
We add an anchor tag to the template which, when clicked, triggers navigation to the <code>HeroesComponent</code>.</p><span>
</span><p>The revised template looks like this:</p><span>
</span><p>app/app.component.ts (template-v2)</p><code language="ts" format="">template: `
   &lt;h1&gt;{{title}}&lt;/h1&gt;
   &lt;a routerLink=&quot;/heroes&quot;&gt;Heroes&lt;/a&gt;
   &lt;router-outlet&gt;&lt;/router-outlet&gt;
 `
</code><p>Notice the <code>routerLink</code> binding in the anchor tag.
We bind the <code>RouterLink</code> directive (another of the <code>RouterModule</code> directives) to a string
that tells the router where to navigate when the user clicks the link.</p><span>
</span><p>Since our link is not dynamic, we define a <em>routing instruction</em> with a <strong>one-time binding</strong> to our route <strong>path</strong>.
Looking back at the route configuration, we confirm that <code>&apos;/heroes&apos;</code> is the path of the route to the <code>HeroesComponent</code>.</p><span>
</span><div class="l-sub-section"><p>Learn more about dynamic router links and the <em>link parameters array</em>
in the <a href="https://angular.io/docs/ts/latest/guide/router.html#link-parameters-array">Routing</a> chapter.</p><span>
</span></div><p>Refresh the browser.  We see only the app title and heroes link. We don&apos;t see the heroes list.</p><span>
</span><div class="l-sub-section"><p>The browser&apos;s address bar shows <code>/</code>.
The route path to <code>HeroesComponent</code> is <code>/heroes</code>, not <code>/</code>.
We don&apos;t have a route that matches the path <code>/</code>, so there is nothing to show.
That&apos;s something we&apos;ll want to fix.</p><span>
</span></div><p>We click the <em>Heroes</em> navigation link, the browser bar updates to <code>/heroes</code>,
and now we see the list of heroes. We are navigating at last!</p><span>
</span><p>At this stage, our <code>AppComponent</code> looks like this.</p><span>
</span><p>app/app.component.ts (v2)</p><code language="ts" format="linenums">import { Component } from &apos;@angular/core&apos;;

@Component({
  selector: &apos;my-app&apos;,
  template: `
     &lt;h1&gt;{{title}}&lt;/h1&gt;
     &lt;a routerLink=&quot;/heroes&quot;&gt;Heroes&lt;/a&gt;
     &lt;router-outlet&gt;&lt;/router-outlet&gt;
   `
})
export class AppComponent {
  title = &apos;Tour of Heroes&apos;;
}
</code><p>The  <em>AppComponent</em> is now attached to a router and displaying routed views.
For this reason and to distinguish it from other kinds of components,
we call this type of component a <em>Router Component</em>.</p><span>
</span><h2 id="add-a-dashboard-">Add a <em>Dashboard</em></h2><span>
</span><p>Routing only makes sense when we have multiple views. We need another view.</p><span>
</span><p>Create a placeholder <code>DashboardComponent</code> that gives us something to navigate to and from.</p><span>
</span><p>app/dashboard.component.ts (v1)</p><code language="ts" format="">import { Component } from &apos;@angular/core&apos;;

@Component({
  selector: &apos;my-dashboard&apos;,
  template: &apos;&lt;h3&gt;My Dashboard&lt;/h3&gt;&apos;
})
export class DashboardComponent { }
</code><p>We&#x2019;ll come back and make it more useful later.</p><span>
</span><h3 id="configure-the-dashboard-route">Configure the dashboard route</h3><span>
</span><p>Go back to <code>app.routing.ts</code> and teach it to navigate to the dashboard.</p><span>
</span><p>Import the dashboard component and
add the following route definition to the <code>Routes</code> array of definitions.</p><span>
</span><p>app/app.routing.ts (Dashboard route)</p><code language="ts" format="">{
  path: &apos;dashboard&apos;,
  component: DashboardComponent
},
</code><p>Also import and add <code>DashboardComponent</code> to our root NgModule&apos;s <code>declarations</code>.</p><span>
</span><p>app/app.module.ts (dashboard)</p><code language="ts" format="">declarations: [
  AppComponent,
  DashboardComponent,
  HeroDetailComponent,
  HeroesComponent
],
</code><h4 id="-_redirectto-">redirectTo</h4><span>
</span><p>We want the app to show the dashboard when it starts and
we want to see a nice URL in the browser address bar that says <code>/dashboard</code>.
Remember that the browser launches with <code>/</code> in the address bar.</p><span>
</span><p>We can use a redirect route to make this happen. Add the following
to our array of route definitions:</p><span>
</span><p>app/app.routing.ts (redirect)</p><code language="ts" format="">{
  path: &apos;&apos;,
  redirectTo: &apos;/dashboard&apos;,
  pathMatch: &apos;full&apos;
},
</code><div class="l-sub-section"><p>Learn about the <em>redirects</em> in the <a href="https://angular.io/docs/ts/latest/guide/router.html#!#redirect">Routing</a> chapter.</p><span>
</span></div><span>
</span><p>Finally, add a dashboard navigation link to the template, just above the <em>Heroes</em> link.</p><span>
</span><p>app/app.component.ts (template-v3)</p><code language="ts" format="">template: `
   &lt;h1&gt;{{title}}&lt;/h1&gt;
   &lt;nav&gt;
     &lt;a routerLink=&quot;/dashboard&quot;&gt;Dashboard&lt;/a&gt;
     &lt;a routerLink=&quot;/heroes&quot;&gt;Heroes&lt;/a&gt;
   &lt;/nav&gt;
   &lt;router-outlet&gt;&lt;/router-outlet&gt;
 `
</code><div class="l-sub-section"><p>We nestled the two links within <code>&lt;nav&gt;</code> tags.
They don&apos;t do anything yet but they&apos;ll be convenient when we style the links a little later in the chapter.</p><span>
</span></div><p>To see these changes in your browser, go to the application root (<code>/</code>) and reload.
The app displays the dashboard and we can navigate between the dashboard and the heroes.</p><span>
</span><h2 id="dashboard-top-heroes">Dashboard Top Heroes</h2><span>
</span><p>Let&#x2019;s spice up the dashboard by displaying the top four heroes at a glance.</p><span>
</span><p>Replace the <code>template</code> metadata with a <code>templateUrl</code> property that points to a new
template file.</p><span>
</span><p>app/dashboard.component.ts (templateUrl)</p><code language="ts" format="">templateUrl: &apos;app/dashboard.component.html&apos;,
</code><div class="l-sub-section"><p>We specify the path <em>all the way back to the application root</em> &#x2014;
<span if-docs="ts"><code>app/</code> in this case &#x2014;</span>
because Angular doesn&apos;t support relative paths <em>by default</em>.
We <em>can</em> switch to <a href="https://angular.io/docs/ts/latest/cookbook/component-relative-paths.html">component-relative paths</a> if we prefer.</p><span>
</span></div><p>Create that file with this content:</p><span>
</span><p>app/dashboard.component.html (excerpt)</p><code language="html" format="">&lt;h3&gt;Top Heroes&lt;/h3&gt;
&lt;div class=&quot;grid grid-pad&quot;&gt;
  &lt;div *ngFor=&quot;let hero of heroes&quot; (click)=&quot;gotoDetail(hero)&quot; class=&quot;col-1-4&quot;&gt;
    &lt;div class=&quot;module hero&quot;&gt;
      &lt;h4&gt;{{hero.name}}&lt;/h4&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;
</code><p>We use <code>*ngFor</code> once again to iterate over a list of heroes and display their names.
We added extra <code>&lt;div&gt;</code> elements to help with styling later in this chapter.</p><span>
</span><p>There&apos;s a <code>(click)</code> binding to a <code>gotoDetail</code> method we haven&apos;t written yet and
we&apos;re displaying a list of heroes that we don&apos;t have.
We have work to do, starting with those heroes.</p><span>
</span><h3 id="share-the-heroservice-">Share the <em>HeroService</em></h3><span>
</span><p>We&apos;d like to re-use the <code>HeroService</code> to populate the component&apos;s <code>heroes</code> array.</p><span>
</span><p>Recall earlier in the chapter that we removed the <code>HeroService</code> from the <code>providers</code> array of <code>HeroesComponent</code>
and added it to the <code>providers</code> array of <code>AppModule</code>.</p><span>
</span><p>That move created a singleton <code>HeroService</code> instance, available to <em>all</em> components of the application.
Angular will inject <code>HeroService</code> and we&apos;ll use it here in the <code>DashboardComponent</code>.</p><span>
</span><h3 id="get-heroes">Get heroes</h3><span>
</span><p>Open <span ngio-ex="">dashboard.component.ts</span> and add the requisite <code>import</code> statements.</p><span>
</span><p>app/dashboard.component.ts (imports)</p><code language="ts" format="">import { Component, OnInit } from &apos;@angular/core&apos;;

import { Hero } from &apos;./hero&apos;;
import { HeroService } from &apos;./hero.service&apos;;
</code><p>Now implement the <code>DashboardComponent</code> class like this:</p><span>
</span><p>app/dashboard.component.ts (class)</p><code language="ts" format="">export class DashboardComponent implements OnInit {

  heroes: Hero[] = [];

  constructor(private heroService: HeroService) { }

  ngOnInit(): void {
    this.heroService.getHeroes()
      .then(heroes =&gt; this.heroes = heroes.slice(1, 5));
  }

  gotoDetail(hero: Hero): void { /* not implemented yet */}
}
</code><p>We&apos;ve seen this kind of logic before in the <code>HeroesComponent</code>:</p><span>
</span><ul>
<li>Define a <code>heroes</code> array property.</li>
<li>Inject the <code>HeroService</code> in the constructor and hold it in a private <code>heroService</code> field.</li>
<li>Call the service to get heroes inside the Angular <code>ngOnInit</code> lifecycle hook.</li>
</ul><span>
</span><p>The noteworthy differences: we cherry-pick four heroes (2nd, 3rd, 4th, and 5th)
and stub the <code>gotoDetail</code> method until we&apos;re ready to implement it.</p><span>
</span><p>Refresh the browser and see four heroes in the new dashboard.</p><span>
</span><span>
</span><p>Although we display the details of a selected hero at the bottom of the <code>HeroesComponent</code>,
we don&apos;t yet <em>navigate</em> to the <code>HeroDetailComponent</code> in the three ways specified in our requirements:</p><span>
</span><ol>
<li>from the <em>Dashboard</em> to a selected hero.</li>
<li>from the <em>Heroes</em> list to a selected hero.</li>
<li>from a &quot;deep link&quot; URL pasted into the browser address bar.</li>
</ol><span>
</span><p>Adding a hero-detail route seems like an obvious place to start.</p><span>
</span><h3 id="routing-to-a-hero-detail">Routing to a hero detail</h3><span>
</span><p>We&apos;ll add a route to the <code>HeroDetailComponent</code> in <code>app.routing.ts</code> where our other routes are configured.</p><span>
</span><p>The new route is a bit unusual in that we must tell the <code>HeroDetailComponent</code> <em>which hero to show</em>.
We didn&apos;t have to tell the <code>HeroesComponent</code> or the <code>DashboardComponent</code> anything.</p><span>
</span><p>At the moment the parent <code>HeroesComponent</code> sets the component&apos;s <code>hero</code> property to a
hero object with a binding like this.</p><span>
</span><code language="html">&lt;my-hero-detail [hero]=&quot;selectedHero&quot;&gt;&lt;/my-hero-detail&gt;
</code><p>That clearly won&apos;t work in any of our routing scenarios.
Certainly not the last one; we can&apos;t embed an entire hero object in the URL! Nor would we want to.</p><span>
</span><h3 id="parameterized-route">Parameterized route</h3><span>
</span><p>We <em>can</em> add the hero&apos;s <code>id</code> to the URL. When routing to the hero whose <code>id</code> is 11,
we could expect to see an URL such as this:</p><span>
</span><code format="">/detail/11
</code><p>The <code>/detail/</code> part of that URL is constant. The trailing numeric <code>id</code> part changes from hero to hero.
We need to represent that variable part of the route with a <em>parameter</em> (or <em>token</em>) that stands for the hero&apos;s <code>id</code>.</p><span>
</span><h3 id="configure-a-route-with-a-parameter">Configure a Route with a Parameter</h3><span>
</span><p>Here&apos;s the <em>route definition</em> we&apos;ll use.</p><span>
</span><p>app/app.routing.ts (hero detail)</p><code language="ts" format="">{
  path: &apos;detail/:id&apos;,
  component: HeroDetailComponent
},
</code><p>The colon (:) in the path indicates that <code>:id</code> is a placeholder to be filled with a specific hero <code>id</code>
when navigating to the <code>HeroDetailComponent</code>.</p><span>
</span><p>We&apos;re finished with the application routes.</p><span>
</span><p>We won&apos;t add a <code>&apos;Hero Detail&apos;</code> link to the template because users
don&apos;t click a navigation <em>link</em> to view a particular hero.
They click a <em>hero</em> whether that hero is displayed on the dashboard or in the heroes list.</p><span>
</span><p>We&apos;ll get to those <em>hero</em> clicks later in the chapter.
There&apos;s no point in working on them until the <code>HeroDetailComponent</code>
is ready to be navigated <em>to</em>.</p><span>
</span><p>That will require an <code>HeroDetailComponent</code> overhaul.</p><span>
</span><h2 id="revise-the-herodetailcomponent-">Revise the <em>HeroDetailComponent</em></h2><span>
</span><p>Before we rewrite the <code>HeroDetailComponent</code>, let&apos;s review what it looks like now:</p><span>
</span><p>app/hero-detail.component.ts (current)</p><code language="ts" format="linenums">import { Component, Input } from &apos;@angular/core&apos;;
import { Hero } from &apos;./hero&apos;;

@Component({
  selector: &apos;my-hero-detail&apos;,
  template: `
    &lt;div *ngIf=&quot;hero&quot;&gt;
      &lt;h2&gt;{{hero.name}} details!&lt;/h2&gt;
      &lt;div&gt;
        &lt;label&gt;id: &lt;/label&gt;{{hero.id}}
      &lt;/div&gt;
      &lt;div&gt;
        &lt;label&gt;name: &lt;/label&gt;
        &lt;input [(ngModel)]=&quot;hero.name&quot; placeholder=&quot;name&quot;/&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  `
})
export class HeroDetailComponent {
  @Input() hero: Hero;
}
</code><p>The template won&apos;t change. We&apos;ll display a hero the same way.
The big changes are driven by how we get the hero.</p><span>
</span><p>We will no longer receive the hero in a parent component property binding.
The new <code>HeroDetailComponent</code> should take the <code>id</code> parameter from the <code>params</code> observable
in the <code>ActivatedRoute</code> service and use the <code>HeroService</code> to fetch the hero with that <code>id</code>.</p><span>
</span><p>First, add the requisite imports:</p><span>
</span><code language="ts" format="">// Keep the Input import for now, we&apos;ll remove it later:
import { Component, Input, OnInit } from &apos;@angular/core&apos;;
import { ActivatedRoute, Params } from &apos;@angular/router&apos;;

import { HeroService } from &apos;./hero.service&apos;;
</code><p>Let&apos;s have the <code>ActivatedRoute</code> service and the <code>HeroService</code> injected
into the constructor, saving their values in private fields:</p><span>
</span><p>app/hero-detail.component.ts (constructor)</p><code language="ts" format="">constructor(
  private heroService: HeroService,
  private route: ActivatedRoute) {
}
</code><p>We tell the class that we want to implement the <code>OnInit</code> interface.</p><span>
</span><code language="ts" format="">export class HeroDetailComponent implements OnInit {
</code><p>Inside the <code>ngOnInit</code> lifecycle hook, we use the <code>params</code> observable to
extract the <code>id</code> parameter value from the <code>ActivateRoute</code> service
and use the <code>HeroService</code> to fetch the hero with that <code>id</code>.</p><span>
</span><p>app/hero-detail.component.ts (ngOnInit)</p><code language="ts" format="">ngOnInit(): void {
  this.route.params.forEach((params: Params) =&gt; {
    let id = +params[&apos;id&apos;];
    this.heroService.getHero(id)
      .then(hero =&gt; this.hero = hero);
  });
}
</code><p>Notice how we extract the <code>id</code> by calling the <code>forEach</code> method
which will deliver our array of route parameters.</p><span>
</span><p>The hero <code>id</code> is a number. Route parameters are <em>always strings</em>.
So we convert the route parameter value to a number with the JavaScript (+) operator.</p><span>
</span><h3 id="add-heroservice-gethero-">Add <em>HeroService.getHero</em></h3><span>
</span><p>The problem with this bit of code is that <code>HeroService</code> doesn&apos;t have a <code>getHero</code> method!
We better fix that quickly before someone notices that we broke the app.</p><span>
</span><p>Open <code>HeroService</code> and add a <code>getHero</code> method that filters the heroes list from <code>getHeroes</code> by <code>id</code>:</p><span>
</span><p>app/hero.service.ts (getHero)</p><code language="ts" format="">getHero(id: number): Promise&lt;Hero&gt; {
  return this.getHeroes()
             .then(heroes =&gt; heroes.find(hero =&gt; hero.id === id));
}
</code><p>Let&apos;s return to the <code>HeroDetailComponent</code> to clean up loose ends.</p><span>
</span><h3 id="find-our-way-back">Find our way back</h3><span>
</span><p>We can navigate <em>to</em> the <code>HeroDetailComponent</code> in several ways.
How do we navigate somewhere else when we&apos;re done?</p><span>
</span><p>The user could click one of the two links in the <code>AppComponent</code>. Or click the browser&apos;s back button.
We&apos;ll add a third option, a <code>goBack</code> method that navigates backward one step in the browser&apos;s history stack.</p><span>
</span><p>app/hero-detail.component.ts (goBack)</p><code language="ts" format="">goBack(): void {
  window.history.back();
}
</code><div class="l-sub-section"><p>Going back too far could take us out of the application.
That&apos;s acceptable in a demo. We&apos;d guard against it in a real application,
perhaps with the <a href="https://angular.io/docs/ts/latest/api/router/index/CanDeactivate-interface.html"><em>CanDeactivate</em> guard</a>.</p><span>
</span></div><p>Then we wire this method with an event binding to a <em>Back</em> button that we
add to the bottom of the component template.</p><span>
</span><code language="html" format="">&lt;button (click)=&quot;goBack()&quot;&gt;Back&lt;/button&gt;
</code><p>Modifing the template to add this button spurs us to take one more
incremental improvement and migrate the template to its own file,
called <span ngio-ex="">hero-detail.component.html</span>:</p><span>
</span><p>app/hero-detail.component.html</p><code language="html" format="linenums">&lt;div *ngIf=&quot;hero&quot;&gt;
  &lt;h2&gt;{{hero.name}} details!&lt;/h2&gt;
  &lt;div&gt;
    &lt;label&gt;id: &lt;/label&gt;{{hero.id}}&lt;/div&gt;
  &lt;div&gt;
    &lt;label&gt;name: &lt;/label&gt;
    &lt;input [(ngModel)]=&quot;hero.name&quot; placeholder=&quot;name&quot; /&gt;
  &lt;/div&gt;
  &lt;button (click)=&quot;goBack()&quot;&gt;Back&lt;/button&gt;
&lt;/div&gt;
</code><p>We update the component metadata with a <code>templateUrl</code> pointing to the template file that we just created.</p><span>
</span><p>app/hero-detail.component.ts (templateUrl)</p><code language="ts" format="">templateUrl: &apos;app/hero-detail.component.html&apos;,
</code><p>Refresh the browser and see the results.</p><span>
</span><h2 id="select-a-dashboard-hero">Select a <em>Dashboard</em> Hero</h2><span>
</span><p>When a user selects a hero in the dashboard, the app should navigate to the <code>HeroDetailComponent</code> to view and edit the selected hero.</p><span>
</span><p>In the dashboard template we bound each hero&apos;s click event to the <code>gotoDetail</code> method, passing along the selected <code>hero</code> entity.</p><span>
</span><p>app/dashboard.component.html (click)</p><code language="html" format="">&lt;div *ngFor=&quot;let hero of heroes&quot; (click)=&quot;gotoDetail(hero)&quot; class=&quot;col-1-4&quot;&gt;
</code><p>We stubbed the <code>gotoDetail</code> method when we rewrote the <code>DashboardComponent</code>.
Now we give it a real implementation.</p><span>
</span><p>app/dashboard.component.ts (gotoDetail)</p><code language="ts" format="">gotoDetail(hero: Hero): void {
  let link = [&apos;/detail&apos;, hero.id];
  this.router.navigate(link);
}
</code><p>The <code>gotoDetail</code> method navigates in two steps:</p><span>
</span><ol>
<li>Set a route <em>link parameters array</em></li>
<li>Pass the array to the router&apos;s navigate method</li>
</ol><span>
</span><p>For navigation, we wrote router links <span if-docs="dart">as <em>link
parameters arrays</em></span> in the <a href="https://angular.io/docs/ts/latest/tutorial/toh-pt5.html#router-links"><code>AppComponent</code>
template</a>.  Those link<span if-docs="dart"> parameters
array</span>s had only one element, the path of the
destination route.</p><span>
</span><p>This link parameters array has two elements, the <strong><em>path</em></strong> of
the destination route and a <strong><em>route parameter</em></strong> <span if-docs="dart">with
an <code>id</code> field</span> set to the value of the selected hero&apos;s <code>id</code>.</p><span>
</span><p>The two array items align with the <strong><em>path</em></strong> and <strong><em>:id</em></strong>
token in the parameterized hero detail route definition we added to
<code>app.routing.ts</code> earlier in the chapter:</p><span>
</span><p>app/app.routing.ts (hero detail)</p><code language="ts" format="">{
  path: &apos;detail/:id&apos;,
  component: HeroDetailComponent
},
</code><p>The <code>DashboardComponent</code> doesn&apos;t have the router yet. We obtain it in the usual way:
import the <code>router</code> reference and inject it in the constructor (along with the <code>HeroService</code>):</p><span>
</span><code language="ts" format="">import { Router } from &apos;@angular/router&apos;;
</code><code language="ts" format="">constructor(
  private router: Router,
  private heroService: HeroService) {
}
</code><p>Refresh the browser and select a hero from the dashboard; the app should navigate directly to that hero&#x2019;s details.</p><span>
</span><h2 id="select-a-hero-in-the-heroescomponent-">Select a Hero in the <em>HeroesComponent</em></h2><span>
</span><p>We&apos;ll do something similar in the <code>HeroesComponent</code>.</p><span>
</span><p>That component&apos;s current template exhibits a &quot;master/detail&quot; style with the list of heroes
at the top and details of the selected hero below.</p><span>
</span><p>app/heroes.component.ts (current template)</p><code language="ts" format="">template: `
  &lt;h1&gt;{{title}}&lt;/h1&gt;
  &lt;h2&gt;My Heroes&lt;/h2&gt;
  &lt;ul class=&quot;heroes&quot;&gt;
    &lt;li *ngFor=&quot;let hero of heroes&quot;
      [class.selected]=&quot;hero === selectedHero&quot;
      (click)=&quot;onSelect(hero)&quot;&gt;
      &lt;span class=&quot;badge&quot;&gt;{{hero.id}}&lt;/span&gt; {{hero.name}}
    &lt;/li&gt;
  &lt;/ul&gt;
  &lt;my-hero-detail [hero]=&quot;selectedHero&quot;&gt;&lt;/my-hero-detail&gt;
`,
</code><p>Delete the last line of the template with the <code>&lt;my-hero-detail&gt;</code> tags.</p><span>
</span><p>We&apos;ll no longer show the full <code>HeroDetailComponent</code> here.
We&apos;re going to display the hero detail on its own page and route to it as we did in the dashboard.</p><span>
</span><p>But we&apos;ll throw in a small twist for variety.
When the user selects a hero from the list, we <em>won&apos;t</em> go to the detail page.
We&apos;ll show a <em>mini-detail</em> on <em>this</em> page instead and make the user click a button to navigate to the <em>full detail </em>page.</p><span>
</span><h3 id="add-the-mini-detail-">Add the <em>mini-detail</em></h3><span>
</span><p>Add the following HTML fragment at the bottom of the template where the <code>&lt;my-hero-detail&gt;</code> used to be:</p><span>
</span><code language="html" format="">&lt;div *ngIf=&quot;selectedHero&quot;&gt;
  &lt;h2&gt;
    {{selectedHero.name | uppercase}} is my hero
  &lt;/h2&gt;
  &lt;button (click)=&quot;gotoDetail()&quot;&gt;View Details&lt;/button&gt;
&lt;/div&gt;
</code><p>After clicking a hero, the user should see something like this below the hero list:</p><span>
</span><figure class="image-display"><img src="https://angular.io/resources/images/devguide/toh/mini-hero-detail.png" alt="Mini Hero Detail" height="70"></figure><h3 id="format-with-the-uppercase-pipe">Format with the <em>uppercase</em> pipe</h3><span>
</span><p>Notice that the hero&apos;s name is displayed in CAPITAL LETTERS. That&apos;s the effect of the <code>uppercase</code> pipe
that we slipped into the interpolation binding. Look for it right after the pipe operator ( | ).</p><span>
</span><code language="html" format="">{{selectedHero.name | uppercase}} is my hero
</code><p>Pipes are a good way to format strings, currency amounts, dates and other display data.
Angular ships with several pipes and we can write our own.</p><span>
</span><div class="l-sub-section"><p>Learn about pipes in the <a href="https://angular.io/docs/ts/latest/guide/pipes.html">Pipes</a> chapter.</p><span>
</span></div><h3 id="move-content-out-of-the-component-file">Move content out of the component file</h3><span>
</span><p>We are not done. We still have to update the component class to support navigation to the
<code>HeroDetailComponent</code> when the user clicks the <em>View Details</em> button.</p><span>
</span><p>This component file is really big. Most of it is either template or CSS styles.
It&apos;s difficult to find the component logic amidst the noise of HTML and CSS.</p><span>
</span><p>Let&apos;s migrate the template and the styles to their own files before we make any more changes:</p><span>
</span><ol>
<li><em>Cut-and-paste</em> the template contents into a new <span ngio-ex="">heroes.component.html</span> file.</li>
<li><em>Cut-and-paste</em> the styles contents into a new <span ngio-ex="">heroes.component.css</span> file.</li>
<li><em>Set</em> the component metadata&apos;s <code>templateUrl</code> and <code>styleUrls</code> properties to refer to both files.</li>
</ol><span>
</span><div class="l-sub-section"><p>The <code>styleUrls</code> property is an array of style file names (with paths).
We could list multiple style files from different locations if we needed them.
<span if-docs="ts">As with <code>templateUrl</code>, we must specify the path <em>all the way
back to the application root</em>.</span></p><span>
</span></div><p>app/heroes.component.ts (revised metadata)</p><code language="ts" format="">@Component({
  selector: &apos;my-heroes&apos;,
  templateUrl: &apos;app/heroes.component.html&apos;,
  styleUrls:  [&apos;app/heroes.component.css&apos;]
})
</code><p>Now we can see what&apos;s going on as we update the component class along the same lines as the dashboard:</p><span>
</span><ol>
<li>Import the <code>router</code></li>
<li>Inject the <code>router</code> in the constructor (along with the <code>HeroService</code>)</li>
<li>Implement the <code>gotoDetail</code> method by calling the <code>router.navigate</code> method</li>
</ol><span>
</span><p>with a two-part hero-detail link parameters array.</p><span>
</span><p>Here&apos;s the revised component class:</p><span>
</span><p>app/heroes.component.ts (class)</p><code language="ts" format="">export class HeroesComponent implements OnInit {
  heroes: Hero[];
  selectedHero: Hero;

  constructor(
    private router: Router,
    private heroService: HeroService) { }

  getHeroes(): void {
    this.heroService.getHeroes().then(heroes =&gt; this.heroes = heroes);
  }

  ngOnInit(): void {
    this.getHeroes();
  }

  onSelect(hero: Hero): void {
    this.selectedHero = hero;
  }

  gotoDetail(): void {
    this.router.navigate([&apos;/detail&apos;, this.selectedHero.id]);
  }
}
</code><p>Refresh the browser and start clicking.
We can navigate around the app, from the dashboard to hero details and back,
for heroes list to the mini-detail to the hero details and back to the heroes again.
We can jump back and forth between the dashboard and the heroes.</p><span>
</span><p>We&apos;ve met all of the navigational requirements that propelled this chapter.</p><span>
</span><h2 id="styling-the-app">Styling the App</h2><span>
</span><p>The app is functional but pretty ugly.
Our creative designer team provided some CSS files to make it look better.</p><span>
</span><h3 id="a-dashboard-with-style">A Dashboard with Style</h3><span>
</span><p>The designers think we should display the dashboard heroes in a row of rectangles.
They&apos;ve given us ~60 lines of CSS for this purpose including some simple media queries for responsive design.</p><span>
</span><p>If we paste these ~60 lines into the component <code>styles</code> metadata,
they&apos;ll completely obscure the component logic.
Let&apos;s not do that. It&apos;s easier to edit CSS in a separate <code>*.css</code> file anyway.</p><span>
</span><p>Add a <span ngio-ex="">dashboard.component.css</span> file to the <code>app</code> folder and reference
that file in the component metadata&apos;s <code>styleUrls</code> array property like this:</p><span>
</span><p>app/dashboard.component.ts (styleUrls)</p><code language="ts" format="">styleUrls: [&apos;app/dashboard.component.css&apos;]
</code><h3 id="stylish-hero-details">Stylish Hero Details</h3><span>
</span><p>The designers also gave us CSS styles specifically for the <code>HeroDetailComponent</code>.</p><span>
</span><p>Add a <span ngio-ex="">hero-detail.component.css</span> to the <code>app</code>
folder and refer to that file inside
the <code>styleUrls</code> array as we did for <code>DashboardComponent</code>.
Let&apos;s also remove the <code>hero</code> property <code>@Input</code> decorator
<span if-docs="ts">and its import</span>
while we are at it.</p><span>
</span><p>Here&apos;s the content for the aforementioned component CSS files.</p><span>
</span><code-tabs><code language="css" name="app/hero-detail.component.css" format="linenums">label {
  display: inline-block;
  width: 3em;
  margin: .5em 0;
  color: #607D8B;
  font-weight: bold;
}
input {
  height: 2em;
  font-size: 1em;
  padding-left: .4em;
}
button {
  margin-top: 20px;
  font-family: Arial;
  background-color: #eee;
  border: none;
  padding: 5px 10px;
  border-radius: 4px;
  cursor: pointer; cursor: hand;
}
button:hover {
  background-color: #cfd8dc;
}
button:disabled {
  background-color: #eee;
  color: #ccc; 
  cursor: auto;
}
</code><code language="css" name="app/dashboard.component.css" format="linenums">[class*=&apos;col-&apos;] {
  float: left;
}
*, *:after, *:before {
    -webkit-box-sizing: border-box;
    -moz-box-sizing: border-box;
    box-sizing: border-box;
}
h3 {
  text-align: center; margin-bottom: 0;
}
[class*=&apos;col-&apos;] {
  padding-right: 20px;
  padding-bottom: 20px;
}
[class*=&apos;col-&apos;]:last-of-type {
  padding-right: 0;
}
.grid {
  margin: 0;
}
.col-1-4 {
  width: 25%;
}
.module {
    padding: 20px;
    text-align: center;
    color: #eee;
    max-height: 120px;
    min-width: 120px;
    background-color: #607D8B;
    border-radius: 2px;
}
h4 {
  position: relative;
}
.module:hover {
  background-color: #EEE;
  cursor: pointer;
  color: #607d8b;
}
.grid-pad {
  padding: 10px 0;
}
.grid-pad &gt; [class*=&apos;col-&apos;]:last-of-type {
  padding-right: 20px;
}
@media (max-width: 600px) {
    .module {
      font-size: 10px;
      max-height: 75px; }
}
@media (max-width: 1024px) {
    .grid {
      margin: 0;
    }
    .module {
      min-width: 60px;
    }
}
</code></code-tabs><span>
</span><p>The designers gave us CSS to make the navigation links in our <code>AppComponent</code> look more like selectable buttons.
We cooperated by surrounding those links in <code>&lt;nav&gt;</code> tags.</p><span>
</span><p>Add a <span ngio-ex="">app.component.css</span> file to the <code>app</code> folder with the following content.</p><span>
</span><p>app/app.component.css (navigation styles)</p><code language="css" format="">h1 {
  font-size: 1.2em;
  color: #999;
  margin-bottom: 0;
}
h2 {
  font-size: 2em;
  margin-top: 0;
  padding-top: 0;
}
nav a {
  padding: 5px 10px;
  text-decoration: none;
  margin-top: 10px;
  display: inline-block;
  background-color: #eee;
  border-radius: 4px;
}
nav a:visited, a:link {
  color: #607D8B;
}
nav a:hover {
  color: #039be5;
  background-color: #CFD8DC;
}
nav a.active {
  color: #039be5;
}
</code><div class="l-sub-section"><p><strong>The <em>routerLinkActive</em> directive</strong></p><span>
</span><p>The Angular Router provides a <code>routerLinkActive</code> directive we can use to
add a class to the HTML navigation element whose route matches the active route.
All we have to do is define the style for it. Sweet!</p><span>
</span><p>app/app.component.ts (active router links)</p><code language="ts" format="">template: `
  &lt;h1&gt;{{title}}&lt;/h1&gt;
  &lt;nav&gt;
    &lt;a routerLink=&quot;/dashboard&quot; routerLinkActive=&quot;active&quot;&gt;Dashboard&lt;/a&gt;
    &lt;a routerLink=&quot;/heroes&quot; routerLinkActive=&quot;active&quot;&gt;Heroes&lt;/a&gt;
  &lt;/nav&gt;
  &lt;router-outlet&gt;&lt;/router-outlet&gt;
`,
</code></div><p>Set the <code>AppComponent</code>&#x2019;s <code>styleUrls</code> property to this CSS file.</p><span>
</span><p>app/app.component.ts (styleUrls)</p><code language="ts" format="">styleUrls: [&apos;app/app.component.css&apos;],
</code><h3 id="global-application-styles">Global application styles</h3><span>
</span><p>When we add styles to a component, we&apos;re keeping everything a component needs
&#x2014; HTML, the CSS, the code &#x2014; together in one convenient place.
It&apos;s pretty easy to package it all up and re-use the component somewhere else.</p><span>
</span><p>We can also create styles at the <em>application level</em> outside of any component.</p><span>
</span><p>Our designers provided some basic styles to apply to elements across the entire app.
These correspond to the full set of master styles that we
introduced earlier (see
<a href="https://angular.io/docs/ts/latest/quickstart.html#!#add-some-style">QuickStart, &quot;Add some style&quot;</a>).
Here is an excerpt:</p><span>
</span><p>styles.css (excerpt)</p><code language="css" format="">/* Master Styles */
h1 {
  color: #369;
  font-family: Arial, Helvetica, sans-serif;
  font-size: 250%;
}
h2, h3 {
  color: #444;
  font-family: Arial, Helvetica, sans-serif;
  font-weight: lighter;
}
body {
  margin: 2em;
}
body, input[text], button {
  color: #888;
  font-family: Cambria, Georgia;
}
/* . . . */
/* everywhere else */
* {
  font-family: Arial, Helvetica, sans-serif;
}
</code><p>Create the file <span ngio-ex="">styles.css</span>, if it doesn&apos;t exist already.
Ensure that it contains the <a href="https://raw.githubusercontent.com/angular/angular.io/master/public/docs/_examples/styles.css">master styles given here</a>.</p><span>
</span><p>If necessary, also edit <span ngio-ex="">index.html</span> to refer to this stylesheet.</p><span>
</span><p>index.html (link ref)</p><code language="html" format="">&lt;link rel=&quot;stylesheet&quot; href=&quot;styles.css&quot;&gt;
</code><p>Look at the app now. Our dashboard, heroes, and navigation links are styling!</p><span>
</span><figure class="image-display"><img src="https://angular.io/resources/images/devguide/toh/dashboard-top-heroes.png" alt="View navigations"></figure><h2 id="application-structure-and-code">Application structure and code</h2><span>
</span><p>Review the sample source code in the <live-example></live-example> for this chapter.
Verify that we have the following structure:</p><span>
</span><div class="filetree"><p>angular2-tour-of-heroes</p><div class="children"><p>app</p><div class="children"><p>app.component.css</p><p>app.component.ts</p><p>app.module.ts</p><p>app.routing.ts</p><p>dashboard.component.css</p><p>dashboard.component.html</p><p>dashboard.component.ts</p><p>hero.service.ts</p><p>hero.ts</p><p>hero-detail.component.css</p><p>hero-detail.component.html</p><p>hero-detail.component.ts</p><p>heroes.component.css</p><p>heroes.component.html</p><p>heroes.component.ts</p><p>main.ts</p><p>mock-heroes.ts</p></div><p>node_modules ...</p><p>typings ...</p><p>index.html</p><p>package.json</p><p>styles.css</p><p>systemjs.config.js</p><p>tsconfig.json</p><p>typings.json</p></div></div><h2 id="recap">Recap</h2><span>
</span><h3 id="the-road-behind">The Road Behind</h3><span>
</span><p>We travelled a great distance in this chapter</p><span>
</span><ul>
<li>We added the Angular <em>Component Router</em> to navigate among different components.</li>
<li>We learned how to create router links to represent navigation menu items.</li>
<li>We used router link parameters to navigate to the details of user selected hero.</li>
<li>We shared the <code>HeroService</code> among multiple components.</li>
<li>We moved HTML and CSS out of the component file and into their own files.</li>
<li>We added the <code>uppercase</code> pipe to format data.</li>
</ul><span>
</span><h3 id="the-road-ahead">The Road Ahead</h3><span>
</span><p>We have much of the foundation we need to build an application.
We&apos;re still missing a key piece: remote data access.</p><span>
</span><p>In the next chapter,
we&#x2019;ll replace our mock data with data retrieved from a server using http.</p><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!--NEXT PAGE HAS NOW BEEN SET--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--></div></div>
        </article>
      
        <article>
          <h3>HTTP - ts</h3>
          <div><div class="showcase-content"><h1 id="getting-and-saving-data">Getting and Saving Data</h1><span>
</span><p>Our stakeholders appreciate our progress.
Now they want to get the hero data from a server, let users add, edit, and delete heroes,
and save these changes back to the server.</p><span>
</span><p>In this chapter we teach our application to make the corresponding HTTP calls to a remote server&apos;s web API.</p><span>
</span><p>Run the <live-example></live-example> for this part.</p><span>
</span><h2 id="where-we-left-off">Where We Left Off</h2><span>
</span><p>In the <a href="https://angular.io/docs/ts/latest/tutorial/toh-pt5.html">previous chapter</a>, we learned to navigate between the dashboard and the fixed heroes list, editing a selected hero along the way.
That&apos;s our starting point for this chapter.</p><span>
</span><h3 id="keep-the-app-transpiling-and-running">Keep the app transpiling and running</h3><span>
</span><p>Open a terminal/console window and enter the following command to
start the TypeScript compiler, start the server, and watch for changes:</p><span>
</span><code language="bash">npm start
</code><p>The application runs and updates automatically as we continue to build the Tour of Heroes.</p><span>
</span><h1>Providing HTTP Services</h1><p>The <code>HttpModule</code> is <strong><em>not</em></strong> a core Angular module.
It&apos;s Angular&apos;s optional approach to web access and it exists as a separate add-on module called <code>@angular/http</code>,
shipped in a separate script file as part of the Angular npm package.</p><span>
</span><p>Fortunately we&apos;re ready to import from <code>@angular/http</code> because <code>systemjs.config</code> configured <em>SystemJS</em> to load that library when we need it.</p><span>
</span><h3 id="register-for-http-services">Register for HTTP services</h3><span>
</span><p>Our app will depend upon the Angular <code>http</code> service which itself depends upon other supporting services.
The <code>HttpModule</code> from <code>@angular/http</code> library holds providers for a complete set of HTTP services.</p><span>
</span><p>We should be able to access these services from anywhere in the application.
So we register them all by adding <code>HttpModule</code> to the <code>imports</code> list of the <code>AppModule</code> where we
bootstrap the application and its root <code>AppComponent</code>.</p><span>
</span><p>app/app.module.ts (v1)</p><code language="ts" format="linenums">import { NgModule }      from &apos;@angular/core&apos;;
import { BrowserModule } from &apos;@angular/platform-browser&apos;;
import { FormsModule }   from &apos;@angular/forms&apos;;
import { HttpModule }    from &apos;@angular/http&apos;;

import { AppComponent }         from &apos;./app.component&apos;;
import { DashboardComponent }   from &apos;./dashboard.component&apos;;
import { HeroesComponent }      from &apos;./heroes.component&apos;;
import { HeroDetailComponent }  from &apos;./hero-detail.component&apos;;
import { HeroService }          from &apos;./hero.service&apos;;
import { routing }              from &apos;./app.routing&apos;;

@NgModule({
  imports: [
    BrowserModule,
    FormsModule,
    HttpModule,
    routing
  ],
  declarations: [
    AppComponent,
    DashboardComponent,
    HeroDetailComponent,
    HeroesComponent,
  ],
  providers: [
    HeroService,
  ],
  bootstrap: [ AppComponent ]
})
export class AppModule {
}
</code><p>Notice that we supply <code>HttpModule</code> as part of the <em>imports</em> array in root NgModule <code>AppModule</code>.</p><span>
</span><h2 id="simulating-the-web-api">Simulating the web API</h2><span>
</span><p>We recommend registering application-wide services in the root
<code>AppModule</code> <em>providers</em>.  <span if-docs="dart">Here we&apos;re
registering in <code>main</code> for a special reason.</span></p><span>
</span><p>Our application is in the early stages of development and far from ready for production.
We don&apos;t even have a web server that can handle requests for heroes.
Until we do, <em>we&apos;ll have to fake it</em>.</p><span>
</span><p>We&apos;re going to <em>trick</em> the HTTP client into fetching and saving data from
a mock service, the <em>in-memory web API</em>.
<span if-docs="dart"> The application itself doesn&apos;t need to know and
shouldn&apos;t know about this.  So we&apos;ll slip the in-memory web API into the
configuration <em>above</em> the <code>AppComponent</code>.</span></p><span>
</span><p>Here is a version of <span ngio-ex="">app/app.module.ts</span> that performs this trick:</p><span>
</span><p>app/app.module.ts (v2)</p><code language="ts" format="">import { NgModule }      from &apos;@angular/core&apos;;
import { BrowserModule } from &apos;@angular/platform-browser&apos;;
import { FormsModule }   from &apos;@angular/forms&apos;;
import { HttpModule }    from &apos;@angular/http&apos;;

// Imports for loading &amp; configuring the in-memory web api
import { InMemoryWebApiModule } from &apos;angular2-in-memory-web-api&apos;;
import { InMemoryDataService }  from &apos;./in-memory-data.service&apos;;

import { AppComponent }         from &apos;./app.component&apos;;
import { DashboardComponent }   from &apos;./dashboard.component&apos;;
import { HeroesComponent }      from &apos;./heroes.component&apos;;
import { HeroDetailComponent }  from &apos;./hero-detail.component&apos;;
import { HeroService }          from &apos;./hero.service&apos;;
import { routing }              from &apos;./app.routing&apos;;

@NgModule({
  imports: [
    BrowserModule,
    FormsModule,
    HttpModule,
    InMemoryWebApiModule.forRoot(InMemoryDataService),
    routing
  ],
  declarations: [
    AppComponent,
    DashboardComponent,
    HeroDetailComponent,
    HeroesComponent,
  ],
  providers: [
    HeroService,
  ],
  bootstrap: [ AppComponent ]
})
export class AppModule {
}
</code><p>We&apos;re importing the  <code>InMemoryWebApiModule</code> and adding it to the module <code>imports</code>.
The  <code>InMemoryWebApiModule</code> replaces the default <code>Http</code> client backend &#x2014;
the supporting service that talks to the remote server &#x2014;
with an  <em>in-memory web API alternative service</em>.</p><span>
</span><code language="ts" format="">InMemoryWebApiModule.forRoot(InMemoryDataService),
</code><p>The <code>forRoot</code> configuration method takes an <code>InMemoryDataService</code> class
that primes the in-memory database as follows:</p><span>
</span><p>app/in-memory-data.service.ts</p><code language="ts" format="">import { InMemoryDbService } from &apos;angular2-in-memory-web-api&apos;;
export class InMemoryDataService implements InMemoryDbService {
  createDb() {
    let heroes = [
      {id: 11, name: &apos;Mr. Nice&apos;},
      {id: 12, name: &apos;Narco&apos;},
      {id: 13, name: &apos;Bombasto&apos;},
      {id: 14, name: &apos;Celeritas&apos;},
      {id: 15, name: &apos;Magneta&apos;},
      {id: 16, name: &apos;RubberMan&apos;},
      {id: 17, name: &apos;Dynama&apos;},
      {id: 18, name: &apos;Dr IQ&apos;},
      {id: 19, name: &apos;Magma&apos;},
      {id: 20, name: &apos;Tornado&apos;}
    ];
    return {heroes};
  }
}
</code><p>This file replaces the <code>mock-heroes.ts</code> which is now safe to delete.</p><div class="alert is-helpful"><p>This chapter is an introduction to the Angular HTTP library.
Please don&apos;t be distracted by the details of this backend substitution. Just follow along with the example.</p><span>
</span><p>Learn more later about the in-memory web API in the <a href="https://angular.io/docs/ts/latest/guide/server-communication.html#!#in-mem-web-api">HTTP client chapter</a>.
Remember, the in-memory web API is only useful in the early stages of development and for demonstrations such as this Tour of Heroes.
Skip it when you have a real web API server.</p><span>
</span></div><h2 id="heroes-and-http">Heroes and HTTP</h2><span>
</span><p>Look at our current <code>HeroService</code> implementation</p><span>
</span><code language="ts" format="">getHeroes(): Promise&lt;Hero[]&gt; {
  return Promise.resolve(HEROES);
}
</code><p>We returned a Promise resolved with mock heroes.
It may have seemed like overkill at the time, but we were anticipating the
day when we fetched heroes with an HTTP client and we knew that would have to be an asynchronous operation.</p><span>
</span><p>That day has arrived! Let&apos;s convert <code>getHeroes()</code> to use HTTP.</p><span>
</span><p>app/hero.service.ts (updated getHeroes and new class members)</p><code language="ts" format="">  private heroesUrl = &apos;app/heroes&apos;;  // URL to web api

  constructor(private http: Http) { }

  getHeroes(): Promise&lt;Hero[]&gt; {
    return this.http.get(this.heroesUrl)
               .toPromise()
               .then(response =&gt; response.json().data as Hero[])
               .catch(this.handleError);
  }
</code><p>Our updated import statements are now:</p><span>
</span><p>app/hero.service.ts (updated imports)</p><code language="ts" format="">import { Injectable }    from &apos;@angular/core&apos;;
import { Headers, Http } from &apos;@angular/http&apos;;

import &apos;rxjs/add/operator/toPromise&apos;;

import { Hero } from &apos;./hero&apos;;
</code><p>Refresh the browser, and the hero data should be successfully loaded from the
mock server.</p><span>
</span><h3 id="http-promise">HTTP Promise</h3><span>

</span><p>We&apos;re still returning a Promise but we&apos;re creating it differently.</p><span>
</span><p>The Angular <code>http.get</code> returns an RxJS <code>Observable</code>.
<em>Observables</em> are a powerful way to manage asynchronous data flows.
We&apos;ll learn about <a href="https://angular.io/docs/ts/latest/tutorial/toh-pt6.html#observables">Observables</a> later in this chapter.</p><span>
</span><p>For <em>now</em> we get back on familiar ground by immediately by
converting that <code>Observable</code> to a <code>Promise</code> using the <code>toPromise</code> operator.</p><span>
</span><code language="ts" format="">.toPromise()
</code><p>Unfortunately, the Angular <code>Observable</code> doesn&apos;t have a <code>toPromise</code> operator ...
not out of the box.
The Angular <code>Observable</code> is a bare-bones implementation.</p><span>
</span><p>There are scores of operators like <code>toPromise</code> that extend <code>Observable</code> with useful capabilities.
If we want those capabilities, we have to add the operators ourselves.
That&apos;s as easy as importing them from the RxJS library like this:</p><span>
</span><code language="ts" format="">import &apos;rxjs/add/operator/toPromise&apos;;
</code><h3 id="extracting-the-data-in-the-then-callback">Extracting the data in the <em>then</em> callback</h3><span>
</span><p>In the <em>promise</em>&apos;s <code>then</code> callback we call the <code>json</code> method of the HTTP <code>Response</code> to extract the
data within the response.</p><span>
</span><code language="ts" format="">.then(response =&gt; response.json().data as Hero[])
</code><p>That response JSON has a single <code>data</code> property.
The <code>data</code> property holds the array of <em>heroes</em> that the caller really wants.
So we grab that array and return it as the resolved Promise value.</p><span>
</span><div class="alert is-important"><p>Pay close attention to the shape of the data returned by the server.
This particular <em>in-memory web API</em> example happens to return an object with a <code>data</code> property.
Your API might return something else. Adjust the code to match <em>your web API</em>.</p><span>
</span></div><p>The caller is unaware of these machinations. It receives a Promise of <em>heroes</em> just as it did before.
It has no idea that we fetched the heroes from the (mock) server.
It knows nothing of the twists and turns required to convert the HTTP response into heroes.
Such is the beauty and purpose of delegating data access to a service like this <code>HeroService</code>.</p><span>
</span><h3 id="error-handling">Error Handling</h3><span>
</span><p>At the end of <code>getHeroes()</code> we <code>catch</code> server failures and pass them to an error handler:</p><span>
</span><code language="ts" format="">.catch(this.handleError);
</code><p>This is a critical step!
We must anticipate HTTP failures as they happen frequently for reasons beyond our control.</p><span>
</span><code language="ts" format="">private handleError(error: any): Promise&lt;any&gt; {
  console.error(&apos;An error occurred&apos;, error); // for demo purposes only
  return Promise.reject(error.message || error);
}
</code><p>In this demo service we log the error to the console; we would do better in real life.</p><span>
</span><p>We&apos;ve also decided to return a user friendly form of the error to
the caller in a rejected promise so that the caller can display a proper error message to the user.</p><span>
</span><h3 id="unchanged-getheroes-api">Unchanged <code>getHeroes</code> API</h3><span>
</span><p>Although we made significant <em>internal</em> changes to <code>getHeroes()</code>, the public signature did not change.
We still return a Promise. We won&apos;t have to update any of the components that call <code>getHeroes()</code>.</p><span>
</span><p>Our stakeholders are thrilled with the added flexibility from the API integration. 
Now they want the ability to create and delete heroes.</p><span>
</span><p>Let&apos;s see first what happens when we try to update a hero&apos;s details.</p><span>
</span><h2 id="update-hero-details">Update hero details</h2><span>
</span><p>We can edit a hero&apos;s name already in the hero detail view. Go ahead and try
it. As we type, the hero name is updated in the view heading. 
But when we hit the <code>Back</code> button, the changes are lost!</p><span>
</span><div class="l-sub-section"><p>Updates weren&apos;t lost before, what&apos;s happening?
When the app used a list of mock heroes, changes were made directly to the
hero objects in the single, app-wide shared list. Now that we are fetching data
from a server, if we want changes to persist, we&apos;ll need to write them back to
the server.</p><span>
</span></div><h3 id="save-hero-details">Save hero details</h3><span>
</span><p>Let&apos;s ensure that edits to a hero&apos;s name aren&apos;t lost. Start by adding,
to the end of the hero detail template, a save button with a <code>click</code> event
binding that invokes a new component method named <code>save</code>:</p><span>
</span><p>app/hero-detail.component.html (save)</p><code language="html" format="">&lt;button (click)=&quot;save()&quot;&gt;Save&lt;/button&gt;
</code><p>The <code>save</code> method persists hero name changes using the hero service
<code>update</code> method and then navigates back to the previous view:</p><span>
</span><p>app/hero-detail.component.ts (save)</p><code language="ts" format="">save(): void {
  this.heroService.update(this.hero)
    .then(this.goBack);
}
</code><h3 id="hero-service-update-method">Hero service <code>update</code> method</h3><span>
</span><p>The overall structure of the <code>update</code> method is similar to that of
<code>getHeroes</code>, although we&apos;ll use an HTTP <em>put</em> to persist changes
server-side:</p><span>
</span><p>app/hero.service.ts (update)</p><code language="ts" format="">private headers = new Headers({&apos;Content-Type&apos;: &apos;application/json&apos;});

update(hero: Hero): Promise&lt;Hero&gt; {
  const url = `${this.heroesUrl}/${hero.id}`;
  return this.http
    .put(url, JSON.stringify(hero), {headers: this.headers})
    .toPromise()
    .then(() =&gt; hero)
    .catch(this.handleError);
}
</code><p>We identify <em>which</em> hero the server should update by encoding the hero id in
the URL. The put body is the JSON string encoding of the hero, obtained by
calling <code>JSON.stringify</code>.  We identify the body content type
(<code>application/json</code>) in the request header.</p><span>
</span><p>Refresh the browser and give it a try. Changes to hero names should now persist.</p><span>
</span><h2 id="add-a-hero">Add a hero</h2><span>
</span><p>To add a new hero we need to know the hero&apos;s name. Let&apos;s use an input
element for that, paired with an add button.</p><span>
</span><p>Insert the following into the heroes component HTML, first thing after
the heading:</p><span>
</span><p>app/heroes.component.html (add)</p><code language="html" format="">&lt;div&gt;
  &lt;label&gt;Hero name:&lt;/label&gt; &lt;input #heroName /&gt;
  &lt;button (click)=&quot;add(heroName.value); heroName.value=&apos;&apos;&quot;&gt;
    Add
  &lt;/button&gt;
&lt;/div&gt;
</code><p>In response to a click event, we call the component&apos;s click handler and then
clear the input field so that it will be ready to use for another name.</p><span>
</span><p>app/heroes.component.ts (add)</p><code language="ts" format="">add(name: string): void {
  name = name.trim();
  if (!name) { return; }
  this.heroService.create(name)
    .then(hero =&gt; {
      this.heroes.push(hero);
      this.selectedHero = null;
    });
}
</code><p>When the given name is non-blank, the handler delegates creation of the
named hero to the hero service, and then adds the new hero to our array.</p><span>
</span><p>Go ahead, refresh the browser and create some new heroes!</p><span>
</span><h2 id="delete-a-hero">Delete a hero</h2><span>
</span><p>Too many heroes?
Let&apos;s add a delete button to each hero in the heroes view.</p><span>
</span><p>Add this button element to the heroes component HTML, right after the hero
name in the repeated <code>&lt;li&gt;</code> tag:</p><span>
</span><code language="html" format="">&lt;button class=&quot;delete&quot;
  (click)=&quot;delete(hero); $event.stopPropagation()&quot;&gt;x&lt;/button&gt;
</code><p>The <code>&lt;li&gt;</code> element should now look like this:</p><span>
</span><p>app/heroes.component.html (li-element)</p><code language="html" format="">  &lt;li *ngFor=&quot;let hero of heroes&quot; (click)=&quot;onSelect(hero)&quot;
      [class.selected]=&quot;hero === selectedHero&quot;&gt;
    &lt;span class=&quot;badge&quot;&gt;{{hero.id}}&lt;/span&gt;
    &lt;span&gt;{{hero.name}}&lt;/span&gt;
    &lt;button class=&quot;delete&quot;
      (click)=&quot;delete(hero); $event.stopPropagation()&quot;&gt;x&lt;/button&gt;
  &lt;/li&gt;
</code><p>In addition to calling the component&apos;s <code>delete</code> method, the delete button
click handling code stops the propagation of the click event &#x2014; we
don&apos;t want the <code>&lt;li&gt;</code> click handler to be triggered because that would
select the hero that we are going to delete!</p><span>
</span><p>The logic of the <code>delete</code> handler is a bit trickier:</p><span>
</span><p>app/heroes.component.ts (delete)</p><code language="ts" format="">delete(hero: Hero): void {
  this.heroService
      .delete(hero.id)
      .then(() =&gt; {
        this.heroes = this.heroes.filter(h =&gt; h !== hero);
        if (this.selectedHero === hero) { this.selectedHero = null; }
      });
}
</code><p>Of course, we delegate hero deletion to the hero service, but the component
is still responsible for updating the display: it removes the deleted hero
from the array and resets the selected hero if necessary.</p><span>
</span><p>We want our delete button to be placed at the far right of the hero entry.
This extra CSS accomplishes that:</p><span>
</span><p>app/heroes.component.css (additions)</p><code language="css" format="">button.delete {
  float:right;
  margin-top: 2px;
  margin-right: .8em;
  background-color: gray !important;
  color:white;
}
</code><h3 id="hero-service-delete-method">Hero service <code>delete</code> method</h3><span>
</span><p>The hero service&apos;s <code>delete</code> method uses the <em>delete</em> HTTP method to remove the hero from the server:</p><span>
</span><p>app/hero.service.ts (delete)</p><code language="ts" format="">delete(id: number): Promise&lt;void&gt; {
  let url = `${this.heroesUrl}/${id}`;
  return this.http.delete(url, {headers: this.headers})
    .toPromise()
    .then(() =&gt; null)
    .catch(this.handleError);
}
</code><p>Refresh the browser and try the new delete functionality.</p><span>
</span><h2 id="-_observable-s">Observables</h2><span>
</span><p>Each <code>Http</code> service method  returns an <code>Observable</code> of HTTP <code>Response</code> objects.</p><span>
</span><p>Our <code>HeroService</code> converts that <code>Observable</code> into a <code>Promise</code> and returns the promise to the caller.
In this section we learn to return the <code>Observable</code> directly and discuss when and why that might be
a good thing to do.</p><span>
</span><h3 id="background">Background</h3><span>
</span><p>An <em>observable</em> is a stream of events that we can process with array-like operators.</p><span>
</span><p>Angular core has basic support for observables. We developers augment that support with
operators and extensions from the <a href="http://reactivex.io/rxjs/">RxJS Observables</a> library.
We&apos;ll see how shortly.</p><span>
</span><p>Recall that our <code>HeroService</code> quickly chained the <code>toPromise</code> operator to the <code>Observable</code> result of <code>http.get</code>.
That operator converted the <code>Observable</code> into a <code>Promise</code> and we passed that promise back to the caller.</p><span>
</span><p>Converting to a promise is often a good choice. We typically ask <code>http.get</code> to fetch a single chunk of data.
When we receive the data, we&apos;re done.
A single result in the form of a promise is easy for the calling component to consume
and it helps that promises are widely understood by JavaScript programmers.</p><span>
</span><p>But requests aren&apos;t always &quot;one and done&quot;. We may start one request,
then cancel it, and make a different request before the server has responded to the first request.
Such a <em>request-cancel-new-request</em> sequence is difficult to implement with <em>Promises</em>.
It&apos;s easy with <em>Observables</em> as we&apos;ll see.</p><span>
</span><h3 id="search-by-name">Search-by-name</h3><span>
</span><p>We&apos;re going to add a <em>hero search</em> feature to the Tour of Heroes.
As the user types a name into a search box, we&apos;ll make repeated HTTP requests for heroes filtered by that name.</p><span>
</span><p>We start by creating <code>HeroSearchService</code> that sends search queries to our server&apos;s web api.</p><span>
</span><p>app/hero-search.service.ts</p><code language="ts" format="linenums">import { Injectable }     from &apos;@angular/core&apos;;
import { Http, Response } from &apos;@angular/http&apos;;
import { Observable } from &apos;rxjs&apos;;

import { Hero }           from &apos;./hero&apos;;

@Injectable()
export class HeroSearchService {

  constructor(private http: Http) {}

  search(term: string): Observable&lt;Hero[]&gt; {
    return this.http
               .get(`app/heroes/?name=${term}`)
               .map((r: Response) =&gt; r.json().data as Hero[]);
  }
}
</code><p>The <code>http.get()</code> call in <code>HeroSearchService</code> is similar to the one
in the <code>HeroService</code>, although the URL now has a query string.
<span if-docs="ts">Another notable difference: we no longer call <code>toPromise</code>,
we simply return the <em>observable</em> instead.</span></p><span>
</span><h3 id="herosearchcomponent">HeroSearchComponent</h3><span>
</span><p>Let&apos;s create a new <code>HeroSearchComponent</code> that calls this new <code>HeroSearchService</code>.</p><span>
</span><p>The component template is simple &#x2014; just a text box and a list of matching search results.</p><span>
</span><p>app/hero-search.component.html</p><code language="html" format="linenums">&lt;div id=&quot;search-component&quot;&gt;
  &lt;h4&gt;Hero Search&lt;/h4&gt;
  &lt;input #searchBox id=&quot;search-box&quot; (keyup)=&quot;search(searchBox.value)&quot; /&gt;
  &lt;div&gt;
    &lt;div *ngFor=&quot;let hero of heroes | async&quot;
         (click)=&quot;gotoDetail(hero)&quot; class=&quot;search-result&quot; &gt;
      {{hero.name}}
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;
</code><p>We&apos;ll also want to add styles for the new component.</p><span>
</span><p>app/hero-search.component.css</p><code language="css" format="linenums">.search-result{
  border-bottom: 1px solid gray;
  border-left: 1px solid gray;
  border-right: 1px solid gray;
  width:195px;
  height: 20px;
  padding: 5px;
  background-color: white;
  cursor: pointer;
}

#search-box{
  width: 200px;
  height: 20px;
}
</code><p>As the user types in the search box, a <em>keyup</em> event binding calls the component&apos;s <code>search</code> method with the new search box value.</p><span>
</span><p>The <code>*ngFor</code> repeats <em>hero</em> objects from the component&apos;s <code>heroes</code> property. No surprise there.</p><span>
</span><p>But, as we&apos;ll soon see, the <code>heroes</code> property is now an <em>Observable</em> of hero arrays, rather than just a hero array.
The <code>*ngFor</code> can&apos;t do anything with an <code>Observable</code> until we flow it through the <code>async</code> pipe (<code>AsyncPipe</code>).
The <code>async</code> pipe subscribes to the <code>Observable</code> and produces the array of heroes to <code>*ngFor</code>.</p><span>
</span><p>Time to create the <code>HeroSearchComponent</code> class and metadata.</p><span>
</span><p>app/hero-search.component.ts</p><code language="ts" format="linenums">import { Component, OnInit } from &apos;@angular/core&apos;;
import { Router }            from &apos;@angular/router&apos;;
import { Observable }        from &apos;rxjs/Observable&apos;;
import { Subject }           from &apos;rxjs/Subject&apos;;

import { HeroSearchService } from &apos;./hero-search.service&apos;;
import { Hero } from &apos;./hero&apos;;

@Component({
  selector: &apos;hero-search&apos;,
  templateUrl: &apos;app/hero-search.component.html&apos;,
  styleUrls:  [&apos;app/hero-search.component.css&apos;],
  providers: [HeroSearchService]
})
export class HeroSearchComponent implements OnInit {
  heroes: Observable&lt;Hero[]&gt;;
  private searchTerms = new Subject&lt;string&gt;();

  constructor(
    private heroSearchService: HeroSearchService,
    private router: Router) {}

  // Push a search term into the observable stream.
  search(term: string): void {
    this.searchTerms.next(term);
  }

  ngOnInit(): void {
    this.heroes = this.searchTerms
      .debounceTime(300)        // wait for 300ms pause in events
      .distinctUntilChanged()   // ignore if next search term is same as previous
      .switchMap(term =&gt; term   // switch to new observable each time
        // return the http search observable
        ? this.heroSearchService.search(term)
        // or the observable of empty heroes if no search term
        : Observable.of&lt;Hero[]&gt;([]))
      .catch(error =&gt; {
        // TODO: real error handling
        console.log(error);
        return Observable.of&lt;Hero[]&gt;([]);
      });
  }

  gotoDetail(hero: Hero): void {
    let link = [&apos;/detail&apos;, hero.id];
    this.router.navigate(link);
  }
}
</code><h4 id="search-terms">Search terms</h4><span>
</span><p>Let&apos;s focus on the <code>searchTerms</code>:</p><span>
</span><code language="ts" format="">private searchTerms = new Subject&lt;string&gt;();

// Push a search term into the observable stream.
search(term: string): void {
  this.searchTerms.next(term);
}
</code><p>A <code>Subject</code> is a producer of an <em>observable</em> event stream;
<code>searchTerms</code> produces an <code>Observable</code> of strings, the filter criteria for the name search.</p><span>
</span><p>Each call to <code>search</code> puts a new string into this subject&apos;s <em>observable</em> stream by calling <code>next</code>.</p><span>
</span><span>
</span><h4 id="initialize-the-_-heroes-_-property-_-ngoninit-_-">Initialize the <em><strong>heroes</strong></em> property (<em><strong>ngOnInit</strong></em>)</h4><span>
</span><p><span if-docs="ts">A <code>Subject</code> is also an <code>Observable</code>.</span>
We&apos;re going to turn the stream
of search terms into a stream of <code>Hero</code> arrays and assign the result to the <code>heroes</code> property.</p><span>
</span><code language="ts" format="">heroes: Observable&lt;Hero[]&gt;;

ngOnInit(): void {
  this.heroes = this.searchTerms
    .debounceTime(300)        // wait for 300ms pause in events
    .distinctUntilChanged()   // ignore if next search term is same as previous
    .switchMap(term =&gt; term   // switch to new observable each time
      // return the http search observable
      ? this.heroSearchService.search(term)
      // or the observable of empty heroes if no search term
      : Observable.of&lt;Hero[]&gt;([]))
    .catch(error =&gt; {
      // TODO: real error handling
      console.log(error);
      return Observable.of&lt;Hero[]&gt;([]);
    });
}
</code><p>If we passed every user keystroke directly to the <code>HeroSearchService</code>, we&apos;d unleash a storm of HTTP requests.
Bad idea. We don&apos;t want to tax our server resources and burn through our cellular network data plan.</p><span>
</span><p>Fortunately, we can chain <code>Observable</code> operators to the string <code>Observable</code> that reduce the request flow.
We&apos;ll make fewer calls to the <code>HeroSearchService</code> and still get timely results. Here&apos;s how:</p><span>
</span><ul>
<li><p><code>debounceTime(300)</code> waits until the flow of new string events pauses for 300 milliseconds
before passing along the latest string. We&apos;ll never make requests more frequently than 300ms.</p>
</li>
<li><p><code>distinctUntilChanged</code> ensures that we only send a request if the filter text changed.
There&apos;s no point in repeating a request for the same search term.</p>
</li>
<li><p><code>switchMap</code> calls our search service for each search term that makes it through the <code>debounce</code> and <code>distinctUntilChanged</code> gauntlet.
It cancels and discards previous search observables, returning only the latest search service observable.</p>
</li>
</ul><span>
</span><div class="l-sub-section"><p>The <a href="http://www.learnrxjs.io/operators/transformation/switchmap.html">switchMap operator</a>
(formerly known as &quot;flatMapLatest&quot;) is very clever.</p><span>
</span><p>Every qualifying key event can trigger an <code>http</code> method call.
Even with a 300ms pause between requests, we could have multiple HTTP requests in flight
and they may not return in the order sent.</p><span>
</span><p><code>switchMap</code> preserves the original request order while returning
 only the observable from the most recent <code>http</code> method call.
Results from prior calls are canceled and discarded.</p><span>
</span><p>We also short-circuit the <code>http</code> method call and return an observable containing an empty array
if the search text is empty.</p><span>
</span><p>Note that <em>canceling</em> the <code>HeroSearchService</code> observable won&apos;t actually abort a pending HTTP request
until the service supports that feature, a topic for another day.
We are content for now to discard unwanted results.</p><span>
</span></div><ul>
<li><code>catch</code> intercepts a failed observable.
Our simple example prints the error to the console; a real life application should do better.
Then we return an observable containing an empty array to clear the search result.</li>
</ul><span>
</span><h3 id="import-rxjs-operators">Import RxJS operators</h3><span>
</span><p>The RxJS operators are not available in Angular&apos;s base <code>Observable</code> implementation.
We have to extend  <code>Observable</code> by <em>importing</em> them.</p><span>
</span><p>We could extend <code>Observable</code> with just the operators we need here by
including the pertinent <code>import</code> statements at the top of this file.</p><span>
</span><div class="l-sub-section"><p>Many authorities say we should do just that.</p><span>
</span></div><p>We take a different approach in this example.
We combine all of the RxJS <code>Observable</code> extensions that <em>our entire app</em> requires into a single RxJS imports file.</p><span>
</span><p>app/rxjs-extensions.ts</p><code language="ts" format="">// Observable class extensions
import &apos;rxjs/add/observable/of&apos;;
import &apos;rxjs/add/observable/throw&apos;;

// Observable operators
import &apos;rxjs/add/operator/catch&apos;;
import &apos;rxjs/add/operator/debounceTime&apos;;
import &apos;rxjs/add/operator/distinctUntilChanged&apos;;
import &apos;rxjs/add/operator/do&apos;;
import &apos;rxjs/add/operator/filter&apos;;
import &apos;rxjs/add/operator/map&apos;;
import &apos;rxjs/add/operator/switchMap&apos;;
</code><p>We load them all at once by importing <code>rxjs-extensions</code> at the top of <code>AppModule</code>.</p><span>
</span><p>app/app.module.ts (rxjs-extensions)</p><code language="ts" format="">import &apos;./rxjs-extensions&apos;;
</code><h3 id="add-the-search-component-to-the-dashboard">Add the search component to the dashboard</h3><span>
</span><p>We add the hero search HTML element to the bottom of the <code>DashboardComponent</code> template.</p><span>
</span><p>app/dashboard.component.html</p><code language="html" format="">&lt;h3&gt;Top Heroes&lt;/h3&gt;
&lt;div class=&quot;grid grid-pad&quot;&gt;
  &lt;div *ngFor=&quot;let hero of heroes&quot; (click)=&quot;gotoDetail(hero)&quot; class=&quot;col-1-4&quot;&gt;
    &lt;div class=&quot;module hero&quot;&gt;
      &lt;h4&gt;{{hero.name}}&lt;/h4&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;
&lt;hero-search&gt;&lt;/hero-search&gt;
</code><p>Finally, we import <code>HeroSearchComponent</code> from 
<span ngio-ex="">hero-search.component.ts</span>
and add it to the <code>declarations</code> array:</p><span>
</span><p>app/app.module.ts (search)</p><code language="ts" format="">  declarations: [
    AppComponent,
    DashboardComponent,
    HeroDetailComponent,
    HeroesComponent,
    HeroSearchComponent
  ],
</code><p>Run the app again, go to the <em>Dashboard</em>, and enter some text in the search box.
At some point it might look like this.</p><span>
</span><figure class="image-display"><img src="https://angular.io/resources/images/devguide/toh/toh-hero-search.png" alt="Hero Search Component"></figure><h2 id="application-structure-and-code">Application structure and code</h2><span>
</span><p>Review the sample source code in the <live-example></live-example> for this chapter.
Verify that we have the following structure:</p><span>
</span><div class="filetree"><p>angular2-tour-of-heroes</p><div class="children"><p>app</p><div class="children"><p>app.component.ts</p><p>app.component.css</p><p>app.module.ts</p><p>app.routing.ts</p><p>dashboard.component.css</p><p>dashboard.component.html</p><p>dashboard.component.ts</p><p>hero.ts</p><p>hero-detail.component.css</p><p>hero-detail.component.html</p><p>hero-detail.component.ts</p><p>hero-search.component.html (new)</p><p>hero-search.component.css (new)</p><p>hero-search.component.ts (new)</p><p>hero-search.service.ts (new)</p><p>rxjs-extensions.ts</p><p>hero.service.ts</p><p>heroes.component.css</p><p>heroes.component.html</p><p>heroes.component.ts</p><p>main.ts</p><p>in-memory-data.service.ts (new)</p></div><p>node_modules ...</p><p>typings ...</p><p>index.html</p><p>package.json</p><p>styles.css</p><p>systemjs.config.js</p><p>tsconfig.json</p><p>typings.json</p></div></div><h2 id="home-stretch">Home Stretch</h2><span>
</span><p>We are at the end of our journey for now, but we have accomplished a lot.</p><span>
</span><ul>
<li>We added the necessary dependencies to use HTTP in our application.</li>
<li>We refactored <code>HeroService</code> to load heroes from a web API.</li>
<li>We extended <code>HeroService</code> to support post, put and delete methods.</li>
<li>We updated our components to allow adding, editing and deleting of heroes.</li>
<li>We configured an in-memory web API.</li>
<li>We learned how to use Observables.</li>
</ul><span>
</span><p>Here are the files we added or changed in this chapter.</p><span>
</span><code-tabs><code language="ts" name="app.comp...ts" format="linenums">import { Component }          from &apos;@angular/core&apos;;

@Component({
  selector: &apos;my-app&apos;,

  template: `
    &lt;h1&gt;{{title}}&lt;/h1&gt;
    &lt;nav&gt;
      &lt;a routerLink=&quot;/dashboard&quot; routerLinkActive=&quot;active&quot;&gt;Dashboard&lt;/a&gt;
      &lt;a routerLink=&quot;/heroes&quot; routerLinkActive=&quot;active&quot;&gt;Heroes&lt;/a&gt;
    &lt;/nav&gt;
    &lt;router-outlet&gt;&lt;/router-outlet&gt;
  `,
  styleUrls: [&apos;app/app.component.css&apos;]
})
export class AppComponent {
  title = &apos;Tour of Heroes&apos;;
}
</code><code language="ts" name="app.mod...ts" format="linenums">import &apos;./rxjs-extensions&apos;;

import { NgModule }      from &apos;@angular/core&apos;;
import { BrowserModule } from &apos;@angular/platform-browser&apos;;
import { FormsModule }   from &apos;@angular/forms&apos;;
import { HttpModule }    from &apos;@angular/http&apos;;

// Imports for loading &amp; configuring the in-memory web api
import { InMemoryWebApiModule } from &apos;angular2-in-memory-web-api&apos;;
import { InMemoryDataService }  from &apos;./in-memory-data.service&apos;;

import { AppComponent }         from &apos;./app.component&apos;;
import { DashboardComponent }   from &apos;./dashboard.component&apos;;
import { HeroesComponent }      from &apos;./heroes.component&apos;;
import { HeroDetailComponent }  from &apos;./hero-detail.component&apos;;
import { HeroService }          from &apos;./hero.service&apos;;
import { HeroSearchComponent }  from &apos;./hero-search.component&apos;;
import { routing }              from &apos;./app.routing&apos;;

@NgModule({
  imports: [
    BrowserModule,
    FormsModule,
    HttpModule,
    InMemoryWebApiModule.forRoot(InMemoryDataService),
    routing
  ],
  declarations: [
    AppComponent,
    DashboardComponent,
    HeroDetailComponent,
    HeroesComponent,
    HeroSearchComponent
  ],
  providers: [
    HeroService,
  ],
  bootstrap: [ AppComponent ]
})
export class AppModule {
}
</code><code language="ts" name="heroes.comp...ts" format="linenums">import { Component, OnInit } from &apos;@angular/core&apos;;
import { Router }            from &apos;@angular/router&apos;;

import { Hero }                from &apos;./hero&apos;;
import { HeroService }         from &apos;./hero.service&apos;;

@Component({
  selector: &apos;my-heroes&apos;,
  templateUrl: &apos;app/heroes.component.html&apos;,
  styleUrls:  [&apos;app/heroes.component.css&apos;]
})
export class HeroesComponent implements OnInit {
  heroes: Hero[];
  selectedHero: Hero;

  constructor(
    private heroService: HeroService,
    private router: Router) { }

  getHeroes(): void {
    this.heroService
        .getHeroes()
        .then(heroes =&gt; this.heroes = heroes);
  }

  add(name: string): void {
    name = name.trim();
    if (!name) { return; }
    this.heroService.create(name)
      .then(hero =&gt; {
        this.heroes.push(hero);
        this.selectedHero = null;
      });
  }

  delete(hero: Hero): void {
    this.heroService
        .delete(hero.id)
        .then(() =&gt; {
          this.heroes = this.heroes.filter(h =&gt; h !== hero);
          if (this.selectedHero === hero) { this.selectedHero = null; }
        });
  }

  ngOnInit(): void {
    this.getHeroes();
  }

  onSelect(hero: Hero): void {
    this.selectedHero = hero;
  }

  gotoDetail(): void {
    this.router.navigate([&apos;/detail&apos;, this.selectedHero.id]);
  }
}
</code><code language="html" name="heroes.comp...html" format="linenums">&lt;h2&gt;My Heroes&lt;/h2&gt;
&lt;div&gt;
  &lt;label&gt;Hero name:&lt;/label&gt; &lt;input #heroName /&gt;
  &lt;button (click)=&quot;add(heroName.value); heroName.value=&apos;&apos;&quot;&gt;
    Add
  &lt;/button&gt;
&lt;/div&gt;
&lt;ul class=&quot;heroes&quot;&gt;
  &lt;li *ngFor=&quot;let hero of heroes&quot; (click)=&quot;onSelect(hero)&quot;
      [class.selected]=&quot;hero === selectedHero&quot;&gt;
    &lt;span class=&quot;badge&quot;&gt;{{hero.id}}&lt;/span&gt;
    &lt;span&gt;{{hero.name}}&lt;/span&gt;
    &lt;button class=&quot;delete&quot;
      (click)=&quot;delete(hero); $event.stopPropagation()&quot;&gt;x&lt;/button&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;div *ngIf=&quot;selectedHero&quot;&gt;
  &lt;h2&gt;
    {{selectedHero.name | uppercase}} is my hero
  &lt;/h2&gt;
  &lt;button (click)=&quot;gotoDetail()&quot;&gt;View Details&lt;/button&gt;
&lt;/div&gt;
</code><code language="css" name="heroes.comp...css" format="linenums">.selected {
  background-color: #CFD8DC !important;
  color: white;
}
.heroes {
  margin: 0 0 2em 0;
  list-style-type: none;
  padding: 0;
  width: 15em;
}
.heroes li {
  cursor: pointer;
  position: relative;
  left: 0;
  background-color: #EEE;
  margin: .5em;
  padding: .3em 0;
  height: 1.6em;
  border-radius: 4px;
}
.heroes li:hover {
  color: #607D8B;
  background-color: #DDD;
  left: .1em;
}
.heroes li.selected:hover {
  background-color: #BBD8DC !important;
  color: white;
}
.heroes .text {
  position: relative;
  top: -3px;
}
.heroes .badge {
  display: inline-block;
  font-size: small;
  color: white;
  padding: 0.8em 0.7em 0 0.7em;
  background-color: #607D8B;
  line-height: 1em;
  position: relative;
  left: -1px;
  top: -4px;
  height: 1.8em;
  margin-right: .8em;
  border-radius: 4px 0 0 4px;
}
button {
  font-family: Arial;
  background-color: #eee;
  border: none;
  padding: 5px 10px;
  border-radius: 4px;
  cursor: pointer;
  cursor: hand;
}
button:hover {
  background-color: #cfd8dc;
}
button.delete {
  float:right;
  margin-top: 2px;
  margin-right: .8em;
  background-color: gray !important;
  color:white;
}
</code><code language="ts" name="hero-detail.comp...ts" format="linenums">import { Component, OnInit } from &apos;@angular/core&apos;;
import { ActivatedRoute, Params } from &apos;@angular/router&apos;;

import { Hero }        from &apos;./hero&apos;;
import { HeroService } from &apos;./hero.service&apos;;

@Component({
  selector: &apos;my-hero-detail&apos;,
  templateUrl: &apos;app/hero-detail.component.html&apos;,
  styleUrls: [&apos;app/hero-detail.component.css&apos;]
})
export class HeroDetailComponent implements OnInit {
  hero: Hero;

  constructor(
    private heroService: HeroService,
    private route: ActivatedRoute) {
  }

  ngOnInit(): void {
    this.route.params.forEach((params: Params) =&gt; {
      let id = +params[&apos;id&apos;];
      this.heroService.getHero(id)
        .then(hero =&gt; this.hero = hero);
    });
  }

  save(): void {
    this.heroService.update(this.hero)
      .then(this.goBack);
  }

  goBack(): void {
    window.history.back();
  }
}
</code><code language="html" name="hero-detail.comp...html" format="linenums">&lt;div *ngIf=&quot;hero&quot;&gt;
  &lt;h2&gt;{{hero.name}} details!&lt;/h2&gt;
  &lt;div&gt;
    &lt;label&gt;id: &lt;/label&gt;{{hero.id}}&lt;/div&gt;
  &lt;div&gt;
    &lt;label&gt;name: &lt;/label&gt;
    &lt;input [(ngModel)]=&quot;hero.name&quot; placeholder=&quot;name&quot; /&gt;
   &lt;/div&gt;
  &lt;button (click)=&quot;goBack()&quot;&gt;Back&lt;/button&gt;
  &lt;button (click)=&quot;save()&quot;&gt;Save&lt;/button&gt;
&lt;/div&gt;
</code><code language="ts" name="hero.service.ts" format="linenums">import { Injectable }    from &apos;@angular/core&apos;;
import { Headers, Http } from &apos;@angular/http&apos;;

import &apos;rxjs/add/operator/toPromise&apos;;

import { Hero } from &apos;./hero&apos;;

@Injectable()
export class HeroService {

  private headers = new Headers({&apos;Content-Type&apos;: &apos;application/json&apos;});
  private heroesUrl = &apos;app/heroes&apos;;  // URL to web api

  constructor(private http: Http) { }

  getHeroes(): Promise&lt;Hero[]&gt; {
    return this.http.get(this.heroesUrl)
               .toPromise()
               .then(response =&gt; response.json().data as Hero[])
               .catch(this.handleError);
  }

  getHero(id: number): Promise&lt;Hero&gt; {
    return this.getHeroes()
               .then(heroes =&gt; heroes.find(hero =&gt; hero.id === id));
  }

  delete(id: number): Promise&lt;void&gt; {
    let url = `${this.heroesUrl}/${id}`;
    return this.http.delete(url, {headers: this.headers})
      .toPromise()
      .then(() =&gt; null)
      .catch(this.handleError);
  }

  create(name: string): Promise&lt;Hero&gt; {
    return this.http
      .post(this.heroesUrl, JSON.stringify({name: name}), {headers: this.headers})
      .toPromise()
      .then(res =&gt; res.json().data)
      .catch(this.handleError);
  }

  update(hero: Hero): Promise&lt;Hero&gt; {
    const url = `${this.heroesUrl}/${hero.id}`;
    return this.http
      .put(url, JSON.stringify(hero), {headers: this.headers})
      .toPromise()
      .then(() =&gt; hero)
      .catch(this.handleError);
  }

  private handleError(error: any): Promise&lt;any&gt; {
    console.error(&apos;An error occurred&apos;, error); // for demo purposes only
    return Promise.reject(error.message || error);
  }
}
</code><code language="ts" name="in-memory-data.service.ts" format="linenums">import { InMemoryDbService } from &apos;angular2-in-memory-web-api&apos;;
export class InMemoryDataService implements InMemoryDbService {
  createDb() {
    let heroes = [
      {id: 11, name: &apos;Mr. Nice&apos;},
      {id: 12, name: &apos;Narco&apos;},
      {id: 13, name: &apos;Bombasto&apos;},
      {id: 14, name: &apos;Celeritas&apos;},
      {id: 15, name: &apos;Magneta&apos;},
      {id: 16, name: &apos;RubberMan&apos;},
      {id: 17, name: &apos;Dynama&apos;},
      {id: 18, name: &apos;Dr IQ&apos;},
      {id: 19, name: &apos;Magma&apos;},
      {id: 20, name: &apos;Tornado&apos;}
    ];
    return {heroes};
  }
}
</code></code-tabs><code-tabs><code language="ts" name="hero-search.service.ts" format="linenums">import { Injectable }     from &apos;@angular/core&apos;;
import { Http, Response } from &apos;@angular/http&apos;;
import { Observable } from &apos;rxjs&apos;;

import { Hero }           from &apos;./hero&apos;;

@Injectable()
export class HeroSearchService {

  constructor(private http: Http) {}

  search(term: string): Observable&lt;Hero[]&gt; {
    return this.http
               .get(`app/heroes/?name=${term}`)
               .map((r: Response) =&gt; r.json().data as Hero[]);
  }
}
</code><code language="ts" name="hero-search.component.ts" format="linenums">import { Component, OnInit } from &apos;@angular/core&apos;;
import { Router }            from &apos;@angular/router&apos;;
import { Observable }        from &apos;rxjs/Observable&apos;;
import { Subject }           from &apos;rxjs/Subject&apos;;

import { HeroSearchService } from &apos;./hero-search.service&apos;;
import { Hero } from &apos;./hero&apos;;

@Component({
  selector: &apos;hero-search&apos;,
  templateUrl: &apos;app/hero-search.component.html&apos;,
  styleUrls:  [&apos;app/hero-search.component.css&apos;],
  providers: [HeroSearchService]
})
export class HeroSearchComponent implements OnInit {
  heroes: Observable&lt;Hero[]&gt;;
  private searchTerms = new Subject&lt;string&gt;();

  constructor(
    private heroSearchService: HeroSearchService,
    private router: Router) {}

  // Push a search term into the observable stream.
  search(term: string): void {
    this.searchTerms.next(term);
  }

  ngOnInit(): void {
    this.heroes = this.searchTerms
      .debounceTime(300)        // wait for 300ms pause in events
      .distinctUntilChanged()   // ignore if next search term is same as previous
      .switchMap(term =&gt; term   // switch to new observable each time
        // return the http search observable
        ? this.heroSearchService.search(term)
        // or the observable of empty heroes if no search term
        : Observable.of&lt;Hero[]&gt;([]))
      .catch(error =&gt; {
        // TODO: real error handling
        console.log(error);
        return Observable.of&lt;Hero[]&gt;([]);
      });
  }

  gotoDetail(hero: Hero): void {
    let link = [&apos;/detail&apos;, hero.id];
    this.router.navigate(link);
  }
}
</code><code language="html" name="hero-search.component.html" format="linenums">&lt;div id=&quot;search-component&quot;&gt;
  &lt;h4&gt;Hero Search&lt;/h4&gt;
  &lt;input #searchBox id=&quot;search-box&quot; (keyup)=&quot;search(searchBox.value)&quot; /&gt;
  &lt;div&gt;
    &lt;div *ngFor=&quot;let hero of heroes | async&quot;
         (click)=&quot;gotoDetail(hero)&quot; class=&quot;search-result&quot; &gt;
      {{hero.name}}
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;
</code><code language="css" name="hero-search.component.css" format="linenums">.search-result{
  border-bottom: 1px solid gray;
  border-left: 1px solid gray;
  border-right: 1px solid gray;
  width:195px;
  height: 20px;
  padding: 5px;
  background-color: white;
  cursor: pointer;
}

#search-box{
  width: 200px;
  height: 20px;
}
</code><code language="ts" name="rxjs-extensions.ts" format="linenums">// Observable class extensions
import &apos;rxjs/add/observable/of&apos;;
import &apos;rxjs/add/observable/throw&apos;;

// Observable operators
import &apos;rxjs/add/operator/catch&apos;;
import &apos;rxjs/add/operator/debounceTime&apos;;
import &apos;rxjs/add/operator/distinctUntilChanged&apos;;
import &apos;rxjs/add/operator/do&apos;;
import &apos;rxjs/add/operator/filter&apos;;
import &apos;rxjs/add/operator/map&apos;;
import &apos;rxjs/add/operator/switchMap&apos;;
</code></code-tabs><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--></div></div>
        </article>
      <h2></h2>
        <article>
          <h3>Documentation Overview</h3>
          <div><div class="showcase-content"><!-- #docregion intro--><figure><img src="https://angular.io/resources/images/devguide/intro/people.png" alt="Us" align="left"></figure><p>This is a practical guide to Angular for experienced programmers who
are building client applications in HTML and TypeScript.</p><span>
</span><span>
</span><!-- #enddocregion intro--><!-- #docregion how-to-read-1--><a id="learning-path"></a><h1 id="organization">Organization</h1><span>
</span><p>The documentation is divided into major thematic sections, each
a collection of pages devoted to that theme.</p><span>
</span><!-- #enddocregion how-to-read-1--><!-- #docregion how-to-read-2--><table width="100%"><colgroup><col width="15%"><col></colgroup><tbody><tr><td><b>QuickStart</b></td><td><p>The foundation for every page and sample in this documentation.</p>
</td></tr><tr><td><b>Tutorial</b></td><td><p>A step-by-step, immersive approach to learning Angular that
introduces the major features of Angular in an application context.</p>
</td></tr><tr><td><b>Basics</b></td><td><p>The essential ingredients of Angular development.</p>
</td></tr><tr><td><b>Developer Guide</b></td><td><p>In-depth analysis of Angular features and development practices.</p>
</td></tr><tr><td><b>Cookbook</b></td><td><p>Recipes for specific application challenges, mostly code snippets with a minimum of exposition.</p>
</td></tr><tr><td><b>API Reference</b></td><td><p>Authoritative details about each member of the Angular libraries.</p>
</td></tr></tbody></table><h1 id="learning-path">Learning path</h1><span>
</span><p>You don&apos;t have to read the guide straight through.  Most pages stand on their own.</p><span>
</span><p>For those new to Angular, the recommended learning path runs through the <em>Basics</em> section:</p><span>
</span><ol>
<li><p>For the big picture, read the <a href="https://angular.io/docs/ts/latest/guide/architecture.html">Architecture</a> overview.</p>
</li>
<li><p>Try <a href="https://angular.io/docs/ts/latest/quickstart.html">QuickStart</a>. QuickStart is the &quot;Hello, World&quot; of Angular 2.
It shows you how to set up the libraries and tools you&apos;ll need to write <em>any</em> Angular app.</p>
</li>
<li><p>Take the <em>Tour of Heroes</em> <a href="https://angular.io/docs/ts/latest/tutorial">tutorial</a>, which picks up where QuickStart leaves off,
and builds a simple data-driven app. The app demonstrates the essential characteristics of a professional application:
a sensible project structure, data binding, master/detail, services, dependency injection, navigation, and remote data access.</p>
</li>
<li><p><a href="https://angular.io/docs/ts/latest/guide/displaying-data.html">Displaying Data</a> explains how to display information on the screen.</p>
</li>
<li><p><a href="https://angular.io/docs/ts/latest/guide/user-input.html">User Input</a> covers how Angular responds to user behavior.</p>
</li>
<li><p><a href="https://angular.io/docs/ts/latest/guide/forms.html">Forms</a> handles user data entry and validation within the UI.</p>
</li>
<li><p><a href="https://angular.io/docs/ts/latest/guide/dependency-injection.html">Dependency Injection</a> is the way to build large, maintainable applications
from small, single-purpose parts.</p>
</li>
<li><p><a href="https://angular.io/docs/ts/latest/guide/template-syntax.html">Template Syntax</a> is a comprehensive study of Angular template HTML.</p>
</li>
</ol><span>
</span><p>After reading the above sections, you can skip to any other pages on this site.</p><span>
</span><!-- #enddocregion how-to-read-2--><!-- #docregion the-rest--><h1 id="code-samples">Code samples</h1><span>
</span><p>Each page includes code snippets that you can reuse in your applications.
These snippets are excerpts from a sample application that accompanies the page.</p><span>
</span><p>Look for a link to a running version of that sample near the top of each page,
such as this <live-example name="architecture"></live-example> from the <a href="https://angular.io/docs/ts/latest/guide/architecture.html">Architecture</a> page.</p><span>
</span><p>The link launches a browser-based code editor where you can inspect, modify, save, and download the code.</p><span>
</span><p>A few early pages are written as tutorials and are clearly marked as such.
The rest of the pages highlight key points in code rather than explain each step necessary to build the sample.
You can always get the full source through the live link.</p><span>
</span><h1 id="reference-pages">Reference pages</h1><span>
</span><p>The <a href="https://angular.io/docs/ts/latest/guide/cheatsheet.html">Cheat Sheet</a> lists Angular syntax for common scenarios.</p><span>
</span><p>The <a href="https://angular.io/docs/ts/latest/guide/glossary.html">Glossary</a> defines terms that Angular developers should know.</p><span>
</span><p>The <a href="https://angular.io/docs/ts/latest/api/">API Reference</a> is the authority on every public-facing member of the Angular libraries.</p><span>
</span><h1 id="feedback">Feedback</h1><span>
</span><p>We welcome feedback! </p><span>
</span><p>Use the <a href="https://github.com/angular/angular.io">angular.io Github repo</a> for <strong>documentation</strong> issues and pull requests.</p><span>
</span><p>Use the <a href="https://github.com/angular/angular">Angular Github repo</a> to report issues with <strong>Angular 2</strong> itself.</p><span>
</span><!-- #enddocregion the-rest--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!--NEXT PAGE HAS NOW BEEN SET--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--></div></div>
        </article>
      
        <article>
          <h3>Architecture Overview</h3>
          <div><div class="showcase-content"><p>Angular 2 is a framework for building client applications in HTML and
either JavaScript or a language (like Dart or TypeScript) that compiles to JavaScript.</p><span>
</span><p>The framework consists of several libraries, some of them core and some optional.</p><span>
</span><p>You write Angular applications by composing HTML <em>templates</em> with Angularized markup,
writing <em>component</em> classes to manage those templates, adding application logic in <em>services</em>,
and boxing components and services in <em>modules</em>.</p><span>
</span><p>Then you launch the app by <em>bootstrapping</em> the <em>root module</em>.
Angular takes over, presenting your application content in a browser and
responding to user interactions according to the instructions you&apos;ve provided.</p><span>
</span><p>Of course, there is more to it than this.
You&apos;ll learn the details in the pages that follow. For now, focus on the big picture.</p><span>
</span><figure><img src="https://angular.io/resources/images/devguide/architecture/overview2.png" alt="overview" width="700"></figure><p>The architecture diagram identifies the eight main building blocks of an Angular 2 application:</p><span>
</span><ul>
<li><a href="https://angular.io/docs/ts/latest/guide/architecture.html#modules">Modules</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/architecture.html#components">Components</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/architecture.html#templates">Templates</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/architecture.html#metadata">Metadata</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/architecture.html#data-binding">Data binding</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/architecture.html#directives">Directives</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/architecture.html#services">Services</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/architecture.html#dependency-injection">Dependency injection</a></li>
</ul><span>
</span><p>Learn these building blocks, and you&apos;re on your way.</p><span>
</span><div class="l-sub-section"><p>The code referenced on this page is available as a <a href="https://angular.io/resources/live-examples/architecture/ts/plnkr.html" target="_blank">live example</a>.</p></div><h2 id="modules">Modules</h2><span>
</span><figure><img src="https://angular.io/resources/images/devguide/architecture/module.png" alt="Component" align="left"></figure><p>Angular apps are modular and Angular has its own modularity system called <em>Angular modules</em> or <em>NgModules</em>.</p><span>
</span><p><em>Angular modules</em> are a big deal. 
This page introduces modules; the <a href="https://angular.io/docs/ts/latest/guide/ngmodule.html">Angular modules</a> page covers them in depth.</p><span>
</span><br clear="all"><p>Every Angular app has at least one module, the <em>root module</em>, conventionally named <code>AppModule</code>.</p><span>
</span><p>While the <em>root module</em> may be the only module in a small application, most apps have many more 
<em>feature modules</em>, each a cohesive block of code dedicated to an application domain,
a workflow, or a closely related set of capabilities. </p><span>
</span><p>An Angular module, whether a <em>root</em> or <em>feature</em>, is a class with an <code>@NgModule</code> decorator.</p><span>
</span><div class="l-sub-section"><p>Decorators are functions that modify JavaScript classes.
Angular has many decorators that attach metadata to classes so that it knows
what those classes mean and how they should work.
<a href="https://medium.com/google-developers/exploring-es7-decorators-76ecb65fb841#.x5c2ndtx0" target="_blank">
Learn more</a> about decorators on the web.</p><span>
</span></div><p><code>NgModule</code> is a decorator function that takes a single metadata object whose properties describe the module. 
The most important properties are:</p><span>
</span><ul>
<li><p><code>declarations</code> - the <em>view classes</em> that belong to this module.
Angular has three kinds of view classes: <a href="https://angular.io/docs/ts/latest/guide/architecture.html#components">components</a>, <a href="https://angular.io/docs/ts/latest/guide/architecture.html#directives">directives</a>, and <a href="https://angular.io/docs/ts/latest/guide/pipes.html">pipes</a>.</p>
</li>
<li><p><code>exports</code> - the subset of declarations that should be visible and usable in the component <a href="https://angular.io/docs/ts/latest/guide/architecture.html#templates">templates</a> of other modules.</p>
</li>
<li><p><code>imports</code> - other modules whose exported classes are needed by component templates declared in <em>this</em> module.</p>
</li>
<li><p><code>providers</code> - creators of <a href="https://angular.io/docs/ts/latest/guide/architecture.html#services">services</a> that this module contributes to
the global collection of services; they become accessible in all parts of the app.</p>
</li>
<li><p><code>bootstrap</code> - the main application view, called the <em>root component</em>, 
that hosts all other app views. Only the <em>root module</em> should set this <code>bootstrap</code> property.</p>
</li>
</ul><span>
</span><p>Here&apos;s a simple root module:</p><span>
</span><p>app/app.module.ts</p><code language="ts" format="">import { NgModule }      from &apos;@angular/core&apos;;
import { BrowserModule } from &apos;@angular/platform-browser&apos;;
@NgModule({
  imports:      [ BrowserModule ],
  providers:    [ Logger ],
  declarations: [ AppComponent ],
  exports:      [ AppComponent ],
  bootstrap:    [ AppComponent ]
})
export class AppModule { }
</code><div class="l-sub-section"><p>The <code>export</code> of <code>AppComponent</code> is just to show how to export; it isn&apos;t actually necessary in this example. A root module has no reason to <em>export</em> anything because other components don&apos;t need to <em>import</em> the root module. </p><span>
</span></div><p>Launch an application by <em>bootstrapping</em> its root module. 
During development you&apos;re likely to bootstrap the <code>AppModule</code> in a <code>main.ts</code> file like this one.</p><span>
</span><p>app/main.ts</p><code language="ts" format="">import { platformBrowserDynamic } from &apos;@angular/platform-browser-dynamic&apos;;
import { AppModule } from &apos;./app.module&apos;;

platformBrowserDynamic().bootstrapModule(AppModule);
</code><h3 id="angular-modules-vs-javascript-modules">Angular modules vs. JavaScript modules</h3><span>
</span><p>The Angular module &#x2014; a class decorated with <code>@NgModule</code> &#x2014; is a fundamental feature of Angular.</p><span>
</span><p>JavaScript also has its own module system for managing collections of JavaScript objects.
It&apos;s completely different and unrelated to the Angular module system.</p><span>
</span><p>In JavaScript each <em>file</em> is a module and all objects defined in the file belong to that module.
The module declares some objects to be public by marking them with the <code>export</code> key word. 
Other JavaScript modules use <em>import statements</em> to access public objects from other modules.</p><span>
</span><code language="ts" format="">import { NgModule }     from &apos;@angular/core&apos;;
import { AppComponent } from &apos;./app.component&apos;;
</code><code language="ts" format="">export class AppModule { }
</code><p>These are two different and <em>complementary</em> module systems. Use them both to write your apps.</p><span>
</span><h3 id="angular-libraries">Angular libraries</h3><span>
</span><figure><img src="https://angular.io/resources/images/devguide/architecture/library-module.png" alt="Component" align="left"></figure><p>Angular ships as a collection of JavaScript modules. You can think of them as library modules. </p><span>
</span><p>Each Angular library name begins with the <code>@angular</code> prefix.</p><span>
</span><p>You install them with the <strong>npm</strong> package manager and import parts of them with JavaScript <code>import</code> statements.</p><span>
</span><br clear="all"><p>For example, import Angular&apos;s <code>Component</code> decorator from the <code>@angular/core</code> library like this:</p><span>
</span><code language="ts" format="">import { Component } from &apos;@angular/core&apos;;
</code><p>You also import Angular <em>modules</em> from Angular <em>libraries</em> using JavaScript import statements:</p><span>
</span><code language="ts" format="">import { BrowserModule } from &apos;@angular/platform-browser&apos;;
</code><p>In the example of the simple root module above, the application module needs material from within that <code>BrowserModule</code>. To access that material, add it to the <code>@NgModule</code> metadata <code>imports</code> like this.</p><span>
</span><code language="ts" format="">imports:      [ BrowserModule ],
</code><p>In this way you&apos;re using both the Angular and JavaScript module systems <em>together</em>.</p><span>
</span><p>It&apos;s easy to confuse the two systems because they share the common vocabulary of &quot;imports&quot; and &quot;exports&quot;.
Hang in there. The confusion yields to clarity with time and experience.</p><span>
</span><h2 id="components">Components</h2><span>
</span><figure><img src="https://angular.io/resources/images/devguide/architecture/hero-component.png" alt="Component" align="left"></figure><p>A <em>component</em> controls a patch of screen called a <em>view</em>.</p><span>
</span><p>For example, the following views are controlled by components:</p><span>
</span><ul>
<li>The app root with the navigation links.</li>
<li>The list of heroes.</li>
<li>The hero editor.</li>
</ul><span>
</span><p>You define a component&apos;s application logic&#x2014;what it does to support the view&#x2014;inside a class.
The class interacts with the view through an API of properties and methods.</p><span>
</span><p><a id="component-code"></a>
For example, this <code>HeroListComponent</code> has a <code>heroes</code> property that returns an array of heroes
that it acquires from a service.
<code>HeroListComponent</code> also has a <code>selectHero()</code> method that sets a <code>selectedHero</code> property when the user clicks to choose a hero from that list.</p><span>
</span><p>app/hero-list.component.ts (class)</p><code language="ts" format="">export class HeroListComponent implements OnInit {
  heroes: Hero[];
  selectedHero: Hero;

  constructor(private service: HeroService) { }

  ngOnInit() {
    this.heroes = this.service.getHeroes();
  }

  selectHero(hero: Hero) { this.selectedHero = hero; }
}
</code><p>Angular creates, updates, and destroys components as the user moves through the application.
Your app can take action at each moment in this lifecycle through optional <a href="https://angular.io/docs/ts/latest/guide/lifecycle-hooks.html">lifecycle hooks</a>, like <code>ngOnInit()</code> declared above.</p><span>
</span><h2 id="templates">Templates</h2><span>
</span><figure><img src="https://angular.io/resources/images/devguide/architecture/template.png" alt="Template" align="left"></figure><p>You define a component&apos;s view with its companion <strong>template</strong>. A template is a form of HTML
that tells Angular how to render the component.</p><span>
</span><p>A template looks like regular HTML, except for a few differences. Here is a
template for our <code>HeroListComponent</code>:</p><span>
</span><p>app/hero-list.component.html</p><code language="html" format="linenums">&lt;h2&gt;Hero List&lt;/h2&gt;

&lt;p&gt;&lt;i&gt;Pick a hero from the list&lt;/i&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li *ngFor=&quot;let hero of heroes&quot; (click)=&quot;selectHero(hero)&quot;&gt;
    {{hero.name}}
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hero-detail *ngIf=&quot;selectedHero&quot; [hero]=&quot;selectedHero&quot;&gt;&lt;/hero-detail&gt;
</code><p>Although this template uses typical HTML elements like <code>&lt;h2&gt;</code> and  <code>&lt;p&gt;</code>, it also has some differences. Code like <code>*ngFor</code>, <code>{{hero.name}}</code>, <code>(click)</code>, <code>[hero]</code>, and <code>&lt;hero-detail&gt;</code> uses Angular&apos;s <a href="https://angular.io/docs/ts/latest/guide/template-syntax.html">template syntax</a>.</p><span>
</span><p>In the last line of the template, the <code>&lt;hero-detail&gt;</code> tag is a custom element that represents a new component, <code>HeroDetailComponent</code>.</p><span>
</span><p>The <code>HeroDetailComponent</code> is a <em>different</em> component than the <code>HeroListComponent</code> you&apos;ve been reviewing.
The <code>HeroDetailComponent</code> (code not shown) presents facts about a particular hero, the
hero that the user selects from the list presented by the <code>HeroListComponent</code>.
The <code>HeroDetailComponent</code> is a <strong>child</strong> of the <code>HeroListComponent</code>.</p><span>
</span><figure><img src="https://angular.io/resources/images/devguide/architecture/component-tree.png" alt="Metadata" align="left"></figure><p>Notice how <code>&lt;hero-detail&gt;</code> rests comfortably among native HTML elements. Custom components mix seamlessly with native HTML in the same layouts.</p><span>
</span><br clear="all"><span>
</span><figure><img src="https://angular.io/resources/images/devguide/architecture/metadata.png" alt="Metadata" align="left"></figure><p>Metadata tells Angular how to process a class.</p><span>
</span><p><a href="https://angular.io/docs/ts/latest/guide/architecture.html#component-code">Looking back at the code</a> for <code>HeroListComponent</code>, you can see that it&apos;s just a class.
There is no evidence of a framework, no &quot;Angular&quot; in it at all.</p><span>
</span><p>In fact, <code>HeroListComponent</code> really is <em>just a class</em>. It&apos;s not a component until you <em>tell Angular about it</em>.</p><span>
</span><p>To tell Angular that <code>HeroListComponent</code> is a component, attach <strong>metadata</strong> to the class.</p><span>
</span><p>In TypeScript, you attach metadata by using a <strong>decorator</strong>.
Here&apos;s some metadata for <code>HeroListComponent</code>:</p><span>
</span><p>app/hero-list.component.ts (metadata)</p><code language="ts" format="">@Component({
  selector:    &apos;hero-list&apos;,
  templateUrl: &apos;app/hero-list.component.html&apos;,
  providers:   [ HeroService ]
})
export class HeroListComponent implements OnInit {
/* . . . */
}
</code><p>Here is the <code>@Component</code> decorator, which identifies the class
immediately below it as a component class.</p><span>
</span><p>The <code>@Component</code> decorator takes a required configuration object with the
information Angular needs to create and present the component and its view.</p><span>
</span><p>Here are a few of the possible <code>@Component</code> configuration options:</p><span>
</span><ul>
<li><p><code>selector</code>: CSS selector that tells Angular to create and insert an instance of this component
where it finds a <code>&lt;hero-list&gt;</code> tag in <em>parent</em> HTML.
For example, if an app&apos;s  HTML contains <code>&lt;hero-list&gt;&lt;/hero-list&gt;</code>, then
Angular inserts an instance of the <code>HeroListComponent</code> view between those tags.</p>
</li>
<li><p><code>templateUrl</code>: address of this component&apos;s HTML template, shown <a href="https://angular.io/docs/ts/latest/guide/architecture.html#templates">above</a>.</p>
</li>
<li><p><code>directives</code>: array of the components or directives that <em>this</em> template requires.
In the last line of <code>hero-list.component.html</code>, Angular inserts a <code>HeroDetailComponent</code>
in the space indicated by <code>&lt;hero-detail&gt;</code> tags.
Angular does so only if <code>HeroDetailComponent</code> is in this <code>directives</code> array.</p>
</li>
<li><p><code>providers</code>: array of <strong>dependency injection providers</strong> for services that the component requires.
This is one way to tell Angular that the component&apos;s constructor requires a <code>HeroService</code>
so it can get the list of heroes to display. </p>
</li>
</ul><span>
</span><figure><img src="https://angular.io/resources/images/devguide/architecture/template-metadata-component.png" alt="Metadata" align="left"></figure><p>The metadata in the <code>@Component</code> tells Angular where to get the major building blocks you specify for the component.</p><span>
</span><p>The template, metadata, and component together describe a view.</p><span>
</span><p>Apply other metadata decorators in a similar fashion to guide Angular behavior.
<code>@Injectable</code>, <code>@Input</code>, and <code>@Output</code> are a few of the more popular decorators.</p><span>
</span><p>The architectural takeaway is that you must add metadata to your code
so that Angular knows what to do.</p><span>
</span><h2 id="data-binding">Data binding</h2><span>
</span><p>Without a framework, you would be responsible for pushing data values into the HTML controls and turning user responses
into actions and value updates. Writing such push/pull logic by hand is tedious, error-prone, and a nightmare to
read as any experienced jQuery programmer can attest.</p><span>
</span><figure><img src="https://angular.io/resources/images/devguide/architecture/databinding.png" alt="Data Binding"></figure><p>Angular supports <strong>data binding</strong>,
a mechanism for coordinating parts of a template with parts of a component.
Add binding markup to the template HTML to tell Angular how to connect both sides.</p><span>
</span><p>As the diagram shows, there are four forms of data binding syntax. Each form has a direction &#x2014; to the DOM, from the DOM, or in both directions.</p><span>
</span><p>The <code>HeroListComponent</code> <a href="https://angular.io/docs/ts/latest/guide/architecture.html#templates">example</a> template has three forms:</p><span>
</span><p>app/hero-list.component.html (binding)</p><code language="html" format="">&lt;li&gt;{{hero.name}}&lt;/li&gt;
&lt;hero-detail [hero]=&quot;selectedHero&quot;&gt;&lt;/hero-detail&gt;
&lt;li (click)=&quot;selectHero(hero)&quot;&gt;&lt;/li&gt;
</code><ul>
<li><p>The <code>{{hero.name}}</code> <a href="https://angular.io/docs/ts/latest/guide/displaying-data.html#interpolation"><em>interpolation</em></a>
displays the component&apos;s <code>hero.name</code> property value within the <code>&lt;li&gt;</code> tags.</p>
</li>
<li><p>The <code>[hero]</code> <a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#property-binding"><em>property binding</em></a> passes the value of <code>selectedHero</code> from
the parent <code>HeroListComponent</code> to the <code>hero</code> property of the child <code>HeroDetailComponent</code>.</p>
</li>
<li><p>The <code>(click)</code> <a href="https://angular.io/docs/ts/latest/guide/user-input.html#click"><em>event binding</em></a> calls the component&apos;s <code>selectHero</code> method when the user clicks a hero&apos;s name.</p>
</li>
</ul><span>
</span><p><strong>Two-way data binding</strong> is an important fourth form
that combines property and event binding in a single notation, using the <code>ngModel</code> directive.
Here&apos;s an example from the <code>HeroDetailComponent</code> template:</p><span>
</span><p>app/hero-detail.component.html (ngModel)</p><code language="html" format="">&lt;input [(ngModel)]=&quot;hero.name&quot;&gt;
</code><p>In two-way binding, a data property value flows to the input box from the component as with property binding.
The user&apos;s changes also flow back to the component, resetting the property to the latest value,
as with event binding.</p><span>
</span><p>Angular processes <em>all</em> data bindings once per JavaScript event cycle,
from the root of the application component tree through all child components.</p><span>
</span><figure><img src="https://angular.io/resources/images/devguide/architecture/component-databinding.png" alt="Data Binding"></figure><p>Data binding plays an important role in communication
between a template and its component.</p><span>
</span><br clear="all"><figure><img src="https://angular.io/resources/images/devguide/architecture/parent-child-binding.png" alt="Parent/Child binding"></figure><p>Data binding is also important for communication between parent and child components.</p><span>
</span><br clear="all"><h2 id="directives">Directives</h2><span>
</span><figure><img src="https://angular.io/resources/images/devguide/architecture/directive.png" alt="Parent child"></figure><p>Angular templates are <em>dynamic</em>. When Angular renders them, it transforms the DOM
according to the instructions given by <strong>directives</strong>.</p><span>
</span><p>A directive is a class with directive metadata. In TypeScript, apply the <code>@Directive</code> decorator
to attach metadata to the class.</p><span>
</span><p>A component is a <em>directive-with-a-template</em>;
a <code>@Component</code> decorator is actually a <code>@Directive</code> decorator extended with template-oriented features.</p><span>
</span><div class="l-sub-section"><p>While <strong>a component is technically a directive</strong>,
components are so distinctive and central to Angular applications that this architectural overview  separates components from directives.</p><span>
</span></div><p>Two <em>other</em> kinds of directives exist: <em>structural</em> and <em>attribute</em> directives.</p><span>
</span><p>They tend to appear within an element tag as attributes do,
sometimes by name but more often as the target of an assignment or a binding.</p><span>
</span><p><strong>Structural</strong> directives alter layout by adding, removing, and replacing elements in DOM.</p><span>
</span><p>The <a href="https://angular.io/docs/ts/latest/guide/architecture.html#templates">example template</a> uses two built-in structural directives:</p><span>
</span><p>app/hero-list.component.html (structural)</p><code language="html" format="">&lt;li *ngFor=&quot;let hero of heroes&quot;&gt;&lt;/li&gt;
&lt;hero-detail *ngIf=&quot;selectedHero&quot;&gt;&lt;/hero-detail&gt;
</code><ul>
<li><a href="https://angular.io/docs/ts/latest/guide/displaying-data.html#ngFor"><code>*ngFor</code></a> tells Angular to stamp out one <code>&lt;li&gt;</code> per hero in the <code>heroes</code> list.</li>
<li><a href="https://angular.io/docs/ts/latest/guide/displaying-data.html#ngIf"><code>*ngIf</code></a> includes the <code>HeroDetail</code> component only if a selected hero exists.</li>
</ul><span>
</span><p><strong>Attribute</strong> directives alter the appearance or behavior of an existing element.
In templates they look like regular HTML attributes, hence the name.</p><span>
</span><p>The <code>ngModel</code> directive, which implements two-way data binding, is
an example of an attribute directive. <code>ngModel</code> modifies the behavior of
an existing element (typically an <code>&lt;input&gt;</code>)
by setting its display value property and responding to change events.</p><span>
</span><p>app/hero-detail.component.html (ngModel)</p><code language="html" format="">&lt;input [(ngModel)]=&quot;hero.name&quot;&gt;
</code><p>Angular has a few more directives that either alter the layout structure
(for example, <a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#ngSwitch">ngSwitch</a>)
or modify aspects of DOM elements and components
(for example, <a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#ngStyle">ngStyle</a> and <a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#ngClass">ngClass</a>).</p><span>
</span><p>Of course, you can also write your own directives. Components such as
<code>HeroListComponent</code> are one kind of custom directive.
<!-- PENDING: link to where to learn more about other kinds! --></p><span>
</span><h2 id="services">Services</h2><span>
</span><figure><img src="https://angular.io/resources/images/devguide/architecture/service.png" alt="Service"></figure><p><em>Service</em> is a broad category encompassing any value, function, or feature that your application needs.</p><span>
</span><p>Almost anything can be a service.
A service is typically a class with a narrow, well-defined purpose. It should do something specific and do it well.</p><span>
</span><p>Examples include:</p><span>
</span><ul>
<li>logging service</li>
<li>data service</li>
<li>message bus</li>
<li>tax calculator</li>
<li>application configuration</li>
</ul><span>
</span><p>There is nothing specifically <em>Angular</em> about services. Angular has no definition of a service.
There is no service base class, and no place to register a service.</p><span>
</span><p>Yet services are fundamental to any Angular application. Components are big consumers of services.</p><span>
</span><p>Here&apos;s an example of a service class that logs to the browser console:</p><span>
</span><p>app/logger.service.ts (class)</p><code language="ts" format="">export class Logger {
  log(msg: any)   { console.log(msg); }
  error(msg: any) { console.error(msg); }
  warn(msg: any)  { console.warn(msg); }
}
</code><p>Here&apos;s a <code>HeroService</code> that fetches heroes and returns them in a resolved <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">Promise</a>.
The <code>HeroService</code> depends on the <code>Logger</code> service and another <code>BackendService</code> that handles the server communication grunt work.</p><span>
</span><p>app/hero.service.ts (class)</p><code language="ts" format="">export class HeroService {
  private heroes: Hero[] = [];

  constructor(
    private backend: BackendService,
    private logger: Logger) { }

  getHeroes() {
    this.backend.getAll(Hero).then( (heroes: Hero[]) =&gt; {
      this.logger.log(`Fetched ${heroes.length} heroes.`);
      this.heroes.push(...heroes); // fill cache
    });
    return this.heroes;
  }
}
</code><p>Services are everywhere.</p><span>
</span><p>Component classes should be lean. They don&apos;t fetch data from the server,
validate user input, or log directly to the console.
They delegate such tasks to services.</p><span>
</span><p>A component&apos;s job is to enable the user experience and nothing more. It mediates between the view (rendered by the template)
and the application logic (which often includes some notion of a <em>model</em>).
A good component presents properties and methods for data binding.
It delegates everything nontrivial to services.</p><span>
</span><p>Angular doesn&apos;t <em>enforce</em> these principles.
It won&apos;t complain if you write a &quot;kitchen sink&quot; component with 3000 lines.</p><span>
</span><p>Angular does help you <em>follow</em> these principles by making it easy to factor your
application logic into services and make those services available to components through <em>dependency injection</em>.</p><span>
</span><h2 id="dependency-injection">Dependency injection</h2><span>
</span><figure><img src="https://angular.io/resources/images/devguide/architecture/dependency-injection.png" alt="Service"></figure><p><em>Dependency injection</em> is a way to supply a new instance of a class
with the fully-formed dependencies it requires. Most dependencies are services.
Angular uses dependency injection to provide new components with the services they need.</p><span>
</span><p>Angular can tell which services a component needs by looking at the types of its constructor parameters.
For example, the constructor of your <code>HeroListComponent</code> needs a <code>HeroService</code>:</p><span>
</span><p>app/hero-list.component.ts (constructor)</p><code language="ts" format="">constructor(private service: HeroService) { }
</code><p>When Angular creates a component, it first asks an <strong>injector</strong> for
the services that the component requires.</p><span>
</span><p>An injector maintains a container of service instances that it has previously created.
If a requested service instance is not in the container, the injector makes one and adds it to the container
before returning the service to Angular.
When all requested services have been resolved and returned,
Angular can call the component&apos;s constructor with those services as arguments.
This is <em>dependency injection</em>.</p><span>
</span><p>The process of <code>HeroService</code> injection looks a bit like this:</p><span>
</span><figure><img src="https://angular.io/resources/images/devguide/architecture/injector-injects.png" alt="Service"></figure><p>If the injector doesn&apos;t have a <code>HeroService</code>, how does it know how to make one?</p><span>
</span><p>In brief, you must have previously registered a <strong>provider</strong> of the <code>HeroService</code> with the injector.
A provider is something that can create or return a service, typically the service class itself.</p><span>
</span><p>You can register providers in modules or in components.</p><span>
</span><p>In general, add providers to the <a href="https://angular.io/docs/ts/latest/guide/architecture.html#module">root module</a> so that
the same instance of a service is available everywhere.</p><span>
</span><p>app/app.module.ts (module providers)</p><code language="ts" format="">providers: [
  BackendService,
  HeroService,
  Logger
],
</code><p>Alternatively, register at a component level in the <code>providers</code> property of the <code>@Component</code> metadata:</p><span>
</span><p>app/hero-list.component.ts (component providers)</p><code language="ts" format="">@Component({
  selector:    &apos;hero-list&apos;,
  templateUrl: &apos;app/hero-list.component.html&apos;,
  providers:   [ HeroService ]
})
</code><p>Registering at a component level means you get a new instance of the
service with each new instance of that component.</p><span>
</span><!-- We've vastly oversimplified dependency injection for this overview.
The full story is in the [dependency injection](dependency-injection.html) page. --><span>
</span><p>Points to remember about dependency injection:</p><span>
</span><ul>
<li><p>Dependency injection is wired into the Angular framework and used everywhere.</p>
</li>
<li><p>The <em>injector</em> is the main mechanism.</p>
<ul>
<li>An injector maintains a <em>container</em> of service instances that it created.</li>
<li>An injector can create a new service instance from a <em>provider</em>.</li>
</ul>
</li>
<li><p>A <em>provider</em> is a recipe for creating a service.</p>
</li>
<li><p>Register <em>providers</em> with injectors.</p>
</li>
</ul><span>
</span><h2 id="wrap-up">Wrap up</h2><span>
</span><p>You&apos;ve learned the basics about the eight main building blocks of an Angular application:</p><span>
</span><ul>
<li><a href="https://angular.io/docs/ts/latest/guide/architecture.html#modules">Modules</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/architecture.html#components">Components</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/architecture.html#templates">Templates</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/architecture.html#metadata">Metadata</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/architecture.html#data-binding">Data binding</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/architecture.html#directives">Directives</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/architecture.html#services">Services</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/architecture.html#dependency-injection">Dependency injection</a></li>
</ul><span>
</span><p>That&apos;s a foundation for everything else in an Angular application,
and it&apos;s more than enough to get going.
But it doesn&apos;t include everything you need to know.</p><span>
</span><p>Here is a brief, alphabetical list of other important Angular features and services.
Most of them are covered in this documentation (or soon will be).</p><span>
</span><blockquote>
<p><a href="https://angular.io/docs/ts/latest/guide/animations.html"><strong>Animations</strong></a>: Animate component behavior
without deep knowledge of animation techniques or CSS with Angular&apos;s animation library.</p>
<p><strong>Change detection</strong>: The change detection documentation will cover how Angular decides that a component property value has changed,
when to update the screen, and how it uses <strong>zones</strong> to intercept asynchronous activity and run its change detection strategies.</p>
<p><strong>Events</strong>: The events documentation will cover how to use components and services to raise events with mechanisms for
publishing and subscribing to events.</p>
<p><a href="https://angular.io/docs/ts/latest/guide/forms.html"><strong>Forms</strong></a>: Support complex data entry scenarios with HTML-based validation and dirty checking.</p>
<p><a href="https://angular.io/docs/ts/latest/guide/server-communication.html"><strong>HTTP</strong></a>: Communicate with a server to get data, save data, and invoke server-side actions with an HTTP client.</p>
<p><a href="https://angular.io/docs/ts/latest/guide/lifecycle-hooks.html"><strong>Lifecycle hooks</strong></a>: Tap into key moments in the lifetime of a component, from its creation to its destruction,
by implementing the lifecycle hook interfaces.</p>
<p><a href="https://angular.io/docs/ts/latest/guide/pipes.html"><strong>Pipes</strong></a>: Use pipes in your templates to improve the user experience by transforming values for display. Consider this <code>currency</code> pipe expression:</p>
</blockquote><span>
</span><p><code>price | currency:&apos;USD&apos;:true</code></p><blockquote>
<p>It displays a price of &quot;42.33&quot; as <code>$42.33</code>.</p>
<p><a href="https://angular.io/docs/ts/latest/guide/router.html"><strong>Router</strong></a>: Navigate from page to page within the client
  application and never leave the browser.</p>
<p><a href="https://angular.io/docs/ts/latest/guide/testing.html"><strong>Testing</strong></a>: Run unit tests with Angular&apos;s 
<a href="https://pub.dartlang.org/packages/angular2_testing">testing library</a>
 on your application parts as they interact with the Angular framework.</p>
</blockquote><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!--NEXT PAGE HAS NOW BEEN SET--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--></div></div>
        </article>
      
        <article>
          <h3>Displaying Data</h3>
          <div><div class="showcase-content"><p>We typically display data in Angular by binding controls in an HTML template
to properties of an Angular component.</p><span>
</span><p>In this chapter, we&apos;ll create a component with a list of heroes. Each hero has a name.
We&apos;ll display the list of hero names and
conditionally show a message below the list.</p><span>
</span><p>The final UI looks like this:</p><span>
</span><figure class="image-display"><img src="https://angular.io/resources/images/devguide/displaying-data/final.png" alt="Final UI"></figure><span>
</span><ul>
<li><a href="https://angular.io/docs/ts/latest/guide/displaying-data.html#interpolation">Showing component properties with interpolation</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/displaying-data.html#ngFor">Showing an array property with NgFor</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/displaying-data.html#ngIf">Conditional display with NgIf</a></li>
</ul><span>
</span><div class="l-sub-section"><p>The <live-example></live-example> demonstrates all of the syntax and code
snippets described in this chapter.</p><span>
</span></div><h2 id="showing-component-properties-with-interpolation">Showing component properties with interpolation</h2><span>
</span><p>The easiest way to display a component property
is to bind the property name through interpolation.
With interpolation, we put the property name in the view template, enclosed in double curly braces: <code>{{myHero}}</code>.</p><span>
</span><p>Let&apos;s build a small illustrative example together.</p><span>
</span><p>Create a new project folder (<ngio-ex path="displaying-data"></ngio-ex>) and follow the steps in the <a href="https://angular.io/docs/ts/latest/quickstart.html">QuickStart</a>.</p><span>
</span><p>Then modify the <ngio-ex path="app.component.ts"></ngio-ex> file by 
changing the template and the body of the component.
When we&apos;re done, it should look like this:</p><span>
</span><p>app/app.component.ts</p><code language="ts" format="linenums">import { Component } from &apos;@angular/core&apos;;

@Component({
  selector: &apos;my-app&apos;,
  template: `
    &lt;h1&gt;{{title}}&lt;/h1&gt;
    &lt;h2&gt;My favorite hero is: {{myHero}}&lt;/h2&gt;
    `
})
export class AppComponent {
  title = &apos;Tour of Heroes&apos;;
  myHero = &apos;Windstorm&apos;;
}
</code><p>We added two properties to the formerly empty component: <code>title</code> and <code>myHero</code>.</p><span>
</span><p>Our revised template displays the two component properties using double curly brace
interpolation:</p><span>
</span><code language="ts" format="">template: `
  &lt;h1&gt;{{title}}&lt;/h1&gt;
  &lt;h2&gt;My favorite hero is: {{myHero}}&lt;/h2&gt;
  `
</code><div class="l-sub-section"><p>The template is a multi-line string within ECMAScript 2015 backticks (<code>`</code>).
The backtick (<code>`</code>) &#x2014; which is <em>not</em> the same character as a single
quote (<code>&apos;</code>) &#x2014; has many nice features. The feature we&apos;re exploiting here
is the ability to compose the string over several lines, which makes for
much more readable HTML.</p><span>
</span></div><p>Angular automatically pulls the value of the <code>title</code> and <code>myHero</code> properties from the component and
inserts those values into the browser. Angular updates the display
when these properties change.</p><span>
</span><div class="l-sub-section"><p>More precisely, the redisplay occurs after some kind of asynchronous event related to
the view such as a keystroke, a timer completion, or an async <code>XHR</code> response.
We don&apos;t have those in this sample.
But then the properties aren&apos;t changing on their own either. For the moment we must operate on faith.</p><span>
</span></div><p>Notice that we haven&apos;t called <strong>new</strong> to create an instance of the <code>AppComponent</code> class.
Angular is creating an instance for us. How?</p><span>
</span><p>Notice the CSS <code>selector</code> in the <code>@Component</code> decorator that specifies an element named <code>my-app</code>.
Remember back in <a href="https://angular.io/docs/ts/latest/quickstart.html">QuickStart</a> that we added the <code>&lt;my-app&gt;</code> element to the body of our <code>index.html</code> file:</p><span>
</span><p>index.html (body)</p><code language="html" format="">&lt;body&gt;
  &lt;my-app&gt;loading...&lt;/my-app&gt;
&lt;/body&gt;
</code><p>When we bootstrap with the <code>AppComponent</code> class (in <ngio-ex path="main.ts"></ngio-ex>), Angular looks for a <code>&lt;my-app&gt;</code>
in the <code>index.html</code>, finds it, instantiates an instance of <code>AppComponent</code>, and renders it
inside the <code>&lt;my-app&gt;</code> tag.</p><span>
</span><p>Try running the app. It should display the title and hero name:</p><span>
</span><figure class="image-display"><img src="https://angular.io/resources/images/devguide/displaying-data/title-and-hero.png" alt="Title and Hero"></figure><p>Let&apos;s review some of the choices we made and consider alternatives.</p><span>
</span><h2 id="template-inline-or-template-file-">Template inline or template file?</h2><span>
</span><p>We can store our component&apos;s template in one of two places.
We can define it <em>inline</em> using the <code>template</code> property, as we do here.
Or we can define the template in a separate HTML file and link to it in
the component metadata using the <code>@Component</code> decorator&apos;s <code>templateUrl</code> property.</p><span>
</span><p>The choice between inline and separate HTML is a matter of taste,
circumstances, and organization policy.
Here we&apos;re using inline HTML because the template is small, and the demo
is simpler without the additional HTML file.</p><span>
</span><p>In either style, the template data bindings have the same access to the component&apos;s properties.</p><span>
</span><h2 id="constructor-or-variable-initialization-">Constructor or variable initialization?</h2><span>
</span><p>We initialized our component properties using variable assignment.
This is a wonderfully concise and compact technique.</p><span>
</span><p>Some folks prefer to declare the properties and initialize them within a constructor like this:</p><span>
</span><p>app/app-ctor.component.ts (class)</p><code language="ts" format="">export class AppCtorComponent {
  title: string;
  myHero: string;

  constructor() {
    this.title = &apos;Tour of Heroes&apos;;
    this.myHero = &apos;Windstorm&apos;;
  }
}
</code><p>That&apos;s fine too. The choice is a matter of taste and organization policy.
We&apos;ll adopt the more terse &quot;variable assignment&quot; style in this chapter simply because
there will be less code to read.</p><span>
</span><h2 id="showing-_an-_array-property-with-ngfor-">Showing an array property with <strong>*ngFor</strong></h2><span>
</span><p>We want to display a list of heroes. We begin by adding an array of hero names to the component and redefine <code>myHero</code> to be the first name in the array.</p><span>
</span><p>app/app.component.ts (class)</p><code language="ts" format="">export class AppComponent {
  title = &apos;Tour of Heroes&apos;;
  heroes = [&apos;Windstorm&apos;, &apos;Bombasto&apos;, &apos;Magneta&apos;, &apos;Tornado&apos;];
  myHero = this.heroes[0];
}
</code><p>Now we use the Angular <code>ngFor</code> directive in the template to display
each item in the <code>heroes</code> list.</p><span>
</span><p>app/app.component.ts (template)</p><code language="ts" format="">  template: `
    &lt;h1&gt;{{title}}&lt;/h1&gt;
    &lt;h2&gt;My favorite hero is: {{myHero}}&lt;/h2&gt;
    &lt;p&gt;Heroes:&lt;/p&gt;
    &lt;ul&gt;
      &lt;li *ngFor=&quot;let hero of heroes&quot;&gt;
        {{ hero }}
      &lt;/li&gt;
    &lt;/ul&gt;
  `
</code><p>Our presentation is the familiar HTML unordered list with <code>&lt;ul&gt;</code> and <code>&lt;li&gt;</code> tags. Let&apos;s focus on the <code>&lt;li&gt;</code> tag.</p><span>
</span><code language="ts" format="">&lt;li *ngFor=&quot;let hero of heroes&quot;&gt;
  {{ hero }}
&lt;/li&gt;
</code><p>We added a somewhat mysterious <code>*ngFor</code> to the <code>&lt;li&gt;</code> element.
That&apos;s the Angular &quot;repeater&quot; directive.
Its presence on the <code>&lt;li&gt;</code> tag marks that <code>&lt;li&gt;</code> element (and its children) as the &quot;repeater template&quot;.</p><span>
</span><div class="alert is-important"><p>Don&apos;t forget the leading asterisk (*) in <code>*ngFor</code>. It is an essential part of the syntax.
Learn more about this and <code>ngFor</code> in the <a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#ngFor">Template Syntax</a> chapter.</p><span>
</span></div><p>Notice the <code>hero</code> in the <code>ngFor</code> double-quoted instruction;
it is an example of a <a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#ngForMicrosyntax">template input variable</a>.</p><span>
</span><p>Angular duplicates the <code>&lt;li&gt;</code> for each item in the list, setting the <code>hero</code> variable
to the item (the hero) in the current iteration. Angular uses that variable as the
context for the interpolation in the double curly braces.</p><span>
</span><div class="l-sub-section"><p>We happened to give <code>ngFor</code> an array to display.
In fact, <code>ngFor</code> can repeat items for any <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols">iterable</a>
object.</p><span>
</span></div><p>Now the heroes appear in an unordered list.</p><span>
</span><figure class="image-display"><img src="https://angular.io/resources/images/devguide/displaying-data/hero-names-list.png" alt="After ngfor"></figure><h2 id="creating-a-class-for-the-data">Creating a class for the data</h2><span>
</span><p>We are defining our data directly inside our component.
That&apos;s fine for a demo but certainly isn&apos;t a best practice. It&apos;s not even a good practice.
Although we won&apos;t do anything about that in this chapter, we&apos;ll make a mental note to fix this down the road.</p><span>
</span><p>At the moment, we&apos;re binding to an array of strings. We do that occasionally in real applications, but
most of the time we&apos;re binding to more specialized objects.</p><span>
</span><p>Let&apos;s turn our array of hero names into an array of <code>Hero</code> objects. For that we&apos;ll need a <code>Hero</code> class.</p><span>
</span><p>Create a new file in the <code>app</code> folder called  <ngio-ex path="hero.ts"></ngio-ex> with the following code:</p><span>
</span><p>app/hero.ts (excerpt)</p><code language="ts" format="">export class Hero {
  constructor(
    public id: number,
    public name: string) { }
}
</code><p>We&apos;ve defined a class with a constructor and two properties: <code>id</code> and <code>name</code>.</p><span>
</span><p>It might not look like we have properties, but we do. We&apos;re taking
advantage of a TypeScript shortcut in our declaration of the constructor parameters.</p><span>
</span><p>Consider the first parameter:</p><span>
</span><p>app/hero.ts (id)</p><code language="ts" format="">public id: number,
</code><p>That brief syntax does a lot:</p><span>
</span><ul>
<li>Declares a constructor parameter and its type</li>
<li>Declares a public property of the same name</li>
<li>Initializes that property with the corresponding argument when we &quot;new&quot; an instance of the class</li>
</ul><span>
</span><h2 id="using-the-hero-class">Using the Hero class</h2><span>
</span><p>Let&apos;s make the <code>heroes</code> property in our component return an array of these <code>Hero</code> objects.</p><span>
</span><p>app/app.component.ts (heroes)</p><code language="ts" format="">heroes = [
  new Hero(1, &apos;Windstorm&apos;),
  new Hero(13, &apos;Bombasto&apos;),
  new Hero(15, &apos;Magneta&apos;),
  new Hero(20, &apos;Tornado&apos;)
];
myHero = this.heroes[0];
</code><p>We&apos;ll have to update the template.
At the moment it displays the hero&apos;s <code>id</code> and <code>name</code>.
Let&apos;s fix that so we display only the hero&apos;s <code>name</code> property.</p><span>
</span><p>app/app.component.ts (template)</p><code language="ts" format="">template: `
  &lt;h1&gt;{{title}}&lt;/h1&gt;
  &lt;h2&gt;My favorite hero is: {{myHero.name}}&lt;/h2&gt;
  &lt;p&gt;Heroes:&lt;/p&gt;
  &lt;ul&gt;
    &lt;li *ngFor=&quot;let hero of heroes&quot;&gt;
      {{ hero.name }}
    &lt;/li&gt;
  &lt;/ul&gt;
`
</code><p>Our display looks the same, but now we know much better what a hero really is.</p><span>
</span><h2 id="conditional-display-with-ngif">Conditional display with NgIf</h2><span>
</span><p>Sometimes an app needs to display a view or a portion of a view only under specific circumstances.</p><span>
</span><p>In our example, we&apos;d like to display a message if we have a large number of heroes, say, more than 3.</p><span>
</span><p>The Angular <code>ngIf</code> directive inserts or removes an element based on a truthy/falsey condition.
We can see it in action by adding the following paragraph at the bottom of the template:</p><span>
</span><p>app/app.component.ts (message)</p><code language="ts" format="">&lt;p *ngIf=&quot;heroes.length &gt; 3&quot;&gt;There are many heroes!&lt;/p&gt;
</code><div class="alert is-important"><p>Don&apos;t forget the leading asterisk (*) in <code>*ngIf</code>. It is an essential part of the syntax.
Learn more about this and <code>ngIf</code> in the <a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#ngIf">Template Syntax</a> chapter.</p><span>
</span></div><p>The <a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#template-expressions">template expression</a> inside the double quotes
looks much like TypeScript, and it <em>is</em> much like TypeScript.
When the component&apos;s list of heroes has more than 3 items, Angular adds the paragraph to the DOM and the message appears.
If there are 3 or fewer items, Angular omits the paragraph, so no message appears.</p><span>
</span><div class="alert is-helpful"><p>Angular isn&apos;t showing and hiding the message. It is adding and removing the paragraph element from the DOM.
That hardly matters here. But it would matter a great deal, from a performance perspective, if
we were conditionally including or excluding a big chunk of HTML with many data bindings.</p><span>
</span></div><p>Try it out. Because the array has four items, the message should appear.
Go back into <ngio-ex path="app.component.ts"></ngio-ex> and delete or comment out one of the elements from the hero array.
The browser should refresh automatically and the message should disappear.</p><span>
</span><h2 id="summary">Summary</h2><span>
</span><p>Now we know how to use:</p><span>
</span><ul>
<li><strong>Interpolation</strong> with double curly braces to display a component property</li>
<li><strong>ngFor</strong> to display an array of items</li>
<li>A TypeScript class to shape the <strong>model data</strong> for our component and display properties of that model</li>
<li><strong>ngIf</strong> to conditionally display a chunk of HTML based on a boolean expression</li>
</ul><span>
</span><p>Here&apos;s our final code:</p><span>
</span><code-tabs><code language="ts" name="app/app.component.ts" format="linenums">import { Component } from &apos;@angular/core&apos;;

import { Hero } from &apos;./hero&apos;;

@Component({
  selector: &apos;my-app&apos;,
  template: `
  &lt;h1&gt;{{title}}&lt;/h1&gt;
  &lt;h2&gt;My favorite hero is: {{myHero.name}}&lt;/h2&gt;
  &lt;p&gt;Heroes:&lt;/p&gt;
  &lt;ul&gt;
    &lt;li *ngFor=&quot;let hero of heroes&quot;&gt;
      {{ hero.name }}
      &lt;/li&gt;
  &lt;/ul&gt;
  &lt;p *ngIf=&quot;heroes.length &gt; 3&quot;&gt;There are many heroes!&lt;/p&gt;
`
})
export class AppComponent {
  title = &apos;Tour of Heroes&apos;;
  heroes = [
    new Hero(1, &apos;Windstorm&apos;),
    new Hero(13, &apos;Bombasto&apos;),
    new Hero(15, &apos;Magneta&apos;),
    new Hero(20, &apos;Tornado&apos;)
  ];
  myHero = this.heroes[0];
}
</code><code language="ts" name="app/hero.ts" format="linenums">export class Hero {
  constructor(
    public id: number,
    public name: string) { }
}
</code><code language="ts" name="app.module.ts" format="linenums">import { NgModule } from &apos;@angular/core&apos;;
import { BrowserModule }  from &apos;@angular/platform-browser&apos;;

import { AppComponent } from &apos;./app.component&apos;;

@NgModule({
  imports: [
    BrowserModule
  ],
  declarations: [
    AppComponent
  ],
  bootstrap: [ AppComponent ]
})
export class AppModule { }
</code><code language="ts" name="main.ts" format="linenums">import { platformBrowserDynamic } from &apos;@angular/platform-browser-dynamic&apos;;

import { AppModule } from &apos;./app.module&apos;;

platformBrowserDynamic().bootstrapModule(AppModule);
</code></code-tabs><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!--NEXT PAGE HAS NOW BEEN SET--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--></div></div>
        </article>
      
        <article>
          <h3>User Input - ts</h3>
          <div><div class="showcase-content"><p>When the user clicks a link, pushes a button, or enters text
we want to know about it. These user actions all raise DOM events.
In this chapter we learn to bind to those events using the Angular
event binding syntax.</p><span>
</span><p>Run the <live-example></live-example>.</p><span>
</span><h2 id="binding-to-user-input-events">Binding to user input events</h2><span>
</span><p>We can use <a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#event-binding">Angular event bindings</a>
to respond to <a href="https://developer.mozilla.org/en-US/docs/Web/Events">any DOM event</a>.</p><span>
</span><p>The syntax is simple. We surround the DOM event name in parentheses and assign a quoted template statement to it.
As an example, here&apos;s an event binding that implements a click handler:</p><span>
</span><code language="html" format="">&lt;button (click)=&quot;onClickMe()&quot;&gt;Click me!&lt;/button&gt;
</code><a id="click"></a><p>The <code>(click)</code> to the left of the equal sign identifies the button&apos;s click event as the <strong>target of the binding</strong>.
The text within quotes on the right is the <strong>template statement</strong> in which we
respond to the click event by calling the component&apos;s <code>onClickMe</code> method. A <a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#template-statements">template statement</a> is a subset
of JavaScript with restrictions and a few added tricks.</p><span>
</span><p>When writing a binding we must be aware of a template statement&apos;s <strong>execution context</strong>.
The identifiers appearing within a statement belong to a specific context object.
That object is usually the Angular component that controls the template  ... which it definitely is
in this case because that snippet of HTML belongs to the following component:</p><span>
</span><p>app/click-me.component.ts</p><code language="ts" format="">@Component({
  selector: &apos;click-me&apos;,
  template: `
    &lt;button (click)=&quot;onClickMe()&quot;&gt;Click me!&lt;/button&gt;
    {{clickMessage}}`
})
export class ClickMeComponent {
  clickMessage = &apos;&apos;;

  onClickMe() {
    this.clickMessage = &apos;You are my hero!&apos;;
  }
}
</code><p>When the user clicks the button, Angular calls the component&apos;s <code>onClickMe</code> method.</p><span>
</span><h2 id="get-user-input-from-the-event-object">Get user input from the $event object</h2><span>
</span><p>We can bind to all kinds of events. Let&apos;s bind to the keyup event of an input box and replay
what the user types back onto the screen.</p><span>
</span><p>This time we&apos;ll (1) listen to an event and (2) grab the user&apos;s input.</p><span>
</span><p>app/keyup.components.ts (template v.1)</p><code language="ts" format="">template: `
  &lt;input (keyup)=&quot;onKey($event)&quot;&gt;
  &lt;p&gt;{{values}}&lt;/p&gt;
`
</code><p>Angular makes an event object available in the <strong><code>$event</code></strong> variable,
which we pass to the component&apos;s <code>onKey()</code> method.
The user data we want is in that variable somewhere.</p><span>
</span><p>app/keyup.components.ts (class v.1)</p><code language="ts" format="">export class KeyUpComponent_v1 {
  values = &apos;&apos;;

  // without strong typing
  onKey(event:any) {
    this.values += event.target.value + &apos; | &apos;;
  }
}
</code><p>The shape of the <code>$event</code> object is determined by whatever raises the event.
The <code>keyup</code> event comes from the DOM, so <code>$event</code> must be a <a href="https://developer.mozilla.org/en-US/docs/Web/API/Event">standard DOM event object</a>.
The <code>$event.target</code> gives us an
<a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLInputElement"><code>HTMLInputElement</code></a>, which
has a <code>value</code> property that contains our user input data.</p><span>
</span><p>The <code>onKey()</code> component method is where we extract the user&apos;s input
from the event object, adding that input to the list of user data that we&apos;re accumulating in the component&apos;s <code>values</code> property.
We then use <a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#interpolation">interpolation</a>
to display the accumulating <code>values</code> property back on screen.</p><span>
</span><p>Enter the letters &quot;abc&quot;, and then backspace to remove them.
Here&apos;s what the UI displays:</p><span>
</span><code>a | ab | abc | ab | a | |</code><figure class="image-display"><img src="https://angular.io/resources/images/devguide/user-input/keyup1-anim.gif" alt="key up 1"></figure><a id="keyup1"></a><div class="l-sub-section"><p>We cast the <code>$event</code> as an <code>any</code> type, which means we&apos;ve abandoned strong typing
to simplify our code. We generally prefer the strong typing that TypeScript affords.
We can rewrite the method, casting to HTML DOM objects like this.</p><span>
</span><p>app/keyup.components.ts (class v.1 - strongly typed )</p><code language="ts" format="">export class KeyUpComponent_v1 {
  values = &apos;&apos;;

  // with strong typing
  onKey(event: KeyboardEvent) {
    this.values += (&lt;HTMLInputElement&gt;event.target).value + &apos; | &apos;;
  }
}
</code><p><br>Strong typing reveals a serious problem with passing a DOM event into the method:
too much awareness of template details, too little separation of concerns.</p><span>
</span><p>We&apos;ll address this problem in our next try at processing user keystrokes.</p><span>
</span></div><h2 id="get-user-input-from-a-template-reference-variable">Get user input from a template reference variable</h2><span>
</span><p>There&apos;s another way to get the user data without the <code>$event</code> variable.</p><span>
</span><p>Angular has a syntax feature called <a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#ref-vars"><strong>template reference variables</strong></a>.
These variables grant us direct access to an element.
We declare a template reference variable by preceding an identifier with a hash/pound character (#).</p><span>
</span><p>Here&apos;s an example of using a template reference variable
to implement a clever keystroke loopback in an ultra-simple template.</p><span>
</span><p>app/loop-back.component.ts</p><code language="ts" format="">@Component({
  selector: &apos;loop-back&apos;,
  template: `
    &lt;input #box (keyup)=&quot;0&quot;&gt;
    &lt;p&gt;{{box.value}}&lt;/p&gt;
  `
})
export class LoopbackComponent { }
</code><p>We&apos;ve declared a template reference variable named <code>box</code> on the <code>&lt;input&gt;</code> element.
The <code>box</code> variable is a reference to the <code>&lt;input&gt;</code> element itself, which means we can
grab the input element&apos;s <code>value</code> and display it
with interpolation between <code>&lt;p&gt;</code> tags.</p><span>
</span><p>The template is completely self contained. It doesn&apos;t bind to the component,
and the component does nothing.</p><span>
</span><p>Type in the input box, and watch the display update with each keystroke. <em>Voila!</em></p><span>
</span><figure class="image-display"><img src="https://angular.io/resources/images/devguide/user-input/keyup-loop-back-anim.gif" alt="loop back"></figure><div class="l-sub-section"><p><strong>This won&apos;t work at all unless we bind to an event</strong>.</p><span>
</span><p>Angular only updates the bindings (and therefore the screen)
if we do something in response to asynchronous events such as keystrokes.</p><span>
</span><p>That&apos;s why we bind the <code>keyup</code> event to a statement that does ... well, nothing.
We&apos;re binding to the number 0, the shortest statement we can think of.
That is all it takes to keep Angular happy. We said it would be clever!</p><span>
</span></div><p>That template reference variable is intriguing. It&apos;s clearly easier to get to the textbox with that
variable than to go through the <code>$event</code> object. Maybe we can rewrite our previous
keyup example so that it uses the variable to get the user&apos;s input. Let&apos;s give it a try.</p><span>
</span><p>app/keyup.components.ts (v2)</p><code language="ts" format="">@Component({
  selector: &apos;key-up2&apos;,
  template: `
    &lt;input #box (keyup)=&quot;onKey(box.value)&quot;&gt;
    &lt;p&gt;{{values}}&lt;/p&gt;
  `
})
export class KeyUpComponent_v2 {
  values = &apos;&apos;;
  onKey(value: string) {
    this.values += value + &apos; | &apos;;
  }
}
</code><p>That sure seems easier.
An especially nice aspect of this approach is that our component code gets clean data values from the view.
It no longer requires knowledge of the <code>$event</code> and its structure.</p><span>
</span><a id="key-event"></a><h2 id="key-event-filtering-with-key-enter-">Key event filtering (with <code>key.enter</code>)</h2><span>
</span><p>Perhaps we don&apos;t care about every keystroke.
Maybe we&apos;re only interested in the input box value when the user presses Enter, and we&apos;d like to ignore all other keys.
When we bind to the <code>(keyup)</code> event, our event handling statement hears <em>every keystroke</em>.
We could filter the keys first, examining every <code>$event.keyCode</code>, and update the <code>values</code> property only if the key is Enter.</p><span>
</span><p>Angular can filter the key events for us. Angular has a special syntax for keyboard events.
We can listen for just the Enter key by binding to Angular&apos;s <code>keyup.enter</code> pseudo-event.</p><span>
</span><p>Only then do we update the component&apos;s <code>values</code> property. (In this example,
the update happens inside the event binding statement. A better practice
would be to put the update code in the component.)</p><span>
</span><p>app/keyup.components.ts (v3)</p><code language="ts" format="">@Component({
  selector: &apos;key-up3&apos;,
  template: `
    &lt;input #box (keyup.enter)=&quot;values=box.value&quot;&gt;
    &lt;p&gt;{{values}}&lt;/p&gt;
  `
})
export class KeyUpComponent_v3 {
  values = &apos;&apos;;
}
</code><p>Here&apos;s how it works.</p><span>
</span><figure class="image-display"><img src="https://angular.io/resources/images/devguide/user-input/keyup3-anim.gif" alt="key up 3"></figure><h2 id="on-blur">On blur</h2><span>
</span><p>Our previous example won&apos;t transfer the current state of the input box if the user mouses away and clicks
elsewhere on the page. We update the component&apos;s <code>values</code> property only when the user presses Enter
while the focus is inside the input box.</p><span>
</span><p>Let&apos;s fix that by listening to the input box&apos;s blur event as well.</p><span>
</span><p>app/keyup.components.ts (v4)</p><code language="ts" format="">@Component({
  selector: &apos;key-up4&apos;,
  template: `
    &lt;input #box
      (keyup.enter)=&quot;values=box.value&quot;
      (blur)=&quot;values=box.value&quot;&gt;

    &lt;p&gt;{{values}}&lt;/p&gt;
  `
})
export class KeyUpComponent_v4 {
  values = &apos;&apos;;
}
</code><h2 id="put-it-all-together">Put it all together</h2><span>
</span><p>We learned how to <a href="https://angular.io/docs/ts/latest/guide/displaying-data.html">display data</a> in the previous chapter.
We&apos;ve acquired a small arsenal of event binding techniques in this chapter.</p><span>
</span><p>Let&apos;s put it all together in a micro-app
that can display a list of heroes and add new heroes to that list.
The user can add a hero by first typing in the input box and then
pressing Enter, clicking the Add button, or clicking elsewhere on the page.</p><span>
</span><figure class="image-display"><img src="https://angular.io/resources/images/devguide/user-input/little-tour-anim.gif" alt="Little Tour of Heroes"></figure><p>Below is the &quot;Little Tour of Heroes&quot;  component.
We&apos;ll call out the highlights after we bask briefly in its minimalist glory.</p><span>
</span><p>app/little-tour.component.ts</p><code language="ts" format="">@Component({
  selector: &apos;little-tour&apos;,
  template: `
    &lt;input #newHero
      (keyup.enter)=&quot;addHero(newHero.value)&quot;
      (blur)=&quot;addHero(newHero.value); newHero.value=&apos;&apos; &quot;&gt;

    &lt;button (click)=addHero(newHero.value)&gt;Add&lt;/button&gt;

    &lt;ul&gt;&lt;li *ngFor=&quot;let hero of heroes&quot;&gt;{{hero}}&lt;/li&gt;&lt;/ul&gt;
  `
})
export class LittleTourComponent {
  heroes = [&apos;Windstorm&apos;, &apos;Bombasto&apos;, &apos;Magneta&apos;, &apos;Tornado&apos;];
  addHero(newHero: string) {
    if (newHero) {
      this.heroes.push(newHero);
    }
  }
}
</code><p>We&apos;ve seen almost everything here before. A few things are new or bear repeating.</p><span>
</span><h3 id="use-template-variables-to-refer-to-elements">Use template variables to refer to elements</h3><span>
</span><p>The <code>newHero</code> template variable refers to the <code>&lt;input&gt;</code> element.
We can use <code>newHero</code> from any sibling or child of the <code>&lt;input&gt;</code> element.</p><span>
</span><p>Getting the element from a template variable makes the button click handler
simpler. Without the variable, we&apos;d have to use a fancy CSS selector
to find the input element.</p><span>
</span><h3 id="pass-values-not-elements">Pass values, not elements</h3><span>
</span><p>We could have passed the <code>newHero</code> into the component&apos;s <code>addHero</code> method.</p><span>
</span><p>But that would require <code>addHero</code> to pick its way through the <code>&lt;input&gt;</code> DOM element,
something we learned to dislike in our first try at a <a href="https://angular.io/docs/ts/latest/guide/user-input.html#keyup1">keyup component</a>.</p><span>
</span><p>Instead, we grab the input box <em>value</em> and pass <em>that</em> to <code>addHero</code>.
The component knows nothing about HTML or the DOM, which is the way we like it.</p><span>
</span><h3 id="keep-template-statements-simple">Keep template statements simple</h3><span>
</span><p>We bound <code>(blur)</code> to <em>two</em> JavaScript statements.</p><span>
</span><p>We like the first one, which calls <code>addHero</code>.
We do not like the second one, which assigns an empty string to the input box value.</p><span>
</span><p>The second statement exists for a good reason. We have to clear the input box after adding the new hero to the list.
The component has no way to do that itself because it has no access to the
input box (our design choice).</p><span>
</span><p>Although the example <em>works</em>, we are rightly wary of JavaScript in HTML.
Template statements are powerful. We&apos;re supposed to use them responsibly.
Complex JavaScript in HTML is irresponsible.</p><span>
</span><p>Should we reconsider our reluctance to pass the input box into the component?</p><span>
</span><p>There should be a better third way. And there is, as we&apos;ll see when we learn about <code>NgModel</code> in the <a href="https://angular.io/docs/ts/latest/guide/forms.html">Forms</a> chapter.</p><span>
</span><h2 id="source-code">Source code</h2><span>
</span><p>Here is all the code we talked about in this chapter.</p><span>
</span><code-tabs><code language="ts" name="click-me.component.ts" format="linenums">import { Component } from &apos;@angular/core&apos;;

@Component({
  selector: &apos;click-me&apos;,
  template: `
    &lt;button (click)=&quot;onClickMe()&quot;&gt;Click me!&lt;/button&gt;
    {{clickMessage}}`
})
export class ClickMeComponent {
  clickMessage = &apos;&apos;;

  onClickMe() {
    this.clickMessage = &apos;You are my hero!&apos;;
  }
}
</code><code language="ts" name="keyup.components.ts" format="linenums">import { Component } from &apos;@angular/core&apos;;

@Component({
  selector: &apos;key-up1&apos;,
  template: `
    &lt;input (keyup)=&quot;onKey($event)&quot;&gt;
    &lt;p&gt;{{values}}&lt;/p&gt;
  `
})
export class KeyUpComponent_v1 {
  values = &apos;&apos;;

  /*
  // without strong typing
  onKey(event:any) {
    this.values += event.target.value + &apos; | &apos;;
  }
  */
  // with strong typing
  onKey(event: KeyboardEvent) {
    this.values += (&lt;HTMLInputElement&gt;event.target).value + &apos; | &apos;;
  }
}

//////////////////////////////////////////

@Component({
  selector: &apos;key-up2&apos;,
  template: `
    &lt;input #box (keyup)=&quot;onKey(box.value)&quot;&gt;
    &lt;p&gt;{{values}}&lt;/p&gt;
  `
})
export class KeyUpComponent_v2 {
  values = &apos;&apos;;
  onKey(value: string) {
    this.values += value + &apos; | &apos;;
  }
}


//////////////////////////////////////////

@Component({
  selector: &apos;key-up3&apos;,
  template: `
    &lt;input #box (keyup.enter)=&quot;values=box.value&quot;&gt;
    &lt;p&gt;{{values}}&lt;/p&gt;
  `
})
export class KeyUpComponent_v3 {
  values = &apos;&apos;;
}


//////////////////////////////////////////

@Component({
  selector: &apos;key-up4&apos;,
  template: `
    &lt;input #box
      (keyup.enter)=&quot;values=box.value&quot;
      (blur)=&quot;values=box.value&quot;&gt;

    &lt;p&gt;{{values}}&lt;/p&gt;
  `
})
export class KeyUpComponent_v4 {
  values = &apos;&apos;;
}
</code><code language="ts" name="loop-back.component.ts" format="linenums">import { Component } from &apos;@angular/core&apos;;
@Component({
  selector: &apos;loop-back&apos;,
  template: `
    &lt;input #box (keyup)=&quot;0&quot;&gt;
    &lt;p&gt;{{box.value}}&lt;/p&gt;
  `
})
export class LoopbackComponent { }
</code><code language="ts
  " name="little-tour.component.ts" format="linenums">import { Component } from &apos;@angular/core&apos;;

@Component({
  selector: &apos;little-tour&apos;,
  template: `
    &lt;input #newHero
      (keyup.enter)=&quot;addHero(newHero.value)&quot;
      (blur)=&quot;addHero(newHero.value); newHero.value=&apos;&apos; &quot;&gt;

    &lt;button (click)=addHero(newHero.value)&gt;Add&lt;/button&gt;

    &lt;ul&gt;&lt;li *ngFor=&quot;let hero of heroes&quot;&gt;{{hero}}&lt;/li&gt;&lt;/ul&gt;
  `
})
export class LittleTourComponent {
  heroes = [&apos;Windstorm&apos;, &apos;Bombasto&apos;, &apos;Magneta&apos;, &apos;Tornado&apos;];
  addHero(newHero: string) {
    if (newHero) {
      this.heroes.push(newHero);
    }
  }
}
</code></code-tabs><h2 id="summary">Summary</h2><span>
</span><p>We&apos;ve mastered the basic primitives for responding to user input and gestures.
As powerful as these primitives are, they are a bit clumsy for handling
large amounts of user input. We&apos;re operating down at the low level of events when
we should be writing two-way bindings between data entry fields and model properties.</p><span>
</span><p>Angular has a two-way binding called <code>NgModel</code>, which we&apos;ll learn about
in the <code>Forms</code> chapter.</p><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!--NEXT PAGE HAS NOW BEEN SET--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--></div></div>
        </article>
      
        <article>
          <h3>Forms - ts</h3>
          <div><div class="showcase-content"><p>We&#x2019;ve all used a form to log in, submit a help request, place an order, book a flight,
schedule a meeting and perform countless other data entry tasks.
Forms are the mainstay of business applications.</p><span>
</span><p>Any seasoned web developer can slap together an HTML form with all the right tags.
It&apos;s more challenging to create a cohesive data entry experience that guides the
user efficiently and effectively through the workflow behind the form.</p><span>
</span><p><em>That</em> takes design skills that are, to be frank, well out of scope for this chapter.</p><span>
</span><p>It also takes framework support for
<strong>two-way data binding, change tracking, validation, and error handling</strong>
... which we shall cover in this chapter on Angular forms.</p><span>
</span><p>We will build a simple form from scratch, one step at a time. Along the way we&apos;ll learn how to</p><span>
</span><ul>
<li><p>build an Angular form with a component and template</p>
</li>
<li><p>two-way data bind with <code>[(ngModel)]</code> syntax for reading and writing values to input controls</p>
</li>
<li><p>track the change state and validity of form controls using <code>ngModel</code> in combination with a form</p>
</li>
<li><p>provide strong visual feedback using special CSS classes that track the state of the controls</p>
</li>
<li><p>display validation errors to users and enable/disable form controls</p>
</li>
<li><p>use <a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#ref-vars">template reference variables</a> for sharing information among HTML elements</p>
</li>
</ul><span>
</span><p>Run the <live-example></live-example>.</p><span>
</span><h2 id="template-driven-forms">Template-Driven Forms</h2><span>
</span><p>Many of us will build forms by writing templates in the Angular <a href="https://angular.io/docs/ts/latest/guide/template-syntax.html">template syntax</a> with
the form-specific directives and techniques described in this chapter.</p><span>
</span><div class="l-sub-section"><p>That&apos;s not the only way to create a form but it&apos;s the way we&apos;ll cover in this chapter.</p><span>
</span></div><p>We can build almost any form we need with an Angular template &#x2014; login forms, contact forms ... pretty much any business forms.
We can lay out the controls creatively, bind them to data, specify validation rules and display validation errors,
conditionally enable or disable specific controls, trigger built-in visual feedback, and much more.</p><span>
</span><p>It will be pretty easy because Angular handles many of the repetitive, boiler plate tasks we&apos;d
otherwise wrestle with ourselves.</p><span>
</span><p>We&apos;ll discuss and learn to build the following template-driven form:</p><span>
</span><figure class="image-display"><img src="https://angular.io/resources/images/devguide/forms/hero-form-1.png" width="400px" alt="Clean Form"></figure><p>Here at the <em>Hero Employment Agency</em> we use this form to maintain personal information about the
heroes in our stable. Every hero needs a job. It&apos;s our company mission to match the right hero with the right crisis!</p><span>
</span><p>Two of the three fields on this form are required. Required fields have a green bar on the left to make them easy to spot.</p><span>
</span><p>If we delete the hero name, the form displays a validation error in an attention grabbing style:</p><span>
</span><figure class="image-display"><img src="https://angular.io/resources/images/devguide/forms/hero-form-2.png" width="400px" alt="Invalid, Name Required"></figure><p>Note that the submit button is disabled and the &quot;required&quot; bar to the left of the input control changed from green to red.</p><span>
</span><div class="l-sub-section"><p>We&apos;ll customize the colors and location of the &quot;required&quot; bar with standard CSS.</p></div><p>We will build this form in the following sequence of small steps</p><span>
</span><ol>
<li>Create the <code>Hero</code> model class</li>
<li>Create the component that controls the form</li>
<li>Create a template with the initial form layout</li>
<li>Bind data properties to each form input control with the <code>ngModel</code> two-way data binding syntax</li>
<li>Add the <code>name</code> attribute to each form input control</li>
<li>Add custom CSS to provide visual feedback</li>
<li>Show and hide validation error messages</li>
<li>Handle form submission with <strong>ngSubmit</strong></li>
<li>Disable the form&#x2019;s submit button until the form is valid</li>
</ol><span>
</span><h2 id="setup">Setup</h2><span>
</span><p>Create a new project folder (<code>angular2-forms</code>) and follow the steps in the <a href="https://angular.io/docs/ts/latest/quickstart.html">QuickStart</a>.</p><span>
</span><h2 id="create-the-hero-model-class">Create the Hero Model Class</h2><span>
</span><p>As users enter form data, we capture their changes and update an instance of a model.
We can&apos;t layout the form until we know what the model looks like.</p><span>
</span><p>A model can be as simple as a &quot;property bag&quot; that holds facts about a thing of application importance.
That describes well our <code>Hero</code> class with its three required fields (<code>id</code>, <code>name</code>, <code>power</code>)
and one optional field (<code>alterEgo</code>).</p><span>
</span><p>Create a new file in the app folder called <code>hero.ts</code> and give it the following class definition:</p><span>
</span><p>app/hero.ts</p><code language="ts" format="linenums">export class Hero {

  constructor(
    public id: number,
    public name: string,
    public power: string,
    public alterEgo?: string
  ) {  }

}
</code><p>It&apos;s an anemic model with few requirements and no behavior. Perfect for our demo.</p><span>
</span><p>The TypeScript compiler generates a public field for each <code>public</code> constructor parameter and
assigns the parameter&#x2019;s value to that field automatically when we create new heroes.</p><span>
</span><p>The <code>alterEgo</code> is optional and the constructor lets us omit it; note the (?) in <code>alterEgo?</code>.</p><span>
</span><p>We can create a new hero like this:</p><span>
</span><code format="">let myHero =  new Hero(42, &apos;SkyDog&apos;,
                       &apos;Fetch any object at any distance&apos;,
                       &apos;Leslie Rollover&apos;);
console.log(&apos;My hero is called &apos; + myHero.name); // &quot;My hero is called SkyDog&quot;</code><h2 id="create-a-form-component">Create a Form component</h2><span>
</span><p>An Angular form has two parts: an HTML-based template and a code-based Component to handle data and user interactions.</p><span>
</span><p>We begin with the Component because it states, in brief, what the Hero editor can do.</p><span>
</span><p>Create a new file called <code>hero-form.component.ts</code> and give it the following definition:</p><span>
</span><p>app/hero-form.component.ts</p><code language="ts" format="linenums">import { Component } from &apos;@angular/core&apos;;

import { Hero }    from &apos;./hero&apos;;

@Component({
  selector: &apos;hero-form&apos;,
  templateUrl: &apos;app/hero-form.component.html&apos;
})
export class HeroFormComponent {

  powers = [&apos;Really Smart&apos;, &apos;Super Flexible&apos;,
            &apos;Super Hot&apos;, &apos;Weather Changer&apos;];

  model = new Hero(18, &apos;Dr IQ&apos;, this.powers[0], &apos;Chuck Overstreet&apos;);

  submitted = false;

  onSubmit() { this.submitted = true; }

  // TODO: Remove this when we&apos;re done
  get diagnostic() { return JSON.stringify(this.model); }
}
</code><p>There&#x2019;s nothing special about this component, nothing form-specific, nothing to distinguish it from any component we&apos;ve written before.</p><span>
</span><p>Understanding this component requires only the Angular concepts we&#x2019;ve learned in previous chapters</p><span>
</span><ol>
<li><p>We import the <code>Component</code> decorator from the Angular library as we usually do.</p>
</li>
<li><p>We import the <code>Hero</code> model we just created.</p>
</li>
<li><p>The <code>@Component</code> selector value of &quot;hero-form&quot; means we can drop this form in a parent template with a <code>&lt;hero-form&gt;</code> tag.</p>
</li>
<li><p>The <code>templateUrl</code> property points to a separate file for the template HTML called <code>hero-form.component.html</code>.</p>
</li>
<li><p>We defined dummy data for <code>model</code> and <code>powers</code> as befits a demo.
Down the road, we can inject a data service to get and save real data
or perhaps expose these properties as <a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#inputs-outputs">inputs and outputs</a> for binding to a
parent component. None of this concerns us now and these future changes won&apos;t affect our form.</p>
</li>
<li><p>We threw in a <code>diagnostic</code> property at the end to return a JSON representation of our model.
It&apos;ll help us see what we&apos;re doing during our development; we&apos;ve left ourselves a cleanup note to discard it later.</p>
</li>
</ol><span>
</span><p>Why don&apos;t we write the template inline in the component file as we often do
elsewhere in the Developer Guide?</p><span>
</span><p>There is no &#x201C;right&#x201D; answer for all occasions. We like inline templates when they are short.
Most form templates won&apos;t be short. TypeScript and JavaScript files generally aren&apos;t the best place to
write (or read) large stretches of HTML and few editors are much help with files that have a mix of HTML and code.
We also like short files with a clear and obvious purpose like this one.</p><span>
</span><p>We made a good choice to put the HTML template elsewhere.
We&apos;ll write that template in a moment. Before we do, we&apos;ll take a step back
and revise the <code>app.module.ts</code> and <code>app.component.ts</code> to make use of our new <code>HeroFormComponent</code>.</p><span>
</span><h2 id="revise-the-app-module-ts-">Revise the <em>app.module.ts</em></h2><span>
</span><p><code>app.module.ts</code> defines the application&apos;s root module. In it we identify the external modules we&apos;ll use in our application
and declare the components that belong to this module, such as our <code>HeroFormComponent</code>.</p><span>
</span><p>Because template-driven forms are in their own module, we need to add the <code>FormsModule</code> to the array of
<code>imports</code> for our application module before we can use forms.</p><span>
</span><p>Replace the contents of the &quot;QuickStart&quot; version with the following:</p><span>
</span><p>app/app.module.ts</p><code language="ts" format="linenums">import { NgModule }      from &apos;@angular/core&apos;;
import { BrowserModule } from &apos;@angular/platform-browser&apos;;
import { FormsModule }   from &apos;@angular/forms&apos;;

import { AppComponent }  from &apos;./app.component&apos;;
import { HeroFormComponent } from &apos;./hero-form.component&apos;;

@NgModule({
  imports: [
    BrowserModule,
    FormsModule
  ],
  declarations: [
    AppComponent,
    HeroFormComponent
  ],
  bootstrap: [ AppComponent ]
})
export class AppModule { }
</code><div class="l-sub-section"><p>There are three changes:</p><span>
</span><ol>
<li><p>We import <code>FormsModule</code> and our new <code>HeroFormComponent</code>.</p>
</li>
<li><p>We add the <code>FormsModule</code> to the list of <code>imports</code> defined in the <code>ngModule</code> decorator. This gives our application
access to all of the template-driven forms features, including <code>ngModel</code>.</p>
</li>
<li><p>We add the <code>HeroFormComponent</code> to the list of <code>declarations</code> defined in the <code>ngModule</code> decorator. This makes
the <code>HeroFormComponent</code> component visible throughout this module.</p>
</li>
</ol><span>
</span></div><div class="alert is-important"><p>If a component, directive, or pipe belongs to a module in the <code>imports</code> array, &#x200B;<em>DON&apos;T</em>&#x200B; declare it in the <code>declarations</code> array.
If you wrote it and it should belong to this module, &#x200B;<em>DO</em>&#x200B; declare it in the <code>declarations</code> array.</p><span>
</span></div><h2 id="revise-the-app-component-ts-">Revise the <em>app.component.ts</em></h2><span>
</span><p><code>app.component.ts</code> is the application&apos;s root component. It will host our new <code>HeroFormComponent</code>.</p><span>
</span><p>Replace the contents of the &quot;QuickStart&quot; version with the following:</p><span>
</span><p>app/app.component.ts</p><code language="ts" format="linenums">import { Component } from &apos;@angular/core&apos;;

@Component({
  selector: &apos;my-app&apos;,
  template: &apos;&lt;hero-form&gt;&lt;/hero-form&gt;&apos;
})
export class AppComponent { }
</code><div class="l-sub-section"><p>There is only one changes:</p><span>
</span><ol>
<li>The <code>template</code> is simply the new element tag identified by the component&apos;s <code>selector</code> property.
This will display the hero form when the application component is loaded.</li>
</ol><span>
</span></div><h2 id="create-an-initial-html-form-template">Create an initial HTML Form Template</h2><span>
</span><p>Create a new template file called <code>hero-form.component.html</code> and give it the following definition:</p><span>
</span><p>app/hero-form.component.html</p><code language="html" format="linenums">&lt;div class=&quot;container&quot;&gt;
    &lt;h1&gt;Hero Form&lt;/h1&gt;
    &lt;form&gt;
      &lt;div class=&quot;form-group&quot;&gt;
        &lt;label for=&quot;name&quot;&gt;Name&lt;/label&gt;
        &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;name&quot; required&gt;
      &lt;/div&gt;

      &lt;div class=&quot;form-group&quot;&gt;
        &lt;label for=&quot;alterEgo&quot;&gt;Alter Ego&lt;/label&gt;
        &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;alterEgo&quot;&gt;
      &lt;/div&gt;

      &lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot;&gt;Submit&lt;/button&gt;

    &lt;/form&gt;
&lt;/div&gt;
</code><p>That is plain old HTML 5. We&apos;re presenting two of the <code>Hero</code> fields, <code>name</code> and <code>alterEgo</code>, and
opening them up for user input in input boxes.</p><span>
</span><p>The <em>Name</em> <code>&lt;input&gt;</code> control has the HTML5 <code>required</code> attribute;
the <em>Alter Ego</em> <code>&lt;input&gt;</code> control does not because <code>alterEgo</code> is optional.</p><span>
</span><p>We&apos;ve got a <em>Submit</em> button at the bottom with some classes on it for styling.</p><span>
</span><p><strong>We are not using Angular yet</strong>. There are no bindings. No extra directives. Just layout.</p><span>
</span><p>The <code>container</code>, <code>form-group</code>, <code>form-control</code>, and <code>btn</code> classes
come from <a href="http://getbootstrap.com/css/">Twitter Bootstrap</a>. Purely cosmetic.
We&apos;re using Bootstrap to gussy up our form.
Hey, what&apos;s a form without a little style!</p><span>
</span><div class="callout is-important"><header>Angular Forms Do Not Require A Style Library</header><p>Angular makes no use of the <code>container</code>, <code>form-group</code>, <code>form-control</code>, and <code>btn</code> classes or
the styles of any external library. Angular apps can use any CSS library
... or none at all.</p><span>
</span></div><p>Let&apos;s add the stylesheet.</p><span>
</span><ol><li>Open a terminal window in the application root folder and enter the command:<code language="html" escape="html">npm install bootstrap --save</code></li><li>Open <code>index.html</code> and add the following link to the <code>&lt;head&gt;</code>.<code language="html" format="">&lt;link rel=&quot;stylesheet&quot; 
      href=&quot;node_modules/bootstrap/dist/css/bootstrap.min.css&quot;&gt;
</code></li></ol><h2 id="add-powers-with-ngfor-">Add Powers with <strong>*ngFor</strong></h2><span>
</span><p>Our hero may choose one super power from a fixed list of Agency-approved powers.
We maintain that list internally (in <code>HeroFormComponent</code>).</p><span>
</span><p>We&apos;ll add a <code>select</code> to our
form and bind the options to the <code>powers</code> list using <code>ngFor</code>,
a technique we might have seen before in the <a href="https://angular.io/docs/ts/latest/guide/displaying-data.html">Displaying Data</a> chapter.</p><span>
</span><p>Add the following HTML <em>immediately below</em> the <em>Alter Ego</em> group.</p><span>
</span><p>app/hero-form.component.html (excerpt)</p><code language="html" format="">&lt;div class=&quot;form-group&quot;&gt;
  &lt;label for=&quot;power&quot;&gt;Hero Power&lt;/label&gt;
  &lt;select class=&quot;form-control&quot; id=&quot;power&quot; required&gt;
    &lt;option *ngFor=&quot;let p of powers&quot; [value]=&quot;p&quot;&gt;{{p}}&lt;/option&gt;
  &lt;/select&gt;
&lt;/div&gt;
</code><p>We are repeating the <code>&lt;options&gt;</code> tag for each power in the list of Powers.
The <code>p</code> template input variable is a different power in each iteration;
we display its name using the interpolation syntax with the double-curly-braces.</p><span>
</span><a id="ngModel"></a><h2 id="two-way-data-binding-with-ngmodel-">Two-way data binding with <strong>ngModel</strong></h2><span>
</span><p>Running the app right now would be disappointing.</p><span>
</span><figure class="image-display"><img src="https://angular.io/resources/images/devguide/forms/hero-form-3.png" width="400px" alt="Early form with no binding"></figure><p>We don&apos;t see hero data because we are not binding to the <code>Hero</code> yet.
We know how to do that from earlier chapters.
<a href="https://angular.io/docs/ts/latest/guide/displaying-data.html">Displaying Data</a> taught us Property Binding.
<a href="https://angular.io/docs/ts/latest/guide/user-input.html">User Input</a> showed us how to listen for DOM events with an
Event Binding and how to update a component property with the displayed value.</p><span>
</span><p>Now we need to display, listen, and extract at the same time.</p><span>
</span><p>We could use those techniques again in our form.
Instead we&apos;ll introduce something new, the <code>[(ngModel)]</code> syntax, that
makes binding our form to the model super-easy.</p><span>
</span><p>Find the <code>&lt;input&gt;</code> tag for the &quot;Name&quot; and update it like this</p><span>
</span><p>app/hero-form.component.html (excerpt)</p><code language="html" format="">&lt;input type=&quot;text&quot;  class=&quot;form-control&quot; id=&quot;name&quot;
       required
       [(ngModel)]=&quot;model.name&quot; name=&quot;name&quot;&gt;
  TODO: remove this: {{model.name}}
</code><div class="l-sub-section"><p>We appended a diagnostic interpolation after the input tag
so we can see what we&apos;re doing.
We left ourselves a note to throw it away when we&apos;re done.</p><span>
</span></div><p>Focus on the binding syntax: <code>[(ngModel)]=&quot;...&quot;</code>.</p><span>
</span><p>If we ran the app right now and started typing in the <em>Name</em> input box,
adding and deleting characters, we&apos;d see them appearing and disappearing
from the interpolated text.
At some point it might look like this.</p><span>
</span><figure class="image-display"><img src="https://angular.io/resources/images/devguide/forms/ng-model-in-action.png" width="400px" alt="ngModel in action"></figure><p>The diagnostic is evidence that we really are flowing values from the input box to the model and
back again. <strong>That&apos;s two-way data binding!</strong></p><span>
</span><p>Notice that we also added a <code>name</code> attribute to our <code>&lt;input&gt;</code> tag and set it to &quot;name&quot;
which makes sense for the hero&apos;s name. Any unique value will do, but using a descriptive name is helpful.
Defining a <code>name</code> attribute is a requirement when using <code>[(ngModel)]</code> in combination with a form.</p><span>
</span><div class="l-sub-section"><p>Internally Angular creates <code>FormControls</code> and registers them with an <code>NgForm</code> directive that Angular
attached to the <code>&lt;form&gt;</code> tag. Each <code>FormControl</code> is registered under the name we assigned to the <code>name</code> attribute.
We&apos;ll talk about <code>NgForm</code> <a href="https://angular.io/docs/ts/latest/guide/forms.html#ngForm">later in this chapter</a>.</p><span>
</span></div><p>Let&apos;s add similar <code>[(ngModel)]</code> bindings and <code>name</code> attributes to <em>Alter Ego</em> and <em>Hero Power</em>.
We&apos;ll ditch the input box binding message
and add a new binding at the top to the component&apos;s <code>diagnostic</code> property.
Then we can confirm that two-way data binding works <em>for the entire Hero model</em>.</p><span>
</span><p>After revision the core of our form should have three <code>[(ngModel)]</code> bindings and <code>name</code> attributes that
look much like this:</p><span>
</span><p>app/hero-form.component.html (excerpt)</p><code language="html" format="linenums">{{diagnostic}}
&lt;div class=&quot;form-group&quot;&gt;
  &lt;label for=&quot;name&quot;&gt;Name&lt;/label&gt;
  &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;name&quot;
         required
         [(ngModel)]=&quot;model.name&quot; name=&quot;name&quot;&gt;
&lt;/div&gt;

&lt;div class=&quot;form-group&quot;&gt;
  &lt;label for=&quot;alterEgo&quot;&gt;Alter Ego&lt;/label&gt;
  &lt;input type=&quot;text&quot;  class=&quot;form-control&quot; id=&quot;alterEgo&quot;
         [(ngModel)]=&quot;model.alterEgo&quot; name=&quot;alterEgo&quot;&gt;
&lt;/div&gt;

&lt;div class=&quot;form-group&quot;&gt;
  &lt;label for=&quot;power&quot;&gt;Hero Power&lt;/label&gt;
  &lt;select class=&quot;form-control&quot;  id=&quot;power&quot;
          required
          [(ngModel)]=&quot;model.power&quot; name=&quot;power&quot;&gt;
    &lt;option *ngFor=&quot;let p of powers&quot; [value]=&quot;p&quot;&gt;{{p}}&lt;/option&gt;
  &lt;/select&gt;
&lt;/div&gt;
</code><div class="l-sub-section"><ul>
<li>Each input element has an <code>id</code> property that is used by the <code>label</code> element&apos;s <code>for</code> attribute
to match the label to it&apos;s input control.</li>
<li>Each input element has a <code>name</code> property that is required by Angular Forms to register the control with the form.</li>
</ul><span>
</span></div><p>If we ran the app right now and changed every Hero model property, the form might display like this:</p><span>
</span><figure class="image-display"><img src="https://angular.io/resources/images/devguide/forms/ng-model-in-action-2.png" width="400px" alt="ngModel in super action"></figure><p>The diagnostic near the top of the form
confirms that all of our changes are reflected in the model.</p><span>
</span><p><strong>Delete</strong> the <code>{{diagnostic}}</code> binding at the top as it has served its purpose.</p><span>
</span><div class="l-sub-section"><h3 id="inside-ngmodel-">Inside [(ngModel)]</h3><span>
</span><p><em>This section is an optional deep dive into [(ngModel)]. Not interested? Skip ahead!</em></p><span>
</span><p>The punctuation in the binding syntax, <span><b>[()]</b></span>, is a good clue to what&apos;s going on.</p><span>
</span><p>In a Property Binding, a value flows from the model to a target property on screen.
We identify that target property by surrounding its name in brackets, <span><b>[]</b></span>.
This is a one-way data binding <strong>from the model to the view</strong>.</p><span>
</span><p>In an Event Binding, we flow the value from the target property on screen to the model.
We identify that target property by surrounding its name in parentheses, <span><b>()</b></span>.
This is a one-way data binding in the opposite direction <strong>from the view to the model</strong>.</p><span>
</span><p>No wonder Angular chose to combine the punctuation as <span><b>[()]</b></span>
to signify a two-way data binding and a <strong>flow of data in both directions</strong>.</p><span>
</span><p>In fact, we can break the <code>NgModel</code> binding into its two separate modes
as we do in this re-write of the &quot;Name&quot; <code>&lt;input&gt;</code> binding:</p><span>
</span><p>app/hero-form.component.html (excerpt)</p><code language="html" format="">&lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;name&quot;
       required
       [ngModel]=&quot;model.name&quot; name=&quot;name&quot;
       (ngModelChange)=&quot;model.name = $event&quot; &gt;
  TODO: remove this: {{model.name}}
</code><p><br>The Property Binding should feel familiar. The Event Binding might seem strange.</p><span>
</span><p>The <code>ngModelChange</code> is not an <code>&lt;input&gt;</code> element event.
It is actually an event property of the <code>NgModel</code> directive.
When Angular sees a binding target in the form <span>[(x)]</span>,
it expects the <code>x</code> directive to have an <code>x</code> input property and an <code>xChange</code> output property.</p><span>
</span><p>The other oddity is the template expression, <code>model.name = $event</code>.
We&apos;re used to seeing an <code>$event</code> object coming from a DOM event.
The <code>ngModelChange</code> property doesn&apos;t produce a DOM event; it&apos;s an Angular <code>EventEmitter</code>
property that returns the input box value when it fires &#x2014; which is precisely what
we should assign to the model&apos;s <code>name</code> property.</p><span>
</span><p>Nice to know but is it practical? We almost always prefer <code>[(ngModel)]</code>.
We might split the binding if we had to do something special in
the event handling such as debounce or throttle the key strokes.</p><span>
</span><p>Learn more about <code>NgModel</code> and other template syntax in the
<a href="https://angular.io/docs/ts/latest/guide/template-syntax.html">Template Syntax</a> chapter.</p><span>
</span></div><h2 id="track-change-state-and-validity-with-ngmodel-">Track change-state and validity with <strong>ngModel</strong></h2><span>
</span><p>A form isn&apos;t just about data binding. We&apos;d also like to know the state of the controls on our form.</p><span>
</span><p>Using <code>ngModel</code> in a form gives us more than just two way data binding. It also tells us if the user touched the control, if the value changed, or if the value became invalid.</p><span>
</span><p>The <em>NgModel</em> directive doesn&apos;t just track state; it updates the control with special Angular CSS classes that reflect the state.
We can leverage those class names to change the appearance of the
control and make messages appear or disappear.</p><span>
</span><table><tbody><tr><th>State</th><th>Class if true</th><th>Class if false</th></tr><tr><td>Control has been visited</td><td><code>ng-touched</code></td><td><code>ng-untouched</code></td></tr><tr><td>Control&apos;s value has changed</td><td><code>ng-dirty</code></td><td><code>ng-pristine</code></td></tr><tr><td>Control&apos;s value is valid</td><td><code>ng-valid</code></td><td><code>ng-invalid</code></td></tr></tbody></table><p>Let&apos;s add a temporary <a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#ref-vars">template reference variable</a> named <strong>spy</strong>
to the &quot;Name&quot; <code>&lt;input&gt;</code> tag and use the spy to display those classes.</p><span>
</span><p>app/hero-form.component.html (excerpt)</p><code language="html" format="">&lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;name&quot;
  required
  [(ngModel)]=&quot;model.name&quot; name=&quot;name&quot;
  #spy &gt;
&lt;br&gt;TODO: remove this: {{spy.className}}
</code><p>Now run the app and focus on the <em>Name</em> input box.
Follow the next four steps <em>precisely</em></p><span>
</span><ol>
<li>Look but don&apos;t touch</li>
<li>Click in the input box, then click outside the text input box</li>
<li>Add slashes to the end of the name</li>
<li>Erase the name</li>
</ol><span>
</span><p>The actions and effects are as follows:</p><span>
</span><figure class="image-display"><img src="https://angular.io/resources/images/devguide/forms/control-state-transitions-anim.gif" alt="Control State Transition"></figure><p>We should be able to see the following four sets of class names and their transitions:</p><span>
</span><figure class="image-display"><img src="https://angular.io/resources/images/devguide/forms/ng-control-class-changes.png" width="400px" alt="Control State Transitions"></figure><p>The (<code>ng-valid</code> | <code>ng-invalid</code>) pair are most interesting to us. We want to send a
strong visual signal when the data are invalid and we want to mark required fields.
So we add custom CSS for visual feedback.</p><span>
</span><p><strong>Delete</strong> the <code>#spy</code> template reference variable and <code>TODO</code> as they have served their purpose.</p><span>
</span><h2 id="add-custom-css-for-visual-feedback">Add Custom CSS for Visual Feedback</h2><span>
</span><p>We realize we can mark required fields and invalid data at the same time with a colored bar
on the left of the input box:</p><span>
</span><figure class="image-display"><img src="https://angular.io/resources/images/devguide/forms/validity-required-indicator.png" width="400px" alt="Invalid Form"></figure><p>We achieve this effect by adding two styles to a new <code>forms.css</code> file
that we add to our project as a sibling to <code>index.html</code>.</p><span>
</span><p>forms.css</p><code language="css" format="">.ng-valid[required], .ng-valid.required  {
  border-left: 5px solid #42A948; /* green */
}

.ng-invalid:not(form)  {
  border-left: 5px solid #a94442; /* red */
}
</code><p>These styles select for the two Angular validity classes and the HTML 5 &quot;required&quot; attribute.</p><span>
</span><p>We update the <code>&lt;head&gt;</code> of the <code>index.html</code> to include this style sheet.</p><span>
</span><p>index.html (excerpt)</p><code language="html" format="">&lt;link rel=&quot;stylesheet&quot; href=&quot;styles.css&quot;&gt;
&lt;link rel=&quot;stylesheet&quot; href=&quot;forms.css&quot;&gt;
</code><h2 id="show-and-hide-validation-error-messages">Show and Hide Validation Error messages</h2><span>
</span><p>We can do better.</p><span>
</span><p>The &quot;Name&quot; input box is required. Clearing it turns the bar red. That says <em>something</em> is wrong but we
don&apos;t know <em>what</em> is wrong or what to do about it.
We can leverage the <code>ng-invalid</code> class to reveal a helpful message.</p><span>
</span><p>Here&apos;s the way it should look when the user deletes the name:</p><span>
</span><figure class="image-display"><img src="https://angular.io/resources/images/devguide/forms/name-required-error.png" width="400px" alt="Name required"></figure><p>To achieve this effect we extend the <code>&lt;input&gt;</code> tag with</p><span>
</span><ol>
<li>a <a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#ref-vars">template reference variable</a></li>
<li>the &quot;<em>is required</em>&quot; message in a nearby <code>&lt;div&gt;</code> which we&apos;ll display only if the control is invalid.</li>
</ol><span>
</span><p>Here&apos;s how we do it for the <em>name</em> input box:</p><span>
</span><p>app/hero-form.component.html (excerpt)</p><code language="html" format="">        &lt;label for=&quot;name&quot;&gt;Name&lt;/label&gt;
        &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;name&quot;
               required
               [(ngModel)]=&quot;model.name&quot; name=&quot;name&quot;
               #name=&quot;ngModel&quot; &gt;
        &lt;div [hidden]=&quot;name.valid || name.pristine&quot; 
             class=&quot;alert alert-danger&quot;&gt;
          Name is required
        &lt;/div&gt;
</code><p>We need a template reference variable to access the input box&apos;s Angular control from within the template.
Here we created a variable called <code>name</code> and gave it the value &quot;ngModel&quot;.</p><span>
</span><div class="l-sub-section"><p>Why &quot;ngModel&quot;?
A directive&apos;s <a href="https://angular.io/docs/ts/latest/api/core/index/DirectiveMetadata-class.html#!#exportAs-anchor">exportAs</a> property
tells Angular how to link the reference variable to the directive.
We set <code>name</code> to <code>ngModel</code> because the <code>ngModel</code> directive&apos;s <code>exportAs</code> property happens to be &quot;ngModel&quot;.</p><span>
</span><p>Now we can control visibility of the &quot;name&quot; error message by binding properties of the <code>name</code> control to the message <code>&lt;div&gt;</code> element&apos;s <code>hidden</code> property.</p><span>
</span></div><p>app/hero-form.component.html (excerpt)</p><code language="html" format="linenums">&lt;div [hidden]=&quot;name.valid || name.pristine&quot; 
     class=&quot;alert alert-danger&quot;&gt;
</code><p>In this example, we hide the message when the control is valid or pristine;
pristine means the user hasn&apos;t changed the value since it was displayed in this form.</p><span>
</span><p>This user experience is the developer&apos;s choice. Some folks want to see the message at all times.
If we ignore the <code>pristine</code> state, we would hide the message only when the value is valid.
If we arrive in this component with a new (blank) hero or an invalid hero,
we&apos;ll see the error message immediately, before we&apos;ve done anything.</p><span>
</span><p>Some folks find that behavior disconcerting. They only want to see the message when the user makes an invalid change.
Hiding the message while the control is &quot;pristine&quot; achieves that goal.
We&apos;ll see the significance of this choice when we <a href="https://angular.io/docs/ts/latest/guide/forms.html#new-hero">add a new hero</a> to the form.</p><span>
</span><p>The Hero <em>Alter Ego</em> is optional so we can leave that be.</p><span>
</span><p>Hero <em>Power</em> selection is required.
We can add the same kind of error handling to the <code>&lt;select&gt;</code> if we  want
but it&apos;s not imperative because the selection box already constrains the
power to valid value.</p><span>
</span><a id="new-hero"></a><span>
</span><a id="reset"></a><h2 id="add-a-hero-and-reset-the-form">Add a hero and reset the form</h2><span>
</span><p>We&apos;d like to add a new hero in this form.
We place a &quot;New Hero&quot; button at the bottom of the form and bind its click event to a component method.</p><span>
</span><p>app/hero-form.component.html (New Hero button)</p><code language="html" format="">&lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot; (click)=&quot;newHero()&quot;&gt;New Hero&lt;/button&gt;
</code><p>app/hero-form.component.ts (New Hero method - v1)</p><code language="ts" format="">newHero() {
  this.model = new Hero(42, &apos;&apos;, &apos;&apos;);
}
</code><p>Run the application again, click the <em>New Hero</em> button, and the form clears.
The <em>required</em> bars to the left of the input box are red, indicating invalid <code>name</code> and <code>power</code> properties.
That&apos;s understandable as these are required fields.
The error messages are hidden because the form is pristine; we haven&apos;t changed anything yet.</p><span>
</span><p>Enter a name and click <em>New Hero</em> again.
This time we see an error message! Why? We don&apos;t want that when we display a new (empty) hero.</p><span>
</span><p>Inspecting the element in the browser tools reveals that the <em>name</em> input box is no longer pristine.
Replacing the hero <em>did not restore the pristine state</em> of the control.</p><span>
</span><div class="l-sub-section"><p>Upon reflection, we realize that Angular cannot distinguish between
replacing the entire hero and clearing the <code>name</code> property programmatically.
Angular makes no assumptions and leaves the control in its current, dirty state.</p><span>
</span></div><p>We&apos;ll have to reset the form controls manually with a small trick.
We add an <code>active</code> flag to the component, initialized to <code>true</code>. When we add a new hero,
we toggle <code>active</code> false and then immediately back to true with a quick <code>setTimeout</code>.</p><span>
</span><p>app/hero-form.component.ts (New Hero method - final)</p><code language="ts" format="">  active = true;

  newHero() {
    this.model = new Hero(42, &apos;&apos;, &apos;&apos;);
    this.active = false;
    setTimeout(() =&gt; this.active = true, 0);
  }
</code><p>Then we bind the form element to this <code>active</code> flag.</p><span>
</span><p>app/hero-form.component.html (Form tag)</p><code language="html" format="">&lt;form *ngIf=&quot;active&quot;&gt;
</code><p>With <code>NgIf</code> bound to the <code>active</code> flag,
clicking &quot;New Hero&quot; removes the form from the DOM and recreates it in a blink of an eye.
The re-created form is in a pristine state. The error message is hidden.</p><span>
</span><div class="l-sub-section"><p>This is a temporary workaround while we await a proper form reset feature.</p><span>
</span></div><h2 id="submit-the-form-with-ngsubmit-">Submit the form with <strong>ngSubmit</strong></h2><span>
</span><p>The user should be able to submit this form after filling it in.
The Submit button at the bottom of the form
does nothing on its own but it will
trigger a form submit because of its type (<code>type=&quot;submit&quot;</code>).</p><span>
</span><p>A &quot;form submit&quot; is useless at the moment.
To make it useful, we&apos;ll update the <code>&lt;form&gt;</code> tag with another Angular directive, <code>NgSubmit</code>,
and bind it to the <code>HeroFormComponent.submit()</code> method with an  event binding</p><span>
</span><code language="html" format="">&lt;form *ngIf=&quot;active&quot; (ngSubmit)=&quot;onSubmit()&quot; #heroForm=&quot;ngForm&quot;&gt;
</code><p>We slipped in something extra there at the end!  We defined a
template reference variable, <strong><code>#heroForm</code></strong>, and initialized it with the value, &quot;ngForm&quot;.</p><span>
</span><p>The variable <code>heroForm</code> is now a reference to the <code>NgForm</code> directive that governs the form as a whole.</p><span>
</span><a id="ngForm"></a><div class="l-sub-section"><h3 id="the-ngform-directive">The NgForm directive</h3><span>
</span><p>What <code>NgForm</code> directive? We didn&apos;t add an <a href="https://angular.io/docs/ts/latest/api/common/index/NgForm-directive.html">NgForm</a> directive!</p><span>
</span><p>Angular did. Angular creates and attaches an <code>NgForm</code> directive to the <code>&lt;form&gt;</code> tag automatically.</p><span>
</span><p>The <code>NgForm</code> directive supplements the <code>form</code> element with additional features.
It holds the controls we created for the elements with <code>ngModel</code> directive and <code>name</code> attribute
and monitors their properties including their validity.
It also has its own <code>valid</code> property which is true only <em>if every contained
control</em> is valid.</p><span>
</span></div><p>Later in the template we bind the button&apos;s <code>disabled</code> property to the form&apos;s over-all validity via
the <code>heroForm</code> variable. Here&apos;s that bit of markup:</p><span>
</span><code language="html" format="">&lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot; [disabled]=&quot;!heroForm.form.valid&quot;&gt;Submit&lt;/button&gt;
</code><p>Re-run the application. The form opens in a valid state and the button is enabled.</p><span>
</span><p>Now delete the <em>Name</em>. We violate the &quot;name required&quot; rule which
is duly noted in our error message as before. And now the Submit button is also disabled.</p><span>
</span><p>Not impressed?  Think about it for a moment. What would we have to do to
wire the button&apos;s enable/disabled state to the form&apos;s validity without Angular&apos;s help?</p><span>
</span><p>For us, it was as simple as</p><span>
</span><ol>
<li>Define a template reference variable on the (enhanced) form element</li>
<li>Reference that variable in a button some 50 lines away.</li>
</ol><span>
</span><h2 id="toggle-two-form-regions-extra-credit-">Toggle two form regions (extra credit)</h2><span>
</span><p>Submitting the form isn&apos;t terribly dramatic at the moment.</p><span>
</span><div class="l-sub-section"><p>An unsurprising observation for a demo. To be honest,
jazzing it up won&apos;t teach us anything new about forms.
But this is an opportunity to exercise some of our newly won
binding skills.
If you&apos;re not interested, you can skip to the chapter&apos;s conclusion
and not miss a thing.</p><span>
</span></div><p>Let&apos;s do something more strikingly visual.
Let&apos;s hide the data entry area and display something else.</p><span>
</span><p>Start by wrapping the form in a <code>&lt;div&gt;</code> and bind
its <code>hidden</code> property to the <code>HeroFormComponent.submitted</code> property.</p><span>
</span><p>app/hero-form.component.html (excerpt)</p><code language="html" format="">  &lt;div  [hidden]=&quot;submitted&quot;&gt;
    &lt;h1&gt;Hero Form&lt;/h1&gt;
    &lt;form *ngIf=&quot;active&quot; (ngSubmit)=&quot;onSubmit()&quot; #heroForm=&quot;ngForm&quot;&gt;

       &lt;!-- ... all of the form ... --&gt;

    &lt;/form&gt;
  &lt;/div&gt;
</code><p>The main form is visible from the start because the
the <code>submitted</code> property is false until we submit the form,
as this fragment from the <code>HeroFormComponent</code> reminds us:</p><span>
</span><code language="ts" format="">submitted = false;

onSubmit() { this.submitted = true; }
</code><p>When we click the Submit button, the <code>submitted</code> flag becomes true and the form disappears
as planned.</p><span>
</span><p>Now we need to show something else while the form is in the submitted state.
Add the following block of HTML below the <code>&lt;div&gt;</code> wrapper we just wrote:</p><span>
</span><p>app/hero-form.component.html (excerpt)</p><code language="html" format="linenums">&lt;div [hidden]=&quot;!submitted&quot;&gt;
  &lt;h2&gt;You submitted the following:&lt;/h2&gt;
  &lt;div class=&quot;row&quot;&gt;
    &lt;div class=&quot;col-xs-3&quot;&gt;Name&lt;/div&gt;
    &lt;div class=&quot;col-xs-9  pull-left&quot;&gt;{{ model.name }}&lt;/div&gt;
  &lt;/div&gt;
  &lt;div class=&quot;row&quot;&gt;
    &lt;div class=&quot;col-xs-3&quot;&gt;Alter Ego&lt;/div&gt;
    &lt;div class=&quot;col-xs-9 pull-left&quot;&gt;{{ model.alterEgo }}&lt;/div&gt;
  &lt;/div&gt;
  &lt;div class=&quot;row&quot;&gt;
    &lt;div class=&quot;col-xs-3&quot;&gt;Power&lt;/div&gt;
    &lt;div class=&quot;col-xs-9 pull-left&quot;&gt;{{ model.power }}&lt;/div&gt;
  &lt;/div&gt;
  &lt;br&gt;
  &lt;button class=&quot;btn btn-default&quot; (click)=&quot;submitted=false&quot;&gt;Edit&lt;/button&gt;
&lt;/div&gt;
</code><p>There&apos;s our hero again, displayed read-only with interpolation bindings.
This slug of HTML only appears while the component is in the submitted state.</p><span>
</span><p>We added an Edit button whose click event is bound to an expression
that clears the <code>submitted</code> flag.</p><span>
</span><p>When we click it, this block disappears and the editable form reappears.</p><span>
</span><p>That&apos;s as much drama as we can muster for now.</p><span>
</span><h2 id="conclusion">Conclusion</h2><span>
</span><p>The Angular form techniques discussed in this chapter take
advantage of the following framework features to provide support for data modification, validation and more:</p><span>
</span><ul>
<li>An Angular HTML form template.</li>
<li>A form component class with a <code>Component</code> decorator.</li>
<li>The <code>ngSubmit</code> directive for handling the form submission.</li>
<li>Template reference variables such as <code>#heroForm</code>, <code>#name</code> and <code>#power</code>.</li>
<li>The <code>[(ngModel)]</code> syntax and a <code>name</code> attribute for two-way data binding, validation and change tracking.</li>
<li>The reference variable&#x2019;s <code>valid</code> property on input controls to check if a control is valid and show/hide error messages.</li>
<li>Controlling the submit button&apos;s enabled state by binding to <code>NgForm</code> validity.</li>
<li>Custom CSS classes that provide visual feedback to users about invalid controls.</li>
</ul><span>
</span><p>Our final project folder structure should look like this:</p><span>
</span><div class="filetree"><p>angular2-forms</p><div class="children"><p>app</p><div class="children"><p>app.component.ts</p><p>app.module.ts</p><p>hero.ts</p><p>hero-form.component.html</p><p>hero-form.component.ts</p><p>main.ts</p></div><p>node_modules ...</p><p>typings ...</p><p>index.html</p><p>package.json</p><p>tsconfig.json</p><p>typings.json</p></div></div><p>Here&#x2019;s the final version of the source:</p><span>
</span><code-tabs><code language="ts" name="hero-form.component.ts" format="linenums">import { Component } from &apos;@angular/core&apos;;

import { Hero }    from &apos;./hero&apos;;

@Component({
  selector: &apos;hero-form&apos;,
  templateUrl: &apos;app/hero-form.component.html&apos;
})
export class HeroFormComponent {

  powers = [&apos;Really Smart&apos;, &apos;Super Flexible&apos;,
            &apos;Super Hot&apos;, &apos;Weather Changer&apos;];

  model = new Hero(18, &apos;Dr IQ&apos;, this.powers[0], &apos;Chuck Overstreet&apos;);

  submitted = false;

  onSubmit() { this.submitted = true; }

  // Reset the form with a new hero AND restore &apos;pristine&apos; class state
  // by toggling &apos;active&apos; flag which causes the form
  // to be removed/re-added in a tick via NgIf
  // TODO: Workaround until NgForm has a reset method (#6822)
  active = true;

  newHero() {
    this.model = new Hero(42, &apos;&apos;, &apos;&apos;);
    this.active = false;
    setTimeout(() =&gt; this.active = true, 0);
  }
}
</code><code language="html" name="hero-form.component.html" format="linenums">&lt;div class=&quot;container&quot;&gt;
  &lt;div  [hidden]=&quot;submitted&quot;&gt;
    &lt;h1&gt;Hero Form&lt;/h1&gt;
    &lt;form *ngIf=&quot;active&quot; (ngSubmit)=&quot;onSubmit()&quot; #heroForm=&quot;ngForm&quot;&gt;
      &lt;div class=&quot;form-group&quot;&gt;
        &lt;label for=&quot;name&quot;&gt;Name&lt;/label&gt;
        &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;name&quot;
               required
               [(ngModel)]=&quot;model.name&quot; name=&quot;name&quot;
               #name=&quot;ngModel&quot; &gt;
        &lt;div [hidden]=&quot;name.valid || name.pristine&quot; 
             class=&quot;alert alert-danger&quot;&gt;
          Name is required
        &lt;/div&gt;
      &lt;/div&gt;

      &lt;div class=&quot;form-group&quot;&gt;
        &lt;label for=&quot;alterEgo&quot;&gt;Alter Ego&lt;/label&gt;
        &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;alterEgo&quot;
               [(ngModel)]=&quot;model.alterEgo&quot; name=&quot;alterEgo&quot; &gt;
      &lt;/div&gt;

      &lt;div class=&quot;form-group&quot;&gt;
        &lt;label for=&quot;power&quot;&gt;Hero Power&lt;/label&gt;
        &lt;select class=&quot;form-control&quot; id=&quot;power&quot;
                required
                [(ngModel)]=&quot;model.power&quot; name=&quot;power&quot; 
                #power=&quot;ngModel&quot; &gt;
          &lt;option *ngFor=&quot;let p of powers&quot; [value]=&quot;p&quot;&gt;{{p}}&lt;/option&gt;
        &lt;/select&gt;
        &lt;div [hidden]=&quot;power.valid || power.pristine&quot; class=&quot;alert alert-danger&quot;&gt;
          Power is required
        &lt;/div&gt;
      &lt;/div&gt;

      &lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot; [disabled]=&quot;!heroForm.form.valid&quot;&gt;Submit&lt;/button&gt;

      &lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot; (click)=&quot;newHero()&quot;&gt;New Hero&lt;/button&gt;

    &lt;/form&gt;
  &lt;/div&gt;

  &lt;div [hidden]=&quot;!submitted&quot;&gt;
    &lt;h2&gt;You submitted the following:&lt;/h2&gt;
    &lt;div class=&quot;row&quot;&gt;
      &lt;div class=&quot;col-xs-3&quot;&gt;Name&lt;/div&gt;
      &lt;div class=&quot;col-xs-9  pull-left&quot;&gt;{{ model.name }}&lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;row&quot;&gt;
      &lt;div class=&quot;col-xs-3&quot;&gt;Alter Ego&lt;/div&gt;
      &lt;div class=&quot;col-xs-9 pull-left&quot;&gt;{{ model.alterEgo }}&lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;row&quot;&gt;
      &lt;div class=&quot;col-xs-3&quot;&gt;Power&lt;/div&gt;
      &lt;div class=&quot;col-xs-9 pull-left&quot;&gt;{{ model.power }}&lt;/div&gt;
    &lt;/div&gt;
    &lt;br&gt;
    &lt;button class=&quot;btn btn-default&quot; (click)=&quot;submitted=false&quot;&gt;Edit&lt;/button&gt;
  &lt;/div&gt;
&lt;/div&gt;
</code><code language="ts" name="hero.ts" format="linenums">export class Hero {

  constructor(
    public id: number,
    public name: string,
    public power: string,
    public alterEgo?: string
  ) {  }

}
</code><code language="ts" name="app.module.ts" format="linenums">import { NgModule }      from &apos;@angular/core&apos;;
import { BrowserModule } from &apos;@angular/platform-browser&apos;;
import { FormsModule }   from &apos;@angular/forms&apos;;

import { AppComponent }  from &apos;./app.component&apos;;
import { HeroFormComponent } from &apos;./hero-form.component&apos;;

@NgModule({
  imports: [
    BrowserModule,
    FormsModule
  ],
  declarations: [
    AppComponent,
    HeroFormComponent
  ],
  bootstrap: [ AppComponent ]
})
export class AppModule { }
</code><code language="ts" name="app.component.ts" format="linenums">import { Component } from &apos;@angular/core&apos;;

@Component({
  selector: &apos;my-app&apos;,
  template: &apos;&lt;hero-form&gt;&lt;/hero-form&gt;&apos;
})
export class AppComponent { }
</code><code language="ts" name="main.ts" format="linenums">import { platformBrowserDynamic } from &apos;@angular/platform-browser-dynamic&apos;;
import { AppModule } from &apos;./app.module&apos;;

// Compiles the module (asynchronously) with the runtime compiler
// which generates a compiled module factory in memory.
// Then bootstraps with that factory, targeting the browser.
platformBrowserDynamic().bootstrapModule(AppModule);
</code><code language="html" name="index.html" format="linenums">&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Hero Form&lt;/title&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;

    &lt;link rel=&quot;stylesheet&quot; 
          href=&quot;node_modules/bootstrap/dist/css/bootstrap.min.css&quot;&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;styles.css&quot;&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;forms.css&quot;&gt;

    &lt;!-- Polyfill(s) for older browsers --&gt;
    &lt;script src=&quot;node_modules/core-js/client/shim.min.js&quot;&gt;&lt;/script&gt;

    &lt;script src=&quot;node_modules/zone.js/dist/zone.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;node_modules/reflect-metadata/Reflect.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;node_modules/systemjs/dist/system.src.js&quot;&gt;&lt;/script&gt;

    &lt;script src=&quot;systemjs.config.js&quot;&gt;&lt;/script&gt;
    &lt;script&gt;
      System.import(&apos;app&apos;).catch(function(err){ console.error(err); });
    &lt;/script&gt;
  &lt;/head&gt;

  &lt;body&gt;
    &lt;my-app&gt;Loading...&lt;/my-app&gt;
  &lt;/body&gt;

&lt;/html&gt;
</code><code language="css" name="forms.css" format="linenums">.ng-valid[required], .ng-valid.required  {
  border-left: 5px solid #42A948; /* green */
}

.ng-invalid:not(form)  {
  border-left: 5px solid #a94442; /* red */
}
</code></code-tabs><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!--NEXT PAGE HAS NOW BEEN SET--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--></div></div>
        </article>
      
        <article>
          <h3>Dependency Injection</h3>
          <div><div class="showcase-content"><p><strong>Dependency injection</strong> is an important application design pattern.
Angular has its own dependency injection framework, and
we really can&apos;t build an Angular application without it.
It&apos;s used so widely that almost everyone just calls it <em>DI</em>.</p><span>
</span><p>In this chapter we&apos;ll learn what DI is and why we want it.
Then we&apos;ll learn <a href="https://angular.io/docs/ts/latest/guide/dependency-injection.html#angular-di">how to use it</a> in an Angular app.</p><span>
</span><ul>
<li><a href="https://angular.io/docs/ts/latest/guide/dependency-injection.html#why-dependency-injection">Why dependency injection?</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/dependency-injection.html#angular-dependency-injection">Angular dependency injection</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/dependency-injection.html#injector-providers">Injector providers</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/dependency-injection.html#dependency-injection-tokens">Dependency injection tokens</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/dependency-injection.html#summary">Summary</a></li>
</ul><span>
</span><p>Run the <live-example></live-example>.</p><span>
</span><h2 id="why-dependency-injection-">Why dependency injection?</h2><span>
</span><p>Let&apos;s start with the following code.</p><span>
</span><p>app/car/car.ts (without DI)</p><code language="ts" format="linenums">export class Car {

  public engine: Engine;
  public tires: Tires;
  public description = &apos;No DI&apos;;

  constructor() {
    this.engine = new Engine();
    this.tires = new Tires();
  }

  // Method using the engine and tires
  drive() {
    return `${this.description} car with ` +
      `${this.engine.cylinders} cylinders and ${this.tires.make} tires.`;
  }
}
</code><p>Our <code>Car</code> creates everything it needs inside its constructor.
What&apos;s the problem?
The problem is that our <code>Car</code> class is brittle, inflexible, and hard to test.</p><span>
</span><p>Our <code>Car</code> needs an engine and tires. Instead of asking for them,
the <code>Car</code> constructor instantiates its own copies from
the very specific classes <code>Engine</code> and <code>Tires</code>.</p><span>
</span><p>What if the <code>Engine</code> class evolves and its constructor requires a parameter?
Our <code>Car</code> is broken and stays broken until we rewrite it along the lines of
<code>this.engine = new Engine(theNewParameter)</code>.
We didn&apos;t care about <code>Engine</code> constructor parameters when we first wrote <code>Car</code>.
We don&apos;t really care about them now.
But we&apos;ll <em>have</em> to start caring because
when the definition of <code>Engine</code> changes, our <code>Car</code> class must change.
That makes <code>Car</code> brittle.</p><span>
</span><p>What if we want to put a different brand of tires on our <code>Car</code>? Too bad.
We&apos;re locked into whatever brand the <code>Tires</code> class creates. That makes our <code>Car</code> inflexible.</p><span>
</span><p>Right now each new car gets its own engine. It can&apos;t share an engine with other cars.
While that makes sense for an automobile engine,
we can think of other dependencies that should be shared, such as the onboard
wireless connection to the manufacturer&apos;s service center. Our <code>Car</code> lacks the flexibility
to share services that have been created previously for other consumers.</p><span>
</span><p>When we write tests for our <code>Car</code> we&apos;re at the mercy of its hidden dependencies.
Is it even possible to create a new <code>Engine</code> in a test environment?
What does <code>Engine</code>itself depend upon? What does that dependency depend on?
Will a new instance of <code>Engine</code> make an asynchronous call to the server?
We certainly don&apos;t want that going on during our tests.</p><span>
</span><p>What if our <code>Car</code> should flash a warning signal when tire pressure is low?
How do we confirm that it actually does flash a warning
if we can&apos;t swap in low-pressure tires during the test?</p><span>
</span><p>We have no control over the car&apos;s hidden dependencies.
When we can&apos;t control the dependencies, a class becomes difficult to test.</p><span>
</span><p>How can we make <code>Car</code> more robust, flexible, and testable?</p><span>
</span><p><a id="ctor-injection"></a>
That&apos;s super easy. We change our <code>Car</code> constructor to a version with DI:</p><span>
</span><code-tabs><code language="ts" name="app/car/car.ts (excerpt with DI)" format=".">public description = &apos;DI&apos;;

constructor(public engine: Engine, public tires: Tires) { }
</code><code language="ts" name="app/car/car.ts (excerpt without DI)" format=".">public engine: Engine;
public tires: Tires;
public description = &apos;No DI&apos;;

constructor() {
  this.engine = new Engine();
  this.tires = new Tires();
}
</code></code-tabs><p>See what happened? We moved the definition of the dependencies to the constructor.
Our <code>Car</code> class no longer creates an engine or tires.
It just consumes them.</p><span>
</span><div class="l-sub-section"><p>We also leveraged TypeScript&apos;s constructor syntax for declaring
parameters and properties simultaneously.</p><span>
</span></div><p>Now we create a car by passing the engine and tires to the constructor.</p><span>
</span><code language="ts" format="">// Simple car with 4 cylinders and Flintstone tires.
let car = new Car(new Engine(), new Tires());
</code><p>How cool is that?
The definition of the engine and tire dependencies are
decoupled from the <code>Car</code> class itself.
We can pass in any kind of engine or tires we like, as long as they
conform to the general API requirements of an engine or tires.</p><span>
</span><p>If someone extends the <code>Engine</code> class, that is not <code>Car</code>&apos;s problem.</p><span>
</span><div class="l-sub-section"><p>The <em>consumer</em> of <code>Car</code> has the problem. The consumer must update the car creation code to
something like this:</p><span>
</span><code language="ts" format="">class Engine2 {
  constructor(public cylinders: number) { }
}
// Super car with 12 cylinders and Flintstone tires.
let bigCylinders = 12;
let car = <span class="otl">new Car(new Engine2(bigCylinders), new Tires());</span>
</code><p>The critical point is this: <code>Car</code> itself did not have to change.
We&apos;ll take care of the consumer&apos;s problem soon enough.</p><span>
</span></div><p>The <code>Car</code> class is much easier to test because we are in complete control
of its dependencies.
We can pass mocks to the constructor that do exactly what we want them to do
during each test:</p><span>
</span><code language="ts" format="">class MockEngine extends Engine { cylinders = 8; }
class MockTires  extends Tires  { make = &apos;YokoGoodStone&apos;; }

// Test car with 8 cylinders and YokoGoodStone tires.
let car = <span class="otl">new Car(new MockEngine(), new MockTires());</span>
</code><p><strong>We just learned what dependency injection is</strong>.</p><span>
</span><p>It&apos;s a coding pattern in which a class receives its dependencies from external
sources rather than creating them itself.</p><span>
</span><p>Cool! But what about that poor consumer?
Anyone who wants a <code>Car</code> must now
create all three parts: the <code>Car</code>, <code>Engine</code>, and <code>Tires</code>.
The <code>Car</code> class shed its problems at the consumer&apos;s expense.
We need something that takes care of assembling these parts for us.</p><span>
</span><p>We could write a giant class to do that:</p><span>
</span><p>app/car/car-factory.ts</p><code language="ts" format="linenums">import { Engine, Tires, Car } from &apos;./car&apos;;

// BAD pattern!
export class CarFactory {
  createCar() {
    let car = new Car(this.createEngine(), this.createTires());
    car.description = &apos;Factory&apos;;
    return car;
  }

  createEngine() {
    return new Engine();
  }

  createTires() {
    return new Tires();
  }
}
</code><p>It&apos;s not so bad now with only three creation methods.
But maintaining it will be hairy as the application grows.
This factory is going to become a huge spiderweb of
interdependent factory methods!</p><span>
</span><p>Wouldn&apos;t it be nice if we could simply list the things we want to build without
having to define which dependency gets injected into what?</p><span>
</span><p>This is where the dependency injection framework comes into play.
Imagine the framework had something called an <em>injector</em>.
We register some classes with this injector, and it figures out how to create them.</p><span>
</span><p>When we need a <code>Car</code>, we simply ask the injector to get it for us and we&apos;re good to go.</p><span>
</span><code language="ts" format="">let car = injector.get(Car);
</code><p>Everyone wins. The <code>Car</code> knows nothing about creating an <code>Engine</code> or <code>Tires</code>.
The consumer knows nothing about creating a <code>Car</code>.
We don&apos;t have a gigantic factory class to maintain.
Both <code>Car</code> and consumer simply ask for what they need and the injector delivers.</p><span>
</span><p>This is what a <strong>dependency injection framework</strong> is all about.</p><span>
</span><p>Now that we know what dependency injection is and appreciate its benefits,
let&apos;s see how it is implemented in Angular.</p><span>
</span><h2 id="angular-dependency-injection">Angular dependency injection</h2><span>
</span><p>Angular ships with its own dependency injection framework. This framework can also be used
as a standalone module by other applications and frameworks.</p><span>
</span><p>That sounds nice. What does it do for us when building components in Angular?
Let&apos;s see, one step at a time.</p><span>
</span><p>We&apos;ll begin with a simplified version of the <code>HeroesComponent</code>
that we built in the <a href="https://angular.io/docs/ts/latest/tutorial/">The Tour of Heroes</a>.</p><span>
</span><code-tabs><code language="ts" name="app/heroes/heroes.component.ts" format="linenums">import { Component }          from &apos;@angular/core&apos;;

@Component({
  selector: &apos;my-heroes&apos;,
  template: `
  &lt;h2&gt;Heroes&lt;/h2&gt;
  &lt;hero-list&gt;&lt;/hero-list&gt;
  `
})
export class HeroesComponent { }
</code><code language="ts" name="app/heroes/hero-list.component.ts" format="linenums">import { Component }   from &apos;@angular/core&apos;;

import { HEROES }      from &apos;./mock-heroes&apos;;

@Component({
  selector: &apos;hero-list&apos;,
  template: `
  &lt;div *ngFor=&quot;let hero of heroes&quot;&gt;
    {{hero.id}} - {{hero.name}}
  &lt;/div&gt;
  `
})
export class HeroListComponent {
  heroes = HEROES;
}
</code><code language="ts" name="app/heroes/hero.ts" format="linenums">export class Hero {
  id: number;
  name: string;
  isSecret = false;
}
</code><code language="ts" name="app/heroes/mock-heroes.ts" format="linenums">import { Hero } from &apos;./hero&apos;;

export var HEROES: Hero[] = [
  { id: 11, isSecret: false, name: &apos;Mr. Nice&apos; },
  { id: 12, isSecret: false, name: &apos;Narco&apos; },
  { id: 13, isSecret: false, name: &apos;Bombasto&apos; },
  { id: 14, isSecret: false, name: &apos;Celeritas&apos; },
  { id: 15, isSecret: false, name: &apos;Magneta&apos; },
  { id: 16, isSecret: false, name: &apos;RubberMan&apos; },
  { id: 17, isSecret: false, name: &apos;Dynama&apos; },
  { id: 18, isSecret: true,  name: &apos;Dr IQ&apos; },
  { id: 19, isSecret: true,  name: &apos;Magma&apos; },
  { id: 20, isSecret: true,  name: &apos;Tornado&apos; }
];
</code></code-tabs><p>The <code>HeroesComponent</code> is the root component of the <em>Heroes</em> feature area.
It governs all the child components of this area.
Our stripped down version has only one child, <code>HeroListComponent</code>,
which displays a list of heroes.</p><span>
</span><p>Right now <code>HeroListComponent</code> gets heroes from <code>HEROES</code>, an in-memory collection
defined in another file.
That may suffice in the early stages of development, but it&apos;s far from ideal.
As soon as we try to test this component or want to get our heroes data from a remote server,
we&apos;ll have to change the implementation of <code>heroes</code> and
fix every other use of the <code>HEROES</code> mock data.</p><span>
</span><p>Let&apos;s make a service that hides how we get hero data.</p><span>
</span><div class="l-sub-section"><p>Given that the service is a
<a href="https://en.wikipedia.org/wiki/Separation_of_concerns">separate concern</a>,
we suggest that you
write the service code in its own file.</p><span>
</span><p>See <a href="https://angular.io/docs/ts/latest/guide/dependency-injection.html#one-class-per-file">this note</a> for details.</p><span>
</span></div><p>app/heroes/hero.service.ts</p><code language="ts" format="linenums">import { Injectable } from &apos;@angular/core&apos;;

import { HEROES }     from &apos;./mock-heroes&apos;;

@Injectable()
export class HeroService {
  getHeroes() { return HEROES;  }
}
</code><p>Our <code>HeroService</code> exposes a <code>getHeroes</code> method that returns
the same mock data as before, but none of its consumers need to know that.</p><span>
</span><div class="l-sub-section"><p>Notice the <code>@Injectable()</code> decorator above the service class.
We&apos;ll discuss its purpose <a href="https://angular.io/docs/ts/latest/guide/dependency-injection.html#injectable">shortly</a>.</p><span>
</span></div><div class="l-sub-section"><p>We aren&apos;t even pretending this is a real service.
If we were actually getting data from a remote server, the API would have to be 
asynchronous, perhaps returning a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">Promise</a>.
We&apos;d also have to rewrite the way components consume our service.
This is important in general, but not to our current story.</p><span>
</span></div><p>A service is nothing more than a class in Angular 2.
It remains nothing more than a class until we register it with an Angular injector.</p><span>
</span><h3 id="configuring-the-injector">Configuring the injector</h3><span>
</span><p>We don&apos;t have to create an Angular injector.
Angular creates an application-wide injector for us during the bootstrap process.</p><span>
</span><p>app/main.ts (excerpt)</p><code language="ts" format="">platformBrowserDynamic().bootstrapModule(AppModule);
</code><p>We do have to configure the injector by registering the <strong>providers</strong>
that create the services our application requires.
We&apos;ll explain what <a href="https://angular.io/docs/ts/latest/guide/dependency-injection.html#providers">providers</a> are later in this chapter.</p><span>
</span><p>We can either register a provider within an <a href="https://angular.io/docs/ts/latest/guide/ngmodule.html">NgModule</a> or in application components</p><span>
</span><h3 id="registering-providers-in-an-ngmodule">Registering providers in an NgModule</h3><span>
</span><p>Here&apos;s our AppModule where we register a <code>Logger</code>, an <code>UserService</code>, and an <code>APP_CONFIG</code> provider.</p><span>
</span><p>app/app.module.ts</p><code language="ts" format="">@NgModule({
  imports: [
    BrowserModule
  ],
  declarations: [
    AppComponent,
    CarComponent,
    HeroesComponent,
    HeroListComponent,
    InjectorComponent,
    TestComponent,
    ProvidersComponent,
    Provider1Component,
    Provider3Component,
    Provider4Component,
    Provider5Component,
    Provider6aComponent,
    Provider6bComponent,
    Provider7Component,
    Provider8Component,
    Provider9Component,
    Provider10Component,
  ],
  <span class="otl">providers</span>: [
    UserService,
    { provide: APP_CONFIG, useValue: HERO_DI_CONFIG }
  ],
  bootstrap: [ AppComponent, ProvidersComponent ]
})
export class AppModule { }
</code><h3 id="registering-providers-in-a-component">Registering providers in a component</h3><span>
</span><p>Here&apos;s a revised <code>HeroesComponent</code> that registers the <code>HeroService</code>.</p><span>
</span><p>app/heroes/heroes.component.ts</p><code language="ts" format="">import { Component }          from &apos;@angular/core&apos;;

import { HeroService }        from &apos;./hero.service&apos;;

@Component({
  selector: &apos;my-heroes&apos;,
  <span class="otl">providers</span>: [HeroService],
  template: `
  &lt;h2&gt;Heroes&lt;/h2&gt;
  &lt;hero-list&gt;&lt;/hero-list&gt;
  `
})
export class HeroesComponent { }
</code><h3 id="when-to-use-the-ngmodule-and-when-an-application-component-">When to use the NgModule and when an application component?</h3><span>
</span><p>On the one hand, a provider in an NgModule is registered in the root injector. That means that every provider
registered within an NgModule will be accessible in the entire application.</p><span>
</span><p>On the other hand, a provider registered in an application component is available only on that component and all its children.</p><span>
</span><p>We want the <code>APP_CONFIG</code> service to be available all across the application, but a <code>HeroService</code> is only used within the <em>Heroes</em>
feature area &#x2014; and nowhere else. &#x2014;</p><span>
</span><div class="l-sub-section"><p>Read also <strong>Should I add providers to the root AppModule or the root AppComponent?</strong> at the <a href="https://angular.io/docs/ts/latest/guide/ngmodule.html#q-root-component-or-module">NgModule</a> chapter.</p><span>
</span></div><h3 id="preparing-the-herolistcomponent-for-injection">Preparing the HeroListComponent for injection</h3><span>
</span><p>The <code>HeroListComponent</code> should get heroes from the injected <code>HeroService</code>.
Per the dependency injection pattern, the component must ask for the service in its 
constructor, <a href="https://angular.io/docs/ts/latest/guide/dependency-injection.html#ctor-injection">as we explained earlier</a>.
It&apos;s a small change:</p><span>
</span><code-tabs><code language="ts" name="app/heroes/hero-list.component (with DI)" format="linenums">import { Component }   from &apos;@angular/core&apos;;

import { Hero }        from &apos;./hero&apos;;
import { HeroService } from &apos;./hero.service&apos;;

@Component({
  selector: &apos;hero-list&apos;,
  template: `
  &lt;div *ngFor=&quot;let hero of heroes&quot;&gt;
    {{hero.id}} - {{hero.name}}
  &lt;/div&gt;
  `
})
export class HeroListComponent {
  heroes: Hero[];

  constructor(heroService: HeroService) {
    this.heroes = heroService.getHeroes();
  }
}
</code><code language="ts" name="app/heroes/hero-list.component (without DI)" format="linenums">import { Component }   from &apos;@angular/core&apos;;

import { HEROES }      from &apos;./mock-heroes&apos;;

@Component({
  selector: &apos;hero-list&apos;,
  template: `
  &lt;div *ngFor=&quot;let hero of heroes&quot;&gt;
    {{hero.id}} - {{hero.name}}
  &lt;/div&gt;
  `
})
export class HeroListComponent {
  heroes = HEROES;
}
</code></code-tabs><div class="l-sub-section"><h4 id="focus-on-the-constructor">Focus on the constructor</h4><span>
</span><p>Adding a parameter to the constructor isn&apos;t all that&apos;s happening here.</p><span>
</span><code language="ts" format="">constructor(heroService: HeroService) {
  this.heroes = heroService.getHeroes();
}
</code><p>Note that the constructor parameter has the type <code>HeroService</code>, and that
the <code>HeroListComponent</code> class has an <code>@Component</code> decorator
(scroll up to confirm that fact).
Also recall that the parent component (<code>HeroesComponent</code>)
has <code>providers</code> information for <code>HeroService</code>.</p><span>
</span><p>The constructor parameter type, the <code>@Component</code> decorator,
and the parent&apos;s <code>providers</code> information combine to tell the
Angular injector to inject an instance of
<code>HeroService</code> whenever it creates a new <code>HeroListComponent</code>.</p><span>
</span></div><h3 id="implicit-injector-creation">Implicit injector creation</h3><span>
</span><p>When we introduced the idea of an injector above, we showed how to
use it to create a new <code>Car</code>. Here we also show how such an injector
would be explicitly created:</p><span>
</span><code language="ts" format="">  injector = ReflectiveInjector.resolveAndCreate([Car, Engine, Tires]);
  let car = injector.get(Car);
</code><p>We won&apos;t find code like that in the Tour of Heroes or any of our other samples.
We <em>could</em> write code that <a href="https://angular.io/docs/ts/latest/guide/dependency-injection.html#explicit-injector">explicitly creates an injector</a> if we <em>had</em> to, but we rarely do.
Angular takes care of creating and calling injectors
when it creates components for us &#x2014; whether through HTML markup, as in <code>&lt;hero-list&gt;&lt;/hero-list&gt;</code>,
or after navigating to a component with the <a href="https://angular.io/docs/ts/latest/guide/router.html">router</a>.
If we let Angular do its job, we&apos;ll enjoy the benefits of automated dependency injection.</p><span>
</span><h3 id="singleton-services">Singleton services</h3><span>
</span><p>Dependencies are singletons within the scope of an injector.
In our example, a single <code>HeroService</code> instance is shared among the
<code>HeroesComponent</code> and its <code>HeroListComponent</code> children.</p><span>
</span><p>However, Angular DI is an hierarchical injection
system, which means that nested injectors can create their own service instances.
Learn more about that in the <a href="https://angular.io/docs/ts/latest/guide/hierarchical-dependency-injection.html">Hierarchical Injectors</a> chapter.</p><span>
</span><h3 id="testing-the-component">Testing the component</h3><span>
</span><p>We emphasized earlier that designing a class for dependency injection makes the class easier to test.
Listing dependencies as constructor parameters may be all we need to test application parts effectively.</p><span>
</span><p>For example, we can create a new <code>HeroListComponent</code> with a mock service that we can manipulate
under test:</p><span>
</span><code language="ts" format="">let expectedHeroes = [{name: &apos;A&apos;}, {name: &apos;B&apos;}]
let mockService = &lt;HeroService&gt; {getHeroes: () =&gt; expectedHeroes }

it(&apos;should have heroes when HeroListComponent created&apos;, () =&gt; {
  let hlc = new HeroListComponent(mockService);
  expect(hlc.heroes.length).toEqual(expectedHeroes.length);
});
</code><h3 id="when-the-service-needs-a-service">When the service needs a service</h3><span>
</span><p>Our <code>HeroService</code> is very simple. It doesn&apos;t have any dependencies of its own.</p><span>
</span><p>What if it had a dependency? What if it reported its activities through a logging service?
We&apos;d apply the same <em>constructor injection</em> pattern,
adding a constructor that takes a <code>Logger</code> parameter.</p><span>
</span><p>Here is the revision compared to the original.</p><span>
</span><code-tabs><code language="ts" name="app/heroes/hero.service (v2)" format="linenums">import { Injectable } from &apos;@angular/core&apos;;

import { HEROES }     from &apos;./mock-heroes&apos;;
import { Logger }     from &apos;../logger.service&apos;;

@Injectable()
export class HeroService {

  constructor(private logger: Logger) {  }

  getHeroes() {
    this.logger.log(&apos;Getting heroes ...&apos;);
    return HEROES;
  }
}
</code><code language="ts" name="app/heroes/hero.service (v1)" format="linenums">import { Injectable } from &apos;@angular/core&apos;;

import { HEROES }     from &apos;./mock-heroes&apos;;

@Injectable()
export class HeroService {
  getHeroes() { return HEROES;  }
}
</code></code-tabs><p>The constructor now asks for an injected instance of a <code>Logger</code> and stores it in a private property called <code>logger</code>.
We call that property within our <code>getHeroes</code> method when anyone asks for heroes.</p><span>
</span><h3 id="injectable">Why @Injectable()?</h3><p><strong><a href="https://angular.io/docs/ts/latest/api/core/index/InjectableMetadata-class.html">@Injectable()</a></strong> marks a class as available to an
injector for instantiation. Generally speaking, an injector will report an
error when trying to instantiate a class that is not marked as
<code>@Injectable()</code>.</p><span>
</span><div class="l-sub-section"><p>As it happens, we could have omitted <code>@Injectable()</code> from our first
version of <code>HeroService</code> because it had no injected parameters.
But we must have it now that our service has an injected dependency.
We need it because Angular requires constructor parameter metadata 
in order to inject a <code>Logger</code>.</p><span>
</span></div><div class="callout is-helpful"><header>Suggestion: add @Injectable() to every service class</header><p>We recommend adding <code>@Injectable()</code> to every service class, even those that don&apos;t have dependencies
and, therefore, do not technically require it. Here&apos;s why:</p><span>
</span><ul><li><b>Future proofing:</b> No need to remember <code>@Injectable()</code> when we add a dependency later.</li><li><b>Consistency:</b> All services follow the same rules, and we don&apos;t have to wonder why a decorator is missing.</li></ul></div><p>Injectors are also responsible for instantiating components
like <code>HeroesComponent</code>. Why haven&apos;t we marked <code>HeroesComponent</code> as
<code>@Injectable()</code>?</p><span>
</span><p>We <em>can</em> add it if we really want to. It isn&apos;t necessary because the
<code>HeroesComponent</code> is already marked with <code>@Component</code>, and this
decorator class (like <code>@Directive</code> and <code>@Pipe</code>, which we&apos;ll learn about later)
is a subtype of <a href="https://angular.io/docs/ts/latest/api/core/index/InjectableMetadata-class.html">InjectableMetadata</a>.  It is in
fact <code>InjectableMetadata</code> decorators that
identify a class as a target for instantiation by an injector.</p><span>
</span><div class="l-sub-section"><p>At runtime, injectors can read class metadata in the transpiled JavaScript code
and use the constructor parameter type information
to determine what things to inject. </p><span>
</span><p>Not every JavaScript class has metadata.
The TypeScript compiler discards metadata by default.
If the <code>emitDecoratorMetadata</code> compiler option is true 
(as it should be in the <code>tsconfig.json</code>),
the compiler adds the metadata to the generated JavaScript 
for <em>every class with at least one decorator</em>.</p><span>
</span><p>While any decorator will trigger this effect, mark the service class with the
<a href="https://angular.io/docs/ts/latest/api/core/index/InjectableMetadata-class.html">InjectableMetadata</a> decorator
to make the intent clear.</p><span>
</span></div><div class="callout is-critical"><header>Always include the parentheses</header><p>Always write <code>@Injectable()</code>, not just <code>@Injectable</code>.
Our application will fail mysteriously if we forget the parentheses.</p><span>
</span></div><h2 id="creating-and-registering-a-logger-service">Creating and registering a logger service</h2><span>
</span><p>We&apos;re injecting a logger into our <code>HeroService</code> in two steps:</p><span>
</span><ol>
<li>Create the logger service.</li>
<li>Register it with the application.</li>
</ol><span>
</span><p>Our logger service is quite simple:</p><span>
</span><p>app/logger.service.ts</p><code language="ts" format="linenums">import { Injectable } from &apos;@angular/core&apos;;

@Injectable()
export class Logger {
  logs: string[] = []; // capture logs for testing

  log(message: string) {
    this.logs.push(message);
    console.log(message);
  }
}
</code><p>We&apos;re likely to need the same logger service everywhere in our application,
so we put it in the project&apos;s <code>app</code> folder, and
we register it in the <code>providers</code> array of the metadata for our application module, <code>AppModule</code>.</p><span>
</span><p>app/app.module.ts (excerpt) (providers-logger)</p><code language="ts" format="">providers: [Logger]
</code><p>If we forget to register the logger, Angular throws an exception when it first looks for the logger:</p><span>
</span><code format="nocode">EXCEPTION: No provider for Logger! (HeroListComponent -&gt; HeroService -&gt; Logger)
</code><p>That&apos;s Angular telling us that the dependency injector couldn&apos;t find the <em>provider</em> for the logger.
It needed that provider to create a <code>Logger</code> to inject into a new
<code>HeroService</code>, which it needed to
create and inject into a new <code>HeroListComponent</code>.</p><span>
</span><p>The chain of creations started with the <code>Logger</code> provider. <em>Providers</em> are the subject of our next section.</p><span>
</span><h2 id="injector-providers">Injector providers</h2><span>
</span><p>A provider <em>provides</em> the concrete, runtime version of a dependency value.
The injector relies on <strong>providers</strong> to create instances of the services
that the injector injects into components and other services.</p><span>
</span><p>We must register a service <em>provider</em> with the injector, or it won&apos;t know how to create the service.</p><span>
</span><p>Earlier we registered the <code>Logger</code> service in the <code>providers</code> array of the metadata for the <code>AppModule</code> like this:</p><span>
</span><code language="ts" format="">providers: [Logger]
</code><p>There are many ways to <em>provide</em> something that looks and behaves like a  <code>Logger</code>.
The <code>Logger</code> class itself is an obvious and natural provider.
But it&apos;s not the only way.</p><span>
</span><p>We can configure the injector with alternative providers that can deliver an object that behaves like  a <code>Logger</code>.
We could provide a substitute class. We could provide a logger-like object. 
We could give it a provider that calls a logger factory function.
Any of these approaches might be a good choice under the right circumstances.</p><span>
</span><p>What matters is that the injector has a provider to go to when it needs a <code>Logger</code>.</p><span>
</span><h3 id="the-provider-class-_andprovidefn-">The <em>Provider</em> class and <i>provide</i> object literal</h3><span>
</span><p>We wrote the <code>providers</code> array like this:</p><span>
</span><code language="ts" format="">providers: [Logger]
</code><p>This is actually a shorthand expression for a provider registration
using a <em>provider</em> object literal with two properties:</p><span>
</span><code language="ts" format="">[{ provide: Logger, useClass: Logger }]
</code><p>The first is the <a href="https://angular.io/docs/ts/latest/guide/dependency-injection.html#token">token</a> that serves as the key for both locating a dependency value
and registering the provider.</p><span>
</span><p>The second is a provider definition object, 
which we can think of as a <em>recipe</em> for creating the dependency value. 
There are many ways to create dependency values ... and many ways to write a recipe.</p><span>
</span><h3 id="alternative-class-providers">Alternative class providers</h3><span>
</span><p>Occasionally we&apos;ll ask a different class to provide the service.
The following code tells the injector
to return a <code>BetterLogger</code> when something asks for the <code>Logger</code>.</p><span>
</span><code language="ts" format="">[{ provide: Logger, useClass: BetterLogger }]
</code><h3 id="class-provider-with-dependencies">Class provider with dependencies</h3><span>
</span><p>Maybe an <code>EvenBetterLogger</code> could display the user name in the log message.
This logger gets the user from the injected <code>UserService</code>,
which happens also to be injected at the application level.</p><span>
</span><code language="ts" format="">@Injectable()
class EvenBetterLogger extends Logger {
  constructor(private userService: UserService) { super(); }

  log(message: string) {
    let name = this.userService.user.name;
    super.log(`Message to ${name}: ${message}`);
  }
}
</code><p>Configure it like we did <code>BetterLogger</code>.</p><span>
</span><code language="ts" format="">[ UserService,
  { provide: Logger, useClass: EvenBetterLogger }]
</code><h3 id="aliased-class-providers">Aliased class providers</h3><span>
</span><p>Suppose an old component depends upon an <code>OldLogger</code> class.
<code>OldLogger</code> has the same interface as the <code>NewLogger</code>, but for some reason
we can&apos;t update the old component to use it.</p><span>
</span><p>When the <em>old</em> component logs a message with <code>OldLogger</code>,
we want the singleton instance of <code>NewLogger</code> to handle it instead.</p><span>
</span><p>The dependency injector should inject that singleton instance
when a component asks for either the new or the old logger.
The <code>OldLogger</code> should be an alias for <code>NewLogger</code>.</p><span>
</span><p>We certainly do not want two different <code>NewLogger</code> instances in our app.
Unfortunately, that&apos;s what we get if we try to alias <code>OldLogger</code> to <code>NewLogger</code> with <code>useClass</code>.</p><span>
</span><code language="ts" format="">[ NewLogger,
  // Not aliased! Creates two instances of `NewLogger`
  { provide: OldLogger, useClass: NewLogger}]
</code><p>The solution: alias with the <code>useExisting</code> option.</p><span>
</span><code language="ts" format="">[ NewLogger,
  // Alias OldLogger w/ reference to NewLogger
  { provide: OldLogger, <span class="otl">useExisting: NewLogger</span>}]
</code><h3 id="value-providers">Value providers</h3><span>
</span><p>Sometimes it&apos;s easier to provide a ready-made object rather than ask the injector to create it from a class.</p><span>
</span><code language="ts" format="">// An object in the shape of the logger service
let silentLogger = {
  logs: [&apos;Silent logger says &quot;Shhhhh!&quot;. Provided via &quot;useValue&quot;&apos;],
  log: () =&gt; {}
};
</code><p>Then we register a provider with the <code>useValue</code> option,
which makes this object play the logger role.</p><span>
</span><code language="ts" format="">[{ provide: Logger, <span class="otl">useValue: silentLogger</span> }]
</code><p>See more <code>useValue</code> examples in the
<a href="https://angular.io/docs/ts/latest/guide/dependency-injection.html#non-class-dependencies">Non-class dependencies</a> and
<a href="https://angular.io/docs/ts/latest/guide/dependency-injection.html#opaquetoken">OpaqueToken</a> sections.</p><span>
</span><h3 id="factory-providers">Factory providers</h3><span>
</span><p>Sometimes we need to create the dependent value dynamically,
based on information we won&apos;t have until the last possible moment.
Maybe the information changes repeatedly in the course of the browser session.</p><span>
</span><p>Suppose also that the injectable service has no independent access to the source of this information.</p><span>
</span><p>This situation calls for a <strong>factory provider</strong>.</p><span>
</span><p>Let&apos;s illustrate by adding a new business requirement:
the HeroService must hide <em>secret</em> heroes from normal users.
Only authorized users should see secret heroes.</p><span>
</span><p>Like the <code>EvenBetterLogger</code>, the <code>HeroService</code> needs a fact about the user.
It needs to know if the user is authorized to see secret heroes.
That authorization can change during the course of a single application session,
as when we log in a different user.</p><span>
</span><p>Unlike <code>EvenBetterLogger</code>, we can&apos;t inject the <code>UserService</code> into the <code>HeroService</code>.
The <code>HeroService</code> won&apos;t have direct access to the user information to decide
who is authorized and who is not.</p><span>
</span><div class="l-sub-section"><p>Why? We don&apos;t know either. Stuff like this happens.</p><span>
</span></div><p>Instead the <code>HeroService</code> constructor takes a boolean flag to control display of secret heroes.</p><span>
</span><p>app/heroes/hero.service.ts (excerpt)</p><code language="ts" format="">constructor(
  private logger: Logger,
  private isAuthorized: boolean) { }

getHeroes() {
  let auth = this.isAuthorized ? &apos;authorized &apos; : &apos;unauthorized&apos;;
  this.logger.log(`Getting heroes for ${auth} user.`);
  return HEROES.filter(hero =&gt; this.isAuthorized || !hero.isSecret);
}
</code><p>We can inject the <code>Logger</code>, but we can&apos;t inject the  boolean <code>isAuthorized</code>.
We&apos;ll have to take over the creation of new instances of this <code>HeroService</code> with a factory provider.</p><span>
</span><p>A factory provider needs a factory function:</p><span>
</span><p>app/heroes/hero.service.provider.ts (excerpt)</p><code language="ts" format="">let heroServiceFactory = (logger: Logger, userService: UserService) =&gt; {
  return new HeroService(logger, userService.user.isAuthorized);
};
</code><p>Although the <code>HeroService</code> has no access to the <code>UserService</code>, our factory function does.</p><span>
</span><p>We inject both the <code>Logger</code> and the <code>UserService</code> into the factory provider and let the injector pass them along to the factory function:</p><span>
</span><p>app/heroes/hero.service.provider.ts (excerpt)</p><code language="ts" format="">export let heroServiceProvider =
  { provide: HeroService,
    useFactory: heroServiceFactory,
    deps: [Logger, UserService]
  };
</code><div class="l-sub-section"><p>The <code>useFactory</code> field tells Angular that the provider is a factory function
whose implementation is the <code>heroServiceFactory</code>.</p><span>
</span><p>The <code>deps</code> property is an array of <a href="https://angular.io/docs/ts/latest/guide/dependency-injection.html#token">provider tokens</a>.
The <code>Logger</code> and <code>UserService</code> classes serve as tokens for their own class providers.
The injector resolves these tokens and injects the corresponding services into the matching factory function parameters.</p><span>
</span></div><p>Notice that we captured the factory provider in an exported variable, <code>heroServiceProvider</code>.
This extra step makes the factory provider reusable.
We can register our <code>HeroService</code> with this variable wherever we need it.</p><span>
</span><p>In our sample, we need it only in the <code>HeroesComponent</code>,
where it replaces the previous <code>HeroService</code> registration in the metadata <code>providers</code> array.
Here we see the new and the old implementation side-by-side:</p><span>
</span><code-tabs><code language="ts" name="app/heroes/heroes.component (v3)" format="linenums">import { Component }          from &apos;@angular/core&apos;;

import { heroServiceProvider } from &apos;./hero.service.provider&apos;;

@Component({
  selector: &apos;my-heroes&apos;,
  template: `
  &lt;h2&gt;Heroes&lt;/h2&gt;
  &lt;hero-list&gt;&lt;/hero-list&gt;
  `,
  providers: [heroServiceProvider]
})
export class HeroesComponent { }
</code><code language="ts" name="app/heroes/heroes.component (v2)" format="linenums">import { Component }          from &apos;@angular/core&apos;;

import { HeroService }        from &apos;./hero.service&apos;;

@Component({
  selector: &apos;my-heroes&apos;,
  <span class="otl">providers: [HeroService]</span>,
  template: `
  &lt;h2&gt;Heroes&lt;/h2&gt;
  &lt;hero-list&gt;&lt;/hero-list&gt;
  `
})
export class HeroesComponent { }
</code></code-tabs><h2 id="dependency-injection-tokens">Dependency injection tokens</h2><span>
</span><p>When we register a provider with an injector, we associate that provider with a dependency injection token.
The injector maintains an internal <em>token-provider</em> map that it references when
asked for a dependency. The token is the key to the map.</p><span>
</span><p>In all previous examples, the dependency value has been a class <em>instance</em>, and
the class <em>type</em> served as its own lookup key.
Here we get a <code>HeroService</code> directly from the injector by supplying the <code>HeroService</code> type as the token:</p><span>
</span><code language="ts" format="">heroService: HeroService = this.injector.get(HeroService);
</code><p>We have similar good fortune when we write a constructor that requires an injected class-based dependency.
We define a constructor parameter with the <code>HeroService</code> class type,
and Angular knows to inject the
service associated with that <code>HeroService</code> class token:</p><span>
</span><code language="ts" format="">constructor(heroService: HeroService)
</code><p>This is especially convenient when we consider that most dependency values are provided by classes.</p><span>
</span><h3 id="non-class-dependencies">Non-class dependencies</h3><span>
</span><p>What if the dependency value isn&apos;t a class? Sometimes the thing we want to inject is a <span>string, function, or object.</span></p><p>Applications often define configuration objects with lots of small facts 
(like the title of the application or the address of a web API endpoint)&#xA0;but these configuration objects aren&apos;t always instances of a class.
They can be object literals &#xA0;such as this one:</p><p>app/app-config.ts (excerpt)</p><code language="ts" format="">export interface AppConfig {
  apiEndpoint: string;
  title: string;
}

export const HERO_DI_CONFIG: AppConfig = {
  apiEndpoint: &apos;api.heroes.com&apos;,
  title: &apos;Dependency Injection&apos;
};
</code><p>We&apos;d like to make this configuration object available for injection.
We know we can register an object with a <a href="https://angular.io/docs/ts/latest/guide/dependency-injection.html#value-provider">value provider</a>.</p><span>
</span><p>But what should we use as the token?
We don&apos;t have a class to serve as a token.
There is no <code>AppConfig</code> class.</p><span>
</span><div id="interface" class="l-sub-section"><h3 id="typescript-interfaces-aren-t-valid-tokens">TypeScript interfaces aren&apos;t valid tokens</h3><span>
</span><p>The <code>HERO_DI_CONFIG</code> constant has an interface, <code>AppConfig</code>. Unfortunately, we
cannot use a TypeScript interface as a token:</p><span>
</span><code language="ts" format="">// FAIL!  Can&apos;t use interface as provider token
[{ provide: AppConfig, useValue: HERO_DI_CONFIG })]
</code><code language="ts" format="">// FAIL! Can&apos;t inject using the interface as the parameter type
constructor(private config: AppConfig){ }
</code><p>That seems strange if we&apos;re used to dependency injection in strongly typed languages, where
an interface is the preferred dependency lookup key.</p><span>
</span><p>It&apos;s not Angular&apos;s fault. An interface is a TypeScript design-time artifact. JavaScript doesn&apos;t have interfaces.
The TypeScript interface disappears from the generated JavaScript.
There is no interface type information left for Angular to find at runtime.</p><span>
</span></div><h3 id="opaquetoken">OpaqueToken</h3><span>
</span><p>One solution to choosing a provider token for non-class dependencies is
to define and use an <a href="https://angular.io/docs/ts/latest/api/core/index/OpaqueToken-class.html"><b>OpaqueToken</b></a>.
The definition looks like this:</p><span>
</span><code language="ts" format="">import { OpaqueToken } from &apos;@angular/core&apos;;

export let APP_CONFIG = new OpaqueToken(&apos;app.config&apos;);
</code><p>We register the dependency provider using the <code>OpaqueToken</code> object:</p><span>
</span><code language="ts" format="">providers: [{ provide: APP_CONFIG, useValue: HERO_DI_CONFIG }]
</code><p>Now we can inject the configuration object into any constructor that needs it, with
the help of an <code>@Inject</code> decorator:</p><span>
</span><code language="ts" format="">constructor(@Inject(APP_CONFIG) config: AppConfig) {
  this.title = config.title;
}
</code><div class="l-sub-section"><p>Although the <code>AppConfig</code> interface plays no role in dependency injection,
it supports typing of the configuration object within the class.</p><span>
</span></div><p>Or we can provide and inject the configuration object in an ngModule like <code>AppModule</code>.</p><span>
</span><p>app/app.module.ts (ngmodule-providers)</p><code language="ts" format="">providers: [
  UserService,
  { provide: APP_CONFIG, useValue: HERO_DI_CONFIG }
],
</code><h2 id="optional-dependencies">Optional dependencies</h2><span>
</span><p>Our <code>HeroService</code> <em>requires</em> a <code>Logger</code>, but what if it could get by without
a logger?
We can tell Angular that the dependency is optional by annotating the 
constructor argument with <code>@Optional()</code>:</p><span>
</span><code language="ts" format="">import { Optional } from &apos;@angular/core&apos;;
</code><code language="ts" format="">constructor(@Optional() private logger: Logger) {
  if (this.logger) {
    this.logger.log(some_message);
  }
}
</code><p>When using <code>@Optional()</code>, our code must be prepared for a null value. If we
don&apos;t register a logger somewhere up the line, the injector will set the
value of <code>logger</code> to null.</p><span>
</span><h2 id="summary">Summary</h2><span>
</span><p>We learned the basics of Angular dependency injection in this chapter.
We can register various kinds of providers,
and we know how to ask for an injected object (such as a service) by
adding a parameter to a constructor.</p><span>
</span><p>Angular dependency injection is more capable than we&apos;ve described.
We can learn more about its advanced features, beginning with its support for
nested injectors, in the
<a href="https://angular.io/docs/ts/latest/guide/hierarchical-dependency-injection.html">Hierarchical Dependency Injection</a> chapter.</p><span>
</span><h2 id="appendix-working-with-injectors-directly">Appendix: Working with injectors directly</h2><span>
</span><p>We rarely work directly with an injector, but
here&apos;s an <code>InjectorComponent</code> that does.</p><span>
</span><p>app/injector.component.ts</p><code language="ts" format="linenums">@Component({
  selector: &apos;my-injectors&apos;,
  template: `
  &lt;h2&gt;Other Injections&lt;/h2&gt;
  &lt;div id=&quot;car&quot;&gt;{{car.drive()}}&lt;/div&gt;
  &lt;div id=&quot;hero&quot;&gt;{{hero.name}}&lt;/div&gt;
  &lt;div id=&quot;rodent&quot;&gt;{{rodent}}&lt;/div&gt;
  `,
  providers: [Car, Engine, Tires, heroServiceProvider, Logger]
})
export class InjectorComponent {
  car: Car = this.injector.get(Car);

  heroService: HeroService = this.injector.get(HeroService);
  hero: Hero = this.heroService.getHeroes()[0];

  constructor(private injector: Injector) { }

  get rodent() {
    let rousDontExist = `R.O.U.S.&apos;s? I don&apos;t think they exist!`;
    return this.injector.get(ROUS, rousDontExist);
  }
}
</code><p>An <code>Injector</code> is itself an injectable service.</p><span>
</span><p>In this example, Angular injects the component&apos;s own <code>Injector</code> into the component&apos;s constructor.
The component then asks the injected injector for the services it wants.</p><span>
</span><p>Note that the services themselves are not injected into the component.
They are retrieved by calling <code>injector.get</code>.</p><span>
</span><p>The <code>get</code> method throws an error if it can&apos;t resolve the requested service.
We can call <code>get</code> with a second parameter (the value to return if the service is not found) 
instead, which we do in one case
to retrieve a service (<code>ROUS</code>) that isn&apos;t registered with this or any ancestor injector.</p><span>
</span><div class="l-sub-section"><p>The technique we just described is an example of the
<a href="https://en.wikipedia.org/wiki/Service_locator_pattern">service locator pattern</a>.</p><span>
</span><p>We <strong>avoid</strong> this technique unless we genuinely need it.
It encourages a careless grab-bag approach such as we see here.
It&apos;s difficult to explain, understand, and test.
We can&apos;t know by inspecting the constructor what this class requires or what it will do.
It could acquire services from any ancestor component, not just its own.
We&apos;re forced to spelunk the implementation to discover what it does.</p><span>
</span><p>Framework developers may take this approach when they
must acquire services generically and dynamically.</p><span>
</span></div><h2 id="appendix-why-we-recommend-one-class-per-file">Appendix: Why we recommend one class per file</h2><span>
</span><p>Having multiple classes in the same file is confusing and best avoided.
Developers expect one class per file. Keep them happy.</p><span>
</span><p>If we scorn this advice and, say,
combine our <code>HeroService</code> class with the <code>HeroesComponent</code> in the same file,
<strong>define the component last!</strong>
If we define the component before the service,
we&apos;ll get a runtime null reference error.</p><span>
</span><div class="l-sub-section"><p>We actually can define the component first with the help of the <code>forwardRef()</code> method as explained
in this <a href="http://blog.thoughtram.io/angular/2015/09/03/forward-references-in-angular-2.html">blog post</a>.
But why flirt with trouble?
Avoid the problem altogether by defining components and services in separate files.</p><span>
</span></div><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!--NEXT PAGE HAS NOW BEEN SET--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--></div></div>
        </article>
      
        <article>
          <h3>Template Syntax</h3>
          <div><div class="showcase-content"><p>Our Angular application manages what the user sees and can do, achieving this through the interaction of a Component class instance (the <em>component</em>) and its user-facing template.</p><span>
</span><p>Many of us are familiar with the component/template duality from our experience with model-view-controller (MVC) or model-view-viewmodel (MVVM). In Angular,  the component plays the part of the controller/viewmodel, and the template represents the view.</p><span>
</span><p>Let&#x2019;s find out what it takes to write a template for our view. We&#x2019;ll cover these basic elements of template syntax:</p><span>
</span><ul>
<li><a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#html">HTML</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#interpolation">Interpolation</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#template-expressions">Template expressions</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#template-statements">Template statements</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#binding-syntax">Binding syntax</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#property-binding">Property binding</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#other-bindings">Attribute, class, and style bindings</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#event-binding">Event binding</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#ngModel">Two-way data binding with <code>NgModel</code></a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#directives">Built-in directives</a><ul>
<li><a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#ngClass">NgClass</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#ngStyle">NgStyle</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#ngIf">NgIf</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#ngSwitch">NgSwitch</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#ngFor">NgFor</a></li>
</ul>
</li>
<li><a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#star-template">* and &lt;template&gt;</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#ref-vars">Template reference variables</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#inputs-outputs">Input and output properties</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#expression-operators">Template expression operators</a><ul>
<li><a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#pipe">pipe</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#safe-navigation-operator">safe navigation operator (?.)</a></li>
</ul>
</li>
</ul><span>
</span><p>The <live-example></live-example>
demonstrates all of the syntax and code snippets described in this chapter.</p><span>
</span><h2 id="html">HTML</h2><span>
</span><p>HTML is the language of the Angular template. Our <a href="https://angular.io/docs/ts/latest/quickstart.html">QuickStart</a> application has a template that is pure HTML:</p><span>
</span><code language="html" escape="html">
</code><p>Almost all HTML syntax is valid template syntax. The <code>&lt;script&gt;</code> element is a notable exception; it is forbidden, eliminating the risk of script injection attacks. (In practice, <code>&lt;script&gt;</code> is simply ignored.)</p><span>
</span><p>Some legal HTML doesn&#x2019;t make much sense in a template. The <code>&lt;html&gt;</code>, <code>&lt;body&gt;</code>, and <code>&lt;base&gt;</code> elements have no useful role in our repertoire. Pretty much everything else is fair game.</p><span>
</span><p>We can extend the HTML vocabulary of our templates with components and directives that appear as new elements and attributes. In the following sections we are going to learn how to get and set DOM (Document Object Model) values dynamically through data binding.</p><span>
</span><p>Let&#x2019;s turn to the first form of data binding &#x2014; interpolation &#x2014; to see how much richer template HTML can be.</p><span>
</span><h2 id="interpolation">Interpolation</h2><span>
</span><p>We met the double-curly braces of interpolation, <code>{{</code> and <code>}}</code>, early in our Angular education.</p><span>
</span><code language="html" format="">&lt;p&gt;My current hero is {{currentHero.firstName}}&lt;/p&gt;
</code><p>We use interpolation to weave calculated strings into the text between HTML element tags and within attribute assignments.</p><span>
</span><code language="html" format="">&lt;h3&gt;
  {{title}}
  &lt;img src=&quot;{{heroImageUrl}}&quot; style=&quot;height:30px&quot;&gt;
&lt;/h3&gt;
</code><p>The material between the braces is often the name of a component property. Angular replaces that name with the
string value of the corresponding component property. In the example above, Angular evaluates the <code>title</code> and <code>heroImageUrl</code> properties
and &quot;fills in the blanks&quot;, first displaying a bold application title and then a heroic image.</p><span>
</span><p>More generally, the material between the braces is a <strong>template expression</strong> that Angular first <strong>evaluates</strong>
and then <strong>converts to a string</strong>. The following interpolation illustrates the point by adding the two numbers within braces:</p><span>
</span><code language="html" format="">&lt;!-- &quot;The sum of 1 + 1 is 2&quot; --&gt;
&lt;p&gt;The sum of 1 + 1 is {{1 + 1}}&lt;/p&gt;
</code><p>The expression can invoke methods of the host component, as we do here with <code>getVal()</code>:</p><span>
</span><code language="html" format="">&lt;!-- &quot;The sum of 1 + 1 is not 4&quot; --&gt;
&lt;p&gt;The sum of 1 + 1 is not {{1 + 1 + getVal()}}&lt;/p&gt;
</code><p>Angular evaluates all expressions in double curly braces, converts the expression results to strings, and links them with neighboring literal strings. Finally,
it assigns this composite interpolated result to an <strong>element or directive property</strong>.</p><span>
</span><p>We appear to be inserting the result between element tags and assigning it to attributes.
It&apos;s convenient to think so, and we rarely suffer for this mistake.
Though this is not exactly true. Interpolation is a special syntax that Angular converts into a
<a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#property-binding">property binding</a>, and is explained below.</p><span>
</span><p>But first, let&apos;s take a closer look at template expressions and statements.</p><span>
</span><a id="template-expressions"></a><h2 id="template-expressions">Template expressions</h2><span>
</span><p>A template <strong>expression</strong> produces a value.
Angular executes the expression and assigns it to a property of a binding target;
the target might be an HTML element, a component, or a directive.</p><span>
</span><p>We put a template expression within the interpolation braces when we wrote <code>{{1 + 1}}</code>.
We&#x2019;ll see template expressions again in the <a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#property-binding">property binding</a> section,
appearing in quotes to the right of the <code>=</code> symbol as in <code>[property]=&quot;expression&quot;</code>.</p><span>
</span><p>We write template expressions in a language that looks like JavaScript.
Many JavaScript expressions are legal template expressions, but not all.</p><span>
</span><p>JavaScript expressions that have or promote side effects are prohibited,
including:</p><span>
</span><ul>
<li>assignments (<code>=</code>, <code>+=</code>, <code>-=</code>, ...)</li>
<li><code>new</code></li>
<li>chaining expressions with <code>;</code> or <code>,</code></li>
<li>increment and decrement operators (<code>++</code> and <code>--</code>)</li>
</ul><span>
</span><p>Other notable differences from JavaScript syntax include:</p><span>
</span><ul>
<li>no support for the bitwise operators <code>|</code> and <code>&amp;</code></li>
<li>new <a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#expression-operators">template expression operators</a>, such as <code>|</code> and <code>?.</code></li>
</ul><span>
</span><h3 id="expression-context">Expression context</h3><p>Perhaps more surprising, template expressions cannot refer to anything in
the global namespace. They can&#x2019;t refer to <code>window</code> or <code>document</code>. They
can&#x2019;t call <code>console.log</code> or <code>Math.max</code>. They are restricted to referencing
members of the expression context.</p><span>
</span><p>The <em>expression context</em> is typically the <strong>component instance</strong>, which is
the source of binding values.</p><span>
</span><p>When we see <em>title</em> wrapped in double-curly braces, <code>{{title}}</code>,
we know that <code>title</code> is a property of the data-bound component.
When we see <em>isUnchanged</em> in <code>[disabled]=&quot;isUnchanged&quot;</code>,
we know we are referring to that component&apos;s <code>isUnchanged</code> property.</p><span>
</span><p>The component itself is usually the expression <em>context</em>, in which case
the template expression usually references that component.</p><span>
</span><p>The expression context can include objects other than the component.
A <a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#ref-vars">template reference variable</a> is one such alternative context object.</p><span>
</span><span>
</span><h3 id="expression-guidelines">Expression guidelines</h3><span>
</span><p>Template expressions can make or break an application.
Please follow these guidelines:</p><span>
</span><ul>
<li><a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#no-visible-side-effects">No visible side effects</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#quick-execution">Quick execution</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#simplicity">Simplicity</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#idempotence">Idempotence</a></li>
</ul><span>
</span><p>The only exceptions to these guidelines should be in specific circumstances that you thoroughly understand.</p><span>
</span><h4 id="no-visible-side-effects">No visible side effects</h4><span>
</span><p>A template expression should not change any application state other than the value of the
target property.</p><span>
</span><p>This rule is essential to Angular&apos;s &quot;unidirectional data flow&quot; policy.
We should never worry that reading a component value might change some other displayed value.
The view should be stable throughout a single rendering pass.</p><span>
</span><h4 id="quick-execution">Quick execution</h4><span>
</span><p>Angular executes template expressions more often than we think.
They can be called after every keypress or mouse move.
Expressions should finish quickly or the user experience may drag, especially on slower devices.
Consider caching values computed from other values when the computation is expensive.</p><span>
</span><h4 id="simplicity">Simplicity</h4><span>
</span><p>Although it&apos;s possible to write quite complex template expressions, we really shouldn&apos;t.</p><span>
</span><p>A property name or method call should be the norm.
An occasional Boolean negation (<code>!</code>) is OK.
Otherwise, confine application and business logic to the component itself,
where it will be easier to develop and test.</p><span>
</span><h4 id="idempotence">Idempotence</h4><span>
</span><p>An <a href="https://en.wikipedia.org/wiki/Idempotence">idempotent</a> expression is ideal because
it is free of side effects and improves Angular&apos;s change detection performance.</p><span>
</span><p>In Angular terms, an idempotent expression always returns <em>exactly the same thing</em> until
one of its dependent values changes.</p><span>
</span><p>Dependent values should not change during a single turn of the event loop.
If an idempotent expression returns a string or a number, it returns the same string or number
when called twice in a row. If the expression returns an object (including an <code>Array</code>),
it returns the same object <em>reference</em> when called twice in a row.</p><span>
</span><h2 id="template-statements">Template statements</h2><span>
</span><p>A template <strong>statement</strong> responds to an <strong>event</strong> raised by a binding target
such as an element, component, or directive.</p><span>
</span><p>We&#x2019;ll see template statements in the <a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#event-binding">event binding</a> section,
appearing in quotes to the right of the <code>=</code> symbol as in <code>(event)=&quot;statement&quot;</code>.</p><span>
</span><p>A template statement <em>has a side effect</em>.
It&apos;s how we update application state from user input.
There would be no point to responding to an event otherwise.</p><span>
</span><div class="l-sub-section"><p>Responding to events is the other side of Angular&apos;s &quot;unidirectional data flow&quot;.
We&apos;re free to change anything, anywhere, during this turn of the event loop.</p><span>
</span></div><p>Like template expressions, template <em>statements</em> use a language that looks like JavaScript.
The template statement parser is different than the template expression parser and
specifically supports both basic assignment (<code>=</code>) and chaining expressions 
(with <code>;</code> or <code>,</code>).</p><span>
</span><p>However, certain JavaScript syntax is not allowed:</p><span>
</span><ul>
<li><code>new</code></li>
<li>increment and decrement operators, <code>++</code> and <code>--</code></li>
<li>operator assignment, such as <code>+=</code> and <code>-=</code></li>
<li>the bitwise operators <code>|</code> and <code>&amp;</code></li>
<li>the <a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#expression-operators">template expression operators</a></li>
</ul><span>
</span><h3 id="statement-context">Statement context</h3><span>
</span><p>As with expressions, statements can refer only to what&apos;s in the statement context &#x2014; typically the
<strong>component instance</strong> to which we&apos;re binding the event.</p><span>
</span><p>Template statements cannot refer to anything in the global namespace. They
can&#x2019;t refer to <code>window</code> or <code>document</code>. They can&#x2019;t call <code>console.log</code> or
<code>Math.max</code>.</p><span>
</span><p>The <em>onSave</em> in <code>(click)=&quot;onSave()&quot;</code> is sure to be a method of the data-bound component instance.</p><span>
</span><p>The statement context may include an object other than the component.
A <a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#ref-vars">template reference variable</a> is one such alternative context object.
We&apos;ll frequently see the reserved <code>$event</code> symbol in event binding statements,
representing the &quot;message&quot; or &quot;payload&quot; of the raised event.</p><span>
</span><h3 id="statement-guidelines">Statement guidelines</h3><span>
</span><p>As with expressions, avoid writing complex template statements.
A method call or simple property assignment should be the norm.</p><span>
</span><p>Now that we have a feel for template expressions and statements,
we&#x2019;re ready to learn about the varieties of data binding syntax beyond interpolation.</p><span>
</span><span>
</span><h2 id="binding-syntax-an-overview">Binding syntax: An overview</h2><span>
</span><p>Data binding is a mechanism for coordinating what users see with application data values.
While we could push values to and pull values from HTML,
the application is easier to write, read, and maintain if we turn these chores over to a binding framework.
We simply declare bindings between binding sources and target HTML elements and let the framework do the work.</p><span>
</span><p>Angular provides many kinds of data binding, and we&#x2019;ll discuss each of them in this chapter.
First we&apos;ll take a high-level view of Angular data binding and its syntax.</p><span>
</span><p>We can group all bindings into three categories by the direction in which data flows.
Each category has its distinctive syntax:</p><span>
</span><table><tbody><tr><th>Data direction</th><th>Syntax</th><th>Binding type</th></tr><tr><td>One-way<br>from data source<br>to view target</td><td><code>{{expression}}
[target] = &quot;expression&quot;
bind-target = &quot;expression&quot;</code></td><td>Interpolation<br>Property<br>Attribute<br>Class<br>Style</td></tr><tr><td>One-way<br>from view target<br>to data source</td><td><code>(target) = &quot;statement&quot;
on-target = &quot;statement&quot;</code></td><td>Event</td></tr><tr><td>Two-way</td><td><code>[(target)] = &quot;expression&quot;
bindon-target = &quot;expression&quot;</code></td><td>Two-way</td></tr></tbody></table><p>Binding types other than interpolation have a <strong>target name</strong> to the left of the equal sign,
either surrounded by punctuation (<code>[]</code>, <code>()</code>) or preceded by a prefix (<code>bind-</code>, <code>on-</code>, <code>bindon-</code>).</p><span>
</span><p>What is that target? Before we can answer that question, we must challenge ourselves to look at template HTML in a new way.</p><span>
</span><h3 id="a-new-mental-model">A new mental model</h3><span>
</span><p>With all the power of data binding and our ability to extend the HTML vocabulary
with custom markup, it is tempting to think of template HTML as <em>HTML Plus</em>.</p><span>
</span><p>Well, it <em>is</em> HTML Plus.
But it&#x2019;s also significantly different than the HTML we&#x2019;re used to.
We really need a new mental model.</p><span>
</span><p>In the normal course of HTML development, we create a visual structure with HTML elements, and
we modify those elements by setting element attributes with string constants.</p><span>
</span><code language="html" format="">&lt;div class=&quot;special&quot;&gt;Mental Model&lt;/div&gt;
&lt;img src=&quot;images/hero.png&quot;&gt;
&lt;button disabled&gt;Save&lt;/button&gt;
</code><p>We still create a structure and initialize attribute values this way in Angular templates.</p><span>
</span><p>Then we learn to create new elements with components that encapsulate HTML
and drop them into our templates as if they were native HTML elements.</p><span>
</span><code language="html" format="">&lt;!-- Normal HTML --&gt;
&lt;div class=&quot;special&quot;&gt;Mental Model&lt;/div&gt;
&lt;!-- Wow! A new element! --&gt;
&lt;hero-detail&gt;&lt;/hero-detail&gt;
</code><p>That&#x2019;s HTML Plus.</p><span>
</span><p>Now we start to learn about data binding. The first binding we meet might look like this:</p><span>
</span><code language="html" format="">&lt;!-- Bind button disabled state to `isUnchanged` property --&gt;
&lt;button [disabled]=&quot;isUnchanged&quot;&gt;Save&lt;/button&gt;
</code><p>We&#x2019;ll get to that peculiar bracket notation in a moment. Looking beyond it,
our intuition tells us that we&#x2019;re binding to the button&apos;s <code>disabled</code> attribute and setting
it to the current value of the component&#x2019;s <code>isUnchanged</code> property.</p><span>
</span><p>Our intuition is wrong! Our everyday HTML mental model is misleading us.
In fact, once we start data binding, we are no longer working with HTML <em>attributes</em>. We aren&apos;t setting attributes.
We are setting the <em>properties</em> of DOM elements, components, and directives.</p><span>
</span><div class="l-sub-section"><h3 id="html-attribute-vs-dom-property">HTML attribute vs. DOM property</h3><span>
</span><p>The distinction between an HTML attribute and a DOM property is crucial to understanding how Angular binding works.</p><span>
</span><p><strong>Attributes are defined by HTML. Properties are defined by the DOM (Document Object Model).</strong></p><span>
</span><ul>
<li><p>A few HTML attributes have 1:1 mapping to properties. <code>id</code> is one example.</p>
</li>
<li><p>Some HTML attributes don&apos;t have corresponding properties. <code>colspan</code> is one example.</p>
</li>
<li><p>Some DOM properties don&apos;t have corresponding attributes. <code>textContent</code> is one example.</p>
</li>
<li><p>Many HTML attributes appear to map to properties ... but not in the way we might think!</p>
</li>
</ul><span>
</span><p>That last category can be especially confusing ... until we understand this general rule:</p><span>
</span><p><strong>Attributes <em>initialize</em> DOM properties and then they are done.
Property values can change; attribute values can&apos;t.</strong></p><span>
</span><p>For example, when the browser renders <code>&lt;input type=&quot;text&quot; value=&quot;Bob&quot;&gt;</code>, it creates a
corresponding DOM node with a <code>value</code> property <em>initialized</em> to &quot;Bob&quot;.</p><span>
</span><p>When the user enters &quot;Sally&quot; into the input box, the DOM element <code>value</code> <em>property</em> becomes &quot;Sally&quot;.
But the HTML <code>value</code> <em>attribute</em> remains unchanged as we discover if we ask the input element
about that attribute: <code>input.getAttribute(&apos;value&apos;) // returns &quot;Bob&quot;</code></p><span>
</span><p>The HTML attribute <code>value</code> specifies the <em>initial</em> value; the DOM <code>value</code> property is the <em>current</em> value.</p><span>
</span><p>The <code>disabled</code> attribute is another peculiar example. A button&apos;s <code>disabled</code> <em>property</em> is
<code>false</code> by default so the button is enabled.
When we add the <code>disabled</code> <em>attribute</em>, its presence alone initializes the  button&apos;s <code>disabled</code> <em>property</em> to <code>true</code>
so the button is disabled.</p><span>
</span><p>Adding and removing the <code>disabled</code> <em>attribute</em> disables and enables the button. The value of the <em>attribute</em> is irrelevant,
which is why we cannot enable a button by writing <code>&lt;button disabled=&quot;false&quot;&gt;Still Disabled&lt;/button&gt;</code>.</p><span>
</span><p>Setting the button&apos;s <code>disabled</code> <em>property</em>  (say, with an Angular binding) disables or enables the button.
The value of the <em>property</em> matters.</p><span>
</span><p><strong>The HTML attribute and the DOM property are not the same thing, even when they have the same name.</strong></p><span>
</span></div><p>This is so important, we&#x2019;ll say it again.</p><span>
</span><p><strong>Template binding works with <em>properties</em> and <em>events</em>, not <em>attributes</em>.</strong></p><span>
</span><div class="callout is-helpful"><header>A world without attributes</header><p>In the world of Angular 2, the only role of attributes is to initialize element and directive state.
When we data bind, we&apos;re dealing exclusively with element and directive properties and events.
Attributes effectively disappear.</p><span>
</span></div><p>With this model firmly in mind, let&apos;s learn about binding targets.</p><span>
</span><h3 id="binding-targets">Binding targets</h3><span>
</span><p>The <strong>target of a data binding</strong> is something in the DOM.
Depending on the binding type, the target can be an
(element | component | directive) property, an
(element | component | directive) event, or (rarely) an attribute name.
The following table summarizes:</p><span>
</span><!-- If you update this table, UPDATE it in Dart & JS, too.--><div width="90%"><table><tbody><tr><th>Binding type</th><th>Target</th><th>Examples</th></tr><tr><td>Property</td><td>Element&#xA0;property<br>Component&#xA0;property<br>Directive&#xA0;property</td><td><code language="html" format="">&lt;img [src] = &quot;heroImageUrl&quot;&gt;
&lt;hero-detail [hero]=&quot;currentHero&quot;&gt;&lt;/hero-detail&gt;
&lt;div [ngClass] = &quot;{selected: isSelected}&quot;&gt;&lt;/div&gt;
</code></td></tr><tr><td>Event</td><td>Element&#xA0;event<br>Component&#xA0;event<br>Directive&#xA0;event</td><td><code language="html" format="">&lt;button (click) = &quot;onSave()&quot;&gt;Save&lt;/button&gt;
&lt;hero-detail (deleteRequest)=&quot;deleteHero()&quot;&gt;&lt;/hero-detail&gt;
&lt;div (myClick)=&quot;clicked=$event&quot;&gt;click me&lt;/div&gt;
</code></td></tr><tr><td>Two-way</td><td>Event and property</td><td><code language="html" format="">&lt;input [(ngModel)]=&quot;heroName&quot;&gt;
</code></td></tr><tr><td>Attribute</td><td>Attribute
(the&#xA0;exception)</td><td><code language="html" format="">&lt;button [attr.aria-label]=&quot;help&quot;&gt;help&lt;/button&gt;
</code></td></tr><tr><td>Class</td><td><code>class</code> property</td><td><code language="html" format="">&lt;div [class.special]=&quot;isSpecial&quot;&gt;Special&lt;/div&gt;
</code></td></tr><tr><td>Style</td><td><code>style</code> property</td><td><code language="html" format="">&lt;button [style.color] = &quot;isSpecial ? &apos;red&apos; : &apos;green&apos;&quot;&gt;
</code></td></tr></tbody></table></div><p>Let&#x2019;s descend from the architectural clouds and look at each of these binding types in concrete detail.</p><span>
</span><h2 id="property-binding">Property binding</h2><span>
</span><p>We write a template <strong>property binding</strong> when we want to set a property of a view element to the value of
a <a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#template-expressions">template expression</a>.</p><span>
</span><p>The most common property binding sets an element property to a component property value. An example is
binding the <code>src</code> property of an image element to a component&#x2019;s <code>heroImageUrl</code> property:</p><span>
</span><code language="html" format="">&lt;img [src]=&quot;heroImageUrl&quot;&gt;
</code><p>Another example is disabling a button when the component says that it <code>isUnchanged</code>:</p><span>
</span><code language="html" format="">&lt;button [disabled]=&quot;isUnchanged&quot;&gt;Cancel is disabled&lt;/button&gt;
</code><p>Another is setting a property of a directive:</p><span>
</span><code language="html" format="">&lt;div [ngClass]=&quot;classes&quot;&gt;[ngClass] binding to the classes property&lt;/div&gt;
</code><p>Yet another is setting the model property of a custom component (a great way
for parent and child components to communicate):</p><span>
</span><code language="html" format="">&lt;hero-detail [hero]=&quot;currentHero&quot;&gt;&lt;/hero-detail&gt;
</code><h3 id="one-way-in-">One-way <em>in</em></h3><span>
</span><p>People often describe property binding as <em>one-way data binding</em> because it flows a value in one direction,
from a component&#x2019;s data property into a target element property.</p><span>
</span><p>We cannot use property binding to pull values <em>out</em> of the target element.
We can&apos;t bind to a property of the target element to read it. We can only set it.</p><span>
</span><div class="l-sub-section"><p>Nor can we use property binding to <em>call</em> a method on the target element.</p><span>
</span><p>If the element raises events we can listen to them with an <a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#event-binding">event binding</a>.</p><span>
</span><p>If we must read a target element property or call one of its methods,
we&apos;ll need a different technique.
See the API reference for
<a href="https://angular.io/docs/ts/latest/api/core/index/ViewChild-var.html">viewChild</a> and
<a href="https://angular.io/docs/ts/latest/api/core/index/ContentChild-var.html">contentChild</a>.</p><span>
</span></div><h3 id="binding-target">Binding target</h3><span>
</span><p>An element property between enclosing square brackets identifies the target property. The target property in the following code is the image element&#x2019;s <code>src</code> property.</p><span>
</span><code language="html" format="">&lt;img [src]=&quot;heroImageUrl&quot;&gt;
</code><p>Some people prefer the <code>bind-</code> prefix alternative, known as the <em>canonical form</em>:</p><span>
</span><code language="html" format="">&lt;img bind-src=&quot;heroImageUrl&quot;&gt;
</code><p>The target name is always the name of a property, even when it appears to be the name of something else. We see <code>src</code> and may think it&#x2019;s the name of an attribute. No. It&#x2019;s the name of an image element property.</p><span>
</span><p>Element properties may be the more common targets,
but Angular looks first to see if the name is a property of a known directive,
as it is in the following example:</p><span>
</span><code language="html" format="">&lt;div [ngClass]=&quot;classes&quot;&gt;[ngClass] binding to the classes property&lt;/div&gt;
</code><div class="l-sub-section"><p>Technically, Angular is matching the name to a directive <a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#inputs-outputs">input</a>,
one of the property names listed in the directive&#x2019;s <code>inputs</code> array or a property decorated with <code>@Input()</code>.
Such inputs map to the directive&#x2019;s own properties.</p><span>
</span></div><p>If the name fails to match a property of a known directive or element, Angular reports an &#x201C;unknown directive&#x201D; error.</p><span>
</span><h3 id="avoid-side-effects">Avoid side effects</h3><span>
</span><p>As we&apos;ve already discussed, evaluation of a template expression should have no visible side effects. The expression language itself does its part to keep us safe. We can&#x2019;t assign a value to anything in a property binding expression nor use the increment and decrement operators.</p><span>
</span><p>Of course, our expression might invoke a property or method that has side effects. Angular has no way of knowing that or stopping us.</p><span>
</span><p>The expression could call something like <code>getFoo()</code>. Only we know what <code>getFoo()</code> does.
If <code>getFoo()</code> changes something and we happen to be binding to that something, we risk an unpleasant experience. Angular may or may not display the changed value. Angular may detect the change and throw a warning error. Our general advice: stick to data properties and to methods that return values and do no more.</p><span>
</span><h3 id="return-the-proper-type">Return the proper type</h3><span>
</span><p>The template expression should evaluate to the type of value expected by the target property.
Return a string if the target property expects a string.
Return a number if the target property expects a number.
Return an object if the target property expects an object.</p><span>
</span><p>The <code>hero</code> property of the <code>HeroDetail</code> component expects a <code>Hero</code> object, which is exactly what we&#x2019;re sending in the property binding:</p><span>
</span><code language="html" format="">&lt;hero-detail [hero]=&quot;currentHero&quot;&gt;&lt;/hero-detail&gt;
</code><h3 id="remember-the-brackets">Remember the brackets</h3><span>
</span><p>The brackets tell Angular to evaluate the template expression.
If we forget the brackets, Angular treats the string as a constant and <em>initializes the target property</em> with that string.
It does <em>not</em> evaluate the string!</p><span>
</span><p>Don&apos;t make the following mistake:</p><span>
</span><code language="html" format="">&lt;!-- ERROR: HeroDetailComponent.hero expects a
     Hero object, not the string &quot;currentHero&quot; --&gt;
  &lt;hero-detail hero=&quot;currentHero&quot;&gt;&lt;/hero-detail&gt;
</code><span>
</span><p>We <em>should</em> omit the brackets when all of the following are true:</p><span>
</span><ul>
<li>The target property accepts a string value.</li>
<li>The string is a fixed value that we can bake into the template.</li>
<li>This initial value never changes.</li>
</ul><span>
</span><p>We routinely initialize attributes this way in standard HTML, and it works
just as well for directive and component property initialization.
The following example initializes the <code>prefix</code> property of the <code>HeroDetailComponent</code> to a fixed string,
not a template expression. Angular sets it and forgets about it.</p><span>
</span><code language="html" format="">&lt;hero-detail prefix=&quot;You are my&quot; [hero]=&quot;currentHero&quot;&gt;&lt;/hero-detail&gt;
</code><p>The <code>[hero]</code> binding, on the other hand, remains a live binding to the component&apos;s <code>currentHero</code> property.</p><span>
</span><h3 id="property-binding-or-interpolation-">Property binding or interpolation?</h3><span>
</span><p>We often have a choice between interpolation and property binding. 
The following binding pairs do the same thing:</p><span>
</span><code language="html" format="">&lt;p&gt;&lt;img src=&quot;{{heroImageUrl}}&quot;&gt; is the &lt;i&gt;interpolated&lt;/i&gt; image.&lt;/p&gt;
&lt;p&gt;&lt;img [src]=&quot;heroImageUrl&quot;&gt; is the &lt;i&gt;property bound&lt;/i&gt; image.&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&quot;{{title}}&quot; is the &lt;i&gt;interpolated&lt;/i&gt; title.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&quot;&lt;span [innerHTML]=&quot;title&quot;&gt;&lt;/span&gt;&quot; is the &lt;i&gt;property bound&lt;/i&gt; title.&lt;/p&gt;
</code><p>Interpolation is a convenient alternative for property binding in many cases.
In fact, Angular  translates those interpolations into the corresponding property bindings
before rendering the view.</p><span>
</span><p>There is no technical reason to prefer one form to the other.
We lean toward readability, which tends to favor interpolation.
We suggest establishing coding style rules and choosing the form that
both conforms to the rules and feels most natural for the task at hand.</p><span>
</span><h4 id="content-security">Content Security</h4><span>
</span><p>Imagine the following <em>malicious content</em>.</p><span>
</span><code language="ts" format="">evilTitle = &apos;Template &lt;script&gt;alert(&quot;evil never sleeps&quot;)&lt;/script&gt;Syntax&apos;;
</code><p>Fortunately, Angular data binding is on alert for dangerous HTML.
It <em>sanitizes</em> the values before displaying them.
It <strong>will not</strong> allow HTML with script tags to leak into the browser, neither with interpolation
nor property binding.</p><span>
</span><code language="html" format="">&lt;p&gt;&lt;span&gt;&quot;{{evilTitle}}&quot; is the &lt;i&gt;interpolated&lt;/i&gt; evil title.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&quot;&lt;span [innerHTML]=&quot;evilTitle&quot;&gt;&lt;/span&gt;&quot; is the &lt;i&gt;property bound&lt;/i&gt; evil title.&lt;/p&gt;
</code><p>Interpolation handles the script tags differently than property binding but both approaches render the
content harmlessly.</p><span>
</span><figure class="image-display"><img src="https://angular.io/resources/images/devguide/template-syntax/evil-title.png" alt="evil title made safe" width="500px"></figure><span>
</span><h2 id="attribute-class-and-style-bindings">Attribute, Class, and Style Bindings</h2><span>
</span><p>The template syntax provides specialized one-way bindings for scenarios less well suited to property binding.</p><span>
</span><h3 id="attribute-binding">Attribute Binding</h3><span>
</span><p>We can set the value of an attribute directly with an <strong>attribute binding</strong>.</p><span>
</span><div class="l-sub-section"><p>This is the only exception to the rule that a binding sets a target property. This is the only binding that creates and sets an attribute.</p><span>
</span></div><p>We have stressed throughout this chapter that setting an element property with a property binding is always preferred to setting the attribute with a string. Why does Angular offer attribute binding?</p><span>
</span><p><strong>We must use attribute binding when there is no element property to bind.</strong></p><span>
</span><p>Consider the <a href="https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA">ARIA</a>,
<a href="https://developer.mozilla.org/en-US/docs/Web/SVG">SVG</a>, and
table span attributes. They are pure attributes.
They do not correspond to element properties, and they do not set element properties.
There are no property targets to bind to.</p><span>
</span><p>We become painfully aware of this fact when we try to write something like this:</p><span>
</span><code language="html">&lt;tr&gt;&lt;td colspan=&quot;{{1 + 1}}&quot;&gt;Three-Four&lt;/td&gt;&lt;/tr&gt;</code><p>We get this error:</p><span>
</span><code format="nocode">Template parse errors:
Can&apos;t bind to &apos;colspan&apos; since it isn&apos;t a known native property</code><p>As the message says, the <code>&lt;td&gt;</code> element does not have a <code>colspan</code> property.
It has the &quot;colspan&quot; <em>attribute</em>, but
interpolation and property binding can set only <em>properties</em>, not attributes.</p><span>
</span><p>We need attribute bindings to create and bind to such attributes.</p><span>
</span><p>Attribute binding syntax resembles property binding.
Instead of an element property between brackets, we start with the prefix <strong><code>attr</code></strong>,
followed by a dot (<code>.</code>) and the name of the attribute. We then set the attribute
value, using an expression that resolves to a string.</p><span>
</span><p>Here we bind <code>[attr.colspan]</code> to a calculated value:</p><span>
</span><code language="html" format="">&lt;table border=1&gt;
  &lt;!--  expression calculates colspan=2 --&gt;
  &lt;tr&gt;&lt;td [attr.colspan]=&quot;1 + 1&quot;&gt;One-Two&lt;/td&gt;&lt;/tr&gt;

  &lt;!-- ERROR: There is no `colspan` property to set!
    &lt;tr&gt;&lt;td colspan=&quot;{{1 + 1}}&quot;&gt;Three-Four&lt;/td&gt;&lt;/tr&gt;
  --&gt;

  &lt;tr&gt;&lt;td&gt;Five&lt;/td&gt;&lt;td&gt;Six&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
</code><p>Here&apos;s how the table renders:</p><span>
</span><span>

</span><p>One of the primary use cases for attribute binding
is to set ARIA attributes, as in this example:</p><span>
</span><code language="html" format="">&lt;!-- create and set an aria attribute for assistive technology --&gt;
&lt;button [attr.aria-label]=&quot;actionName&quot;&gt;{{actionName}} with Aria&lt;/button&gt;
</code><h3 id="class-binding">Class Binding</h3><span>
</span><p>We can add and remove CSS class names from an element&#x2019;s <code>class</code> attribute with
a <strong>class binding</strong>.</p><span>
</span><p>Class binding syntax resembles property binding.
Instead of an element property between brackets, we start with the prefix <code>class</code>,
optionally followed by a dot (<code>.</code>) and the name of a CSS class: <code>[class.class-name]</code>.</p><span>
</span><p>The following examples show how to add and remove the application&apos;s &quot;special&quot; class
with class bindings.  Here&apos;s how we set the attribute without binding:</p><span>
</span><code language="html" format="">&lt;!-- standard class attribute setting  --&gt;
&lt;div class=&quot;bad curly special&quot;&gt;Bad curly special&lt;/div&gt;
</code><p>We can replace that with a binding to a string of the desired class names; this is an all-or-nothing, replacement binding.</p><span>
</span><code language="html" format="">&lt;!-- reset/override all class names with a binding  --&gt;
&lt;div class=&quot;bad curly special&quot;
     [class]=&quot;badCurly&quot;&gt;Bad curly&lt;/div&gt;
</code><p>Finally, we can bind to a specific class name.
Angular adds the class when the template expression evaluates to truthy.
It removes the class when the expression is falsey.</p><span>
</span><code language="html" format="">&lt;!-- toggle the &quot;special&quot; class on/off with a property --&gt;
&lt;div [class.special]=&quot;isSpecial&quot;&gt;The class binding is special&lt;/div&gt;

&lt;!-- binding to `class.special` trumps the class attribute --&gt;
&lt;div class=&quot;special&quot;
     [class.special]=&quot;!isSpecial&quot;&gt;This one is not so special&lt;/div&gt;
</code><div class="l-sub-section"><p>While this is a fine way to toggle a single class name,
we generally prefer the <a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#ngClass">NgClass directive</a> for managing multiple class names at the same time.</p><span>
</span></div><h3 id="style-binding">Style Binding</h3><span>
</span><p>We can set inline styles with a <strong>style binding</strong>.</p><span>
</span><p>Style binding syntax resembles property binding.
Instead of an element property between brackets, we start with the prefix <code>style</code>,
followed by a dot (<code>.</code>) and the name of a CSS style property: <code>[style.style-property]</code>.</p><span>
</span><code language="html" format="">&lt;button [style.color] = &quot;isSpecial ? &apos;red&apos;: &apos;green&apos;&quot;&gt;Red&lt;/button&gt;
&lt;button [style.background-color]=&quot;canSave ? &apos;cyan&apos;: &apos;grey&apos;&quot; &gt;Save&lt;/button&gt;
</code><p>Some style binding styles have unit extension. Here we conditionally set the font size in  &#x201C;em&#x201D; and &#x201C;%&#x201D; units .</p><span>
</span><code language="html" format="">&lt;button [style.font-size.em]=&quot;isSpecial ? 3 : 1&quot; &gt;Big&lt;/button&gt;
&lt;button [style.font-size.%]=&quot;!isSpecial ? 150 : 50&quot; &gt;Small&lt;/button&gt;
</code><div class="l-sub-section"><p>While this is a fine way to set a single style,
we generally prefer the <a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#ngStyle">NgStyle directive</a> when setting several inline styles at the same time.</p><span>
</span></div><div class="l-sub-section"><p>Note that a <em>style property</em> name can be written in either
<a href="https://angular.io/docs/ts/latest/guide/glossary.html#dash-case">dash-case</a>, as shown above, or
<a href="https://angular.io/docs/ts/latest/guide/glossary.html#camelcase">camelCase</a>, such as <code>fontSize</code>.</p><span>
</span></div><h2 id="event-binding">Event Binding</h2><span>
</span><p>The bindings we&#x2019;ve met so far flow data in one direction: <em>from the component to an element</em>.</p><span>
</span><p>Users don&#x2019;t just stare at the screen. They enter text into input boxes. They pick items from lists.
They click buttons. Such user actions may result in a flow of data in the opposite direction:
<em>from an element to the component</em>.</p><span>
</span><p>The only way to know about a user action is to listen for certain events such as
keystrokes, mouse movements, clicks, and touches.
We declare our interest in user actions through Angular event binding.</p><span>
</span><p>Event binding syntax consists of a <strong>target event</strong> within parentheses on the left of an equal sign, and a quoted
<a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#template-statements">template statement</a> on the right.
The following event binding listens for the button&#x2019;s click event, calling
the component&apos;s <code>onSave()</code> method whenever a click occurs:</p><span>
</span><code language="html" format="">&lt;button (click)=&quot;onSave()&quot;&gt;Save&lt;/button&gt;
</code><h3 id="target-event">Target Event</h3><span>
</span><p>A <strong>name between enclosing parentheses</strong> &#x2014; for example, <code>(click)</code> &#x2014;
identifies the target event. In the following example, the target is the button&#x2019;s click event.</p><span>
</span><code language="html" format="">&lt;button (click)=&quot;onSave()&quot;&gt;Save&lt;/button&gt;
</code><p>Some people prefer the <code>on-</code> prefix alternative, known as the <em>canonical form</em>:</p><span>
</span><code language="html" format="">&lt;button on-click=&quot;onSave()&quot;&gt;On Save&lt;/button&gt;
</code><p>Element events may be the more common targets, but Angular looks first to see if the name matches an event property
of a known directive, as it does in the following example:</p><span>
</span><code language="html" format="">&lt;!-- `myClick` is an event on the custom `MyClickDirective` --&gt;
&lt;div (myClick)=&quot;clickMessage=$event&quot;&gt;click with myClick&lt;/div&gt;
</code><div class="l-sub-section"><p>The <code>myClick</code> directive is further described below in the section
on <a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#aliasing-io">Aliasing input/output properties</a>.</p><span>
</span></div><p>If the name fails to match an element event or an output property of a known directive,
Angular reports an &#x201C;unknown directive&#x201D; error.</p><span>
</span><h3 id="-event-and-event-handling-statements"><em>$event</em> and event handling statements</h3><span>
</span><p>In an event binding, Angular sets up an event handler for the target event.</p><span>
</span><p>When the event is raised, the handler executes the template statement.
The template statement typically involves a receiver that wants to do something
in response to the event, such as take a value from the HTML control and store it
in a model.</p><span>
</span><p>The binding conveys information about the event, including data values, through
an <strong>event object named <code>$event</code></strong>.</p><span>
</span><p>The shape of the event object is determined by the target event itself.
If the target event is a native DOM element event, the <code>$event</code> is a
<a href="https://developer.mozilla.org/en-US/docs/Web/Events">DOM event object</a>,
with properties such as <code>target</code> and <code>target.value</code>.</p><span>
</span><p>Consider this example:</p><span>
</span><code language="html" format="">&lt;input [value]=&quot;currentHero.firstName&quot;
       (input)=&quot;currentHero.firstName=$event.target.value&quot; &gt;
</code><p>We&#x2019;re binding the input box <code>value</code> to a <code>firstName</code> property, and we&#x2019;re listening for changes by binding to the input box&#x2019;s <code>input</code> event.
When the user makes changes, the <code>input</code> event is raised, and the binding executes the statement within a context that includes the DOM event object, <code>$event</code>.</p><span>
</span><p>To update the <code>firstName</code> property, we must get the changed text by following
the path <code>$event.target.value</code>.</p><span>
</span><p>If the event belongs to a directive (remember: components are directives), <code>$event</code> has whatever shape the directive chose to produce.</p><span>
</span><span>
</span><h3 id="custom-events-with-eventemitter">Custom Events with EventEmitter</h3><span>
</span><p>Directives typically raise custom events with an Angular <a href="https://angular.io/docs/ts/latest/api/core/index/EventEmitter-class.html">EventEmitter</a>.
A directive creates an <code>EventEmitter</code> and exposes it as a property.
The directive calls <code>EventEmitter.emit(payload)</code> to fire an event, passing in a message payload that can be anything.
Parent directives listen for the event by binding to this property and accessing the payload through the <code>$event</code> object.</p><span>
</span><p>Consider a <code>HeroDetailComponent</code> that presents hero information and responds to user actions.
Although the <code>HeroDetailComponent</code> has a delete button it doesn&apos;t know how to delete the hero itself.
The best it can do is raise an event reporting the user&apos;s delete request.</p><span>
</span><p>Here are the pertinent excerpts from that <code>HeroDetailComponent</code>:</p><span>
</span><p>HeroDetailComponent.ts (template)</p><code language="ts" format="">template: `
&lt;div&gt;
  &lt;img src=&quot;{{heroImageUrl}}&quot;&gt;
  &lt;span [style.text-decoration]=&quot;lineThrough&quot;&gt;
    {{prefix}} {{hero?.fullName}}
  &lt;/span&gt;
  &lt;button (click)=&quot;delete()&quot;&gt;Delete&lt;/button&gt;
&lt;/div&gt;`
</code><p>HeroDetailComponent.ts (delete logic)</p><code language="ts" format="">// This component make a request but it can&apos;t actually delete a hero.
deleteRequest = new EventEmitter&lt;Hero&gt;();

delete() {
  this.deleteRequest.emit(this.hero);
}
</code><p>The component defines a <code>deleteRequest</code> property that returns an <code>EventEmitter</code>.
When the user clicks <em>delete</em>, the component invokes the <code>delete()</code> method
which tells the <code>EventEmitter</code> to emit a <code>Hero</code> object.</p><span>
</span><p>Now imagine a hosting parent component that binds to the <code>HeroDetailComponent</code>&apos;s <code>deleteRequest</code> event.</p><span>
</span><code language="html" format="">&lt;hero-detail (deleteRequest)=&quot;deleteHero($event)&quot; [hero]=&quot;currentHero&quot;&gt;&lt;/hero-detail&gt;
</code><p>When the <code>deleteRequest</code> event fires, Angular calls the parent component&apos;s <code>deleteHero</code> method,
passing the <em>hero-to-delete</em> (emitted by <code>HeroDetail</code>) in the <code>$event</code> variable.</p><span>
</span><h3 id="template-statements-have-side-effects">Template statements have side effects</h3><span>
</span><p>The <code>deleteHero</code> method has a side effect: it deletes a hero.
Template statement side effects are not just OK, they are expected.</p><span>
</span><p>Deleting the hero updates the model, perhaps triggering other changes
including queries and saves to a remote server.
These changes percolate through the system and are ultimately displayed in this and other views.
It&apos;s all good.</p><span>
</span><!--:marked
  ### Event bubbling and propagation [TODO: reinstate this section when it becomes true]
  Angular invokes the event-handling statement if the event is raised by the current element or one of its child elements.
+makeExample('template-syntax/ts/app/app.component.html', 'event-binding-bubbling')(format=".")
:marked
  Many DOM events, both [native](https://developer.mozilla.org/en-US/docs/Web/Guide/Events/Overview_of_Events_and_Handlers ) and [custom](https://developer.mozilla.org/en-US/docs/Web/Guide/Events/Creating_and_triggering_events ), bubble up their ancestor tree of DOM elements until an event handler along the way prevents further propagation.

.l-sub-section
  :marked
    `EventEmitter` events don’t bubble.

:marked
  The result of an event binding statement determines whether
  [event propagation](https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Examples#Example_5:_Event_Propagation)
  continues or stops with the current element.

  Event propagation stops if the binding statement returns a falsey value (as does a method with no return value).
  Clicking the button in the next example triggers a save;
  the click doesn't make it to the outer `<div>` so the div's save handler is not called.
+makeExample('template-syntax/ts/app/app.component.html', 'event-binding-no-propagation')(format=".")
:marked
  Propagation continues if the statement returns a truthy value. In the next example, the click is heard by both the button
  and the outer `<div>`, causing a double save.
+makeExample('template-syntax/ts/app/app.component.html', 'event-binding-propagation')(format=".")

--><span>
</span><h2 id="two-way-binding-with-ngmodel">Two-way binding with NgModel</h2><span>
</span><p>When developing data entry forms, we often want to both display a data property and update that property when the user makes changes.</p><span>
</span><p>The <code>[(ngModel)]</code> two-way data binding syntax makes that easy. Here&apos;s an example:</p><span>
</span><code language="html" format="">&lt;input [(ngModel)]=&quot;currentHero.firstName&quot;&gt;
</code><div class="callout is-important"><header>[()] = banana in a box</header><p>To remember that the parentheses go inside the brackets, visualize a <em>banana in a box</em>.</p><span>
</span></div><div class="callout is-important"><header>FormsModule is Required to use ngModel</header><p>Before we can use the <code>ngModel</code> directive in a two-way data binding,
we must import the <code>FormsModule</code> and add it to the Angular module&apos;s <code>imports</code> list.
Learn more about the <code>FormsModule</code> and <code>ngModel</code> in the
<a href="https://angular.io/docs/ts/latest/guide/forms.html#ngModel">Forms</a> chapter.</p><span>
</span></div><p>app.module.ts (FormsModule import)</p><code language="ts" format="linenums">import { NgModule } from &apos;@angular/core&apos;;
import { BrowserModule }  from &apos;@angular/platform-browser&apos;;
import { FormsModule } from &apos;@angular/forms&apos;;

import { AppComponent } from &apos;./app.component&apos;;

@NgModule({
  imports: [
    BrowserModule,
    FormsModule
  ],
  declarations: [
    AppComponent
  ],
  bootstrap: [ AppComponent ]
})
export class AppModule { }
</code><p>There&#x2019;s a story behind this construction, a story that builds on the property and event binding techniques we learned previously.</p><span>
</span><h3 id="inside-ngmodel-">Inside <code>[(ngModel)]</code></h3><span>
</span><p>We could have achieved the same result with separate bindings to
the <code>&lt;input&gt;</code> element&apos;s  <code>value</code> property and <code>input</code> event.</p><span>
</span><code language="html" format="">&lt;input [value]=&quot;currentHero.firstName&quot;
       (input)=&quot;currentHero.firstName=$event.target.value&quot; &gt;
</code><p>That&#x2019;s cumbersome. Who can remember which element property to set and what event reports user changes?
How do we extract the currently displayed text from the input box so we can update the data property?
Who wants to look that up each time?</p><span>
</span><p>That <code>ngModel</code> directive hides these onerous details behind its own  <code>ngModel</code> input and <code>ngModelChange</code> output properties.</p><span>
</span><code language="html" format="">&lt;input
  [ngModel]=&quot;currentHero.firstName&quot;
  (ngModelChange)=&quot;currentHero.firstName=$event&quot;&gt;
</code><div class="l-sub-section"><p>The <code>ngModel</code> input property sets the element&apos;s value property and the <code>ngModelChange</code> output property
listens for changes to the element&apos;s value.
The details are specific to each kind of element and therefore the <code>NgModel</code> directive only works for elements,
such as the input text box, that are supported by a <a href="https://angular.io/docs/ts/latest/api/common/index/ControlValueAccessor-interface.html">ControlValueAccessor</a>.
We can&apos;t apply <code>[(ngModel)]</code> to our custom components until we write a suitable <em>value accessor</em>,
a technique that is beyond the scope of this chapter.</p><span>
</span></div><p>Separate <code>ngModel</code> bindings is an improvement. We can do better.</p><span>
</span><p>We shouldn&apos;t have to mention the data property twice. Angular should be able to capture the component&#x2019;s data property and set it
with a single declaration &#x2014; which it can with the <code>[( )]</code> syntax:</p><span>
</span><code language="html" format="">&lt;input [(ngModel)]=&quot;currentHero.firstName&quot;&gt;
</code><div class="l-sub-section"><p><code>[(ngModel)]</code> is a specific example of a more general pattern in which Angular &quot;de-sugars&quot; the <code>[(x)]</code> syntax
into an <code>x</code> input property for property binding and an <code>xChange</code> output property for event binding.
Angular constructs the event property binding&apos;s template statement by appending <code>=$event</code>
to the literal string of the template expression.</p><span>
</span><blockquote>
<p><span>[(<em>x</em>)]=&quot;<em>e</em>&quot; &lt;==&gt; [<em>x</em>]=&quot;<em>e</em>&quot; (<i>x</i>Change)=&quot;<em>e</em>=$event&quot;</span></p>
</blockquote><span>
</span><p>We can write a two-way binding directive of our own to exploit this behavior.</p><span>
</span></div><p>Is <code>[(ngModel)]</code> all we need? Is there ever a reason to fall back to its expanded form?</p><span>
</span><p>The <code>[( )]</code> syntax can only <em>set</em> a data-bound property.
If we need to do something more or something different, we need to write the expanded form ourselves.</p><span>
</span><p>Let&apos;s try something silly like forcing the input value to uppercase:</p><span>
</span><code language="html" format="">&lt;input
  [ngModel]=&quot;currentHero.firstName&quot;
  (ngModelChange)=&quot;setUpperCaseFirstName($event)&quot;&gt;
</code><p>Here are all variations in action, including the uppercase version:</p><span>
</span><figure class="image-display"><img src="https://angular.io/resources/images/devguide/template-syntax/ng-model-anim.gif" alt="NgModel variations"></figure><span>
</span><h2 id="built-in-directives">Built-in directives</h2><span>
</span><p>Earlier versions of Angular included over seventy built-in directives.
The community contributed many more, and countless private directives
have been created for internal applications.</p><span>
</span><p>We don&#x2019;t need many of those directives in Angular 2.
Quite often we can achieve the same results with the more capable and expressive Angular 2 binding system.
Why create a directive to handle a click when we can write a simple binding such as this?</p><span>
</span><code language="html" format="">&lt;button (click)=&quot;onSave()&quot;&gt;Save&lt;/button&gt;
</code><p>We still benefit from directives that simplify complex tasks.
Angular still ships with built-in directives; just not as many.
We&apos;ll write our own directives, just not as many.</p><span>
</span><p>This segment reviews some of the most frequently used built-in directives.</p><span>
</span><a id="ngClass"></a><h3 id="ngclass">NgClass</h3><span>
</span><p>We typically control how elements appear
by adding and removing CSS classes dynamically.
We can bind to <code>NgClass</code> to add or remove several classes simultaneously.</p><span>
</span><p>A <a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#class-binding">class binding</a> is a good way to add or remove a <em>single</em> class.</p><span>
</span><code language="html" format="">&lt;!-- toggle the &quot;special&quot; class on/off with a property --&gt;
&lt;div [class.special]=&quot;isSpecial&quot;&gt;The class binding is special&lt;/div&gt;
</code><p>The <code>NgClass</code> directive may be the better choice
when we want to add or remove <em>many</em> CSS classes at the same time.</p><span>
</span><p>A good way to apply <code>NgClass</code> is by binding it to a key:value control object. Each key of the object is a CSS class name; its value is <code>true</code> if the class should be added, <code>false</code> if it should be removed.</p><span>
</span><p>Consider a component method such as <code>setClasses</code> that manages the state of three CSS classes:</p><span>
</span><code language="ts" format="">setClasses() {
  let classes =  {
    saveable: this.canSave,      // true
    modified: !this.isUnchanged, // false
    special: this.isSpecial,     // true
  };
  return classes;
}
</code><p>Now we can add an <code>NgClass</code> property binding that calls <code>setClasses</code>
and sets the element&apos;s classes accordingly:</p><span>
</span><code language="html" format="">&lt;div [ngClass]=&quot;setClasses()&quot;&gt;This div is saveable and special&lt;/div&gt;
</code><a id="ngStyle"></a><h3 id="ngstyle">NgStyle</h3><span>
</span><p>We can set inline styles dynamically, based on the state of the component.
Binding to <code>NgStyle</code> lets us set many inline styles simultaneously.</p><span>
</span><p>A <a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#style-binding">style binding</a> is an easy way to set a <em>single</em> style value.</p><span>
</span><code language="html" format="">&lt;div [style.font-size]=&quot;isSpecial ? &apos;x-large&apos; : &apos;smaller&apos;&quot; &gt;
  This div is x-large.
&lt;/div&gt;
</code><p>The <code>NgStyle</code> directive may be the better choice
when we want to set <em>many</em> inline styles at the same time.</p><span>
</span><p>We apply <code>NgStyle</code> by binding it to a key:value control object.
Each key of the object is a style name; its value is whatever is appropriate for that style.</p><span>
</span><p>Consider a component method such as <code>setStyles</code> that returns an object defining three styles:</p><span>
</span><code language="ts" format="">setStyles() {
  let styles = {
    // CSS property names
    &apos;font-style&apos;:  this.canSave      ? &apos;italic&apos; : &apos;normal&apos;,  // italic
    &apos;font-weight&apos;: !this.isUnchanged ? &apos;bold&apos;   : &apos;normal&apos;,  // normal
    &apos;font-size&apos;:   this.isSpecial    ? &apos;24px&apos;   : &apos;8px&apos;,     // 24px
  };
  return styles;
}
</code><p>Now we just add an <code>NgStyle</code> property binding that calls <code>setStyles</code>
and sets the element&apos;s styles accordingly:</p><span>
</span><code language="html" format="">&lt;div [ngStyle]=&quot;setStyles()&quot;&gt;
  This div is italic, normal weight, and extra large (24px).
&lt;/div&gt;
</code><a id="ngIf"></a><h3 id="ngif">NgIf</h3><span>
</span><p>We can add an element subtree (an element and its children) to the DOM  by binding an <code>NgIf</code> directive to a truthy expression.</p><span>
</span><code language="html" format="">&lt;div *ngIf=&quot;currentHero&quot;&gt;Hello, {{currentHero.firstName}}&lt;/div&gt;
</code><div class="alert is-critical"><p>Don&apos;t forget the asterisk (<code>*</code>) in front of <code>ngIf</code>.
For more information, see <a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#star-template">* and &lt;template&gt;</a>.</p><span>
</span></div><p>Binding to a falsey expression removes the element subtree from the DOM.</p><span>
</span><code language="html" format="">&lt;!-- because of the ngIf guard
    `nullHero.firstName` never has a chance to fail --&gt;
&lt;div *ngIf=&quot;nullHero&quot;&gt;Hello, {{nullHero.firstName}}&lt;/div&gt;

&lt;!-- Hero Detail is not in the DOM because isActive is false--&gt;
&lt;hero-detail *ngIf=&quot;isActive&quot;&gt;&lt;/hero-detail&gt;
</code><h4 id="visibility-and-ngif-are-not-the-same">Visibility and NgIf are not the same</h4><span>
</span><p>We can show and hide an element subtree (the element and its children) with a
<a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#class-binding">class</a> or <a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#style-binding">style</a> binding:</p><span>
</span><code language="html" format="">&lt;!-- isSpecial is true --&gt;
&lt;div [class.hidden]=&quot;!isSpecial&quot;&gt;Show with class&lt;/div&gt;
&lt;div [class.hidden]=&quot;isSpecial&quot;&gt;Hide with class&lt;/div&gt;

&lt;!-- HeroDetail is in the DOM but hidden --&gt;
&lt;hero-detail [class.hidden]=&quot;isSpecial&quot;&gt;&lt;/hero-detail&gt;

&lt;div [style.display]=&quot;isSpecial ? &apos;block&apos; : &apos;none&apos;&quot;&gt;Show with style&lt;/div&gt;
&lt;div [style.display]=&quot;isSpecial ? &apos;none&apos;  : &apos;block&apos;&quot;&gt;Hide with style&lt;/div&gt;
</code><p>Hiding a subtree is quite different from excluding a subtree with <code>NgIf</code>.</p><span>
</span><p>When we hide the element subtree, it remains in the DOM.
Components in the subtree are preserved, along with their state.
Angular may continue to check for changes even to invisible properties.
The subtree may tie up substantial memory and computing resources.</p><span>
</span><p>When <code>NgIf</code> is <code>false</code>, Angular physically removes the element subtree from the DOM.
It destroys components in the subtree, along with their state, potentially freeing up substantial resources and
resulting in better performance for the user.</p><span>
</span><p>The show/hide technique is probably fine for small element trees.
We should be wary when hiding large trees; <code>NgIf</code> may be the safer choice. Always measure before leaping to conclusions.</p><span>
</span><a id="ngSwitch"></a><h3 id="ngswitch">NgSwitch</h3><span>
</span><p>We bind to <code>NgSwitch</code> when we want to display <em>one</em> element tree (an element and its children)
from a <em>set</em> of possible element trees, based on some condition.
Angular puts only the <em>selected</em> element tree into the DOM.</p><span>
</span><p>Here&#x2019;s an example:</p><span>
</span><code language="html" format="">&lt;span [ngSwitch]=&quot;toeChoice&quot;&gt;
  &lt;span *ngSwitchCase=&quot;&apos;Eenie&apos;&quot;&gt;Eenie&lt;/span&gt;
  &lt;span *ngSwitchCase=&quot;&apos;Meanie&apos;&quot;&gt;Meanie&lt;/span&gt;
  &lt;span *ngSwitchCase=&quot;&apos;Miney&apos;&quot;&gt;Miney&lt;/span&gt;
  &lt;span *ngSwitchCase=&quot;&apos;Moe&apos;&quot;&gt;Moe&lt;/span&gt;
  &lt;span *ngSwitchDefault&gt;other&lt;/span&gt;
&lt;/span&gt;
</code><p>We bind the parent <code>NgSwitch</code> directive to an expression returning a <em>switch value</em>.
The value is a string in this example, but it can be a value of any type.</p><span>
</span><p>In this example, the parent <code>NgSwitch</code> directive controls a set of child <code>&lt;span&gt;</code> elements.
A <code>&lt;span&gt;</code> is either pegged to a <em>match value</em> expression or marked as the default.</p><span>
</span><p><strong>At any particular moment, at most one of these <em>spans</em> is in the DOM.</strong></p><span>
</span><p>If the <em>span</em>&#x2019;s <em>match value</em> equals the switch value, Angular adds the <code>&lt;span&gt;</code> to the DOM.
If none of the <em>spans</em> is a match, Angular adds the default <em>span</em> to the DOM.
Angular removes and destroys all other <em>spans</em>.</p><span>
</span><div class="l-sub-section"><p>We could substitute any element for the <em>span</em> in this example.
That element could be a <code>&lt;div&gt;</code> with a vast subtree of its own elements.
Only the matching <code>&lt;div&gt;</code> and its subtree would appear in the DOM;
the others would be removed.</p><span>
</span></div><p>Three collaborating directives are at work here:</p><span>
</span><ol>
<li><code>ngSwitch</code>: bound to an expression that returns the switch value</li>
<li><code>ngSwitchCase</code>: bound to an expression returning a match value</li>
<li><code>ngSwitchDefault</code>: a marker attribute on the default element</li>
</ol><span>
</span><div class="alert is-critical"><p><strong>Do <em>not</em></strong> put the asterisk (<code>*</code>) in front of <code>ngSwitch</code>. Use the property binding instead.</p><span>
</span><p><strong>Do</strong> put the asterisk (<code>*</code>) in front of <code>ngSwitchCase</code> and <code>ngSwitchDefault</code>.
For more information, see <a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#star-template">* and &lt;template&gt;</a>.</p><span>
</span></div><a id="ngFor"></a><h3 id="ngfor">NgFor</h3><span>
</span><p><code>NgFor</code> is a <em>repeater</em> directive &#x2014; a way to customize data display.</p><span>
</span><p>Our goal is to present a list of items. We define a block of HTML that defines how a single item should be displayed.
We tell Angular to use that block as a template for rendering each item in the list.</p><span>
</span><p>Here is an example of <code>NgFor</code> applied to a simple <code>&lt;div&gt;</code>:</p><span>
</span><code language="html" format="">&lt;div *ngFor=&quot;let hero of heroes&quot;&gt;{{hero.fullName}}&lt;/div&gt;
</code><p>We can also apply an <code>NgFor</code> to a component element, as in this example:</p><span>
</span><code language="html" format="">&lt;hero-detail *ngFor=&quot;let hero of heroes&quot; [hero]=&quot;hero&quot;&gt;&lt;/hero-detail&gt;
</code><div class="alert is-critical"><p>Don&apos;t forget the asterisk (<code>*</code>) in front of <code>ngFor</code>.
For more information, see <a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#star-template">* and &lt;template&gt;</a>.</p><span>
</span></div><p>The text assigned to <code>*ngFor</code> is the instruction that guides the repeater process.</p><span>
</span><a id="ngForMicrosyntax"></a><h4 id="ngfor-microsyntax">NgFor microsyntax</h4><span>
</span><p>The string assigned to <code>*ngFor</code> is not a <a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#template-expressions">template expression</a>.
It&#x2019;s a <em>microsyntax</em> &#x2014; a little language of its own that Angular interprets. In this example, the string <code>&quot;let hero of heroes&quot;</code> means:</p><span>
</span><blockquote>
<p><em>Take each hero in the <code>heroes</code> array, store it in the local <code>hero</code> variable, and make it available to the templated HTML for each iteration.</em></p>
</blockquote><span>
</span><p>Angular translates this instruction into a new set of elements and bindings.</p><span>
</span><p>In the two previous examples, the <code>ngFor</code> directive iterates over the <code>heroes</code> array returned by the parent component&#x2019;s <code>heroes</code> property,
stamping out instances of the element to which it is applied.
Angular creates a fresh instance of the template for each hero in the array.</p><span>
</span><p>The <code>let</code> keyword before <code>hero</code> creates a template input variable called <code>hero</code>.</p><span>
</span><div class="alert is-critical"><p>A template input variable is <strong>not</strong> the same as a <a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#ref-vars">template reference variable</a>!</p><span>
</span></div><p>We use this variable within the template to access a hero&#x2019;s properties,
as we&#x2019;re doing in the interpolation.
We can also pass the variable in a binding to a component element,
as we&apos;re doing with <code>hero-detail</code>.</p><span>
</span><h4 id="ngfor-with-index">NgFor with index</h4><span>
</span><p>The <code>ngFor</code> directive supports an optional <code>index</code> that increases from 0 to the length of the array for each iteration.
We can capture the index in a template input variable and use it in our template.</p><span>
</span><p>The next example captures the index in a variable named <code>i</code>, using it to stamp out rows like &quot;1 - Hercules Son of Zeus&quot;.</p><span>
</span><code language="html" format="">&lt;div *ngFor=&quot;let hero of heroes; let i=index&quot;&gt;{{i + 1}} - {{hero.fullName}}&lt;/div&gt;
</code><div class="l-sub-section"><p>Learn about other special <em>index-like</em> values such as <code>last</code>, <code>even</code>, and <code>odd</code> in the <a href="https://angular.io/docs/ts/latest/api/common/index/NgFor-directive.html">NgFor API reference</a>.</p><span>
</span></div><h4 id="ngfortrackby">NgForTrackBy</h4><span>
</span><p>The <code>ngFor</code> directive has the potential to perform poorly, especially with large lists.
A small change to one item, an item removed, or an item added can trigger a cascade of DOM manipulations.</p><span>
</span><p>For example, we could refresh the list of heroes by re-querying the server.
The refreshed list probably contains most, if not all, of the previously displayed heroes.</p><span>
</span><p><em>We</em> know this because the <code>id</code> of each hero hasn&apos;t changed.
But Angular sees only a fresh list of new object references.
It has no choice but to tear down the old list, discard those DOM elements, and re-build a new list with new DOM elements.</p><span>
</span><p>Angular can avoid this churn if we give it a <em>tracking</em> function that tells it what we know:
that two objects with the same <code>hero.id</code> are the same <em>hero</em>. Here is such a function:</p><span>
</span><code language="ts" format="">trackByHeroes(index: number, hero: Hero) { return hero.id; }
</code><p>Now set the <code>NgForTrackBy</code> directive to that <em>tracking</em> function.</p><span>
</span><code language="html" format="">&lt;div *ngFor=&quot;let hero of heroes; trackBy:trackByHeroes&quot;&gt;({{hero.id}}) {{hero.fullName}}&lt;/div&gt;
</code><p>The <em>tracking</em> function doesn&apos;t eliminate all DOM changes.
Angular may have to update the DOM element if the same-hero <em>properties</em> have changed.
But if the properties haven&apos;t changed &#x2014; and most of the time they will not have changed &#x2014;
Angular can leave those DOM elements alone. The list UI will be smoother and more responsive.</p><span>
</span><p>Here is an illustration of the <code>NgForTrackBy</code> effect.</p><span>
</span><figure class="image-display"><img src="https://angular.io/resources/images/devguide/template-syntax/ng-for-track-by-anim.gif" alt="NgForTrackBy"></figure><a id="star-template"></a><span>
</span><a id="structural-directive"></a><h2 id="-and-lt-template-gt-">* and &lt;template&gt;</h2><span>
</span><p>When we reviewed the <code>NgFor</code>, <code>NgIf</code>, and <code>NgSwitch</code> built-in directives, we called out an oddity of the syntax: the asterisk (<code>*</code>) that appears before the directive names.</p><span>
</span><p>The <code>*</code> is a bit of syntactic sugar that makes it easier to read and write directives that modify HTML layout
with the help of templates.
<code>NgFor</code>, <code>NgIf</code>, and <code>NgSwitch</code> all add and remove element subtrees that are wrapped in <code>&lt;template&gt;</code> tags.</p><span>
</span><p>We didn&apos;t see the <code>&lt;template&gt;</code> tags because the <code>*</code> prefix syntax allowed us to skip those tags and
focus directly on the HTML element that we are including, excluding, or repeating.</p><span>
</span><p>In this section we go under the hood and see how
Angular strips away the <code>*</code> and expands the HTML into the <code>&lt;template&gt;</code> tags for us.</p><span>
</span><h3 id="expanding-ngif-">Expanding <code>*ngIf</code></h3><span>
</span><p>We can do what Angular does ourselves and expand the <code>*</code> prefix syntax to template syntax. Here&apos;s some code with <code>*ngIf</code>:</p><span>
</span><code language="html" format="">&lt;hero-detail *ngIf=&quot;currentHero&quot; [hero]=&quot;currentHero&quot;&gt;&lt;/hero-detail&gt;
</code><p>The <code>currentHero</code> is referenced twice, first as the true/false condition for <code>NgIf</code> and
again as the actual hero passed into the <code>HeroDetailComponent</code>.</p><span>
</span><p>The first expansion step transports the <code>ngIf</code> (without the <code>*</code> prefix) and its contents
into an expression assigned to a <code>template</code> directive.</p><span>
</span><code language="html" format="">&lt;hero-detail template=&quot;ngIf:currentHero&quot; [hero]=&quot;currentHero&quot;&gt;&lt;/hero-detail&gt;
</code><p>The next (and final) step unfolds the HTML into a <code>&lt;template&gt;</code> tag and <code>[ngIf]</code> <a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#property-binding">property binding</a>:</p><span>
</span><code language="html" format="">&lt;template [ngIf]=&quot;currentHero&quot;&gt;
  &lt;hero-detail [hero]=&quot;currentHero&quot;&gt;&lt;/hero-detail&gt;
&lt;/template&gt;
</code><p>Notice that the <code>[hero]=&quot;currentHero&quot;</code> binding remains on the child <code>&lt;hero-detail&gt;</code>
element inside the template.</p><span>
</span><div class="callout is-critical"><header>Remember the brackets!</header><p>Don&#x2019;t make the mistake of writing <code>ngIf=&quot;currentHero&quot;</code>!
That syntax assigns the <em>string</em> value <code>&quot;currentHero&quot;</code> to <code>ngIf</code>.
In JavaScript a non-empty string is a truthy value, so <code>ngIf</code> would always be
<code>true</code> and Angular would always display the <code>hero-detail</code>
&#x2026; even when there is no <code>currentHero</code>!</p><span>
</span></div><h3 id="expanding-ngswitch-">Expanding <code>*ngSwitch</code></h3><span>
</span><p>A similar transformation applies to <code>*ngSwitch</code>. We can de-sugar the syntax ourselves.
Here&apos;s an example, first with <code>*ngSwitchCase</code> and <code>*ngSwitchDefault</code> and then again with <code>&lt;template&gt;</code> tags:</p><span>
</span><code language="html" format="">    &lt;span [ngSwitch]=&quot;toeChoice&quot;&gt;

      &lt;!-- with *NgSwitch --&gt;
      &lt;span *ngSwitchCase=&quot;&apos;Eenie&apos;&quot;&gt;Eenie&lt;/span&gt;
      &lt;span *ngSwitchCase=&quot;&apos;Meanie&apos;&quot;&gt;Meanie&lt;/span&gt;
      &lt;span *ngSwitchCase=&quot;&apos;Miney&apos;&quot;&gt;Miney&lt;/span&gt;
      &lt;span *ngSwitchCase=&quot;&apos;Moe&apos;&quot;&gt;Moe&lt;/span&gt;
      &lt;span *ngSwitchDefault&gt;other&lt;/span&gt;

      &lt;!-- with &lt;template&gt; --&gt;
      &lt;template [ngSwitchCase]=&quot;&apos;Eenie&apos;&quot;&gt;&lt;span&gt;Eenie&lt;/span&gt;&lt;/template&gt;
      &lt;template [ngSwitchCase]=&quot;&apos;Meanie&apos;&quot;&gt;&lt;span&gt;Meanie&lt;/span&gt;&lt;/template&gt;
      &lt;template [ngSwitchCase]=&quot;&apos;Miney&apos;&quot;&gt;&lt;span&gt;Miney&lt;/span&gt;&lt;/template&gt;
      &lt;template [ngSwitchCase]=&quot;&apos;Moe&apos;&quot;&gt;&lt;span&gt;Moe&lt;/span&gt;&lt;/template&gt;
      &lt;template ngSwitchDefault&gt;&lt;span&gt;other&lt;/span&gt;&lt;/template&gt;

    &lt;/span&gt;
</code><p>The <code>*ngSwitchCase</code> and <code>*ngSwitchDefault</code> expand in exactly the same manner as <code>*ngIf</code>,
wrapping their former elements in <code>&lt;template&gt;</code> tags.</p><span>
</span><p>Now we can see why the <code>ngSwitch</code> itself is not prefixed with an asterisk (*).
It does not define content. It&apos;s job is to control a collection of templates.</p><span>
</span><p>In this case, it governs two sets of <code>ngSwitchCase</code> and <code>NgSwitchDefault</code> directives.
We should expect it to display the values of the selected template twice,
once for the (*) prefixed version and once for the expanded template version.
That&apos;s exactly what we see in this example:</p><span>
</span><figure class="image-display"><img src="https://angular.io/resources/images/devguide/template-syntax/ng-switch-anim.gif" alt="NgSwitch"></figure><h3 id="expanding-ngfor-">Expanding <code>*ngFor</code></h3><span>
</span><p>The <code>*ngFor</code> undergoes a similar transformation. We begin with an <code>*ngFor</code> example:</p><span>
</span><code language="html" format="">&lt;hero-detail *ngFor=&quot;let hero of heroes; trackBy:trackByHeroes&quot; [hero]=&quot;hero&quot;&gt;&lt;/hero-detail&gt;
</code><p>Here&apos;s the same example after transporting the <code>ngFor</code> to the <code>template</code> directive:</p><span>
</span><code language="html" format="">&lt;hero-detail template=&quot;ngFor let hero of heroes; trackBy:trackByHeroes&quot; [hero]=&quot;hero&quot;&gt;&lt;/hero-detail&gt;
</code><p>And here it is expanded further into a <code>&lt;template&gt;</code> tag wrapping the original <code>&lt;hero-detail&gt;</code> element:</p><span>
</span><code language="html" format="">&lt;template ngFor let-hero [ngForOf]=&quot;heroes&quot; [ngForTrackBy]=&quot;trackByHeroes&quot;&gt;
  &lt;hero-detail [hero]=&quot;hero&quot;&gt;&lt;/hero-detail&gt;
&lt;/template&gt;
</code><p>The <code>NgFor</code> code is a bit more complex than <code>NgIf</code> because a repeater has more moving parts to configure.
In this case, we have to remember to create and assign the <code>NgForOf</code> directive that identifies the list and the <code>NgForTrackBy</code> directive.
Using the <code>*ngFor</code> syntax is much easier than writing out this expanded HTML ourselves.</p><span>
</span><a id="ref-vars"></a><h2 id="template-reference-variables">Template reference variables</h2><span>
</span><p>A <strong>template reference variable</strong> is a reference to a DOM element or directive within a template.</p><span>
</span><p>It can be used with native DOM elements but also with Angular 2 components &#x2014; in fact, it will work with any custom web component.</p><span>
</span><h3 id="referencing-a-template-reference-variable">Referencing a template reference variable</h3><span>
</span><p>We can reference a template reference variable on the same element, on a sibling element, or on
any child elements.</p><span>
</span><p>Here are two other examples of creating and consuming a Template reference variable:</p><span>
</span><code language="html" format="">&lt;!-- phone refers to the input element; pass its `value` to an event handler --&gt;
&lt;input #phone placeholder=&quot;phone number&quot;&gt;
&lt;button (click)=&quot;callPhone(phone.value)&quot;&gt;Call&lt;/button&gt;

&lt;!-- fax refers to the input element; pass its `value` to an event handler --&gt;
&lt;input ref-fax placeholder=&quot;fax number&quot;&gt;
&lt;button (click)=&quot;callFax(fax.value)&quot;&gt;Fax&lt;/button&gt;
</code><p>The hash (<code>#</code>) prefix to &quot;phone&quot; means that we&apos;re defining a <code>phone</code> variable.</p><span>
</span><div class="l-sub-section"><p>Folks who don&apos;t like using the <code>#</code> character can use its canonical alternative,
the <code>ref-</code> prefix. For example, we can declare the our <code>phone</code> variable using
either <code>#phone</code> or <code>ref-phone</code>.</p><span>
</span></div><h3 id="how-a-variable-gets-its-value">How a variable gets its value</h3><span>
</span><p>Angular sets the variable&apos;s value to the element on which it was defined.
We defined these variables on the <code>input</code> elements.
We&#x2019;re passing those <code>input</code> element objects across to the
button elements, where they&apos;re used in arguments to the <code>call</code> methods in the event bindings.</p><span>
</span><h3 id="ngform-and-template-reference-variables">NgForm and template reference variables</h3><span>
</span><p>Let&apos;s look at one final example: a form, the poster child for template reference variables.</p><span>
</span><p>The HTML for a form can be quite involved, as we saw in the <a href="https://angular.io/docs/ts/latest/guide/forms.html">Forms</a> chapter.
The following is a <em>simplified</em> example &#x2014; and it&apos;s not simple at all.</p><span>
</span><code language="html" format="">&lt;form (ngSubmit)=&quot;onSubmit(theForm)&quot; #theForm=&quot;ngForm&quot;&gt;
  &lt;div class=&quot;form-group&quot;&gt;
    &lt;label for=&quot;name&quot;&gt;Name&lt;/label&gt;
    &lt;input class=&quot;form-control&quot; name=&quot;name&quot; required [(ngModel)]=&quot;currentHero.firstName&quot;&gt;
  &lt;/div&gt;
  &lt;button type=&quot;submit&quot; [disabled]=&quot;!theForm.form.valid&quot;&gt;Submit&lt;/button&gt;
&lt;/form&gt;
</code><p>A template reference variable, <code>theForm</code>, appears three times in this example, separated
by a large amount of HTML.</p><span>
</span><code language="html" format="">&lt;form (ngSubmit)=&quot;onSubmit(theForm)&quot; #theForm=&quot;ngForm&quot;&gt;
  &lt;button type=&quot;submit&quot; [disabled]=&quot;!theForm.form.valid&quot;&gt;Submit&lt;/button&gt;
&lt;/form&gt;
</code><p>What is the value of <code>theForm</code>?</p><span>
</span><p>It would be the <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLFormElement">HTMLFormElement</a>
if Angular hadn&apos;t taken it over.
It&apos;s actually <code>ngForm</code>, a reference to the Angular built-in <code>NgForm</code> directive that wraps the native <code>HTMLFormElement</code>
and endows it with additional superpowers such as the ability to
track the validity of user input.</p><span>
</span><p>This explains how we can disable the submit button by checking <code>theForm.form.valid</code>
and pass an object with rich information to the parent component&apos;s <code>onSubmit</code> method.</p><span>
</span><a id="inputs-outputs"></a><h2 id="input-and-output-properties">Input and output properties</h2><span>
</span><p>So far, we&#x2019;ve focused mainly on binding to component members within template expressions and statements
that appear on the <em>right side of the binding declaration</em>.
A member in that position is a data binding <strong>source</strong>.</p><span>
</span><p>This section concentrates on binding to <strong>targets</strong>, which are directive
properties on the <em>left side of the binding declaration</em>.
These directive properties must be declared as <strong>inputs</strong> or <strong>outputs</strong>.</p><span>
</span><div class="alert is-important"><p>Remember: All <strong>components</strong> are <strong>directives</strong>.</p><span>
</span></div><div class="l-sub-section"><p>We&apos;re drawing a sharp distinction between a data binding <strong>target</strong> and a data binding <strong>source</strong>.</p><span>
</span><p>The <em>target</em> of a binding is to the <em>left</em> of the <code>=</code>.
The <em>source</em> is on the <em>right</em> of the <code>=</code>.</p><span>
</span><p>The <em>target</em> of a binding is the property or event inside the binding punctuation: <code>[]</code>, <code>()</code> or <code>[()]</code>.
The <em>source</em> is either inside quotes (<code>&quot; &quot;</code>) or within an interpolation (<code>{{}}</code>).</p><span>
</span><p>Every member of a <strong>source</strong> directive is automatically available for binding.
We don&apos;t have to do anything special to access a directive member in a template expression or statement.</p><span>
</span><p>We have <em>limited</em> access to members of a <strong>target</strong> directive.
We can only bind to properties that are explicitly identified as <em>inputs</em> and <em>outputs</em>.</p><span>
</span></div><p>In the following example, <code>iconUrl</code> and <code>onSave</code> are members of a component
that are referenced within quoted syntax to the right of the <code>=</code>.</p><span>
</span><code language="html" format="">&lt;img [src]=&quot;iconUrl&quot;/&gt;
&lt;button (click)=&quot;onSave()&quot;&gt;Save&lt;/button&gt;
</code><p>They are <em>neither inputs nor outputs</em> of the component. They are data sources for their bindings.</p><span>
</span><p>Now look at <code>HeroDetailComponent</code> when it is the <strong>target of a binding</strong>.</p><span>
</span><code language="html" format="">&lt;hero-detail [hero]=&quot;currentHero&quot; (deleteRequest)=&quot;deleteHero($event)&quot;&gt;
&lt;/hero-detail&gt;
</code><p>Both <code>HeroDetailComponent.hero</code> and <code>HeroDetailComponent.deleteRequest</code> are on the <strong>left side</strong> of binding declarations.
<code>HeroDetailComponent.hero</code> is inside brackets; it is the target of a property binding.
<code>HeroDetailComponent.deleteRequest</code> is inside parentheses; it is the target of an event binding.</p><span>
</span><h3 id="declaring-input-and-output-properties">Declaring input and output properties</h3><span>
</span><p>Target properties must be explicitly marked as inputs or outputs.</p><span>
</span><p>When we peek inside <code>HeroDetailComponent</code>, we see that these properties are marked
with decorators as input and output properties.</p><span>
</span><code language="ts" format="">@Input()  hero: Hero;
@Output() deleteRequest = new EventEmitter&lt;Hero&gt;();
</code><div class="l-sub-section"><p>Alternatively, we can identify members in the <code>inputs</code> and <code>outputs</code> arrays
of the directive metadata, as in this example:</p><span>
</span><code language="ts" format="">@Component({
  inputs: [&apos;hero&apos;],
  outputs: [&apos;deleteRequest&apos;],
})
</code><p>We can specify an input/output property either with a decorator or in a metadata array.
Don&apos;t do both!</p><span>
</span></div><h3 id="input-or-output-">Input or output?</h3><span>
</span><p><em>Input</em> properties usually receive data values.
<em>Output</em> properties expose event producers, such as <code>EventEmitter</code> objects.</p><span>
</span><p>The terms <em>input</em> and <em>output</em> reflect the perspective of the target directive.</p><span>
</span><figure class="image-display"><img src="https://angular.io/resources/images/devguide/template-syntax/input-output.png" alt="Inputs and outputs"></figure><p><code>HeroDetailComponent.hero</code> is an <strong>input</strong> property from the perspective of <code>HeroDetailComponent</code>
because data flows <em>into</em> that property from a template binding expression.</p><span>
</span><p><code>HeroDetailComponent.deleteRequest</code> is an <strong>output</strong> property from the perspective of <code>HeroDetailComponent</code>
because events stream <em>out</em> of that property and toward the handler in a template binding statement.</p><span>
</span><h3 id="aliasing-io">Aliasing input/output properties</h3><p>Sometimes we want the public name of an input/output property to be different from the internal name.</p><span>
</span><p>This is frequently the case with <a href="https://angular.io/docs/ts/latest/guide/attribute-directives.html">attribute directives</a>.
Directive consumers expect to bind to the name of the directive.
For example, when we apply a directive with a <code>myClick</code> selector to a <code>&lt;div&gt;</code> tag,
we expect to bind to an event property that is also called <code>myClick</code>.</p><span>
</span><code language="html" format="">&lt;div (myClick)=&quot;clickMessage=$event&quot;&gt;click with myClick&lt;/div&gt;
</code><p>However, the directive name is often a poor choice for the name of a property within the directive class.
The directive name rarely describes what the property does.
The <code>myClick</code> directive name is not a good name for a property that emits click messages.</p><span>
</span><p>Fortunately, we can have a public name for the property that meets conventional expectations,
while using a different name internally.
In the example immediately above, we are actually binding <em>through the</em> <code>myClick</code> <em>alias</em> to
the directive&apos;s own <code>clicks</code> property.</p><span>
</span><p>We can specify the alias for the property name by passing it into the input/output decorator like this:</p><span>
</span><code language="ts" format="">@Output(&apos;myClick&apos;) clicks = new EventEmitter&lt;string&gt;(); //  @Output(alias) propertyName = ...
</code><div class="l-sub-section"><p>We can also alias property names in the <code>inputs</code> and <code>outputs</code> arrays.
We write a colon-delimited (<code>:</code>) string with
the directive property name on the <em>left</em> and the public alias on the <em>right</em>:</p><span>
</span><code language="ts" format="">@Directive({
  outputs: [&apos;clicks:myClick&apos;]  // propertyName:alias
})
</code></div><a id="expression-operators"></a><h2 id="template-expression-operators">Template expression operators</h2><span>
</span><p>The template expression language employs a subset of JavaScript syntax supplemented with a few special operators
for specific scenarios. We&apos;ll cover two of these operators: <em>pipe</em> and <em>safe navigation operator</em>.</p><span>
</span><span>
</span><h3 id="the-pipe-operator-">The pipe operator ( | )</h3><span>
</span><p>The result of an expression might require some transformation before we&#x2019;re ready to use it in a binding.  For example, we might want to display a number as a currency, force text to uppercase, or filter a list and sort it.</p><span>
</span><p>Angular <a href="https://angular.io/docs/ts/latest/guide/pipes.html">pipes</a> are a good choice for small transformations such as these.
Pipes are simple functions that accept an input value and return a transformed value.
They&apos;re easy to apply within template expressions, using the <strong>pipe operator (<code>|</code>)</strong>:</p><span>
</span><code language="html" format="">&lt;div&gt;Title through uppercase pipe: {{title | uppercase}}&lt;/div&gt;
</code><p>The pipe operator passes the result of an expression on the left to a pipe function on the right.</p><span>
</span><p>We can chain expressions through multiple pipes:</p><span>
</span><code language="html" format="">&lt;!-- Pipe chaining: convert title to uppercase, then to lowercase --&gt;
&lt;div&gt;
  Title through a pipe chain:
  {{title | uppercase | lowercase}}
&lt;/div&gt;
</code><p>And we can also <a href="https://angular.io/docs/ts/latest/guide/pipes.html#parameterizing-a-pipe">apply parameters</a> to a pipe:</p><span>
</span><code language="html" format="">&lt;!-- pipe with configuration argument =&gt; &quot;February 25, 1970&quot; --&gt;
&lt;div&gt;Birthdate: {{currentHero?.birthdate | date:&apos;longDate&apos;}}&lt;/div&gt;
</code><p>The <code>json</code> pipe is particularly helpful for debugging our bindings:</p><span>
</span><code language="html" format="">&lt;div&gt;{{currentHero | json}}&lt;/div&gt;
</code><p>The generated output would look something like this</p><span>
</span><code language="json">{ &quot;firstName&quot;: &quot;Hercules&quot;, &quot;lastName&quot;: &quot;Son of Zeus&quot;,
  &quot;birthdate&quot;: &quot;1970-02-25T08:00:00.000Z&quot;,
  &quot;url&quot;: &quot;http://www.imdb.com/title/tt0065832/&quot;,
  &quot;rate&quot;: 325, &quot;id&quot;: 1 }
</code><span>
</span><h3 id="the-safe-navigation-operator-and-null-property-paths">The safe navigation operator ( ?. ) and null property paths</h3><span>
</span><p>The Angular <strong>safe navigation operator (<code>?.</code>)</strong> is a fluent and convenient way to guard against null and undefined values in property paths.
Here it is, protecting against a view render failure if the <code>currentHero</code> is null.</p><span>
</span><code language="html" format="">The current hero&apos;s name is {{currentHero?.firstName}}
</code><p>Let&#x2019;s elaborate on the problem and this particular solution.</p><span>
</span><p>What happens when the following data bound <code>title</code> property is null?</p><span>
</span><code language="html" format="">The title is {{title}}
</code><p>The view still renders but the displayed value is blank; we see only &quot;The title is&quot; with nothing after it.
That is reasonable behavior. At least the app doesn&apos;t crash.</p><span>
</span><p>Suppose the template expression involves a property path, as in this next example
where we&#x2019;re displaying the <code>firstName</code> of a null hero.</p><span>
</span><code language="html">The null hero&apos;s name is {{nullHero.firstName}}
</code><p>JavaScript throws a null reference error, and so does Angular:</p><span>
</span><code format="nocode">TypeError: Cannot read property &apos;firstName&apos; of null in [null].
</code><p>Worse, the <em>entire view disappears</em>.</p><span>
</span><p>We could claim that this is reasonable behavior if we believed that the <code>hero</code> property must never be null.
If it must never be null and yet it is null,
we&apos;ve made a programming error that should be caught and fixed.
Throwing an exception is the right thing to do.</p><span>
</span><p>On the other hand, null values in the property path may be OK from time to time,
especially when we know the data will arrive eventually.</p><span>
</span><p>While we wait for data, the view should render without complaint, and
the null property path should display as blank just as the <code>title</code> property does.</p><span>
</span><p>Unfortunately, our app crashes when the <code>currentHero</code> is null.</p><span>
</span><p>We could code around that problem with <a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#ngIf">NgIf</a>.</p><span>
</span><code language="html" format="">&lt;!--No hero, div not displayed, no error --&gt;
&lt;div *ngIf=&quot;nullHero&quot;&gt;The null hero&apos;s name is {{nullHero.firstName}}&lt;/div&gt;
</code><p>Or we could try to chain parts of the property path with <code>&amp;&amp;</code>, knowing that the expression bails out
when it encounters the first null.</p><span>
</span><code language="html" format="">The null hero&apos;s name is {{nullHero &amp;&amp; nullHero.firstName}}
</code><p>These approaches have merit but can be cumbersome, especially if the property path is long.
Imagine guarding against a null somewhere in a long property path such as <code>a.b.c.d</code>.</p><span>
</span><p>The Angular safe navigation operator (<code>?.</code>) is a more fluent and convenient way to guard against nulls in property paths.
The expression bails out when it hits the first null value.
The display is blank, but the app keeps rolling without errors.</p><span>
</span><code language="html" format="">&lt;!-- No hero, no problem! --&gt;
The null hero&apos;s name is {{nullHero?.firstName}}
</code><p>It works perfectly with long property paths such as <code>a?.b?.c?.d</code>.</p><span>
</span><h2 id="summary">Summary</h2><span>
</span><p>We&#x2019;ve completed our survey of template syntax. Now it&apos;s time to put that knowledge to work as we write our own components and directives.</p><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!--NEXT PAGE HAS NOW BEEN SET--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--></div></div>
        </article>
      
        <article>
          <h3>Angular Cheat Sheet</h3>
          <div><div class="banner"><p class="text-body">A quick guide to Angular syntax.</p></div></div>
        </article>
      
        <article>
          <h3>Style Guide</h3>
          <div><div class="showcase-content"><div class="alert is-important"><p>We are still preparing style recommendations for the new NgModules feature
introduced in RC5 and will add it to the style guide soon.</p><span>
</span></div><p>Welcome to the Angular 2 Style Guide</p><span>
</span><h2 id="purpose">Purpose</h2><span>
</span><p>If you are looking for an opinionated style guide for syntax, conventions, and structuring Angular applications, then step right in.</p><span>
</span><p>The purpose of this style guide is to provide guidance on building Angular applications by showing the conventions we use and, more importantly, why we choose them.</p><span>
</span><h2 id="style-vocabulary">Style Vocabulary</h2><span>
</span><p>Each guideline describes either a good or bad practice, and all have a consistent presentation.</p><span>
</span><p>The wording of each guideline indicates how strong the recommendation is.</p><span>
</span><div class="s-rule do"><p><strong>Do</strong> is one that should always be followed.
<em>Always</em> might be a bit too strong of a word.
Guidelines that literally should always be followed are extremely rare.
On the other hand, we need a really unusual case for breaking a <em>Do</em> guideline.</p><span>
</span></div><div class="s-rule consider"><p><strong>Consider</strong> guidelines should generally be followed.
If you fully understand the meaning behind the guideline and have a good reason to deviate, then do so. Please strive to be consistent.</p><span>
</span></div><div class="s-rule avoid"><p><strong>Avoid</strong> indicates something we should almost never do. Code examples to <em>avoid</em> have an unmistakeable red header.</p><span>
</span></div><h2 id="file-structure-conventions">File Structure Conventions</h2><span>
</span><p>Some code examples display a file that has one or more similarly named companion files. (e.g. hero.component.ts and hero.component.html).</p><span>
</span><p>The guideline will use the shortcut <code>hero.component.ts|html|css|spec</code> to represent those various files. Using this shortcut makes this guide&apos;s file structures easier to read and more terse.</p><span>
</span><a id="toc"></a><h2 id="table-of-contents">Table of Contents</h2><span>
</span><ol>
<li><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#single-responsibility">Single Responsibility</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#naming">Naming</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#coding-conventions">Coding Conventions</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#application-structure">Application Structure</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#components">Components</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#directives">Directives</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#services">Services</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#data-services">Data Services</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#lifecycle-hooks">Lifecycle Hooks</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#appendix">Appendix</a></li>
</ol><span>
</span><h2 id="single-responsibility">Single Responsibility</h2><span>
</span><p>We apply the <a href="https://wikipedia.org/wiki/Single_responsibility_principle">Single Responsibility Principle</a> to all Components, Services, and other symbols we create. This helps make our app cleaner, easier to read and maintain, and more testable.</p><span>
</span><h3 id="-a-id-01-01-a-rule-of-one"><a id="01-01"></a>Rule of One</h3><span>
</span><h4 id="-a-href-01-01-style-01-01-a-"><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#01-01">Style 01-01</a></h4><span>
</span><div class="s-rule do"><p><strong>Do</strong> define one thing (e.g. service or component) per file.</p><span>
</span></div><div class="s-rule consider"><p><strong>Consider</strong> limiting files to 400 lines of code.</p><span>
</span></div><div class="s-why"><p><strong>Why?</strong> One component per file makes it far easier to read, maintain, and avoid collisions with teams in source control.</p><span>
</span></div><div class="s-why"><p><strong>Why?</strong> One component per file avoids hidden bugs that often arise when combining components in a file where they may share variables, create unwanted closures, or unwanted coupling with dependencies.</p><span>
</span></div><div class="s-why s-why-last"><p><strong>Why?</strong> A single component can be the default export for its file which facilitates lazy loading with the Component Router.</p><span>
</span></div><p>The key is to make the code more reusable, easier to read, and less mistake prone.</p><span>
</span><p>The following <em>negative</em> example defines the <code>AppComponent</code>, bootstraps the app, defines the <code>Hero</code> model object, and loads heroes from the server ... all in the same file. <em>Don&apos;t do this</em>.</p><span>
</span><p>AVOID: app/heroes/hero.component.ts</p><code language="ts" format="linenums">/* avoid */

import { platformBrowserDynamic } from &apos;@angular/platform-browser-dynamic&apos;;
import { BrowserModule } from &apos;@angular/platform-browser&apos;;
import { NgModule, Component, OnInit } from &apos;@angular/core&apos;;

class Hero {
  id: number;
  name: string;
}

@Component({
  selector: &apos;my-app&apos;,
  template: `
      &lt;h1&gt;{{title}}&lt;/h1&gt;
      &lt;pre&gt;{{heroes | json}}&lt;/pre&gt;
    `,
  styleUrls: [&apos;app/app.component.css&apos;]
})
class AppComponent implements OnInit {
  title = &apos;Tour of Heroes&apos;;

  heroes: Hero[] = [];

  ngOnInit() {
    getHeroes().then(heroes =&gt; this.heroes = heroes);
  }
}

@NgModule({
  imports: [ BrowserModule ],
  declarations: [ AppComponent ],
  exports: [ AppComponent ],
  bootstrap: [ AppComponent ]
})
export class AppModule { }

platformBrowserDynamic().bootstrapModule(AppModule);

const HEROES: Hero[] = [
  {id: 1, name: &apos;Bombasto&apos;},
  {id: 2, name: &apos;Tornado&apos;},
  {id: 3, name: &apos;Magneta&apos;},
];

function getHeroes(): Promise&lt;Hero[]&gt; {
  return Promise.resolve(HEROES); // TODO: get hero data from the server;
}
</code><p>Better to redistribute the component and supporting activities into their own dedicated files.</p><span>
</span><code-tabs><code language="ts" name="main.ts" format="linenums">import { platformBrowserDynamic } from &apos;@angular/platform-browser-dynamic&apos;;

import { AppModule }      from &apos;./app/app.module&apos;;

platformBrowserDynamic().bootstrapModule(AppModule);
</code><code language="ts" name="app/app.module.ts" format="linenums">import { NgModule } from &apos;@angular/core&apos;;
import { BrowserModule } from &apos;@angular/platform-browser&apos;;
import { RouterModule } from &apos;@angular/router&apos;;

import { AppComponent } from &apos;./app.component&apos;;
import { HeroesComponent } from &apos;./heroes/heroes.component&apos;;

@NgModule({
  imports: [
    BrowserModule,
  ],
  declarations: [
    AppComponent,
    HeroesComponent
  ],
  exports: [ AppComponent ],
  bootstrap: [ AppComponent ]
})
export class AppModule { }
</code><code language="ts" name="app/app.component.ts" format="linenums">import { Component } from &apos;@angular/core&apos;;

import { HeroService } from &apos;./heroes&apos;;

@Component({
  moduleId: module.id,
  selector: &apos;toh-app&apos;,
  template: `
      &lt;toh-heroes&gt;&lt;/toh-heroes&gt;
    `,
  styleUrls: [&apos;app.component.css&apos;],
  providers: [ HeroService ]
})
export class AppComponent { }
</code><code language="ts" name="app/heroes/heroes.component.ts" format="linenums">import { Component, OnInit } from &apos;@angular/core&apos;;

import { Hero, HeroService } from &apos;./shared&apos;;

@Component({
  selector: &apos;toh-heroes&apos;,
  template: `
      &lt;pre&gt;{{heroes | json}}&lt;/pre&gt;
    `
})
export class HeroesComponent implements OnInit {
  heroes: Hero[] = [];

  constructor(private heroService: HeroService) {}

  ngOnInit() {
    this.heroService.getHeroes()
      .then(heroes =&gt; this.heroes = heroes);
  }
}
</code><code language="ts" name="app/heroes/shared/hero.service.ts" format="linenums">import { Injectable } from &apos;@angular/core&apos;;

import { HEROES } from &apos;./mock-heroes&apos;;

@Injectable()
export class HeroService {
  getHeroes() {
    return Promise.resolve(HEROES);
  }
}
</code><code language="ts" name="app/heroes/shared/hero.model.ts" format="linenums">export class Hero {
  id: number;
  name: string;
}
</code><code language="ts" name="app/heroes/shared/mock-heroes.ts" format="linenums">import { Hero } from &apos;./hero.model&apos;;

export const HEROES: Hero[] = [
  {id: 1, name: &apos;Bombasto&apos;},
  {id: 2, name: &apos;Tornado&apos;},
  {id: 3, name: &apos;Magneta&apos;},
];
</code></code-tabs><p>As the app grows, this rule becomes even more important.</p><span>
</span><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#toc">Back to top</a><h3 id="-a-id-01-02-a-small-functions"><a id="01-02"></a>Small Functions</h3><span>
</span><h4 id="-a-href-01-02-style-01-02-a-"><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#01-02">Style 01-02</a></h4><span>
</span><div class="s-rule do"><p><strong>Do</strong> define small functions</p><span>
</span></div><div class="s-rule consider"><p><strong>Consider</strong> limiting to no more than 75 lines.</p><span>
</span></div><div class="s-why"><p><strong>Why?</strong> Small functions are easier to test, especially when they do one thing and serve one purpose.</p><span>
</span></div><div class="s-why"><p><strong>Why?</strong> Small functions promote reuse.</p><span>
</span></div><div class="s-why"><p><strong>Why?</strong> Small functions are easier to read.</p><span>
</span></div><div class="s-why"><p><strong>Why?</strong> Small functions are easier to maintain.</p><span>
</span></div><div class="s-why s-why-last"><p><strong>Why?</strong> Small functions help avoid hidden bugs that come with large functions that share variables with external scope, create unwanted closures, or unwanted coupling with dependencies.</p><span>
</span></div><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#toc">Back to top</a><h2 id="naming">Naming</h2><span>
</span><p>Naming conventions are hugely important to maintainability and readability. This guide recommends naming conventions for the file name and the symbol name.</p><span>
</span><h3 id="-a-id-02-01-a-general-naming-guidelines"><a id="02-01"></a>General Naming Guidelines</h3><span>
</span><h4 id="-a-href-02-01-style-02-01-a-"><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#02-01">Style 02-01</a></h4><span>
</span><div class="s-rule do"><p><strong>Do</strong> use consistent names for all symbols.</p><span>
</span></div><div class="s-rule do"><p><strong>Do</strong> follow a pattern that describes the symbol&apos;s feature then its type. The recommended pattern is <code>feature.type.ts</code>.</p><span>
</span></div><div class="s-why"><p><strong>Why?</strong> Naming conventions help provide a consistent way to find content at a glance. Consistency within the project is vital. Consistency with a team is important. Consistency across a company provides tremendous efficiency.</p><span>
</span></div><div class="s-why"><p><strong>Why?</strong> The naming conventions should simply help us find our code faster and make it easier to understand.</p><span>
</span></div><div class="s-why s-why-last"><p><strong>Why?</strong> Names of folders and files should clearly convey their intent. For example, <code>app/heroes/hero-list.component.ts</code> may contain a component that manages a list of heroes.</p><span>
</span></div><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#toc">Back to top</a><h3 id="-a-id-02-02-a-separate-file-names-with-dots-and-dashes"><a id="02-02"></a>Separate File Names with Dots and Dashes</h3><span>
</span><h4 id="-a-href-02-02-style-02-02-a-"><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#02-02">Style 02-02</a></h4><span>
</span><div class="s-rule do"><p><strong>Do</strong> use dashes to separate words in the descriptive name.</p><span>
</span></div><div class="s-rule do"><p><strong>Do</strong> use dots to separate the descriptive name from the type.</p><span>
</span></div><div class="s-rule do"><p><strong>Do</strong> use consistent type names for all components following a pattern that describes the component&apos;s feature then its type. A recommended pattern is <code>feature.type.ts</code>.</p><span>
</span></div><div class="s-rule do"><p><strong>Do</strong> use conventional type names including <code>.service</code>, <code>.component</code>, <code>.pipe</code>. 
Invent additional type names if you must but take care not to create too many.</p><span>
</span></div><div class="s-why"><p><strong>Why?</strong> Type names provide a consistent way to quickly identify what is in the file.</p><span>
</span></div><div class="s-why"><p><strong>Why?</strong> Make it easy to find a specific file type using an editor or IDE&apos;s fuzzy search techniques.</p><span>
</span></div><div class="s-why"><p><strong>Why?</strong> Unabbreviated type names such as <code>.service</code> are descriptive and unambiguous.
Abbreviations such as <code>.srv</code>, <code>.svc</code>, and <code>.serv</code> can be confusing.</p><span>
</span></div><div class="s-why s-why-last"><p><strong>Why?</strong> Provides pattern matching for any automated tasks.</p><span>
</span></div><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#toc">Back to top</a><h3 id="-a-id-02-03-a-components-and-directives"><a id="02-03"></a>Components and Directives</h3><span>
</span><h4 id="-a-href-02-03-style-02-03-a-"><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#02-03">Style 02-03</a></h4><span>
</span><div class="s-rule do"><p><strong>Do</strong> use consistent names for all assets named after what they represent.</p><span>
</span></div><div class="s-rule do"><p><strong>Do</strong> use upper camel case for symbols. Match the name of the symbol to the naming of the file.</p><span>
</span></div><div class="s-rule do"><p><strong>Do</strong> append the symbol name with the suffix that it represents.</p><span>
</span></div><div class="s-why"><p><strong>Why?</strong> Provides a consistent way to quickly identify and reference assets.</p><span>
</span></div><div class="s-why"><p><strong>Why?</strong> Upper camel case is conventional for identifying objects that can be instantiated using a constructor.</p><span>
</span></div><div class="s-why s-why-last"><p><strong>Why?</strong> The <code>Component</code> suffix is more commonly used and is more explicitly descriptive.</p><span>
</span></div><table width="100%"><colgroup><col width="50%"><col width="50%"></colgroup><tbody><tr><th>Symbol Name</th><th>File Name</th></tr><tr><td><code>@Component({ ... })
export class AppComponent {}</code></td><td><p>app.component.ts</p>
</td></tr><tr><td><code>@Component({ ... })
export class HeroesComponent</code></td><td><p>heroes.component.ts</p>
</td></tr><tr><td><code>@Component({ ... })
export class HeroListComponent</code></td><td><p>hero-list.component.ts</p>
</td></tr><tr><td><code>@Component({ ... })
export class HeroDetailComponent</code></td><td><p>hero-detail.component.ts</p>
</td></tr><tr><td><code>@Directive({ ... })
export class ValidationDirective</code></td><td><p>validation.directive.ts</p>
</td></tr></tbody></table><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#toc">Back to top</a><h3 id="-a-id-02-04-a-service-names"><a id="02-04"></a>Service Names</h3><span>
</span><h4 id="-a-href-02-04-style-02-04-a-"><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#02-04">Style 02-04</a></h4><span>
</span><div class="s-rule do"><p><strong>Do</strong> use consistent names for all services named after their feature.</p><span>
</span></div><div class="s-rule do"><p><strong>Do</strong> use upper camel case for services.</p><span>
</span></div><div class="s-rule do"><p><strong>Do</strong> suffix services with <code>Service</code> when it is not clear what they are (e.g. when they are nouns).</p><span>
</span></div><div class="s-why"><p><strong>Why?</strong> Provides a consistent way to quickly identify and reference services.</p><span>
</span></div><div class="s-why"><p><strong>Why?</strong> Clear service names such as <code>Logger</code> do not require a suffix.</p><span>
</span></div><div class="s-why s-why-last"><p><strong>Why?</strong> Service names such as <code>Credit</code> are nouns and require a suffix and should be named with a suffix when it is not obvious if it is a service or something else.</p><span>
</span></div><table width="100%"><colgroup><col width="50%"><col width="50%"></colgroup><tbody><tr><th>Symbol Name</th><th>File Name</th></tr><tr><td><code>@Injectable()
export class HeroDataService {}</code></td><td><p>hero-data.service.ts</p>
</td></tr><tr><td><code>@Injectable()
export class CreditService {}</code></td><td><p>credit.service.ts</p>
</td></tr><tr><td><code>@Injectable()
export class Logger {}</code></td><td><p>logger.service.ts</p>
</td></tr></tbody></table><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#toc">Back to top</a><h3 id="-a-id-02-05-a-bootstrapping"><a id="02-05"></a>Bootstrapping</h3><span>
</span><h4 id="-a-href-02-05-style-02-05-a-"><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#02-05">Style 02-05</a></h4><span>
</span><div class="s-rule do"><p><strong>Do</strong> put bootstrapping and platform logic for the app in a file named <code>main.ts</code>.</p><span>
</span></div><div class="s-rule avoid"><p><strong>Avoid</strong> putting app logic in the <code>main.ts</code>. Instead consider placing it in a Component or Service.</p><span>
</span></div><div class="s-why"><p><strong>Why?</strong> Follows a consistent convention for the startup logic of an app.</p><span>
</span></div><div class="s-why s-why-last"><p><strong>Why?</strong> Follows a familiar convention from other technology platforms.</p><span>
</span></div><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#toc">Back to top</a><h3 id="-a-id-02-06-a-directive-selectors"><a id="02-06"></a>Directive Selectors</h3><span>
</span><h4 id="-a-href-02-06-style-02-06-a-"><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#02-06">Style 02-06</a></h4><span>
</span><div class="s-rule do"><p><strong>Do</strong> Use lower camel case for naming the selectors of our directives.</p><span>
</span></div><div class="s-why"><p><strong>Why?</strong> Keeps the names of the properties defined in the directives that are bound to the view consistent with the attribute names.</p><span>
</span></div><div class="s-why s-why-last"><p><strong>Why?</strong> The Angular 2 HTML parser is case sensitive and will recognize lower camel case.</p><span>
</span></div><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#toc">Back to top</a><h3 id="-a-id-02-07-a-custom-prefix-for-components"><a id="02-07"></a>Custom Prefix for Components</h3><span>
</span><h4 id="-a-href-02-07-style-02-07-a-"><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#02-07">Style 02-07</a></h4><span>
</span><div class="s-rule do"><p><strong>Do</strong> use a custom prefix for the selector of our components. For example, the prefix <code>toh</code> represents from <strong>T</strong>our <strong>o</strong>f <strong>H</strong>eroes and the prefix <code>admin</code> represents an admin feature area.</p><span>
</span></div><div class="s-rule do"><p><strong>Do</strong> use a prefix that identifies the feature area or the app itself.</p><span>
</span></div><div class="s-why"><p><strong>Why?</strong> Prevents name collisions.</p><span>
</span></div><div class="s-why"><p><strong>Why?</strong> Makes it easier to promote and share our feature in other apps.</p><span>
</span></div><div class="s-why s-why-last"><p><strong>Why?</strong> Our Components and elements are easily identified.</p><span>
</span></div><p>AVOID: app/heroes/hero.component.ts</p><code language="ts" format="linenums">/* avoid */

// HeroComponent is in the Tour of Heroes feature
@Component({
  selector: &apos;hero&apos;
})
export class HeroComponent {}
</code><p>AVOID: app/users/users.component.ts</p><code language="ts" format="linenums">/* avoid */

// UsersComponent is in an Admin feature
@Component({
  selector: &apos;users&apos;
})
export class UsersComponent {}
</code><p>app/heroes/hero.component.ts</p><code language="ts" format="linenums">@Component({
  selector: &apos;toh-hero&apos;
})
export class HeroComponent {}
</code><p>app/users/users.component.ts</p><code language="ts" format="linenums">@Component({
  selector: &apos;admin-users&apos;
})
export class UsersComponent {}
</code><h3 id="-a-id-02-08-a-custom-prefix-for-directives"><a id="02-08"></a>Custom Prefix for Directives</h3><span>
</span><h4 id="-a-href-02-08-style-02-08-a-"><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#02-08">Style 02-08</a></h4><span>
</span><div class="s-rule do"><p><strong>Do</strong> use a custom prefix for the selector of our directives (for instance below we use the prefix <code>toh</code> from <strong>T</strong>our <strong>o</strong>f <strong>H</strong>eroes).</p><span>
</span></div><div class="s-why"><p><strong>Why?</strong> Prevents name collisions.</p><span>
</span></div><div class="s-why s-why-last"><p><strong>Why?</strong> Our Directives are easily identified.</p><span>
</span></div><p>AVOID: app/shared/validate.directive.ts</p><code language="ts" format="linenums">/* avoid */

@Directive({
  selector: &apos;[validate]&apos;
})
export class ValidateDirective {}
</code><p>app/shared/validate.directive.ts</p><code language="ts" format="linenums">@Directive({
  selector: &apos;[tohValidate]&apos;
})
export class ValidateDirective {}
</code><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#toc">Back to top</a><h3 id="-a-id-02-09-a-pipe-names"><a id="02-09"></a>Pipe Names</h3><span>
</span><h4 id="-a-href-02-09-style-02-09-a-"><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#02-09">Style 02-09</a></h4><span>
</span><div class="s-rule do"><p><strong>Do</strong> use consistent names for all pipes, named after their feature.</p><span>
</span></div><div class="s-why s-why-last"><p><strong>Why?</strong> Provides a consistent way to quickly identify and reference pipes.</p><span>
</span></div><table width="100%"><colgroup><col width="50%"><col width="50%"></colgroup><tbody><tr><th>Symbol Name</th><th>File Name</th></tr><tr><td><code>@Pipe({ name: &apos;ellipsis&apos; })
export class EllipsisPipe implements PipeTransform { }</code></td><td><p>ellipsis.pipe.ts</p>
</td></tr><tr><td><code>@Pipe({ name: &apos;initCaps&apos; })
export class InitCapsPipe implements PipeTransform { }</code></td><td><p>init-caps.pipe.ts</p>
</td></tr></tbody></table><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#toc">Back to top</a><h3 id="-a-id-02-10-a-unit-test-file-names"><a id="02-10"></a>Unit Test File Names</h3><span>
</span><h4 id="-a-href-02-10-style-02-10-a-"><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#02-10">Style 02-10</a></h4><span>
</span><div class="s-rule do"><p><strong>Do</strong> name test specification files the same as the component they test.</p><span>
</span></div><div class="s-rule do"><p><strong>Do</strong> name test specification files with a suffix of <code>.spec</code>.</p><span>
</span></div><div class="s-why"><p><strong>Why?</strong> Provides a consistent way to quickly identify tests.</p><span>
</span></div><div class="s-why s-why-last"><p><strong>Why?</strong> Provides pattern matching for <a href="http://karma-runner.github.io/">karma</a> or other test runners.</p><span>
</span></div><table width="100%"><colgroup><col width="50%"><col width="50%"></colgroup><tbody><tr><th>Symbol Name</th><th>File Name</th></tr><tr><td><p>Components</p>
</td><td><p>heroes.component.spec.ts</p>
<p>hero-list.component.spec.ts</p>
<p>hero-detail.component.spec.ts</p>
</td></tr><tr><td><p>Services</p>
</td><td><p>logger.service.spec.ts</p>
<p>hero.service.spec.ts</p>
<p>filter-text.service.spec.ts</p>
</td></tr><tr><td><p>Pipes</p>
</td><td><p>ellipsis.pipe.spec.ts</p>
<p>init-caps.pipe.spec.ts</p>
</td></tr></tbody></table><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#toc">Back to top</a><h3 id="-a-id-02-11-a-end-to-end-test-file-names"><a id="02-11"></a>End to End Test File Names</h3><span>
</span><h4 id="-a-href-02-11-style-02-11-a-"><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#02-11">Style 02-11</a></h4><span>
</span><div class="s-rule do"><p><strong>Do</strong> name end-to-end test specification files after the feature they test with a suffix of <code>.e2e-spec</code>.</p><span>
</span></div><div class="s-why"><p><strong>Why?</strong> Provides a consistent way to quickly identify end-to-end tests.</p><span>
</span></div><div class="s-why s-why-last"><p><strong>Why?</strong> Provides pattern matching for test runners and build automation.</p><span>
</span></div><table width="100%"><colgroup><col width="50%"><col width="50%"></colgroup><tbody><tr><th>Symbol Name</th><th>File Name</th></tr><tr><td><p>End to End Tests</p>
</td><td><p>app.e2e-spec.ts</p>
<p>heroes.e2e-spec.ts</p>
</td></tr></tbody></table><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#toc">Back to top</a><h2 id="coding-conventions">Coding Conventions</h2><span>
</span><p>Have consistent set of coding, naming, and whitespace conventions.</p><span>
</span><h3 id="-a-id-03-01-a-classes"><a id="03-01"></a>Classes</h3><span>
</span><h4 id="-a-href-03-01-style-03-01-a-"><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#03-01">Style 03-01</a></h4><span>
</span><div class="s-rule do"><p><strong>Do</strong> use upper camel case when naming classes.</p><span>
</span></div><div class="s-why"><p><strong>Why?</strong> Follows conventional thinking for class names.</p><span>
</span></div><div class="s-why s-why-last"><p><strong>Why?</strong> Classes can be instantiated and construct an instance. We often use upper camel case to indicate a constructable asset.</p><span>
</span></div><p>AVOID: app/shared/exception.service.ts</p><code language="ts" format="linenums">/* avoid */

export class exceptionService {
  constructor() { }
}
</code><p>app/shared/exception.service.ts</p><code language="ts" format="linenums">export class ExceptionService {
  constructor() { }
}
</code><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#toc">Back to top</a><h3 id="-a-id-03-02-a-constants"><a id="03-02"></a>Constants</h3><span>
</span><h4 id="-a-href-03-02-style-03-02-a-"><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#03-02">Style 03-02</a></h4><span>
</span><div class="s-rule do"><p><strong>Do</strong> declare variables with <code>const</code> if their values should not change during the application lifetime.</p><span>
</span></div><div class="s-why"><p><strong>Why?</strong> Conveys to readers that the value is invariant.</p><span>
</span></div><div class="s-why s-why-last"><p>TypeScript helps enforce that intent by requiring immediate initialization and by
preventing subsequent re-assignment.</p><span>
</span></div><div class="s-rule consider"><p><strong>Consider</strong> spelling <code>const</code> variables in lower camel case.</p><span>
</span></div><div class="s-why"><p><strong>Why?</strong> lower camel case variable names (<code>heroRoutes</code>) are easier to read and understand
than the traditional UPPER_SNAKE_CASE names (<code>HERO_ROUTES</code>).</p><span>
</span></div><div class="s-why s-why-last"><p><strong>Why?</strong> The tradition of naming constants in UPPER_SNAKE_CASE reflects
an era before the modern IDEs that quickly reveal the <code>const</code> declaration.
TypeScript itself prevents accidental reassignment. </p><span>
</span></div><div class="s-rule do"><p><strong>Do</strong> tolerate <em>existing</em> <code>const</code> variables that are spelled in UPPER_SNAKE_CASE.</p><span>
</span></div><div class="s-why s-why-last"><p><strong>Why?</strong> Although we recommend creating <em>new</em> constants in lower camel case,
the tradition of UPPER_SNAKE_CASE remains popular and pervasive,
especially in third party modules.</p><span>
</span></div><p>app/shared/data.service.ts</p><code language="ts" format="linenums">export const mockHeroes   = [&apos;Sam&apos;, &apos;Jill&apos;]; // prefer
export const heroesUrl    = &apos;api/heroes&apos;;    // prefer
export const VILLAINS_URL = &apos;api/villains&apos;;  // tolerate
</code><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#toc">Back to top</a><h3 id="-a-id-03-03-a-interfaces"><a id="03-03"></a>Interfaces</h3><span>
</span><h4 id="-a-href-03-03-style-03-03-a-"><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#03-03">Style 03-03</a></h4><span>
</span><div class="s-rule do"><p><strong>Do</strong> name an interface using upper camel case.</p><span>
</span></div><div class="s-rule consider"><p><strong>Consider</strong> naming an interface without an <code>I</code> prefix.</p><span>
</span></div><div class="s-why s-why-last"><p><strong>Why?</strong> When we use types, we can often simply use the class as the type.</p><span>
</span></div><p>AVOID: app/shared/hero-collector.service.ts</p><code language="ts" format="linenums">/* avoid */

import { Injectable } from &apos;@angular/core&apos;;

import { IHero } from &apos;./hero.model.avoid&apos;;

@Injectable()
export class HeroCollectorService {
  hero: IHero;

  constructor() { }
}
</code><p>app/shared/hero-collector.service.ts</p><code language="ts" format="linenums">import { Injectable } from &apos;@angular/core&apos;;

import { Hero } from &apos;./hero.model&apos;;

@Injectable()
export class HeroCollectorService {
  hero: Hero;

  constructor() { }
}
</code><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#toc">Back to top</a><h3 id="-a-id-03-04-a-properties-and-methods"><a id="03-04"></a>Properties and Methods</h3><span>
</span><h4 id="-a-href-03-04-style-03-04-a-"><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#03-04">Style 03-04</a></h4><span>
</span><div class="s-rule do"><p><strong>Do</strong> use lower camel case to name properties and methods.</p><span>
</span></div><div class="s-rule avoid"><p><strong>Avoid</strong> prefixing private properties and methods with an underscore.</p><span>
</span></div><div class="s-why"><p><strong>Why?</strong> Follows conventional thinking for properties and methods.</p><span>
</span></div><div class="s-why"><p><strong>Why?</strong> JavaScript lacks a true private property or method.</p><span>
</span></div><div class="s-why s-why-last"><p><strong>Why?</strong> TypeScript tooling makes it easy to identify private vs public properties and methods.</p><span>
</span></div><p>AVOID: app/shared/toast.service.ts</p><code language="ts" format="linenums">/* avoid */

import { Injectable } from &apos;@angular/core&apos;;

@Injectable()
export class ToastService {
  message: string;

  private _toastCount: number;

  hide() {
    this._toastCount--;
    this._log();
  }

  show() {
    this._toastCount++;
    this._log();
  }

  private _log() {
    console.log(this.message);
  }
}
</code><p>app/shared/toast.service.ts</p><code language="ts" format="linenums">import { Injectable } from &apos;@angular/core&apos;;

@Injectable()
export class ToastService {
  message: string;

  private toastCount: number;

  hide() {
    this.toastCount--;
    this.log();
  }

  show() {
    this.toastCount++;
    this.log();
  }

  private log() {
    console.log(this.message);
  }
}
</code><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#toc">Back to top</a><h3 id="-a-id-03-05-a-import-destructuring-spacing"><a id="03-05"></a>Import Destructuring Spacing</h3><span>
</span><h4 id="-a-href-03-05-style-03-05-a-"><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#03-05">Style 03-05</a></h4><span>
</span><div class="s-rule do"><p><strong>Do</strong> leave one whitespace character inside of the <code>import</code> statements&apos; curly braces when destructuring.</p><span>
</span></div><div class="s-why s-why-last"><p><strong>Why?</strong> Whitespace makes it easier to read the imports.</p><span>
</span></div><p>AVOID: app/+heroes/shared/hero.service.ts</p><code language="ts" format="linenums">/* avoid */

import {Injectable} from &apos;@angular/core&apos;;
import {Http, Response} from &apos;@angular/http&apos;;

import {Hero} from &apos;./hero.model&apos;;
import {ExceptionService, SpinnerService, ToastService} from &apos;../../shared&apos;;
</code><p>app/+heroes/shared/hero.service.ts</p><code language="ts" format="linenums">import { Injectable } from &apos;@angular/core&apos;;
import { Http, Response } from &apos;@angular/http&apos;;

import { Hero } from &apos;./hero.model&apos;;
import { ExceptionService, SpinnerService, ToastService } from &apos;../../shared&apos;;
</code><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#toc">Back to top</a><h3 id="-a-id-03-06-a-import-line-spacing"><a id="03-06"></a>Import Line Spacing</h3><span>
</span><h4 id="-a-href-03-06-style-03-06-a-"><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#03-06">Style 03-06</a></h4><span>
</span><div class="s-rule do"><p><strong>Do</strong> leave one empty line between third party imports and imports of code we created.</p><span>
</span></div><div class="s-rule do"><p><strong>Do</strong> list import lines alphabetized by the module.</p><span>
</span></div><div class="s-rule do"><p><strong>Do</strong> list destructured imported assets alphabetically.</p><span>
</span></div><div class="s-why"><p><strong>Why?</strong> The empty line makes it easy to read and locate imports.</p><span>
</span></div><div class="s-why s-why-last"><p><strong>Why?</strong> Alphabetizing makes it easier to read and locate imports.</p><span>
</span></div><p>AVOID: app/+heroes/shared/hero.service.ts</p><code language="ts" format="linenums">/* avoid */

import { ExceptionService, SpinnerService, ToastService } from &apos;../../shared&apos;;
import { Http, Response } from &apos;@angular/http&apos;;
import { Injectable } from &apos;@angular/core&apos;;
import { Hero } from &apos;./hero.model&apos;;
</code><p>app/+heroes/shared/hero.service.ts</p><code language="ts" format="linenums">import { Injectable } from &apos;@angular/core&apos;;
import { Http, Response } from &apos;@angular/http&apos;;

import { Hero } from &apos;./hero.model&apos;;
import { ExceptionService, SpinnerService, ToastService } from &apos;../../shared&apos;;
</code><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#toc">Back to top</a><h2 id="application-structure">Application Structure</h2><span>
</span><p>Have a near term view of implementation and a long term vision. Start small but keep in mind where the app is heading down the road.</p><span>
</span><p>All of the app&apos;s code goes in a folder named <code>app</code>. All content is 1 feature per file. Each component, service, and pipe is in its own file. All 3rd party vendor scripts are stored in another folder and not in the <code>app</code> folder. We didn&apos;t write them and we don&apos;t want them cluttering our app. Use the naming conventions for files in this guide.</p><span>
</span><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#toc">Back to top</a><h3 id="-a-id-04-01-a-lift"><a id="04-01"></a>LIFT</h3><span>
</span><h4 id="-a-href-04-01-style-04-01-a-"><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#04-01">Style 04-01</a></h4><span>
</span><div class="s-rule do"><p><strong>Do</strong> structure the app such that we can <code>L</code>ocate our code quickly, <code>I</code>dentify the code at a glance, keep the <code>F</code>lattest structure we can, and <code>T</code>ry to be DRY.</p><span>
</span></div><div class="s-rule do"><p><strong>Do</strong> define the structure to follow these four basic guidelines, listed in order of importance.</p><span>
</span></div><div class="s-why s-why-last"><p><strong>Why?</strong> LIFT Provides a consistent structure that scales well, is modular, and makes it easier to increase developer efficiency by finding code quickly. Another way to check our app structure is to ask ourselves: How quickly can we open and work in all of the related files for a feature?</p><span>
</span></div><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#toc">Back to top</a><h3 id="-a-id-04-02-a-locate"><a id="04-02"></a>Locate</h3><span>
</span><h4 id="-a-href-04-02-style-04-02-a-"><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#04-02">Style 04-02</a></h4><span>
</span><div class="s-rule do"><p><strong>Do</strong> make locating our code intuitive, simple and fast.</p><span>
</span></div><div class="s-why s-why-last"><p><strong>Why?</strong> We find this to be super important for a project. If we cannot find the files we need to work on quickly, we will not be able to work as efficiently as possible, and the structure will need to change. We may not know the file name or where its related files are, so putting them in the most intuitive locations and near each other saves a ton of time. A descriptive folder structure can help with this.</p><span>
</span></div><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#toc">Back to top</a><h3 id="-a-id-04-03-a-identify"><a id="04-03"></a>Identify</h3><span>
</span><h4 id="-a-href-04-03-style-04-03-a-"><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#04-03">Style 04-03</a></h4><span>
</span><div class="s-rule do"><p><strong>Do</strong> name the file such that we instantly know what it contains and represents.</p><span>
</span></div><div class="s-rule do"><p><strong>Do</strong> be descriptive with file names and keep the contents of the file to exactly one component.</p><span>
</span></div><div class="s-rule avoid"><p><strong>Avoid</strong> files with multiple components, multiple services, or a mixture.</p><span>
</span></div><div class="s-why s-why-last"><p><strong>Why?</strong> We spend less time hunting and pecking for code, and become more efficient. If this means we want longer file names, then so be it.</p><span>
</span></div><div class="l-sub-section"><p>There are deviations of the 1 per file rule when we have a set of very small features that are all related to each other, as they are still easily identifiable.</p><span>
</span></div><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#toc">Back to top</a><h3 id="-a-id-04-04-a-flat"><a id="04-04"></a>Flat</h3><span>
</span><h4 id="-a-href-04-04-style-04-04-a-"><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#04-04">Style 04-04</a></h4><span>
</span><div class="s-rule do"><p><strong>Do</strong> keep a flat folder structure as long as possible.</p><span>
</span></div><div class="s-rule consider"><p><strong>Consider</strong> creating folders when we get to seven or more files.</p><span>
</span></div><div class="s-why s-why-last"><p><strong>Why?</strong> Nobody wants to search seven levels of folders to find a file. In a folder structure there is no hard and fast number rule, but when a folder has seven to ten files, that may be time to create subfolders. We base it on our comfort level. Use a flatter structure until there is an obvious value (to help the rest of LIFT) in creating a new folder.</p><span>
</span></div><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#toc">Back to top</a><h3 id="-a-id-04-05-a-t-dry-try-to-be-dry-"><a id="04-05"></a>T-DRY (Try to be DRY)</h3><span>
</span><h4 id="-a-href-04-05-style-04-05-a-"><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#04-05">Style 04-05</a></h4><span>
</span><div class="s-rule do"><p><strong>Do</strong> be DRY (Don&apos;t Repeat Yourself)</p><span>
</span></div><div class="s-rule avoid"><p><strong>Avoid</strong> being so DRY that we sacrifice readability.</p><span>
</span></div><div class="s-why s-why-last"><p><strong>Why?</strong> Being DRY is important, but not crucial if it sacrifices the others in LIFT, which is why we call it T-DRY. We don&#x2019;t want to type <code>hero-view.component.html</code> for a view because, well, it&#x2019;s obviously a view. If it is not obvious or by convention, then we name it.</p><span>
</span></div><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#toc">Back to top</a><h3 id="-a-id-04-06-a-overall-structural-guidelines"><a id="04-06"></a>Overall Structural Guidelines</h3><span>
</span><h4 id="-a-href-04-06-style-04-06-a-"><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#04-06">Style 04-06</a></h4><span>
</span><div class="s-rule do"><p><strong>Do</strong> start small but keep in mind where the app is heading down the road.</p><span>
</span></div><div class="s-rule do"><p><strong>Do</strong> have a near term view of implementation and a long term vision.</p><span>
</span></div><div class="s-rule do"><p><strong>Do</strong> put all of the app&apos;s code in a folder named <code>app</code>.</p><span>
</span></div><div class="s-rule consider"><p><strong>Consider</strong> creating a folder for each component including its <code>.ts</code>, <code>.html</code>, <code>.css</code> and <code>.spec</code> file.</p><span>
</span></div><div class="s-why"><p><strong>Why?</strong> Helps us keep the app structure small and easy to maintain in the early stages, while being easy to evolve as the app grows.</p><span>
</span></div><div class="s-why s-why-last"><p><strong>Why?</strong> Components often have four files (e.g. <code>*.html</code>, <code>*.css</code>, <code>*.ts</code>, and <code>*.spec.ts</code>) and can clutter a folder quickly.</p><span>
</span></div><p>Overall Folder and File Structure</p><div class="filetree"><p>src</p><div class="children"><p>app</p><div class="children"><p>+heroes</p><div class="children"><p>hero</p><div class="children"><p>hero.component.ts|html|css|spec.ts</p><p>index.ts</p></div><p>hero-list</p><div class="children"><p>hero-list.component.ts|html|css|spec.ts</p><p>index.ts</p></div><p>shared</p><div class="children"><p>hero.model.ts</p><p>hero.service.ts|spec.ts</p><p>index.ts</p></div><p>heroes.component.ts|html|css|spec.ts</p><p>index.ts</p></div><p>shared</p><p>app.component.ts|html|css|spec.ts</p></div><p>main.ts</p><p>index.html</p><p>...</p></div></div><div class="l-sub-section"><p>While we prefer our Components to be in their own dedicated folder, another option for small apps is to keep Components flat (not in a dedicated folder). This adds up to four files to the existing folder, but also reduces the folder nesting. Be consistent.</p><span>
</span></div><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#toc">Back to top</a><h3 id="-a-id-04-07-a-shared-folder"><a id="04-07"></a>Shared Folder</h3><span>
</span><h4 id="-a-href-04-07-style-04-07-a-"><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#04-07">Style 04-07</a></h4><span>
</span><div class="s-rule do"><p><strong>Do</strong> put all shared files within a component feature in a <code>shared</code> folder.</p><span>
</span></div><div class="s-rule consider"><p><strong>Consider</strong> creating a folder for each component including its <code>.ts</code>, <code>.html</code>, <code>.css</code> and <code>.spec</code> file.</p><span>
</span></div><div class="s-why"><p><strong>Why?</strong> Separates shared files from the components within a feature.</p><span>
</span></div><div class="s-why s-why-last"><p><strong>Why?</strong> Makes it easier to locate shared files within a component feature.</p><span>
</span></div><p>Shared Folder</p><div class="filetree"><p>src</p><div class="children"><p>app</p><div class="children"><p>+heroes</p><div class="children"><p>hero</p><p>hero-list</p><p>shared</p><div class="children"><p>hero-button</p><p>hero.model.ts</p><p>hero.service.ts|spec.ts</p><p>index.ts</p></div><p>heroes.component.ts|html|css|spec.ts</p><p>index.ts</p></div><p>shared</p><div class="children"><p>exception.service.ts|spec.ts</p><p>index.ts</p><p>nav</p></div><p>app.component.ts|html|css|spec.ts</p></div><p>main.ts</p><p>index.html</p><p>...</p></div></div><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#toc">Back to top</a><h3 id="-a-id-04-08-a-folders-by-feature-structure"><a id="04-08"></a>Folders-by-Feature Structure</h3><span>
</span><h4 id="-a-href-04-08-style-04-08-a-"><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#04-08">Style 04-08</a></h4><span>
</span><div class="s-rule do"><p><strong>Do</strong> create folders named for the feature they represent.</p><span>
</span></div><div class="s-why"><p><strong>Why?</strong> A developer can locate the code, identify what each file represents at a glance, the structure is as flat as it can be, and there is no repetitive nor redundant names.</p><span>
</span></div><div class="s-why"><p><strong>Why?</strong> The LIFT guidelines are all covered.</p><span>
</span></div><div class="s-why"><p><strong>Why?</strong> Helps reduce the app from becoming cluttered through organizing the content and keeping them aligned with the LIFT guidelines.</p><span>
</span></div><div class="s-why s-why-last"><p><strong>Why?</strong> When there are a lot of files (e.g. 10+) locating them is easier with a consistent folder structures and more difficult in flat structures.</p><span>
</span></div><p>Below is an example of a small app with folders per component.</p><span>
</span><p>Folders per Component</p><div class="filetree"><p>src</p><div class="children"><p>app</p><div class="children"><p>+heroes</p><div class="children"><p>hero</p><p>hero-list</p><p>shared</p><p>heroes.component.ts|html|css|spec.ts</p><p>index.ts</p></div><p>+villains</p><div class="children"><p>villain</p><p>villain-list</p><p>shared</p><p>villains.component.ts|html|css|spec.ts</p><p>index.ts</p></div><p>shared</p><p>app.component.ts|html|css|spec.ts</p></div><p>main.ts</p><p>index.html</p><p>...</p></div></div><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#toc">Back to top</a><h3 id="-a-id-04-09-a-layout-components"><a id="04-09"></a>Layout Components</h3><span>
</span><h4 id="-a-href-04-09-style-04-09-a-"><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#04-09">Style 04-09</a></h4><span>
</span><div class="s-rule do"><p><strong>Do</strong> put components that define the overall layout in a <code>shared</code> folder.</p><span>
</span></div><div class="s-rule do"><p><strong>Do</strong> put shared layout components in their own folder, under the <code>shared</code> folder.</p><span>
</span></div><div class="s-why"><p><strong>Why?</strong> We need a place to host our layout for our app. Our navigation bar, footer, and other aspects of the app that are needed for the entire app.</p><span>
</span></div><div class="s-why s-why-last"><p><strong>Why?</strong> Organizes all layout in a consistent place re-used throughout the application.</p><span>
</span></div><p>Folder for Layout Components</p><div class="filetree"><p>src</p><div class="children"><p>app</p><div class="children"><p>+heroes</p><p>shared</p><div class="children"><p>nav</p><div class="children"><p>index.ts</p><p>nav.component.ts|html|css|spec.ts</p></div><p>footer</p><div class="children"><p>index.ts</p><p>footer.component.ts|html|css|spec.ts</p></div><p>index.ts</p><p>...</p></div><p>app.component.ts|html|css|spec.ts</p></div><p>main.ts</p><p>index.html</p><p>...</p></div></div><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#toc">Back to top</a><h3 id="-a-id-04-10-a-create-and-import-barrels"><a id="04-10"></a>Create and Import Barrels</h3><span>
</span><h4 id="-a-href-04-10-style-04-10-a-"><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#04-10">Style 04-10</a></h4><span>
</span><div class="s-rule consider"><p><strong>Consider</strong> creating a file that imports, aggregates, and re-exports items. We call this technique a <strong>barrel</strong>.</p><span>
</span></div><div class="s-rule consider"><p><strong>Consider</strong> naming this barrel file <code>index.ts</code>.</p><span>
</span></div><div class="s-why"><p><strong>Why?</strong> A barrel aggregates many imports into a single import.</p><span>
</span></div><div class="s-why"><p><strong>Why?</strong> A barrel reduces the number of imports a file may need.</p><span>
</span></div><div class="s-why"><p><strong>Why?</strong> A barrel provides a consistent pattern to import everything exported in the barrel from a folder.</p><span>
</span></div><div class="s-why"><p><strong>Why?</strong> This is consistent with a pattern from Node, which imports the index.js|ts file from a folder.</p><span>
</span></div><div class="s-why s-why-last"><p><strong>Why?</strong> A barrel shortens import statements.</p><span>
</span></div><code-tabs><code language="ts" name="app/shared/index.ts" format="linenums">export * from &apos;./config&apos;;
export * from &apos;./entity.service&apos;;
export * from &apos;./exception.service&apos;;
export * from &apos;./filter-text&apos;;
export * from &apos;./init-caps.pipe&apos;;
export * from &apos;./modal&apos;;
export * from &apos;./nav&apos;;
export * from &apos;./spinner&apos;;
export * from &apos;./toast&apos;;
</code><code language="ts" name="app/shared/filter-text/index.ts" format="linenums">export * from &apos;./filter-text.component&apos;;
export * from &apos;./filter-text.service&apos;;
</code><code language="ts" name="app/shared/modal/index.ts" format="linenums">export * from &apos;./modal.component&apos;;
export * from &apos;./modal.service&apos;;
</code><code language="ts" name="app/shared/nav/index.ts" format="linenums">export * from &apos;./nav.component&apos;;
</code><code language="ts" name="app/shared/spinner/index.ts" format="linenums">export * from &apos;./spinner.component&apos;;
export * from &apos;./spinner.service&apos;;
</code><code language="ts" name="app/shared/toast/index.ts" format="linenums">export * from &apos;./toast.component&apos;;
export * from &apos;./toast.service&apos;;
</code></code-tabs><p>Folder Barrels</p><div class="filetree"><p>src</p><div class="children"><p>app</p><div class="children"><p>+dashboard</p><p>+heroes</p><p>shared</p><p>app.component.ts|html|css|spec.ts</p></div><p>main.ts</p><p>index.html</p><p>...</p></div></div><p>AVOID: app/heroes/heroes.component.ts</p><code language="ts" format="linenums">/* avoid */

import { Component, OnInit } from &apos;@angular/core&apos;;

import { CONFIG } from &apos;../shared/config&apos;;
import { EntityService } from &apos;../shared/entity.service&apos;;
import { ExceptionService } from &apos;../shared/exception.service&apos;;
import { FilterTextComponent } from &apos;../shared/filter-text/filter-text.component&apos;;
import { InitCapsPipe } from &apos;../shared/init-caps.pipe&apos;;
import { SpinnerService } from &apos;../shared/spinner/spinner.service&apos;;
import { ToastService } from &apos;../shared/toast/toast.service&apos;;

@Component({
  selector: &apos;toh-heroes&apos;,
  templateUrl: &apos;app/+heroes/heroes.component.html&apos;
})
export class HeroesComponent implements OnInit {
  constructor() { }

  ngOnInit() { }
}
</code><p>app/heroes/heroes.component.ts</p><code language="ts" format="linenums">import { Component, OnInit } from &apos;@angular/core&apos;;

import {
  CONFIG,
  EntityService,
  ExceptionService,
  SpinnerService,
  ToastService
} from &apos;../shared&apos;;

@Component({
  selector: &apos;toh-heroes&apos;,
  templateUrl: &apos;heroes.component.html&apos;
})
export class HeroesComponent implements OnInit {
  constructor() { }

  ngOnInit() { }
}
</code><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#toc">Back to top</a><h3 id="-a-id-04-11-a-lazy-loaded-folders"><a id="04-11"></a>Lazy Loaded Folders</h3><span>
</span><h4 id="-a-href-04-11-style-04-11-a-"><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#04-11">Style 04-11</a></h4><span>
</span><p>A distinct application feature or workflow may be <em>lazy loaded</em> or <em>loaded on demand</em> rather than when the application starts.</p><span>
</span><div class="s-rule do"><p><strong>Do</strong> put the contents of lazy loaded features in a <em>lazy loaded folder</em>.
A typical <em>lazy loaded folder</em> contains a <em>routing component</em>, its child components, and their related assets and modules.</p><span>
</span></div><div class="s-why s-why-last"><p><strong>Why?</strong> The folder makes it easy to identify and isolate the feature content.</p><span>
</span></div><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#toc">Back to top</a><h3 id="-a-id-04-12-a-prefix-lazy-loaded-folders-with-"><a id="04-12"></a>Prefix Lazy Loaded Folders with +</h3><span>
</span><h4 id="-a-href-04-12-style-04-12-a-"><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#04-12">Style 04-12</a></h4><span>
</span><div class="s-rule do"><p><strong>Do</strong> prefix the name of a <em>lazy loaded folder</em> with a (+) e.g., <code>+dashboard/</code>.</p><span>
</span></div><div class="s-why"><p><strong>Why?</strong> Lazy loaded code paths are easily identifiable by their <code>+</code> prefix.</p><span>
</span></div><div class="s-why"><p><strong>Why?</strong> Lazy loaded code paths are easily distinguishable from non lazy loaded paths.</p><span>
</span></div><div class="s-why s-why-last"><p><strong>Why?</strong> If we see an <code>import</code> path that contains a <code>+</code>, we can quickly refactor to use lazy loading.</p><span>
</span></div><p>Lazy Loaded Folders</p><div class="filetree"><p>src</p><div class="children"><p>app</p><div class="children"><p>+dashboard</p><div class="children"><p>dashboard.component.ts|html|css|spec.ts</p><p>index.ts</p></div></div></div></div><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#toc">Back to top</a><h3 id="-a-id-04-13-a-never-directly-import-lazy-loaded-folders"><a id="04-13"></a>Never Directly Import Lazy Loaded Folders</h3><span>
</span><h4 id="-a-href-04-13-style-04-13-a-"><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#04-13">Style 04-13</a></h4><span>
</span><div class="s-rule avoid"><p><strong>Avoid</strong> allowing modules in sibling and parent folders to directly import a module in a <em>lazy loaded feature</em>.</p><span>
</span></div><div class="s-why s-why-last"><p><strong>Why?</strong> Directly importing a module loads it immediately when our intention is to load it on demand.</p><span>
</span></div><p>AVOID: app/app.component.ts</p><code language="ts" format="">import { HeroesComponent } from &apos;./+heroes&apos;;
</code><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#toc">Back to top</a><h3 id="-a-id-04-14-a-lazy-loaded-folders-may-import-from-a-parent"><a id="04-14"></a>Lazy Loaded Folders May Import From a Parent</h3><span>
</span><h4 id="-a-href-04-14-style-04-14-a-"><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#04-14">Style 04-14</a></h4><span>
</span><div class="s-rule do"><p><strong>Do</strong> allow lazy loaded modules to import a module from a parent folder.</p><span>
</span></div><div class="s-why s-why-last"><p><strong>Why?</strong> A parent module has already been loaded by the time the lazy loaded module imports it.</p><span>
</span></div><p>app/+heroes/heroes.component.ts</p><code language="ts" format="">import { Logger } from &apos;../shared&apos;;
</code><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#toc">Back to top</a><h3 id="-a-id-04-15-a-use-component-router-to-lazy-load"><a id="04-15"></a>Use Component Router to Lazy Load</h3><span>
</span><h4 id="-a-href-04-15-style-04-15-a-"><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#04-15">Style 04-15</a></h4><span>
</span><div class="s-rule do"><p><strong>Do</strong> use the Component Router to lazy load routable features.</p><span>
</span></div><div class="s-why s-why-last"><p><strong>Why?</strong> That&apos;s the easiest way to load a module on demand.</p><span>
</span></div><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#toc">Back to top</a><h2 id="components">Components</h2><span>
</span><h3 id="-a-id-05-02-a-components-selector-naming"><a id="05-02"></a>Components Selector Naming</h3><span>
</span><h4 id="-a-href-05-02-style-05-02-a-"><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#05-02">Style 05-02</a></h4><span>
</span><div class="s-rule do"><p><strong>Do</strong> use <code>kebab-case</code> for naming the element selectors of our components.</p><span>
</span></div><div class="s-why s-why-last"><p><strong>Why?</strong> Keeps the element names consistent with the specification for <a href="https://www.w3.org/TR/custom-elements/">Custom Elements</a>.</p><span>
</span></div><p>AVOID: app/heroes/shared/hero-button/hero-button.component.ts</p><code language="ts" format="linenums">/* avoid */

@Component({
  selector: &apos;tohHeroButton&apos;,
  templateUrl: &apos;hero-button.component.html&apos;
})
export class HeroButtonComponent {}
</code><code-tabs><code language="ts" name="app/heroes/shared/hero-button/hero-button.component.ts" format="linenums">@Component({
  selector: &apos;toh-hero-button&apos;,
  templateUrl: &apos;hero-button.component.html&apos;
})
export class HeroButtonComponent {}
</code><code language="html" name="app/app.component.html" format="linenums">&lt;toh-hero-button&gt;&lt;/toh-hero-button&gt;
</code></code-tabs><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#toc">Back to top</a><h3 id="-a-id-05-03-a-components-as-elements"><a id="05-03"></a>Components as Elements</h3><span>
</span><h4 id="-a-href-05-03-style-05-03-a-"><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#05-03">Style 05-03</a></h4><span>
</span><div class="s-rule do"><p><strong>Do</strong> define Components as elements via the selector.</p><span>
</span></div><div class="s-why"><p><strong>Why?</strong> Components have templates containing HTML and optional Angular template syntax. They are most associated with putting content on a page, and thus are more closely aligned with elements.</p><span>
</span></div><div class="s-why"><p><strong>Why?</strong> Components are derived from Directives, and thus their selectors can be elements, attributes, or other selectors. Defining the selector as an element provides consistency for components that represent content with a template.</p><span>
</span></div><div class="s-why s-why-last"><p><strong>Why?</strong> It is easier to recognize that a symbol is a component vs a directive by looking at the template&apos;s html.</p><span>
</span></div><p>AVOID: app/heroes/hero-button/hero-button.component.ts</p><code language="ts" format="linenums">/* avoid */

@Component({
  selector: &apos;[tohHeroButton]&apos;,
  templateUrl: &apos;hero-button.component.html&apos;
})
export class HeroButtonComponent {}
</code><p>AVOID: app/app.component.html</p><code language="html" format="linenums">&lt;!-- avoid --&gt;

&lt;div tohHeroButton&gt;&lt;/div&gt;
</code><code-tabs><code language="ts" name="app/heroes/shared/hero-button/hero-button.component.ts" format="linenums">@Component({
  selector: &apos;toh-hero-button&apos;,
  templateUrl: &apos;hero-button.component.html&apos;
})
export class HeroButtonComponent {}
</code><code language="html" name="app/app.component.html" format="linenums">&lt;toh-hero-button&gt;&lt;/toh-hero-button&gt;
</code></code-tabs><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#toc">Back to top</a><h3 id="-a-id-05-04-a-extract-template-and-styles-to-their-own-files"><a id="05-04"></a>Extract Template and Styles to Their Own Files</h3><span>
</span><h4 id="-a-href-05-04-style-05-04-a-"><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#05-04">Style 05-04</a></h4><span>
</span><div class="s-rule do"><p><strong>Do</strong> extract templates and styles into a separate file, when more than 3 lines.</p><span>
</span></div><div class="s-rule do"><p><strong>Do</strong> name the template file <code>[component-name].component.html</code>, where [component-name] is our component name.</p><span>
</span></div><div class="s-rule do"><p><strong>Do</strong> name the style file <code>[component-name].component.css</code>, where [component-name] is our component name.</p><span>
</span></div><div class="s-why"><p><strong>Why?</strong> Syntax hints for inline templates in (<em>.js and </em>.ts) code files are not supported by some editors.</p><span>
</span></div><div class="s-why s-why-last"><p><strong>Why?</strong> A component file&apos;s logic is easier to read when not mixed with inline template and styles.</p><span>
</span></div><p>AVOID: app/heroes/heroes.component.ts</p><code language="ts" format="linenums">/* avoid */

@Component({
  selector: &apos;toh-heroes&apos;,
  template: `
    &lt;div&gt;
      &lt;h2&gt;My Heroes&lt;/h2&gt;
      &lt;ul class=&quot;heroes&quot;&gt;
        &lt;li *ngFor=&quot;let hero of heroes&quot;&gt;
          &lt;span class=&quot;badge&quot;&gt;{{hero.id}}&lt;/span&gt; {{hero.name}}
        &lt;/li&gt;
      &lt;/ul&gt;
      &lt;div *ngIf=&quot;selectedHero&quot;&gt;
        &lt;h2&gt;{{selectedHero.name | uppercase}} is my hero&lt;/h2&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  `,
  styleUrls:  [`
    .heroes {
      margin: 0 0 2em 0; list-style-type: none; padding: 0; width: 15em;
    }
    .heroes li {
      cursor: pointer;
      position: relative;
      left: 0;
      background-color: #EEE;
      margin: .5em;
      padding: .3em 0;
      height: 1.6em;
      border-radius: 4px;
    }
    .heroes .badge {
      display: inline-block;
      font-size: small;
      color: white;
      padding: 0.8em 0.7em 0 0.7em;
      background-color: #607D8B;
      line-height: 1em;
      position: relative;
      left: -1px;
      top: -4px;
      height: 1.8em;
      margin-right: .8em;
      border-radius: 4px 0 0 4px;
    }
  `]
})
export class HeroesComponent implements OnInit {
  heroes: Hero[];
  selectedHero: Hero;

  ngOnInit() {}
}
</code><code-tabs><code language="ts" name="app/heroes/heroes.component.ts" format="linenums">@Component({
  selector: &apos;toh-heroes&apos;,
  templateUrl: &apos;heroes.component.html&apos;,
  styleUrls:  [&apos;heroes.component.css&apos;]
})
export class HeroesComponent implements OnInit {
  heroes: Hero[];
  selectedHero: Hero;

  ngOnInit() { }
}
</code><code language="html" name="app/heroes/heroes.component.html" format="linenums">&lt;div&gt;
  &lt;h2&gt;My Heroes&lt;/h2&gt;
  &lt;ul class=&quot;heroes&quot;&gt;
    &lt;li *ngFor=&quot;let hero of heroes&quot;&gt;
      &lt;span class=&quot;badge&quot;&gt;{{hero.id}}&lt;/span&gt; {{hero.name}}
    &lt;/li&gt;
  &lt;/ul&gt;
  &lt;div *ngIf=&quot;selectedHero&quot;&gt;
    &lt;h2&gt;{{selectedHero.name | uppercase}} is my hero&lt;/h2&gt;
  &lt;/div&gt;
&lt;/div&gt;
</code><code language="css" name="app/heroes/heroes.component.css" format="linenums">.heroes {
  margin: 0 0 2em 0; list-style-type: none; padding: 0; width: 15em;
}
.heroes li {
  cursor: pointer;
  position: relative;
  left: 0;
  background-color: #EEE;
  margin: .5em;
  padding: .3em 0;
  height: 1.6em;
  border-radius: 4px;
}
.heroes .badge {
  display: inline-block;
  font-size: small;
  color: white;
  padding: 0.8em 0.7em 0 0.7em;
  background-color: #607D8B;
  line-height: 1em;
  position: relative;
  left: -1px;
  top: -4px;
  height: 1.8em;
  margin-right: .8em;
  border-radius: 4px 0 0 4px;
}
</code></code-tabs><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#toc">Back to top</a><h3 id="-a-id-05-12-a-decorate-input-and-output-properties-inline"><a id="05-12"></a>Decorate Input and Output Properties Inline</h3><span>
</span><h4 id="-a-href-05-12-style-05-12-a-"><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#05-12">Style 05-12</a></h4><span>
</span><div class="s-rule do"><p><strong>Do</strong> place the <code>@Input()</code> or <code>@Output()</code> on the same line as the property they decorate.</p><span>
</span></div><div class="s-why"><p><strong>Why?</strong> It is easier and more readable to identify which properties in a class are inputs or outputs.</p><span>
</span></div><div class="s-why"><p><strong>Why?</strong> If we ever need to rename the property or event name associated to <a href="https://angular.io/docs/ts/latest/api/core/index/Input-var.html"><code>@Input</code></a> or <a href="https://angular.io/docs/ts/latest/api/core/index/Output-var.html"><code>@Output</code></a> we can modify it on a single place.</p><span>
</span></div><div class="s-why"><p><strong>Why?</strong> The metadata declaration attached to the directive is shorter and thus more readable.</p><span>
</span></div><div class="s-why s-why-last"><p><strong>Why?</strong> Placing the decorator on the same line makes for shorter code and still easily identifies the property as an input or output.</p><span>
</span></div><p>AVOID: app/heroes/shared/hero-button/hero-button.component.ts</p><code language="ts" format="linenums">/* avoid */

@Component({
  selector: &apos;toh-hero-button&apos;,
  template: `&lt;button&gt;&lt;/button&gt;`,
  inputs: [
    &apos;label&apos;
  ],
  outputs: [
    &apos;change&apos;
  ]
})
export class HeroButtonComponent {
  change = new EventEmitter&lt;any&gt;();
  label: string;
}
</code><p>app/heroes/shared/hero-button/hero-button.component.ts</p><code language="ts" format="linenums">@Component({
  selector: &apos;toh-hero-button&apos;,
  template: `&lt;button&gt;{{label}}&lt;/button&gt;`
})
export class HeroButtonComponent {
  @Output() change = new EventEmitter&lt;any&gt;();
  @Input() label: string;
}
</code><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#toc">Back to top</a><h3 id="-a-id-05-13-a-avoid-renaming-inputs-and-outputs"><a id="05-13"></a>Avoid Renaming Inputs and Outputs</h3><span>
</span><h4 id="-a-href-05-13-style-05-13-a-"><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#05-13">Style 05-13</a></h4><span>
</span><div class="s-rule avoid"><p><strong>Avoid</strong> renaming inputs and outputs, when possible.</p><span>
</span></div><div class="s-why s-why-last"><p><strong>Why?</strong> May lead to confusion when the output or the input properties of a given directive are named a given way but exported differently as a public API.</p><span>
</span></div><p>AVOID: app/heroes/shared/hero-button/hero-button.component.ts</p><code language="ts" format="linenums">/* avoid */

@Component({
  selector: &apos;toh-hero-button&apos;,
  template: `&lt;button&gt;{{label}}&lt;/button&gt;`
})
export class HeroButtonComponent {
  @Output(&apos;changeEvent&apos;) change = new EventEmitter&lt;any&gt;();
  @Input(&apos;labelAttribute&apos;) label: string;
}
</code><p>AVOID: app/app.component.html</p><code language="html" format="linenums">&lt;!-- avoid --&gt;

&lt;toh-hero-button labelAttribute=&quot;OK&quot; (changeEvent)=&quot;doSomething()&quot;&gt;
&lt;/toh-hero-button&gt;
</code><code-tabs><code language="ts" name="app/heroes/shared/hero-button/hero-button.component.ts" format="linenums">@Component({
  selector: &apos;toh-hero-button&apos;,
  template: `&lt;button&gt;{{label}}&lt;/button&gt;`
})
export class HeroButtonComponent {
  @Output() change = new EventEmitter&lt;any&gt;();
  @Input() label: string;
}
</code><code language="html" name="app/app.component.html" format="linenums">&lt;toh-hero-button label=&quot;OK&quot; (change)=&quot;doSomething()&quot;&gt;
&lt;/toh-hero-button&gt;
</code></code-tabs><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#toc">Back to top</a><h3 id="-a-id-05-14-a-member-sequence"><a id="05-14"></a>Member Sequence</h3><span>
</span><h4 id="-a-href-05-14-style-05-14-a-"><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#05-14">Style 05-14</a></h4><span>
</span><div class="s-rule do"><p><strong>Do</strong> place properties up top followed by methods.</p><span>
</span></div><div class="s-rule do"><p><strong>Do</strong> place private members after public members, alphabetized.</p><span>
</span></div><div class="s-why s-why-last"><p><strong>Why?</strong> Placing members in a consistent sequence makes it easy to read and helps we instantly identify which members of the component serve which purpose.</p><span>
</span></div><p>AVOID: app/shared/toast/toast.component.ts</p><code language="ts" format="linenums">/* avoid */

export class ToastComponent implements OnInit {

  private defaults = {
    title: &apos;&apos;,
    message: &apos;May the Force be with You&apos;
  };
  message: string;
  title: string;
  private toastElement: any;

  ngOnInit() {
    this.toastElement = document.getElementById(&apos;toh-toast&apos;);
  }

  // private methods
  private hide() {
    this.toastElement.style.opacity = 0;
    window.setTimeout(() =&gt; this.toastElement.style.zIndex = 0, 400);
  }

  activate(message = this.defaults.message, title = this.defaults.title) {
    this.title = title;
    this.message = message;
    this.show();
  }

  private show() {
    console.log(this.message);
    this.toastElement.style.opacity = 1;
    this.toastElement.style.zIndex = 9999;

    window.setTimeout(() =&gt; this.hide(), 2500);
  }
}
</code><p>app/shared/toast/toast.component.ts</p><code language="ts" format="linenums">export class ToastComponent implements OnInit {
  // public properties
  message: string;
  title: string;

  // private fields
  private defaults = {
    title: &apos;&apos;,
    message: &apos;May the Force be with You&apos;
  };
  private toastElement: any;

  // public methods
  activate(message = this.defaults.message, title = this.defaults.title) {
    this.title = title;
    this.message = message;
    this.show();
  }

  ngOnInit() {
    this.toastElement = document.getElementById(&apos;toh-toast&apos;);
  }

  // private methods
  private hide() {
    this.toastElement.style.opacity = 0;
    window.setTimeout(() =&gt; this.toastElement.style.zIndex = 0, 400);
  }

  private show() {
    console.log(this.message);
    this.toastElement.style.opacity = 1;
    this.toastElement.style.zIndex = 9999;
    window.setTimeout(() =&gt; this.hide(), 2500);
  }
}
</code><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#toc">Back to top</a><h3 id="-a-id-05-15-a-put-logic-in-services"><a id="05-15"></a>Put Logic in Services</h3><span>
</span><h4 id="-a-href-05-14-style-05-15-a-"><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#05-14">Style 05-15</a></h4><span>
</span><div class="s-rule do"><p><strong>Do</strong> limit logic in a component to only that required for the view. All other logic should be delegated to services.</p><span>
</span></div><div class="s-rule do"><p><strong>Do</strong> move reusable logic to services and keep components simple and focused on their intended purpose.</p><span>
</span></div><div class="s-why"><p><strong>Why?</strong> Logic may be reused by multiple components when placed within a service and exposed via a function.</p><span>
</span></div><div class="s-why"><p><strong>Why?</strong> Logic in a service can more easily be isolated in a unit test, while the calling logic in the component can be easily mocked.</p><span>
</span></div><div class="s-why"><p><strong>Why?</strong> Removes dependencies and hides implementation details from the component.</p><span>
</span></div><div class="s-why s-why-last"><p><strong>Why?</strong> Keeps the component slim, trim, and focused.</p><span>
</span></div><p>AVOID: app/heroes/hero-list/hero-list.component.ts</p><code language="ts" format="linenums">/* avoid */

import { OnInit } from &apos;@angular/core&apos;;
import { Http, Response } from &apos;@angular/http&apos;;
import { Observable } from &apos;rxjs/Observable&apos;;

import { Hero } from &apos;../shared/hero.model&apos;;

const heroesUrl = &apos;http://angular.io&apos;;

export class HeroListComponent implements OnInit {
  heroes: Hero[];
  constructor(private http: Http) {}
  getHeroes() {
    this.heroes = [];
    this.http.get(heroesUrl)
      .map((response: Response) =&gt; &lt;Hero[]&gt;response.json().data)
      .catch(this.catchBadResponse)
      .finally(() =&gt; this.hideSpinner())
      .subscribe((heroes: Hero[]) =&gt; this.heroes = heroes);
  }
  ngOnInit() {
    this.getHeroes();
  }

  private catchBadResponse(err: any, source: Observable&lt;any&gt;) {
    // log and handle the exception
    return new Observable();
  }

  private hideSpinner() {
    // hide the spinner
  }
}
</code><p>app/heroes/hero-list/hero-list.component.ts</p><code language="ts" format="linenums">import { Component, OnInit } from &apos;@angular/core&apos;;

import { Hero, HeroService } from &apos;../shared&apos;;

@Component({
  selector: &apos;toh-hero-list&apos;,
  template: `...`
})
export class HeroListComponent implements OnInit {
  heroes: Hero[];
  constructor(private heroService: HeroService) {}
  getHeroes() {
    this.heroes = [];
    this.heroService.getHeroes()
      .subscribe(heroes =&gt; this.heroes = heroes);
  }
  ngOnInit() {
    this.getHeroes();
  }
}
</code><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#toc">Back to top</a><h3 id="-a-id-05-16-a-don-t-prefix-output-properties"><a id="05-16"></a>Don&apos;t Prefix Output Properties</h3><span>
</span><h4 id="-a-href-05-16-style-05-16-a-"><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#05-16">Style 05-16</a></h4><span>
</span><div class="s-rule do"><p><strong>Do</strong> name events without the prefix <code>on</code>.</p><span>
</span></div><div class="s-rule do"><p><strong>Do</strong> name our event handler methods with the prefix <code>on</code> followed by the event name.</p><span>
</span></div><div class="s-why"><p><strong>Why?</strong> This is consistent with built-in events such as button clicks.</p><span>
</span></div><div class="s-why s-why-last"><p><strong>Why?</strong> Angular allows for an <a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#!#binding-syntax">alternative syntax</a> <code>on-*</code>. If the event itself was prefixed with <code>on</code> this would result in an <code>on-onEvent</code> binding expression.</p><span>
</span></div><p>AVOID: app/heroes/hero.component.ts</p><code language="ts" format="linenums">/* avoid */

@Component({
  selector: &apos;toh-hero&apos;,
  template: `...`
})
export class HeroComponent {
  @Output() onSavedTheDay = new EventEmitter&lt;boolean&gt;();
}
</code><p>AVOID: app/app.component.html</p><code language="html" format="linenums">&lt;!-- avoid --&gt;

&lt;toh-hero (onSavedTheDay)=&quot;onSavedTheDay($event)&quot;&gt;&lt;/toh-hero&gt;
</code><code-tabs><code language="ts" name="app/heroes/hero.component.ts" format="linenums">export class HeroComponent {
  @Output() savedTheDay = new EventEmitter&lt;boolean&gt;();
}
</code><code language="html" name="app/app.component.html" format="linenums">&lt;toh-hero (savedTheDay)=&quot;onSavedTheDay($event)&quot;&gt;&lt;/toh-hero&gt;
</code></code-tabs><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#toc">Back to top</a><h3 id="-a-id-05-17-a-put-presentation-logic-in-the-component-class"><a id="05-17"></a>Put Presentation Logic in the Component Class</h3><span>
</span><h4 id="-a-href-05-17-style-05-17-a-"><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#05-17">Style 05-17</a></h4><span>
</span><div class="s-rule do"><p><strong>Do</strong> put presentation logic in the Component class, and not in the template.</p><span>
</span></div><div class="s-why"><p><strong>Why?</strong> Logic will be contained in one place (the Component class) instead of being spread in two places.</p><span>
</span></div><div class="s-why s-why-last"><p><strong>Why?</strong> Keeping the component&apos;s presentation logic in the class instead of the template improves testability, maintainability, and reusability.</p><span>
</span></div><p>AVOID: app/heroes/hero-list/hero-list.component.ts</p><code language="ts" format="linenums">/* avoid */

@Component({
  selector: &apos;toh-hero-list&apos;,
  template: `
    &lt;section&gt;
      Our list of heroes:
      &lt;hero-profile *ngFor=&quot;let hero of heroes&quot; [hero]=&quot;hero&quot;&gt;
      &lt;/hero-profile&gt;
      Total powers: {{totalPowers}}&lt;br&gt;
      Average power: {{totalPowers / heroes.length}}
    &lt;/section&gt;
  `
})
export class HeroListComponent {
  heroes: Hero[];
  totalPowers: number;
}
</code><p>app/heroes/hero-list/hero-list.component.ts</p><code language="ts" format="linenums">@Component({
  selector: &apos;toh-hero-list&apos;,
  template: `
    &lt;section&gt;
      Our list of heroes:
      &lt;toh-hero *ngFor=&quot;let hero of heroes&quot; [hero]=&quot;hero&quot;&gt;
      &lt;/toh-hero&gt;
      Total powers: {{totalPowers}}&lt;br&gt;
      Average power: {{avgPower}}
    &lt;/section&gt;
  `
})
export class HeroListComponent {
  heroes: Hero[];
  totalPowers: number;

  get avgPower() {
    return this.totalPowers / this.heroes.length;
  }
}
</code><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#toc">Back to top</a><h2 id="directives">Directives</h2><span>
</span><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#toc">Back to top</a><h3 id="-a-id-06-01-a-use-directives-to-enhance-an-existing-element"><a id="06-01"></a>Use Directives to Enhance an Existing Element</h3><span>
</span><h4 id="-a-href-06-01-style-06-01-a-"><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#06-01">Style 06-01</a></h4><span>
</span><div class="s-rule do"><p><strong>Do</strong> use attribute directives when you have presentation logic without a template.</p><span>
</span></div><div class="s-why"><p><strong>Why?</strong> Attributes directives don&apos;t have an associated template.</p><span>
</span></div><div class="s-why s-why-last"><p><strong>Why?</strong> An element may have more than one attribute directive applied.</p><span>
</span></div><p>app/shared/highlight.directive.ts</p><code language="ts" format="linenums">@Directive({
  selector: &apos;[tohHighlight]&apos;
})
export class HighlightDirective {
  @HostListener(&apos;mouseover&apos;) onMouseEnter() {
    // do highlight work
  }
}
</code><p>app/app.component.html</p><code language="html" format="">&lt;div tohHighlight&gt;Bombasta&lt;/div&gt;
</code><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#toc">Back to top</a><h3 id="-a-id-06-03-a-use-hostlistener-and-hostbinding-class-decorators"><a id="06-03"></a>Use HostListener and HostBinding Class Decorators</h3><span>
</span><h4 id="-a-href-06-03-style-06-03-a-"><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#06-03">Style 06-03</a></h4><span>
</span><div class="s-rule do"><p><strong>Do</strong> use @HostListener and @HostBinding instead of the host property of the @Directive and @Component decorators:</p><span>
</span></div><div class="s-why"><p><strong>Why?</strong> The property or method name associated with @HostBinding or respectively @HostListener should be modified only in a single place - in the directive&apos;s class. In contrast if we use host we need to modify both the property declaration inside the controller, and the metadata associated to the directive.</p><span>
</span></div><div class="s-why s-why-last"><p><strong>Why?</strong> The metadata declaration attached to the directive is shorter and thus more readable.</p><span>
</span></div><p>AVOID: app/shared/validator.directive.ts</p><code language="ts" format="linenums">/* avoid */

@Directive({
  selector: &apos;[tohValidator]&apos;,
  host: {
    &apos;(mouseenter)&apos;: &apos;onMouseEnter()&apos;,
    &apos;attr.role&apos;: &apos;button&apos;
  }
})
export class ValidatorDirective {
  role = &apos;button&apos;;
  onMouseEnter() {
    // do work
  }
}
</code><p>app/shared/validator.directive.ts</p><code language="ts" format="linenums">@Directive({
  selector: &apos;[tohValidator]&apos;
})
export class ValidatorDirective {
  @HostBinding(&apos;attr.role&apos;) role = &apos;button&apos;;
  @HostListener(&apos;mouseenter&apos;) onMouseEnter() {
    // do work
  }
}
</code><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#toc">Back to top</a><h2 id="services">Services</h2><span>
</span><h3 id="-a-id-07-01-a-services-are-singletons-in-same-injector"><a id="07-01"></a>Services are Singletons in Same Injector</h3><span>
</span><h4 id="-a-href-07-01-style-07-01-a-"><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#07-01">Style 07-01</a></h4><span>
</span><div class="s-rule do"><p><strong>Do</strong> use services as singletons within the same injector. Use them for sharing data and functionality.</p><span>
</span></div><div class="s-why"><p><strong>Why?</strong> Services are ideal for sharing methods across a feature area or an app.</p><span>
</span></div><div class="s-why s-why-last"><p><strong>Why?</strong> Services are ideal for sharing stateful in-memory data.</p><span>
</span></div><p>app/heroes/shared/hero.service.ts</p><code language="ts" format="linenums">export class HeroService {
  constructor(private http: Http) { }

  getHeroes() {
    return this.http.get(&apos;api/heroes&apos;)
      .map((response: Response) =&gt; &lt;Hero[]&gt;response.json().data);
  }
}
</code><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#toc">Back to top</a><h3 id="-a-id-07-02-a-single-responsibility"><a id="07-02"></a>Single Responsibility</h3><span>
</span><h4 id="-a-href-07-02-style-07-02-a-"><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#07-02">Style 07-02</a></h4><span>
</span><div class="s-rule do"><p><strong>Do</strong> create services with a single responsibility that is encapsulated by its context.</p><span>
</span></div><div class="s-rule do"><p><strong>Do</strong> create a new service once the service begins to exceed that singular purpose.</p><span>
</span></div><div class="s-why"><p><strong>Why?</strong> When a service has multiple responsibilities, it becomes difficult to test.</p><span>
</span></div><div class="s-why s-why-last"><p><strong>Why?</strong> When a service has multiple responsibilities, every Component or Service that injects it now carries the weight of them all.</p><span>
</span></div><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#toc">Back to top</a><h3 id="-a-id-07-03-a-providing-a-service"><a id="07-03"></a>Providing a Service</h3><span>
</span><h4 id="-a-href-07-03-style-07-03-a-"><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#07-03">Style 07-03</a></h4><span>
</span><div class="s-rule do"><p><strong>Do</strong> provide services to the Angular 2 injector at the top-most component where they will be shared.</p><span>
</span></div><div class="s-why"><p><strong>Why?</strong> The Angular 2 injector is hierarchical.</p><span>
</span></div><div class="s-why"><p><strong>Why?</strong> When providing the service to a top level component, that instance is shared and available to all child components of that top level component.</p><span>
</span></div><div class="s-why"><p><strong>Why?</strong> This is ideal when a service is sharing methods or state.</p><span>
</span></div><div class="s-why s-why-last"><p><strong>Why?</strong> This is not ideal when two different components need different instances of a service. In this scenario it would be better to provide the service at the component level that needs the new and separate instance.</p><span>
</span></div><code-tabs><code language="ts" name="app/app.component.ts" format="linenums">import { Component } from &apos;@angular/core&apos;;

import { HeroService } from &apos;./heroes&apos;;

@Component({
  selector: &apos;toh-app&apos;,
  template: `
      &lt;toh-heroes&gt;&lt;/toh-heroes&gt;
    `,
  providers: [HeroService]
})
export class AppComponent {}
</code><code language="ts" name="app/heroes/hero-list/hero-list.component.ts" format="linenums">import { Component, OnInit } from &apos;@angular/core&apos;;

import { Hero, HeroService } from &apos;../shared&apos;;

@Component({
  selector: &apos;toh-heroes&apos;,
  template: `
      &lt;pre&gt;{{heroes | json}}&lt;/pre&gt;
    `
})
export class HeroListComponent implements OnInit {
  heroes: Hero[] = [];

  constructor(private heroService: HeroService) { }

  ngOnInit() {
    this.heroService.getHeroes().subscribe(heroes =&gt; this.heroes = heroes);
  }
}
</code></code-tabs><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#toc">Back to top</a><h3 id="-a-id-07-04-a-use-the-injectable-class-decorator"><a id="07-04"></a>Use the @Injectable() Class Decorator</h3><span>
</span><h4 id="-a-href-07-04-style-07-04-a-"><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#07-04">Style 07-04</a></h4><span>
</span><div class="s-rule do"><p><strong>Do</strong> use the <code>@Injectable</code> class decorator instead of the <code>@Inject</code> parameter decorator when using types as tokens for the dependencies of a service.</p><span>
</span></div><div class="s-why"><p><strong>Why?</strong> The Angular DI mechanism resolves all the dependencies of our services based on their types declared with the services&apos; constructors.</p><span>
</span></div><div class="s-why s-why-last"><p><strong>Why?</strong> When a service accepts only dependencies associated with type tokens, the <code>@Injectable()</code> syntax is much less verbose compared to using <code>@Inject()</code> on each individual constructor parameter.</p><span>
</span></div><p>AVOID: app/heroes/shared/hero-arena.service.ts</p><code language="ts" format="linenums">/* avoid */

export class HeroArena {
  constructor(
      @Inject(HeroService) private heroService: HeroService,
      @Inject(Http) private http: Http) {}
}
</code><p>app/heroes/shared/hero-arena.service.ts</p><code language="ts" format="linenums">@Injectable()
export class HeroArena {
  constructor(
    private heroService: HeroService,
    private http: Http) {}
}
</code><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#toc">Back to top</a><h2 id="data-services">Data Services</h2><span>
</span><h3 id="-a-id-08-01-a-separate-data-calls"><a id="08-01"></a>Separate Data Calls</h3><span>
</span><h4 id="-a-href-08-01-style-08-01-a-"><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#08-01">Style 08-01</a></h4><span>
</span><div class="s-rule do"><p><strong>Do</strong> refactor logic for making data operations and interacting with data to a service.</p><span>
</span></div><div class="s-rule do"><p><strong>Do</strong> make data services responsible for XHR calls, local storage, stashing in memory, or any other data operations.</p><span>
</span></div><div class="s-why"><p><strong>Why?</strong> The component&apos;s responsibility is for the presentation and gathering of information for the view. It should not care how it gets the data, just that it knows who to ask for it. Separating the data services moves the logic on how to get it to the data service, and lets the component be simpler and more focused on the view.</p><span>
</span></div><div class="s-why"><p><strong>Why?</strong> This makes it easier to test (mock or real) the data calls when testing a component that uses a data service.</p><span>
</span></div><div class="s-why s-why-last"><p><strong>Why?</strong> Data service implementation may have very specific code to handle the data repository. This may include headers, how to talk to the data, or other services such as <code>Http</code>. Separating the logic into a data service encapsulates this logic in a single place hiding the implementation from the outside consumers (perhaps a component), also making it easier to change the implementation.</p><span>
</span></div><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#toc">Back to top</a><h2 id="lifecycle-hooks">Lifecycle Hooks</h2><span>
</span><p>Use Lifecycle Hooks to tap into important events exposed by Angular.</p><span>
</span><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#toc">Back to top</a><h3 id="-a-id-09-01-a-implement-lifecycle-hooks-interfaces"><a id="09-01"></a>Implement Lifecycle Hooks Interfaces</h3><span>
</span><h4 id="-a-href-09-01-style-09-01-a-"><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#09-01">Style 09-01</a></h4><span>
</span><div class="s-rule do"><p><strong>Do</strong> implement the lifecycle hook interfaces.</p><span>
</span></div><div class="s-why s-why-last"><p><strong>Why?</strong> We get strong typing for the method signatures.
The compiler and editor can call our attention to misspellings.</p><span>
</span></div><p>AVOID: app/heroes/shared/hero-button/hero-button.component.ts</p><code language="ts" format="linenums">/* avoid */

@Component({
  selector: &apos;toh-hero-button&apos;,
  template: `&lt;button&gt;OK&lt;button&gt;`
})
export class HeroButtonComponent {
  onInit() { // misspelled
    console.log(&apos;The component is initialized&apos;);
  }
}
</code><p>app/heroes/shared/hero-button/hero-button.component.ts</p><code language="ts" format="linenums">@Component({
  selector: &apos;toh-hero-button&apos;,
  template: `&lt;button&gt;OK&lt;/button&gt;`
})
export class HeroButtonComponent implements OnInit {
  ngOnInit() {
    console.log(&apos;The component is initialized&apos;);
  }
}
</code><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#toc">Back to top</a><h2 id="appendix">Appendix</h2><span>
</span><p>Useful tools and tips for Angular 2.</p><span>
</span><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#toc">Back to top</a><h3 id="-a-id-a-01-a-codelyzer"><a id="A-01"></a>Codelyzer</h3><span>
</span><h4 id="-a-href-a-01-style-a-01-a-"><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#A-01">Style A-01</a></h4><span>
</span><div class="s-rule consider"><p><strong>Consider</strong> adjusting the rules in codelyzer to suit your needs.</p><span>
</span></div><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#toc">Back to top</a><h3 id="-a-id-a-02-a-file-templates-and-snippets"><a id="A-02"></a>File Templates and Snippets</h3><span>
</span><h4 id="-a-href-a-02-style-a-02-a-"><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#A-02">Style A-02</a></h4><span>
</span><div class="s-rule do"><p><strong>Do</strong> use file templates or snippets to help follow consistent styles and patterns. Here are templates and/or snippets for some of the web development editors and IDEs.</p><span>
</span></div><a href="https://angular.io/docs/ts/latest/guide/style-guide.html#toc">Back to top</a><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--></div></div>
        </article>
      
        <article>
          <h3>Glossary - ts</h3>
          <div><div class="showcase-content"><span>
</span><p>Angular 2 has a vocabulary of its own.
Most Angular 2 terms are everyday English words
with a specific meaning within the Angular system.</p><span>
</span><p>We have gathered here the most prominent terms
and a few less familiar ones that have unusual or
unexpected definitions.</p><span>
</span><p><a href="https://angular.io/docs/ts/latest/guide/glossary.html#A">A</a> <a href="https://angular.io/docs/ts/latest/guide/glossary.html#B">B</a> <a href="https://angular.io/docs/ts/latest/guide/glossary.html#C">C</a> <a href="https://angular.io/docs/ts/latest/guide/glossary.html#D">D</a> <a href="https://angular.io/docs/ts/latest/guide/glossary.html#E">E</a> <a href="https://angular.io/docs/ts/latest/guide/glossary.html#F">F</a> <a href="https://angular.io/docs/ts/latest/guide/glossary.html#G">G</a> <a href="https://angular.io/docs/ts/latest/guide/glossary.html#H">H</a> <a href="https://angular.io/docs/ts/latest/guide/glossary.html#I">I</a>
<a href="https://angular.io/docs/ts/latest/guide/glossary.html#J">J</a> <a href="https://angular.io/docs/ts/latest/guide/glossary.html#K">K</a> <a href="https://angular.io/docs/ts/latest/guide/glossary.html#L">L</a> <a href="https://angular.io/docs/ts/latest/guide/glossary.html#M">M</a> <a href="https://angular.io/docs/ts/latest/guide/glossary.html#N">N</a> <a href="https://angular.io/docs/ts/latest/guide/glossary.html#O">O</a> <a href="https://angular.io/docs/ts/latest/guide/glossary.html#P">P</a> <a href="https://angular.io/docs/ts/latest/guide/glossary.html#Q">Q</a> <a href="https://angular.io/docs/ts/latest/guide/glossary.html#R">R</a>
<a href="https://angular.io/docs/ts/latest/guide/glossary.html#S">S</a> <a href="https://angular.io/docs/ts/latest/guide/glossary.html#T">T</a> <a href="https://angular.io/docs/ts/latest/guide/glossary.html#U">U</a> <a href="https://angular.io/docs/ts/latest/guide/glossary.html#V">V</a> <a href="https://angular.io/docs/ts/latest/guide/glossary.html#W">W</a> <a href="https://angular.io/docs/ts/latest/guide/glossary.html#X">X</a> <a href="https://angular.io/docs/ts/latest/guide/glossary.html#Y">Y</a> <a href="https://angular.io/docs/ts/latest/guide/glossary.html#Z">Z</a></p><span>
</span><a id="aot"></a><span>
</span><div class="l-sub-section"><p>Angular applications can be compiled by developers at build-time.
By compiling your application using the compiler-cli, <code>ngc</code>, you can bootstrap directly
to a Module Factory, meaning you don&apos;t need to include the Angular compiler in your javascript bundle.
Ahead of Time compiled applications also benefit from decreased load time and increased performance.</p><span>
</span></div><h2 id="angular-module">Angular Module</h2><span>
</span><div class="l-sub-section"><p>Helps us organize an application into cohesive blocks of functionality.
An Angular module identifies the components, directives, and pipes that are used by the application
along with the list of external Angular modules that the application needs, such as <code>FormsModule</code>.</p><span>
</span><p>Every Angular application has an application root module class. By convention the class is
called <code>AppModule</code> and resides in a file named <code>app.component.ts</code>.</p><span>
</span><p>See the <a href="https://angular.io/docs/ts/latest/guide/ngmodule.html">Angular Module</a> chapter for details and examples.</p><span>
</span></div><h2 id="annotation">Annotation</h2><span>
</span><div class="l-sub-section"><p>In practice, a synonym for <a href="https://angular.io/docs/ts/latest/guide/glossary.html#decorator">Decoration</a>.</p><span>
</span></div><h2 id="attribute-directive">Attribute Directive</h2><span>
</span><div class="l-sub-section"><p>A category of <a href="https://angular.io/docs/ts/latest/guide/glossary.html#directive">Directive</a> that can listen to and modify the behavior of
other HTML elements, attributes, properties, and components. They are usually represented
as HTML attributes, hence the name.</p><span>
</span><p>The <code>ngClass</code> directive for adding and removing CSS class names is a good example of
an Attribute Directive.</p><span>
</span></div><h2 id="barrel">Barrel</h2><span>
</span><div class="l-sub-section"><p>A barrel is a way to <em>rollup exports</em> from several ES2015 modules into a single convenience ES2015 module.
The barrel itself is an ES2015 module file that re-exports <em>selected</em> exports of other ES2015 modules.</p><span>
</span><p>Imagine three ES2015 modules in a <code>heroes</code> folder:</p><span>
</span><code>// heroes/hero.component.ts
export class HeroComponent {}

// heroes/hero.model.ts
export class Hero {}

// heroes/hero.service.ts
export class HeroService {}</code><p>Without a barrel, a consumer would need three import statements:</p><span>
</span><code>import { HeroComponent } from &apos;../heroes/hero.component.ts&apos;;
import { Hero }          from &apos;../heroes/hero.model.ts&apos;;
import { HeroService }   from &apos;../heroes/hero.service.ts&apos;;</code><p>We can add a barrel to the <code>heroes</code> folder (called <code>index</code> by convention) that exports all of these items:</p><span>
</span><code>export * from &apos;./hero.model.ts&apos;;   // re-export all of its exports
export * from &apos;./hero.service.ts&apos;; // re-export all of its exports
export { HeroComponent } from &apos;./hero.component.ts&apos;; // re-export the named thing</code><p>Now a consumer can import what it needs from the barrel.</p><span>
</span><code>import { Hero, HeroService } from &apos;../heroes&apos;; // index is implied</code><p>The Angular <a href="https://angular.io/docs/ts/latest/guide/glossary.html#scoped-package">scoped packages</a> each have a barrel named <code>index</code>.</p><span>
</span><p>That&apos;s why we can write this:</p><span>
</span><code language="ts" format="">import { Component } from &apos;@angular/core&apos;;
</code><div class="alert is-important"><p>Note that you can often achieve this same goal using <a href="https://angular.io/docs/ts/latest/guide/glossary.html#angular-module">Angular modules</a> instead.</p><span>
</span></div></div><h2 id="binding">Binding</h2><span>
</span><div class="l-sub-section"><p>Almost always refers to <a href="https://angular.io/docs/ts/latest/guide/glossary.html#data-binding">Data Binding</a> and the act of
binding an HTML object property to a data object property.</p><span>
</span><p>May refer to a <a href="https://angular.io/docs/ts/latest/guide/glossary.html#dependency-injection">Dependency Injection</a> binding
between a &quot;token&quot; or &quot;key&quot; and a dependency <a href="https://angular.io/docs/ts/latest/guide/glossary.html#provider">provider</a>.
This more rare usage should be clear in context.</p><span>
</span></div><h2 id="bootstrap">Bootstrap</h2><span>
</span><div class="l-sub-section"><p>We launch an Angular application by &quot;bootstrapping&quot; it using the application root Angular module (<code>AppModule</code>).
The bootstraping identifies an application&apos;s top level &quot;root&quot; <a href="https://angular.io/docs/ts/latest/guide/glossary.html#component">Component</a>, which is the first
component that is loaded for the application. For more information see the <a href="https://angular.io/docs/ts/latest/quickstart.html">QuickStart</a>.</p><span>
</span><p>One can bootstrap multiple apps in the same <code>index.html</code>, each with its own top level root.</p><span>
</span></div><h2 id="camelcase">camelCase</h2><span>
</span><div class="l-sub-section"><p>The practice of writing compound words or phrases such that each word or abbreviation begins with a capital letter
<em>except the first letter which is a lowercase letter</em>.</p><span>
</span><p>Function, property, and method names are typically spelled in camelCase. Examples include: <code>square</code>, <code>firstName</code> and <code>getHeroes</code>.</p><span>
</span><p>This form is also known as <strong>lower camel case</strong>, to distinguish it from <strong>upper camel case</strong> which we call <a href="https://angular.io/docs/ts/latest/guide/glossary.html#pascalcase">PascalCase</a>.
When we write &quot;camelCase&quot; in this documentation we always mean <em>lower camel case</em>.</p><span>
</span></div><h2 id="component">Component</h2><span>
</span><div class="l-sub-section"><p>An Angular class responsible for exposing data
to a <a href="https://angular.io/docs/ts/latest/guide/glossary.html#view">View</a> and handling most of the view&#x2019;s display
and user-interaction logic.</p><span>
</span><p>The Component is one of the most important building blocks in the Angular system.
It is, in fact, an Angular <a href="https://angular.io/docs/ts/latest/guide/glossary.html#directive">Directive</a> with a companion <a href="https://angular.io/docs/ts/latest/guide/glossary.html#template">Template</a>.</p><span>
</span><p>The  developer applies the <code>@Component</code> <a href="https://angular.io/docs/ts/latest/guide/glossary.html#decorator">decorator</a> to
the component class, thereby attaching to the class the essential component metadata
that Angular needs to create a component instance and render it with its template
as a view.</p><span>
</span><p>Those familiar with &quot;MVC&quot; and &quot;MVVM&quot; patterns will recognize
the Component in the role of &quot;Controller&quot; or &quot;View Model&quot;.</p><span>
</span></div><h2 id="dash-case">dash-case</h2><span>
</span><div class="l-sub-section"><p>The practice of writing compound words or phrases such that each word is separated by a dash or hyphen (<code>-</code>).
This form is also known as <a href="https://angular.io/docs/ts/latest/guide/glossary.html#kebab-case">kebab-case</a>.</p><span>
</span><p><a href="https://angular.io/docs/ts/latest/guide/glossary.html#directive">Directive</a> selectors (like <code>my-app</code>) <span if-docs="ts">and
the root of filenames (such as <code>hero-list.component.ts</code>)</span> are often
spelled in dash-case.</p><span>
</span></div><h2 id="data-binding">Data Binding</h2><span>
</span><div class="l-sub-section"><p>Applications display data values to a user and respond to user
actions (clicks, touches, keystrokes).</p><span>
</span><p>We could push application data values into HTML, attach
event listeners, pull changed values from the screen, and
update application data values ... all by hand.</p><span>
</span><p>Or we could declare the relationship between an HTML widget
and an application data source ... and let a data binding
framework handle the details.</p><span>
</span><p>Data Binding is that second approach. Angular has a rich
data binding framework with a variety of data binding
operations and supporting declaration syntax.</p><span>
</span><p> The many forms of binding include:</p><span>
</span><span>
</span><p>Learn more about data binding in the
<a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#data-binding">Template Syntax</a> chapter.</p><span>
</span></div><a id="decorator"></a><a id="decoration"></a><h2 id="decorator-decoration">Decorator | Decoration</h2><span>
</span><div class="l-sub-section"><p>A Decorator is a <strong>function</strong> that adds metadata to a class, its members (properties, methods) and function arguments.</p><span>
</span><p>Decorators are a JavaScript language <a href="https://github.com/wycats/javascript-decorators">feature</a>, implemented in TypeScript and proposed for ES2016 (AKA ES7).</p><span>
</span><p>We apply a decorator by positioning it
immediately above or to the left of the thing it decorates.</p><span>
</span><p>Angular has its own set of decorators to help it interoperate with our application parts.
Here is an example of a <code>@Component</code> decorator that identifies a
class as an Angular <a href="https://angular.io/docs/ts/latest/guide/glossary.html#component">Component</a> and an <code>@Input</code> decorator applied to a property
of that component.
The elided object argument to the <code>@Component</code> decorator would contain the pertinent component metadata.</p><span>
</span><pre><code>@Component({...})
export class AppComponent {
  constructor(@Inject(&apos;SpecialFoo&apos;) public foo:Foo) {}
  @Input() name:string;
}
</code></pre><p>The scope of a decorator is limited to the language feature
that it decorates. None of the decorations shown here will &quot;leak&quot; to other
classes appearing below it in the file.</p><span>
</span><div class="alert is-important"><p>Always include the parentheses <code>()</code> when applying a decorator.
A decorator is a <strong>function</strong> that must be called when applied.</p><span>
</span></div></div><h2 id="dependency-injection">Dependency Injection</h2><span>
</span><div class="l-sub-section"><p>Dependency Injection is both a design pattern and a mechanism
for creating and delivering parts of an application to other
parts of an application that request them.</p><span>
</span><p>Angular developers prefer to build applications by defining many simple parts
that each do one thing well and then wire them together at runtime.</p><span>
</span><p>These parts often rely on other parts. An Angular <a href="https://angular.io/docs/ts/latest/guide/glossary.html#component">Component</a>
part might rely on a service part to get data or perform a calculation. When a
part &quot;A&quot; relies on another part &quot;B&quot;, we say that &quot;A&quot; depends on &quot;B&quot; and
that &quot;B&quot; is a dependency of &quot;A&quot;.</p><span>
</span><p>We can ask a &quot;Dependency Injection System&quot; to create &quot;A&quot;
for us and handle all the dependencies.
If &quot;A&quot; needs &quot;B&quot; and &quot;B&quot; needs &quot;C&quot;, the system resolves that chain of dependencies
and returns a fully prepared instance of &quot;A&quot;.</p><span>
</span><p>Angular provides and relies upon its own sophisticated
<a href="https://angular.io/docs/ts/latest/guide/dependency-injection.html">Dependency Injection</a> system
to assemble and run applications by &quot;injecting&quot; application parts
into other application parts where and when needed.</p><span>
</span><p>At the core there is an <a href="https://angular.io/docs/ts/latest/guide/glossary.html#injector"><code>Injector</code></a> that returns dependency values on request.
The expression <code>injector.get(token)</code> returns the value associated with the given token.</p><span>
</span><p>A token is an Angular type (<code>OpaqueToken</code>). We rarely deal with tokens directly; most
methods accept a class name (<code>Foo</code>) or a string (&quot;foo&quot;) and Angular converts it
to a token. When we write <code>injector.get(Foo)</code>, the injector returns
the value associated with the token for the <code>Foo</code> class, typically an instance of <code>Foo</code> itself.</p><span>
</span><p>Angular makes similar requests internally during many of its operations
as when it creates a <a href="https://angular.io/docs/ts/latest/guide/glossary.html#component"><code>Component</code></a> for display.</p><span>
</span><p>The <code>Injector</code> maintains an internal map of tokens to dependency values.
If the <code>Injector</code> can&apos;t find a value for a given token, it creates
a new value using a <code>Provider</code> for that token.</p><span>
</span><p>A <a href="https://angular.io/docs/ts/latest/guide/glossary.html#provider">Provider</a> is a recipe for
creating new instances of a dependency value associated with a particular token.</p><span>
</span><p>An injector can only create a value for a given token if it has
a <code>Provider</code> for that token in its internal provider registry.
Registering providers is a critical preparatory step.</p><span>
</span><p>Angular registers some of its own providers with every injector.
We can register our own providers.</p><span>
</span><p>Learn more in the <a href="https://angular.io/docs/ts/latest/guide/dependency-injection.html">Dependency Injection</a> chapter.</p><span>
</span></div><h2 id="directive">Directive</h2><span>
</span><div class="l-sub-section"><p>An Angular class responsible for creating, re-shaping, and interacting with HTML elements
in the browser DOM. Directives are Angular&apos;s most fundamental feature.</p><span>
</span><p>A Directive is almost always associated with an HTML element or attribute.
We often refer to such an element or attribute as the directive itself.
When Angular finds a directive in an HTML template,
it creates the matching directive class instance
and gives that instance control over that portion of the browser DOM.</p><span>
</span><p>Developers can invent custom HTML markup (e.g., <code>&lt;my-directive&gt;</code>) to
associate with their custom directives. They add this custom markup to HTML templates
as if they were writing native HTML. In this way, directives become extensions of
HTML itself.</p><span>
</span><p>Directives fall into one of three categories:</p><span>
</span><ol>
<li><p><a href="https://angular.io/docs/ts/latest/guide/glossary.html#component">Components</a> that combine application logic with an HTML template to
render application [views]. Components are usually represented as HTML elements.
They are the building blocks of an Angular application and the
developer can expect to write a lot of them.</p>
</li>
<li><p><a href="https://angular.io/docs/ts/latest/guide/glossary.html#attribute-directive">Attribute Directives</a> that can listen to and modify the behavior of
other HTML elements, attributes, properties, and components. They are usually represented
as HTML attributes, hence the name.</p>
</li>
<li><p><a href="https://angular.io/docs/ts/latest/guide/glossary.html#structural-directive">Structural Directives</a>, a directive responsible for
shaping or re-shaping HTML layout, typically by adding, removing, or manipulating
elements and their children.</p>
</li>
</ol><span>
</span></div><h2 id="ecmascript">ECMAScript</h2><span>
</span><div class="l-sub-section"><p>The <a href="https://en.wikipedia.org/wiki/ECMAScript">official JavaScript language specification</a>.</p><span>
</span><p>The latest approved version of JavaScript is
<a href="http://www.ecma-international.org/ecma-262/7.0/">ECMAScript 2016</a>
(AKA &quot;ES2016&quot; or &quot;ES7&quot;) and many Angular 2 developers will write their applications
either in this version of the language or a dialect that strives to be
compatible with it such as <a href="https://angular.io/docs/ts/latest/guide/glossary.html#typesScript">TypeScript</a>.</p><span>
</span><p>Most modern browsers today only support the much older &quot;ECMAScript 5&quot; (AKA ES5) standard.
Applications written in ES2016, ES2015 or one of their dialects must be &quot;<a href="https://angular.io/docs/ts/latest/guide/glossary.html#transpile">transpiled</a>&quot;
to ES5 JavaScript.</p><span>
</span><p>Angular 2 developers may choose to write in ES5 directly.</p><span>
</span></div><h2 id="es2015">ES2015</h2><span>
</span><div class="l-sub-section"><p>Short hand for &quot;<a href="https://angular.io/docs/ts/latest/guide/glossary.html#ecmascript=2015">ECMAScript 2015</a>&quot;.</p><span>
</span></div><h2 id="es6">ES6</h2><span>
</span><div class="l-sub-section"><p>Short hand for &quot;<a href="https://angular.io/docs/ts/latest/guide/glossary.html#ecmascript=2015">ECMAScript 2015</a>&quot;.</p><span>
</span></div><h2 id="es5">ES5</h2><span>
</span><div class="l-sub-section"><p>Short hand for &quot;ECMAScript 5&quot;, the version of JavaScript run by most modern browsers.
See <a href="https://angular.io/docs/ts/latest/guide/glossary.html#ecmascript">ECMAScript</a>.</p><span>
</span></div><a id="F"></a><a id="G"></a><a id="H"></a><h2 id="injector">Injector</h2><span>
</span><div class="l-sub-section"><p>An object in the Angular <a href="https://angular.io/docs/ts/latest/guide/glossary.html#dependency-injection">dependency injection system</a>
that can find a named &quot;dependency&quot; in its cache or create such a thing
with a registered <a href="https://angular.io/docs/ts/latest/guide/glossary.html#provider">provider</a>.</p><span>
</span></div><h2 id="input">Input</h2><span>
</span><div class="l-sub-section"><p>A directive property that can be the <strong><em>target</em></strong> of a
<a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#property-binding">Property Binding</a>.
Data values flow <em>into</em> this property from the data source identified
in the template expression to the right of the equal sign.</p><span>
</span><p>See the <a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#inputs-outputs">Template Syntax</a> chapter.</p><span>
</span></div><h2 id="interpolation">Interpolation</h2><span>
</span><div class="l-sub-section"><p>A form of <a href="https://angular.io/docs/ts/latest/guide/glossary.html#data-binding">Property Data Binding</a> in which a
<a href="https://angular.io/docs/ts/latest/guide/glossary.html#template-expression">template expression</a> between double-curly braces
renders as text.  That text may be concatenated with neighboring text
before it is assigned to an element property
or displayed between element tags as in this example.</p><span>
</span><code language="html" escape="html"><label>My current hero is {{hero.name}}</label>
</code><p>Learn more about interpolation in the
<a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#interpolation">Template Syntax</a> chapter.</p><span>
</span></div><a id="jit"></a><span>
</span><div class="l-sub-section"><p>With Angular <em>Just in Time</em>  bootstrapping you compile your components and modules in the browser
and launch the application dynamically. This is a good choice during development.
Consider the <a href="https://angular.io/docs/ts/latest/guide/glossary.html#aot">Ahead of Time</a> mode for production apps.</p><span>
</span></div><h2 id="kebab-case">kebab-case</h2><span>
</span><h2 id="lifecycle-hooks">Lifecycle Hooks</h2><span>
</span><div class="l-sub-section"><p><a href="https://angular.io/docs/ts/latest/guide/glossary.html#directive">Directives</a> and <a href="https://angular.io/docs/ts/latest/guide/glossary.html#component">Components</a> have a lifecycle
managed by Angular as it creates, updates and destroys them.</p><span>
</span><p>Developers can tap into key moments in that lifecycle by implementing
one or more of the &quot;Lifecycle Hook&quot; interfaces.</p><span>
</span><p>Each interface has a single hook method whose name is the interface name prefixed with <code>ng</code>.
For example, the <code>OnInit</code> interface has a hook method names <code>ngOnInit</code>.</p><span>
</span><p>Angular calls these hook methods in the following order:</p><span>
</span><ul>
<li><code>ngOnChanges</code> - called when an <a href="https://angular.io/docs/ts/latest/guide/glossary.html#input">input</a>/<a href="https://angular.io/docs/ts/latest/guide/glossary.html#output">output</a> binding values change</li>
<li><code>ngOnInit</code> - after the first <code>ngOnChanges</code></li>
<li><code>ngDoCheck</code> - developer&apos;s custom change detection</li>
<li><code>ngAfterContentInit</code> - after component content initialized</li>
<li><code>ngAfterContentChecked</code> - after every check of component content</li>
<li><code>ngAfterViewInit</code> - after component&apos;s view(s) are initialized</li>
<li><code>ngAfterViewChecked</code> - after every check of a component&apos;s view(s)</li>
<li><code>ngOnDestroy</code> - just before the directive is destroyed.</li>
</ul><span>
</span><p>Learn more in the <a href="https://angular.io/docs/ts/latest/guide/lifecycle-hooks.html">Lifecycle Hooks</a> chapter.</p><span>
</span></div><h2 id="module">Module</h2><span>
</span><div class="l-sub-section"><div class="alert is-important"><p>In Angular, there are two types of modules:</p><span>
</span><ul>
<li><a href="https://angular.io/docs/ts/latest/guide/glossary.html#angular-module">Angular modules</a>.
See the <a href="https://angular.io/docs/ts/latest/guide/ngmodule.html">Angular Module</a> chapter for details and examples.</li>
<li>ES2015 modules as described in this section.</li>
</ul><span>
</span></div><p>Angular apps are modular.</p><span>
</span><p>In general, we assemble our application from many modules, both the ones we write ourselves
and the ones we acquire from others.</p><span>
</span><p>A typical module is a cohesive block of code dedicated to a single purpose.</p><span>
</span><p>A module <strong>exports</strong> something of value in that code, typically one thing such as a class.
A module that needs that thing, <strong>imports</strong> it.</p><span>
</span><p>The structure of Angular modules and the import/export syntax
is based on the <a href="https://angular.io/docs/ts/latest/guide/glossary.html#es2015">ES2015</a> module standard
described <a href="http://www.2ality.com/2014/09/es6-modules-final.html">here</a>.</p><span>
</span><p>An application that adheres to this standard requires a module loader to
load modules on request and resolve inter-module dependencies.
Angular does not ship with a module loader and does not have a preference
for any particular 3rd party library (although most samples use SystemJS).
Application developers may pick any module library that conforms to the standard</p><span>
</span><p>Modules are typically named after the file in which the exported thing is defined.
The Angular <a href="https://github.com/angular/angular/blob/master/modules/@angular/common/src/pipes/date_pipe.ts">DatePipe</a>
class belongs to a feature module named <code>date_pipe</code> in the file <code>date_pipe.ts</code>.</p><span>
</span><p>Developers rarely access Angular feature modules directly.
We usually import them from one of the Angular <a href="https://angular.io/docs/ts/latest/guide/glossary.html#scoped-package">scoped packages</a> such as <code>@angular/core</code>.</p><span>
</span></div><a id="N"></a><h2 id="observable">Observable</h2><span>
</span><div class="l-sub-section"><p>We can think of an observable as an array whose items arrive asynchronously over time.
Observables help us manage asynchronous data, such as data coming from a backend service.
Observables are used within Angular itself, including Angular&apos;s event system and its http client service.</p><span>
</span><p>To use observables, Angular uses a third-party library called Reactive Extensions (RxJS).
Observables are a proposed feature for ES 2016, the next version of JavaScript.</p><span>
</span></div><h2 id="output">Output</h2><span>
</span><div class="l-sub-section"><p>A directive property that can be the <strong><em>target</em></strong> of an
<a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#property-binding">Event Binding</a>.
Events stream <em>out</em> of this property to the receiver identified
in the template expression to the right of the equal sign.</p><span>
</span><p>See the <a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#inputs-outputs">Template Syntax</a> chapter.</p><span>
</span></div><h2 id="pascalcase">PascalCase</h2><span>
</span><div class="l-sub-section"><p>The practice of writing compound words or phrases such that each word or abbreviation begins with a capital letter.
Class names are typically spelled in PascalCase. Examples include: <code>Person</code> and <code>HeroDetailComponent</code>.</p><span>
</span><p>This form is also known as <strong>upper camel case</strong>, to distinguish it from <strong>lower camel case</strong> which we simply call <a href="https://angular.io/docs/ts/latest/guide/glossary.html#camelcase">camelCase</a>.
In this documentation, &quot;PascalCase&quot; means <em>upper camel case</em> and  &quot;camelCase&quot; means <em>lower camel case</em>.</p><span>
</span></div><h2 id="pipe">Pipe</h2><span>
</span><div class="l-sub-section"><p>An Angular pipe is a function that transforms input values to output values for
display in a <a href="https://angular.io/docs/ts/latest/guide/glossary.html#view">view</a>. We use the <code>@Pipe</code> <a href="https://angular.io/docs/ts/latest/guide/glossary.html#decorator">decorator</a>
to associate the pipe function with a name. We can then use that
name in our HTML to declaratively transform values on screen.</p><span>
</span><p>Here&apos;s an example that uses the built-in <code>currency</code> pipe to display
a numeric value in the local currency.</p><span>
</span><code language="html" escape="html"><label>Price: </label>{{product.price | currency}}</code><p>Learn more in the chapter on <a href="https://angular.io/docs/ts/latest/guide/pipes.html">pipes</a> .</p><span>
</span></div><h2 id="provider">Provider</h2><span>
</span><div class="l-sub-section"><p>A <a href="https://angular.io/docs/ts/latest/api/core/index/Provider-class.html">Provider</a> creates a new instance of a dependency for the
<a href="https://angular.io/docs/ts/latest/guide/glossary.html#dependency-injection">Dependency Injection</a> system.
It relates a lookup token to code &#x2014; sometimes called a &quot;recipe&quot; &#x2014;
that can create a dependency value.</p><span>
</span></div><a id="Q"></a><h2 id="reactive-forms">Reactive Forms</h2><span>
</span><div class="l-sub-section"><p>A technique for building Angular forms through code in a component.
The alternate technique is <a href="https://angular.io/docs/ts/latest/guide/glossary.html#template-driven-forms">Template-Driven Forms</a>.</p><span>
</span><p>When building reactive forms:</p><span>
</span><ul>
<li>The &quot;source of truth&quot; is the component. The validation is defined using code in the component.</li>
<li>Each control is explicitly created in the component class with <code>new FormControl()</code> or with <code>FormBuilder</code>.</li>
<li>The template input elements do <em>not</em> use <code>ngModel</code>.</li>
<li>The associated Angular directives are all prefixed with <code>Form</code> such as <code>FormGroup</code>, <code>FormControl</code>, and <code>FormControlName</code>.</li>
</ul><span>
</span><p>Reactive forms are powerful, flexible, and great for more complex data entry form scenarios, such as dynamic generation
of form controls.</p><span>
</span></div><h2 id="router">Router</h2><span>
</span><div class="l-sub-section"><p>Most applications consist of many screens or <a href="https://angular.io/docs/ts/latest/guide/glossary.html#view">views</a>.
The user navigates among them by clicking links and buttons
and taking other similar actions that cause the application to
replace one view with another.</p><span>
</span><p>The Angular <a href="https://angular.io/docs/ts/latest/guide/router.html">Component Router</a> is a richly featured mechanism for configuring
and managing the entire view navigation process including the creation and destruction
of views.</p><span>
</span><p>In most cases, components becomes attached to a <a href="https://angular.io/docs/ts/latest/guide/glossary.html#router">router</a> by means
of a <code>RouterConfig</code> that defines routes to views.</p><span>
</span><p>A <a href="https://angular.io/docs/ts/latest/guide/glossary.html#routing-component">routing component&apos;s</a> template has a <code>RouterOutlet</code> element
where it can display views produced by the router.</p><span>
</span><p>Other views in the application likely have anchor tags or buttons with <code>RouterLink</code>
directives that users can click to navigate.</p><span>
</span><p>See the <a href="https://angular.io/docs/ts/latest/guide/router.html">Component Router</a> chapter to learn more.</p><span>
</span></div><h2 id="routermodule">RouterModule</h2><span>
</span><div class="l-sub-section"><p>A separate <a href="https://angular.io/docs/ts/latest/guide/glossary.html#angular-module">Angular module</a> that provides the necessary service providers and directives for navigating through application views.</p><span>
</span><p>See the <a href="https://angular.io/docs/ts/latest/guide/router.html">Component Router</a> chapter to learn more.</p><span>
</span></div><h2 id="routing-component">Routing Component</h2><span>
</span><div class="l-sub-section"><p>An Angular <a href="https://angular.io/docs/ts/latest/guide/glossary.html#component">Component</a> with a RouterOutlet that displays views based on router navigations.</p><span>
</span><p>See the <a href="https://angular.io/docs/ts/latest/guide/router.html">Component Router</a> chapter to learn more.</p><span>
</span></div><h2 id="scoped-package">Scoped Package</h2><span>
</span><div class="l-sub-section"><p>Angular modules are delivered within <em>scoped packages</em> such as <code>@angular/core</code>, <code>@angular/common</code>, <code>@angular/platform-browser-dynamic</code>,
<code>@angular/http</code>, and <code>@angular/router</code>.</p><span>
</span><p>A <a href="https://docs.npmjs.com/misc/scope"><em>scoped package</em></a> is a way to group related <em>npm</em> packages.</p><span>
</span><p>We import a scoped package the same way we&apos;d import a <em>normal</em> package.
The only difference, from a consumer perspective,
is that the package name begins with the Angular <em>scope name</em>, <code>@angular</code>.</p><span>
</span><code language="ts" format="">import { Component } from &apos;@angular/core&apos;;
</code></div><a id="snake-case"></a><h2 id="snake_case">snake_case</h2><span>
</span><div class="l-sub-section"><p>The practice of writing compound words or phrases such that each word is separated by an
underscore (<code>_</code>). This form is also known as <strong>underscore case</strong>.</p><span>
</span></div><h2 id="service">Service</h2><span>
</span><div class="l-sub-section"><p>Components are great and all, but what do we do with data or logic that are not associated
with a specific view or that we want to share across components? We build services!</p><span>
</span><p>Applications often require services such as a hero data service or a logging service.
Our components depend on these services to do the heavy lifting.</p><span>
</span><p>A service is a class with a focused purpose.
We often create a service to implement features that are
independent from any specific view,
provide share data or logic across components, or encapsulate external interactions.</p><span>
</span><p>See the <a href="https://angular.io/docs/ts/latest/tutorial/toh-pt4.html">Services</a> chapter of the tutorial to learn more.</p><span>
</span></div><h2 id="structural-directive">Structural Directive</h2><span>
</span><div class="l-sub-section"><p>A category of <a href="https://angular.io/docs/ts/latest/guide/glossary.html#directive">Directive</a> that can
shape or re-shape HTML layout, typically by adding, removing, or manipulating
elements and their children.</p><span>
</span><p>The <code>ngIf</code> &quot;conditional element&quot; directive and the <code>ngFor</code> &quot;repeater&quot; directive are
good examples in this category.</p><span>
</span><p>See the <a href="https://angular.io/docs/ts/latest/guide/structural-directives.html">Structural Directives</a> chapter to learn more.</p><span>
</span></div><h2 id="template">Template</h2><span>
</span><div class="l-sub-section"><p>A template is a chunk of HTML that Angular uses to render a <a href="https://angular.io/docs/ts/latest/guide/glossary.html#view">view</a> with
the support and continuing guidance of an Angular <a href="https://angular.io/docs/ts/latest/guide/glossary.html#directive">Directive</a>,
most notably a <a href="https://angular.io/docs/ts/latest/guide/glossary.html#component">Component</a>.</p><span>
</span><p>We write templates in a special <a href="https://angular.io/docs/ts/latest/guide/template-syntax.html">Template Syntax</a>.</p><span>
</span></div><h2 id="template-driven-forms">Template-Driven Forms</h2><span>
</span><div class="l-sub-section"><p>A technique for building Angular forms using HTML forms and input elements in the view.
The alternate technique is <a href="https://angular.io/docs/ts/latest/guide/glossary.html#reactive-forms">Reactive Forms</a>.</p><span>
</span><p>When building template-driven forms:</p><span>
</span><ul>
<li>The &quot;source of truth&quot; is the template. The validation is defined using attributes on the individual input elements.</li>
<li><a href="https://angular.io/docs/ts/latest/guide/glossary.html#data-binding">Two-way binding</a> with <code>ngModel</code> keeps the component model in synchronization with the user&apos;s entry into the input elements.</li>
<li>Behind the scenes, Angular creates a new control for each input element that has a <code>name</code> attribute and
two-way binding set up.</li>
<li>The associated Angular directives are all prefixed with <code>ng</code> such as <code>ngForm</code>, <code>ngModel</code>, and <code>ngModelGroup</code>.</li>
</ul><span>
</span><p>Template-driven forms are convenient, quick, and simple and are a good choice for many basic data entry form scenarios.</p><span>
</span><p>Learn how to build template-driven forms
in the <a href="https://angular.io/docs/ts/latest/guide/forms.html">Forms</a> chapter.</p><span>
</span></div><h2 id="template-expression">Template Expression</h2><span>
</span><div class="l-sub-section"><p>An expression is a TypeScript-like syntax that Angular evaluates within
a <a href="https://angular.io/docs/ts/latest/guide/glossary.html#data-binding">data binding</a>.  Learn how to write template expressions
in the <a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#template-expressions">Template Syntax</a> chapter.</p><span>
</span></div><h2 id="transpile">Transpile</h2><span>
</span><div class="l-sub-section"><p>The process of transforming code written in one form of JavaScript
(e.g., TypeScript) into another form of JavaScript  (e.g., <a href="https://angular.io/docs/ts/latest/guide/glossary.html#es5">ES5</a>).</p><span>
</span></div><h2 id="typescript">TypeScript</h2><span>
</span><div class="l-sub-section"><p>A version of JavaScript that supports most <a href="https://angular.io/docs/ts/latest/guide/glossary.html#ecmascript=2015">ECMAScript 2015</a>
language features and many features that may arrive in future versions
of JavaScript such as <a href="https://angular.io/docs/ts/latest/guide/glossary.html#decorator">Decorators</a>.</p><span>
</span><p>TypeScript is also noteable for its optional typing system which gives
us compile-time type-checking and strong tooling support (e.g. &quot;intellisense&quot;,
code completion, refactoring, and intelligent search). Many code editors
and IDEs support TypeScript either natively or with plugins.</p><span>
</span><p>TypeScript is the preferred language for Angular 2 development although
we are welcome to write in other JavaScript dialects such as <a href="https://angular.io/docs/ts/latest/guide/glossary.html#es5">ES5</a>.</p><span>
</span><p>Learn more about TypeScript on its <a href="http://www.typescriptlang.org/">website</a>.</p><span>
</span></div><a id="U"></a><h2 id="view">View</h2><span>
</span><div class="l-sub-section"><p>A view is a portion of the screen that displays information and responds
to user actions such as clicks, mouse moves, and keystrokes.</p><span>
</span><p>Angular renders a view under the control of one or more <a href="https://angular.io/docs/ts/latest/guide/glossary.html#directive">Directives</a>,
especially  <a href="https://angular.io/docs/ts/latest/guide/glossary.html#component">Component</a> directives and their companion <a href="https://angular.io/docs/ts/latest/guide/glossary.html#template">Templates</a>.
The Component plays such a prominent role that we often
find it convenient to refer to a component as a view.</p><span>
</span><p>Views often contain other views and any view might be loaded and unloaded
dynamically as the user navigates through the application, typically
under the control of a <a href="https://angular.io/docs/ts/latest/guide/glossary.html#router">router</a>.</p><span>
</span></div><a id="W"></a><a id="X"></a><a id="Y"></a><h2 id="zone">Zone</h2><span>
</span><div class="l-sub-section"><p>Zones are a mechanism for encapsulating and intercepting
a JavaScript application&apos;s asynchronous activity.</p><span>
</span><p>The browser DOM and JavaScript have a limited number
of asynchronous activities, activities such as DOM events (e.g., clicks),
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">promises</a>, and
<a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest">XHR</a>
calls to remote servers.</p><span>
</span><p>Zones intercept all of these activities and give a &quot;zone client&quot; the opportunity
to take action before and after the async activity completes.</p><span>
</span><p>Angular runs our application in a zone where it can respond to
asynchronous events by checking for data changes and updating
the information it displays via <a href="https://angular.io/docs/ts/latest/guide/glossary.html#data-binding">data bindings</a>.</p><span>
</span><p>Learn more about zones in this
<a href="https://www.youtube.com/watch?v=3IqtmUscE_U">Brian Ford video</a>.</p><span>
</span></div><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--></div></div>
        </article>
      <h2></h2>
        <article>
          <h3>Angular Modules (NgModule)</h3>
          <div><div class="showcase-content"><!-- TODOImages
--><p><strong>Angular Modules</strong> help organize an application into cohesive blocks of functionality.</p><span>
</span><p>An Angular Module is a <em>class</em> adorned with the <strong>@NgModule</strong> decorator function.
<code>@NgModule</code> takes a metadata object that tells Angular how to compile and run module code. 
It identifies the module&apos;s <em>own</em> components, directives and pipes, 
making some of them public so external components can use them. 
It may add service providers to the application dependency injectors. 
And there are more options covered here. </p><span>
</span><p>This page explains how to <strong>create</strong> <code>NgModule</code> classes and how to load them, 
either immediately when the application launches or later, as needed, via the <a href="https://angular.io/docs/ts/latest/guide/router.html">Router</a>.  </p><span>
</span><h2 id="contents">Contents</h2><span>
</span><ul>
<li><a href="https://angular.io/docs/ts/latest/guide/ngmodule.html#angular-modularity" title="Add structure to the app with NgModule">Angular modularity</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/ngmodule.html#root-module" title="The startup module that every app requires">The application root module</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/ngmodule.html#bootstrap" title="Launch the app in a browser with the root module as the entry point">Bootstrap</a> the root module</li>
<li><a href="https://angular.io/docs/ts/latest/guide/ngmodule.html#declarations" title="Declare the components, directives, and pipes that belong to a module">Declarations</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/ngmodule.html#providers" title="Extend the app with additional services">Providers</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/ngmodule.html#imports" title="Import components, directives, and pipes for use in component templates">Imports</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/ngmodule.html#resolve-conflicts" title="When two directives have the same selector ...">Resolve conflicts</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/ngmodule.html#feature-modules" title="Partition the app into feature modules">Feature modules</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/ngmodule.html#lazy-load" title="Load modules asynchronously">Lazy loaded modules</a> with the Router</li>
<li><a href="https://angular.io/docs/ts/latest/guide/ngmodule.html#shared-module" title="Create modules for commonly used components, directives, and pipes">Shared modules</a> </li>
<li><a href="https://angular.io/docs/ts/latest/guide/ngmodule.html#core-module" title="Create a core module with app-wide singleton services and single-use components">The Core module</a> </li>
<li><a href="https://angular.io/docs/ts/latest/guide/ngmodule.html#core-for-root" title="Configure providers during module import">Configure core services with <em>forRoot</em></a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/ngmodule.html#prevent-reimport" title="because bad things happen if a lazy loaded module imports Core">Prevent reimport of the <em>CoreModule</em></a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/ngmodule.html#ngmodule-properties" title="A technical summary of the @NgModule metadata properties">NgModule metadata properties</a></li>
</ul><span>
</span><h3 id="live-examples">Live examples</h3><span>
</span><p>This page explains Angular Modules through a progression of improvements to a sample with a &quot;Tour of Heroes&quot; theme.
Here&apos;s an index to live examples at key moments in the evolution of that sample:</p><span>
</span><ul>
<li><live-example plnkr="minimal.0">A minimal NgModule app</live-example></li>
<li><live-example plnkr="contact.1b">The first contact module</live-example></li>
<li><live-example plnkr="contact.2">The revised contact module</live-example></li>
<li><live-example plnkr="pre-shared.3">Just before adding <em>SharedModule</em></live-example> </li>
<li><live-example>The final version</live-example></li>
</ul><span>
</span><h3 id="frequently-asked-questions-faqs-">Frequently Asked Questions (FAQs)</h3><span>
</span><p>This page covers Angular Module concepts in a tutorial fashion.</p><span>
</span><p>The companion <a href="https://angular.io/docs/ts/latest/cookbook/ngmodule-faq.html" title="Angular Module FAQs">Angular Module FAQs</a> cookbook
offers ready answers to specific design and implementation questions.
Read this page first before hopping over to those FAQs.</p><span>
</span><a id="angular-modularity"> </a><h2 id="angular-modularity">Angular Modularity</h2><span>
</span><p>Modules are a great way to organize the application and extend it with capabilities from external libraries.</p><span>
</span><p>Many Angular libraries are modules (e.g, <code>FormsModule</code>, <code>HttpModule</code>, <code>RouterModule</code>). 
Many third party libraries are available as Angular modules (e.g., 
<a href="https://material.angular.io/" target="_blank">Material Design</a>,
<a href="http://ionicframework.com/" target="_blank">Ionic</a>,
<a href="https://github.com/angular/angularfire2" target="_blank">AngularFire2</a>).</p><span>
</span><p>Angular modules consolidate components, directives and pipes into
cohesive blocks of functionality, each focused on a 
feature area, application business domain, workflow, or common collection of utilities.</p><span>
</span><p>Modules can also add services to the application.
Such services might be internally-developed such as the application logger.
They can come from outside sources such as the Angular router and Http client.</p><span>
</span><p>Modules can be loaded eagerly when the application starts.
They can also be <em>lazy loaded</em> asynchronously by the router.</p><span>
</span><p>An Angular module is a class decorated with <code>@NgModule</code> metadata. The metadata:</p><span>
</span><ul>
<li>declare which components, directives and pipes  <em>belong</em> to the module.</li>
<li>make some of those classes public so that other component templates can use them.</li>
<li>import other modules with the components, directives and pipes needed by the components in <em>this</em> module.</li>
<li>provide services at the application level that any application component can use.</li>
</ul><span>
</span><p>Every Angular app has at least one module class, the <em>root module</em>. 
We bootstrap that module to launch the application.</p><span>
</span><p>The <em>root module</em> is all we need in a simple application with a few components.
As the app grows, we refactor the <em>root module</em> into <strong>feature modules</strong> 
that represent collections of related functionality. 
We then import these modules into the <em>root module</em>.</p><span>
</span><p>We&apos;ll see how later in the page. Let&apos;s start with the <em>root module</em>.</p><span>
</span><a id="root_module"> </a><h2 id="_appmodule_-the-application-root-module"><em>AppModule</em> - the application root module</h2><span>
</span><p>Every Angular app has a <strong>root module</strong> class. 
By convention it&apos;s a class called <code>AppModule</code> in a file named <code>app.module.ts</code>.</p><span>
</span><p>This <code>AppModule</code> is about as minimal as it gets:</p><span>
</span><p>app/app.module.ts (minimal)</p><code language="ts" format="">import { NgModule }      from &apos;@angular/core&apos;;
import { BrowserModule } from &apos;@angular/platform-browser&apos;;

import
       { AppComponent }  from &apos;./app.component&apos;;

@NgModule({
  imports: [ BrowserModule ],
  declarations: [ AppComponent ],
  bootstrap:    [ AppComponent ]
})
export class AppModule { }
</code><p>The <code>@NgModule</code> decorator defines the metadata for the module. 
We&apos;ll take an intuitive approach to understanding the metadata and fill in details as we go.</p><span>
</span><p>This metadata imports a single helper module, <code>BrowserModule</code>, the module every browser app must import.</p><span>
</span><p><code>BrowserModule</code> registers critical application service providers.
It also includes common directives like <code>NgIf</code> and <code>NgFor</code> which become immediately visible and usable
in any of this modules component templates. </p><span>
</span><p>The <code>declarations</code> list identifies the application&apos;s only component, 
the <em>root component</em>, the top of this app&apos;s rather bare component tree.</p><span>
</span><p>The example <code>AppComponent</code> simply displays a data-bound title:</p><span>
</span><p>app/app.component.ts (minimal)</p><code language="ts" format="">import { Component } from &apos;@angular/core&apos;;

@Component({
  selector: &apos;my-app&apos;,
  template: &apos;&lt;h1&gt;{{title}}&lt;/h1&gt;&apos;,
})
export class AppComponent {
  title = &apos;Minimal NgModule&apos;;
}
</code><p>Lastly, the <code>@NgModule.bootstrap</code> property identifies this <code>AppComponent</code> as the <em>bootstrap component</em>. 
When Angular launches the app, it places the HTML rendering of <code>AppComponent</code> in the DOM,
inside the <code>&lt;my-app&gt;</code> element tags of the <code>index.html</code></p><span>
</span><a id="bootstrap"></a><h2 id="bootstrapping-in-_main-ts_">Bootstrapping in <em>main.ts</em></h2><span>
</span><p>We launch the application by bootstrapping the <code>AppModule</code> in the <code>main.ts</code> file.</p><span>
</span><p>Angular offers a variety of bootstrapping options, targeting multiple platforms. 
In this page we consider two options, both targeting the browser.</p><span>
</span><span>
</span><p>In the first, <em>dynamic</em> option, the <a href="https://angular.io/docs/ts/latest/cookbook/ngmodule-faq.html#q-angular-compiler" title="About the Angular Compiler">Angular compiler</a> 
compiles the application in the browser and then launches the app.</p><span>
</span><p>app/main.ts (dynamic)</p><code language="ts" format="">// The browser platform with a compiler
import { platformBrowserDynamic } from &apos;@angular/platform-browser-dynamic&apos;;

// The app module
import { AppModule } from &apos;./app.module&apos;;

// Compile and launch the module
platformBrowserDynamic().bootstrapModule(AppModule);
</code><p>The samples in this page demonstrate the dynamic bootstrapping approach. </p><span>
</span><p><live-example embedded="" plnkr="minimal.0" img="devguide/ngmodule/minimal-plunker.png">Try the live example.</live-example></p><span>
</span><span>
</span><p>Consider the static alternative which can produce a much smaller application that
launches faster, especially on mobile devices and high latency networks.</p><span>
</span><p>In the <em>static</em> option, the Angular compiler runs ahead of time as part of the build process,
producing a collection of class factories in their own files. 
Among them is the <code>AppModuleNgFactory</code>.</p><span>
</span><p>The syntax for bootstrapping the pre-compiled <code>AppModuleNgFactory</code> is similar to 
the dynamic version that bootstraps the <code>AppModule</code> class.</p><span>
</span><p>app/main.ts (static)</p><code language="ts" format="">// The browser platform without a compiler
import { platformBrowser } from &apos;@angular/platform-browser&apos;;

// The app module factory produced by the static offline compiler
import { AppModuleNgFactory } from &apos;./app.module.ngfactory&apos;;

// Launch with the app module factory.
platformBrowser().bootstrapModuleFactory(AppModuleNgFactory);
</code><p>Because the entire application was pre-compiled, 
we don&apos;t ship the <em>Angular Compiler</em> to the browser and we don&apos;t compile in the browser.</p><span>
</span><p>The application code downloaded to the browser is much smaller than the dynamic equivalent
and it is ready to execute immediately. The performance boost can be significant.</p><span>
</span><p>Both the JIT and AOT compilers generate an <code>AppModuleNgFactory</code> class from the same <code>AppModule</code> source code.
The JIT compiler creates that factory class on the fly, in memory, in the browser.
The AOT compiler outputs the factory to a physical file
that we&apos;re importing here in the static version of <code>main.ts</code>.</p><span>
</span><p>In general, the <code>AppModule</code> should neither know nor care how it is bootstrapped.</p><span>
</span><p>Although the <code>AppModule</code> evolves as the app grows, the bootstrap code in <code>main.ts</code> doesn&apos;t change.
This is the last time we&apos;ll look at <code>main.ts</code>.</p><span>
</span><a id="declarations"></a><h2 id="declare-directives-and-components">Declare directives and components</h2><span>
</span><p>The app evolves. 
The first addition is a <code>HighlightDirective</code>, an <a href="https://angular.io/docs/ts/latest/guide/attribute-directives.html">attribute directive</a>
that sets the background color of the attached element.</p><span>
</span><p>app/highlight.directive.ts</p><code language="ts" format="">import { Directive, ElementRef, Renderer } from &apos;@angular/core&apos;;

@Directive({ selector: &apos;[highlight]&apos; })
/** Highlight the attached element in gold */
export class HighlightDirective {
  constructor(renderer: Renderer, el: ElementRef) {
    renderer.setElementStyle(el.nativeElement, &apos;backgroundColor&apos;, &apos;gold&apos;);
    console.log(
      `* AppRoot highlight called for ${el.nativeElement.tagName}`);
  }
}
</code><p>We update the <code>AppComponent</code> template to attach the directive to the title:</p><span>
</span><code language="ts" format="">template: &apos;&lt;h1 highlight&gt;{{title}}&lt;/h1&gt;&apos;
</code><p>If we ran the app now, Angular would not recognize the <code>highlight</code> attribute and would ignore it. 
We must declare the directive in <code>AppModule</code>.</p><span>
</span><p>Import the <code>HighlightDirective</code> class and add it to the module&apos;s <code>declarations</code> like this:</p><span>
</span><code language="ts" format="">declarations: [
  AppComponent,
  HighlightDirective,
],
</code><h3 id="add-a-component">Add a component</h3><span>
</span><p>We decide to refactor the title into its own <code>TitleComponent</code>. 
The component&apos;s template binds to the component&apos;s <code>title</code> and <code>subtitle</code> properties like this:</p><span>
</span><p>app/title.component.html</p><code language="html" format="">&lt;h1 highlight&gt;{{title}} {{subtitle}}&lt;/h1&gt;
</code><p>app/title.component.ts</p><code language="ts" format="">import { Component, Input } from &apos;@angular/core&apos;;

@Component({
  selector: &apos;app-title&apos;,
  templateUrl: &apos;app/title.component.html&apos;,
})
export class TitleComponent {
  @Input() subtitle = &apos;&apos;;
  title = &apos;Angular Modules&apos;;
}
</code><p>We rewrite the <code>AppComponent</code> to display the new <code>TitleComponent</code> in the <code>&lt;app-title&gt;</code> element,
using an input binding to set the <code>subtitle</code>.</p><span>
</span><p>app/app.component.ts (v1)</p><code language="ts" format="">import { Component } from &apos;@angular/core&apos;;

@Component({
  selector: &apos;my-app&apos;,
  template: &apos;&lt;app-title [subtitle]=&quot;subtitle&quot;&gt;&lt;/app-title&gt;&apos;
})
export class AppComponent {
  subtitle = &apos;(v1)&apos;;
}
</code><p>Angular won&apos;t recognize the <code>&lt;app-title&gt;</code> tag until we declare it in <code>AppModule</code>. 
Import the <code>TitleComponent</code> class and add it to the module&apos;s <code>declarations</code>:</p><span>
</span><code language="ts" format="">  declarations: [
    AppComponent,
    HighlightDirective,
    TitleComponent,
  ],
</code><a id="providers"></a><h2 id="service-providers">Service Providers</h2><span>
</span><p>Modules are a great way to provide services for all of the module&apos;s components.</p><span>
</span><p>The <a href="https://angular.io/docs/ts/latest/guide/dependency-injection.html">Dependency Injection</a> page describes
the Angular hierarchical dependency injection system and how to configure that system
with <a href="https://angular.io/docs/ts/latest/guide/dependency-injection.html#providers">providers</a> at different levels of the
application&apos;s component tree.</p><span>
</span><p>A module can add providers to the application&apos;s root dependency injector, making those services
available everywhere in the application.</p><span>
</span><p>Many applications capture information about the currently logged-in user and make that information 
accessible through a user service. 
This sample application has a dummy implementation of such a <code>UserService</code>.</p><span>
</span><p>app/user.service.ts</p><code language="ts" format="">import { Injectable } from &apos;@angular/core&apos;;

@Injectable()
/** Dummy version of an authenticated user service */
export class UserService {
  userName = &apos;Sherlock Holmes&apos;;
}
</code><p>The sample application should display a welcome message to the logged in user just below the application title.
Update the <code>TitleComponent</code> template to show the welcome message below the application title.</p><span>
</span><p>app/title.component.html</p><code language="html" format="">&lt;h1 highlight&gt;{{title}} {{subtitle}}&lt;/h1&gt;
&lt;p *ngIf=&quot;user&quot;&gt;
  &lt;i&gt;Welcome, {{user}}&lt;/i&gt;
&lt;p&gt;
</code><p>Update the <code>TitleComponent</code> class with a constructor that injects the <code>UserService</code>
and sets the component&apos;s <code>user</code> property from the service.</p><span>
</span><p>app/title.component.ts</p><code language="ts" format="">import { Component, Input } from &apos;@angular/core&apos;;
import { UserService } from &apos;./user.service&apos;;

@Component({
  selector: &apos;app-title&apos;,
  templateUrl: &apos;app/title.component.html&apos;,
})
export class TitleComponent {
  @Input() subtitle = &apos;&apos;;
  title = &apos;Angular Modules&apos;;
  user = &apos;&apos;;

  constructor(userService: UserService) {
    this.user = userService.userName;
  }
}
</code><p>We&apos;ve <em>defined</em> and <em>used</em> the service. Now we <em>provide</em> it for all components to use by
adding it to a <code>providers</code> property in the <code>AppModule</code> metadata:</p><span>
</span><p>app/app.module.ts (providers)</p><code language="ts" format="">providers: [ UserService ],
</code><a id="imports"></a><h2 id="import-supporting-modules">Import supporting modules</h2><span>
</span><p>The app shouldn&apos;t welcome a user if there is no user.</p><span>
</span><p>Notice in the revised <code>TitleComponent</code> that an <code>*ngIf</code> directive guards the message.
There is no message if there is no user.</p><span>
</span><p>app/title.component.html (ngIf)</p><code language="html" format="">&lt;p *ngIf=&quot;user&quot;&gt;
  &lt;i&gt;Welcome, {{user}}&lt;/i&gt;
&lt;p&gt;
</code><p>Although <code>AppModule</code> doesn&apos;t declare <code>NgIf</code>, the application still compiles and runs.
How can that be? The Angular compiler should either ignore or complain about unrecognized HTML.</p><span>
</span><p>Angular <em>does</em> recognize <code>NgIf</code> because we imported it earlier. 
The initial version of <code>AppModule</code> imports <code>BrowserModule</code>.</p><span>
</span><p>app/app.module.ts (imports)</p><code language="ts" format="">imports: [ BrowserModule ],
</code><p>Importing <code>BrowserModule</code> made all of its public components, directives and pipes visible 
to the component templates in <code>AppModule</code>. They are ready to use without further ado.</p><span>
</span><div class="l-sub-section"><p>More accurately, <code>NgIf</code> is declared in <code>CommonModule</code> from <code>@angular/common</code>.</p><span>
</span><p><code>CommonModule</code> contributes many of the common directives that applications need including <code>ngIf</code> and <code>ngFor</code>.</p><span>
</span><p><code>BrowserModule</code> imports <code>CommonModule</code> and <a href="https://angular.io/docs/ts/latest/cookbook/ngmodule-faq.html#q-re-export"><em>re-exports</em></a> it.
The net effect is that an importer of <code>BrowserModule</code> gets <code>CommonModule</code> directives automatically.</p><span>
</span></div><p>Many familiar Angular directives do not belong to<code>CommonModule</code>. 
For example,  <code>NgModel</code> and <code>RouterLink</code> belong to Angular&apos;s <code>FormsModule</code> and <code>RouterModule</code> respectively.
We must <em>import</em> those modules before we can use their directives.</p><span>
</span><p>To illustrate this point, we extend the sample app with <code>ContactComponent</code>, 
a form component that imports form support from the Angular <code>FormsModule</code>.</p><span>
</span><span>
</span><p><a href="https://angular.io/docs/ts/latest/guide/forms.html">Angular Forms</a> are a great way to manage user data entry.</p><span>
</span><p>The <code>ContactComponent</code> presents a &quot;contact editor&quot;, 
implemented with <em>Angular Forms</em> in the <a href="https://angular.io/docs/ts/latest/guide/forms.html"><em>template-driven form</em></a> style.</p><span>
</span><div class="l-sub-section"><h4 id="angular-form-styles">Angular Form Styles</h4><span>
</span><p>We write Angular form components in either the
<a href="https://angular.io/docs/ts/latest/guide/forms.html"><em>template-driven form</em></a> style or 
the <a href="https://angular.io/docs/ts/latest/cookbook/dynamic-form.html"><em>reactive form</em></a> style.</p><span>
</span><p>This sample is about to import the <code>FormsModule</code> from <code>@angular/forms</code> because
the <code>ContactComponent</code> is written in the <em>template-driven</em> style.
Modules with components written in the <em>reactive</em> style,
should import the <code>ReactiveFormsModule</code> instead.</p><span>
</span></div><p>The <code>ContactComponent</code> selector matches an element named <code>&lt;app-contact&gt;</code>. 
Add an element with that name to the <code>AppComponent</code> template just below the <code>&lt;app-title&gt;</code>:</p><span>
</span><p>app/app.component.ts (template)</p><code language="ts" format="">template: `
  &lt;app-title [subtitle]=&quot;subtitle&quot;&gt;&lt;/app-title&gt;
  &lt;app-contact&gt;&lt;/app-contact&gt;
`
</code><p>The <code>ContactComponent</code> has a lot going on. 
Form components are often complex anyway and this one has its own <code>ContactService</code>, 
its own <a href="https://angular.io/docs/ts/latest/guide/ngmodule.html#pipes.html#custom-pipes">custom pipe</a> called <code>Awesome</code>,
and an alternative version of the <code>HighlightDirective</code>.</p><span>
</span><p>To make it manageable, we place all contact-related material in an <code>app/contact</code> folder
and break the component into three constituent HTML, TypeScript, and css files:</p><span>
</span><code-tabs><code language="html" name="app/contact/contact.component.html" format="linenums">&lt;h2&gt;Contact of {{userName}}&lt;/h2&gt;
&lt;div *ngIf=&quot;msg&quot; class=&quot;msg&quot;&gt;{{msg}}&lt;/div&gt;

&lt;form *ngIf=&quot;contacts&quot; (ngSubmit)=&quot;onSubmit()&quot; #contactForm=&quot;ngForm&quot;&gt;
  &lt;h3 highlight&gt;{{ contact.name | awesome }}&lt;/h3&gt;
  &lt;div class=&quot;form-group&quot;&gt;
    &lt;label for=&quot;name&quot;&gt;Name&lt;/label&gt;
    &lt;input type=&quot;text&quot; class=&quot;form-control&quot; required
      [(ngModel)]=&quot;contact.name&quot;
        name=&quot;name&quot;  #name=&quot;ngModel&quot; &gt;
    &lt;div [hidden]=&quot;name.valid&quot; class=&quot;alert alert-danger&quot;&gt;
      Name is required
    &lt;/div&gt;
  &lt;/div&gt;
  &lt;br&gt;
  &lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot; [disabled]=&quot;!contactForm.form.valid&quot;&gt;Save&lt;/button&gt;
  &lt;button type=&quot;button&quot; class=&quot;btn&quot; (click)=&quot;next()&quot; [disabled]=&quot;!contactForm.form.valid&quot;&gt;Next Contact&lt;/button&gt;
  &lt;button type=&quot;button&quot; class=&quot;btn&quot; (click)=&quot;newContact()&quot;&gt;New Contact&lt;/button&gt;
&lt;/form&gt;
</code><code language="ts" name="app/contact/contact.component.ts" format="linenums">import { Component, OnInit }      from &apos;@angular/core&apos;;

import { Contact, ContactService } from &apos;./contact.service&apos;;
import { UserService }    from &apos;../user.service&apos;;

@Component({
  selector: &apos;app-contact&apos;,
  templateUrl: &apos;app/contact/contact.component.html&apos;,
  styleUrls: [&apos;app/contact/contact.component.css&apos;]
})
export class ContactComponent implements OnInit {
  contact:  Contact;
  contacts: Contact[];

  msg = &apos;Loading contacts ...&apos;;
  userName = &apos;&apos;;

  constructor(private contactService: ContactService, userService: UserService) {
    this.userName = userService.userName;
  }

  ngOnInit() {
    this.contactService.getContacts().then(contacts =&gt; {
      this.msg = &apos;&apos;;
      this.contacts = contacts;
      this.contact = contacts[0];
    });
  }

  next() {
    let ix = 1 + this.contacts.indexOf(this.contact);
    if (ix &gt;= this.contacts.length) { ix = 0; }
    this.contact = this.contacts[ix];
  }

  onSubmit() {
    // TODO: do something like save it
    this.displayMessage(&apos;Saved &apos; + this.contact.name);
  }

  newContact() {
    this.displayMessage(&apos;New contact&apos;);
    this.contact = {id: 42, name: &apos;&apos;};
    this.contacts.push(this.contact);
  }

  /** Display a message briefly, then remove it. */
  displayMessage(msg: string) {
    this.msg = msg;
    setTimeout(() =&gt; this.msg = &apos;&apos;, 1500);
  }
}
</code><code language="css" name="app/contact/contact.component.css" format="linenums">.ng-valid[required] {
  border-left: 5px solid #42A948; /* green */
}

.ng-invalid {
  border-left: 5px solid #a94442; /* red */
}

.alert {
  padding: 15px;
  margin: 8px 0;
  border: 1px solid transparent;
  border-radius: 4px;
}
.alert-danger {
  color: #a94442;
  background-color: #f2dede;
  border-color: #ebccd1;
}

.msg {
  color: blue;
  background-color: whitesmoke;
  border: 1px solid transparent;
  border-radius: 4px;
  margin-bottom: 20px;
}
</code><code language="ts" name="app/contact/contact.service.ts" format="linenums">import { Injectable } from &apos;@angular/core&apos;;

export class Contact {
  constructor(public id: number, public name: string) { }
}

const CONTACTS: Contact[] = [
  new Contact(21, &apos;Sam Spade&apos;),
  new Contact(22, &apos;Nick Danger&apos;),
  new Contact(23, &apos;Nancy Drew&apos;)
];

const FETCH_LATENCY = 500;

@Injectable()
export class ContactService {

  getContacts() {
    return new Promise&lt;Contact[]&gt;(resolve =&gt; {
      setTimeout(() =&gt; { resolve(CONTACTS); }, FETCH_LATENCY);
    });
  }

  getContact(id: number | string) {
    return this.getContacts()
      .then(heroes =&gt; heroes.find(hero =&gt; hero.id === +id));
  }
}
</code><code language="ts" name="app/contact/awesome.pipe.ts" format="linenums">import { Pipe, PipeTransform } from &apos;@angular/core&apos;;

@Pipe({ name: &apos;awesome&apos; })
/** Precede the input string with the word &quot;Awesome &quot; */
export class AwesomePipe implements PipeTransform {
  transform(phrase: string) {
    return phrase ? &apos;Awesome &apos; + phrase : &apos;&apos;;
  }
}
</code><code language="ts
  " name="app/contact/highlight.directive.ts" format="linenums">import { Directive, ElementRef, Renderer } from &apos;@angular/core&apos;;

@Directive({ selector: &apos;[highlight], input&apos; })
/** Highlight the attached element or an InputElement in blue */
export class HighlightDirective {
  constructor(renderer: Renderer, el: ElementRef) {
    renderer.setElementStyle(el.nativeElement, &apos;backgroundColor&apos;, &apos;powderblue&apos;);
    console.log(
      `* Contact highlight called for ${el.nativeElement.tagName}`);
  }
}
</code></code-tabs><p>Focus on the component template.
Notice the two-way data binding <code>[(ngModel)]</code> in the middle of the template.
<code>ngModel</code> is the selector for the <code>NgModel</code> directive.</p><span>
</span><p>Although <code>NgModel</code> is an Angular directive, the <em>Angular Compiler</em> won&apos;t recognize it
because (a) <code>AppModule</code> doesn&apos;t declare it and (b) it wasn&apos;t imported via <code>BrowserModule</code>.</p><span>
</span><p>Less obviously, even if Angular somehow recognized <code>ngModel</code>,
this <code>ContactComponent</code> would not behave like an Angular form because
form features such as validation are not yet available.</p><span>
</span><h3 id="import-the-formsmodule">Import the FormsModule</h3><span>
</span><p>Add the <code>FormsModule</code> to the <code>AppModule</code> metadata&apos;s <code>imports</code> list.</p><span>
</span><code language="ts" format="">imports: [ BrowserModule, FormsModule ],
</code><p>Now <code>[(ngModel)]</code> binding will work and the user input will be validated by Angular Forms, 
once we declare our new component, pipe and directive.</p><span>
</span><div class="alert is-critical"><p><strong>Do not</strong> add <code>NgModel</code> &#x2014; or the <code>FORMS_DIRECTIVES</code> &#x2014; 
to the <code>AppModule</code> metadata&apos;s declarations!</p><span>
</span><p>These directives belong to the <code>FormsModule</code>.
Components, directives and pipes belong to one module &#x2014; and <em>one module only</em>.</p><span>
</span><p><strong>Never re-declare classes that belong to another module.</strong></p><span>
</span></div><a id="declare-pipe"></a><span>
</span><p>The application fails to compile until we declare the contact component, directive and pipe.
Update the <code>declarations</code> in the  <code>AppModule</code> accordingly:</p><span>
</span><p>app/app.module.ts (declarations)</p><code language="ts" format="">  declarations: [
    AppComponent,
    HighlightDirective,
    TitleComponent,

    AwesomePipe,
    ContactComponent,
    ContactHighlightDirective
  ],
</code><a id="import-name-conflict"></a><div class="l-sub-section"><p>There are two directives with the same name, both called <code>HighlightDirective</code>.</p><span>
</span><p>We work around it by creating an alias for the second, contact version using the <code>as</code> JavaScript import keyword:</p><span>
</span><code language="ts" format="">import {
  HighlightDirective as ContactHighlightDirective
} from &apos;./contact/highlight.directive&apos;;
</code><p>This solves the immediate problem of referencing both directive <em>types</em> in the same file but 
leaves another problem unresoved as we discuss <a href="https://angular.io/docs/ts/latest/guide/ngmodule.html#resolve-conflicts">below</a>.</p><span>
</span></div><span>
</span><p>The <code>ContactComponent</code> displays contacts retrieved by the <code>ContactService</code>
which Angular injects into its constructor. </p><span>
</span><p>We have to provide that service somewhere.
The <code>ContactComponent</code> <em>could</em> provide it. 
But then it would be scoped to this component <em>only</em>. 
We want to share this service with other contact-related components that we will surely add later.</p><span>
</span><p>In this app we chose to add <code>ContactService</code> to the <code>AppModule</code> metadata&apos;s <code>providers</code> list:</p><span>
</span><p>app/app.module.ts (providers)</p><code language="ts" format="">providers: [ ContactService, UserService ],
</code><p>Now <code>ContactService</code> (like <code>UserService</code>) can be injected into any component in the application.</p><span>
</span><a id="application-scoped-providers"></a><div class="l-sub-section"><h4 id="application-scoped-providers">Application-scoped Providers</h4><span>
</span><p>  The <code>ContactService</code> provider is <em>application</em>-scoped because Angular 
  registers a module&apos;s <code>providers</code> with the application&apos;s <strong>root injector</strong>.</p><span>
</span><p>  Architecturally, the <code>ContactService</code> belongs to the Contact business domain. 
  Classes in <em>other</em> domains don&apos;t need the <code>ContactService</code> and shouldn&apos;t inject it.</p><span>
</span><p>  We might expect Angular to offer a <em>module</em>-scoping mechanism to enforce this design.
  It doesn&apos;t. Angular module instances, unlike components, do not have their own injectors
  so they can&apos;t have their own provider scopes.</p><span>
</span><p>  This omission is intentional. 
  Angular modules are designed primarily to extend an application, 
  to enrich the entire app with the module&apos;s capabilities.</p><span>
</span><p>  Service scoping is rarely a problem in practice.
  Non-contact components can&apos;t inject the <code>ContactService</code> by accident.
  To inject <code>ContactService</code>, you must first import its <em>type</em>.
  Only Contact components should import the <code>ContactService</code> <em>type</em>.</p><span>
</span><p>  See the <a href="https://angular.io/docs/ts/latest/cookbook/ngmodule-faq.html#q-component-scoped-providers">FAQ that pursues this issue</a> 
  and its mitigations in greater detail.</p><span>
</span></div><h3 id="run-the-app">Run the app</h3><span>
</span><p>Everything is now in place to run the application with its contact editor.</p><span>
</span><p>The app file structure looks like this:</p><span>
</span><div class="filetree"><p>app</p><div class="children"><p>app.component.ts</p><p>app.module.ts</p><p>highlight.directive.ts</p><p>main.ts</p><p>title.component.(html|ts)</p><p>user.service.ts</p><p>contact</p><div class="children"><p>awesome.pipe.ts</p><p>contact.component.(css|html|ts)</p><p>contact.service.ts</p><p>highlight.directive.ts</p></div></div></div><p>Try the example:</p><span>
</span><span>
</span><a id="resolve-conflicts"></a><h2 id="resolve-directive-conflicts">Resolve directive conflicts</h2><span>
</span><p>We ran into trouble <a href="https://angular.io/docs/ts/latest/guide/ngmodule.html#import-name-conflict">above</a> when we declared the contact&apos;s <code>HighlightDirective</code> because
we already had a <code>HighlightDirective</code> class at the application level.</p><span>
</span><p>That both directives have the same name smells of trouble.</p><span>
</span><p>A look at their selectors reveals that they both highlight the attached element with a different color.</p><span>
</span><code-tabs><code language="ts" name="app/highlight.directive.ts" format="linenums">import { Directive, ElementRef, Renderer } from &apos;@angular/core&apos;;

@Directive({ selector: &apos;[highlight]&apos; })
/** Highlight the attached element in gold */
export class HighlightDirective {
  constructor(renderer: Renderer, el: ElementRef) {
    renderer.setElementStyle(el.nativeElement, &apos;backgroundColor&apos;, &apos;gold&apos;);
    console.log(
      `* AppRoot highlight called for ${el.nativeElement.tagName}`);
  }
}
</code><code language="ts" name="app/contact/highlight.directive.ts" format="linenums">import { Directive, ElementRef, Renderer } from &apos;@angular/core&apos;;

@Directive({ selector: &apos;[highlight], input&apos; })
/** Highlight the attached element or an InputElement in blue */
export class HighlightDirective {
  constructor(renderer: Renderer, el: ElementRef) {
    renderer.setElementStyle(el.nativeElement, &apos;backgroundColor&apos;, &apos;powderblue&apos;);
    console.log(
      `* Contact highlight called for ${el.nativeElement.tagName}`);
  }
}
</code></code-tabs><p>Will Angular use only one of them? No. 
Both directives are declared in this module so <em>both directives are active</em>.</p><span>
</span><p>When the two directives compete to color the same element, 
the directive declared later wins because its DOM changes overwrite the first.
In this case, the contact&apos;s <code>HighlightDirective</code> colors the application title text blue
when it should stay gold.</p><span>
</span><div class="l-sub-section"><p>The real problem is that there are <em>two different classes</em> trying to do the same thing.</p><span>
</span><p>It&apos;s OK to import the <em>same</em> directive class multiple times. 
Angular removes duplicate classes and only registers one of them.</p><span>
</span><p>But these are actually two different classes, defined in different files, that happen to have the same name.</p><span>
</span><p>They&apos;re not duplicates from Angular&apos;s perspective. Angular keeps both directives and
they take turns modifying the same HTML element.</p><span>
</span></div><p>At least the app still compiles. 
If we define two different component classes with the same selector specifying the same element tag, 
the compiler reports an error. It can&apos;t insert two components in the same DOM location.</p><span>
</span><p>What a mess! </p><span>
</span><p>We can eliminate component and directive conflicts by creating feature modules
that insulate the declarations in one module from the declarations in another.</p><span>
</span><a id="feature-modules"></a><h2 id="feature-modules">Feature Modules</h2><span>
</span><p>This application isn&apos;t big yet. But it&apos;s already suffering structural problems.</p><span>
</span><ul>
<li><p>The root <code>AppModule</code> grows larger with each new application class and shows no signs of stopping.</p>
</li>
<li><p>We have conflicting directives. 
The <code>HighlightDirective</code> in contact is re-coloring the work done by the <code>HighlightDirective</code> declared in <code>AppModule</code>.
And it&apos;s coloring the application title text when it should only color the <code>ContactComponent</code>.</p>
</li>
<li><p>The app lacks clear boundaries between contact functionality and other application features.
That lack of clarity makes it harder to assign development responsibilities to different teams.</p>
</li>
</ul><span>
</span><p>We mitigate these problems with <em>feature modules</em>.</p><span>
</span><h3 id="_feature-module_"><em>Feature Module</em></h3><span>
</span><p>A <em>feature module</em> is a class adorned by the <code>@NgModule</code> decorator and its metadata,
just like a root module. 
Feature module metadata have the same properties as the metadata for a root module.</p><span>
</span><p>The root module and the feature module share the same execution context.
They share the same dependency injector which means the services in one module
are available to all.</p><span>
</span><p>There are two significant technical differences:</p><span>
</span><ol>
<li><p>We <em>boot</em> the root module to <em>launch</em> the app;
we <em>import</em> a feature module to <em>extend</em> the app.</p>
</li>
<li><p>A feature module can expose or hide its implementation from other modules.</p>
</li>
</ol><span>
</span><p>Otherwise, a feature module is distinguished primarily by its intent.</p><span>
</span><p>A feature module delivers a cohesive set of functionality
focused on an application business domain, a user workflow, a facility (forms, http, routing), 
or a collection of related utilities.</p><span>
</span><p>While we can do everything within the root module,
feature modules help us partition the app into areas of specific interest and purpose.</p><span>
</span><p>A feature module collaborates with the root module and with other modules 
through the services it provides and 
the components, directives, and pipes that it chooses to share.</p><span>
</span><p>In the next section, we carve the contact functionality out of the root module
and into a dedicated feature module.</p><span>
</span><span>
</span><span>
</span><p>It&apos;s easy to refactor the contact material into a contact feature module.</p><span>
</span><ol>
<li>Create the <code>ContactModule</code> in the <code>app/contact</code> folder.</li>
<li>Move the contact material from <code>AppModule</code> to <code>ContactModule</code>.</li>
<li>Replace the imported  <code>BrowserModule</code> with <code>CommonModule</code>.</li>
<li>Import the <code>ContactModule</code> into the <code>AppModule</code>.</li>
</ol><span>
</span><p><code>AppModule</code> is the only <em>existing</em> class that changes. But we do add one new file.</p><span>
</span><span>
</span><p>Here&apos;s the new <code>ContactModule</code></p><span>
</span><p>app/contact/contact.module.ts</p><code language="ts" format="linenums">import { NgModule }           from &apos;@angular/core&apos;;
import { CommonModule }       from &apos;@angular/common&apos;;
import { FormsModule }        from &apos;@angular/forms&apos;;

import { AwesomePipe }        from &apos;./awesome.pipe&apos;;

import
       { ContactComponent }   from &apos;./contact.component&apos;;
import { ContactService }     from &apos;./contact.service&apos;;
import { HighlightDirective } from &apos;./highlight.directive&apos;;

@NgModule({
  imports:      [ CommonModule, FormsModule ],
  declarations: [ ContactComponent, HighlightDirective, AwesomePipe ],
  exports:      [ ContactComponent ],
  providers:    [ ContactService ]
})
export class ContactModule { }
</code><p>We copy from <code>AppModule</code> the contact-related import statements and the <code>@NgModule</code> properties
that concern the contact and paste them in <code>ContactModule</code>.</p><span>
</span><p>We <em>import</em> the <code>FormsModule</code> because the contact component needs it. </p><span>
</span><div class="alert is-important"><p>Modules do not inherit access to the components, directives or pipes that are declared in other modules.
What <code>AppModule</code> imports is irrelevant to <code>ContactModule</code> and vice versa.
Before <code>ContactComponent</code> can bind with <code>[(ngModel)]</code>, its <code>ContactModule</code> must import <code>FormsModule</code>.</p><span>
</span></div><p>We also replaced <code>BrowserModule</code> by <code>CommonModule</code> for reasons explained in
<a href="https://angular.io/docs/ts/latest/cookbook/ngmodule-faq.html#q-browser-vs-common-module">an FAQ</a>.</p><span>
</span><p>We <em>declare</em> the contact component, directive, and pipe in the module <code>declarations</code>.</p><span>
</span><p>We <em>export</em> the <code>ContactComponent</code> so
other modules that import the <code>ContactModule</code> can include it in their component templates.</p><span>
</span><p>All other declared contact classes are private by default.
The <code>AwesomePipe</code> and <code>HighlightDirective</code> are hidden from the rest of the application. 
The <code>HighlightDirective</code> can no longer color the <code>AppComponent</code> title text.</p><span>
</span><h3 id="refactor-the-_appmodule_">Refactor the <em>AppModule</em></h3><span>
</span><p>Return to the <code>AppModule</code> and remove everything specific to the contact feature set.</p><span>
</span><p>Delete the contact import statements.
Delete the contact declarations and contact providers.
Remove the <code>FormsModule</code> from the <code>imports</code> list (<code>AppComponent</code> doesn&apos;t need it).
Leave only the classes required at the application root level.</p><span>
</span><p>Then import the <code>ContactModule</code> so the app can continue to display the exported <code>ContactComponent</code>.</p><span>
</span><p>Here&apos;s the refactored version of the <code>AppModule</code> side-by-side with the previous version.</p><span>
</span><code-tabs><code language="ts" name="app/app.module.ts (v2)" format="linenums">import { NgModule }           from &apos;@angular/core&apos;;
import { BrowserModule }      from &apos;@angular/platform-browser&apos;;

/* App Root */
import
       { AppComponent }       from &apos;./app.component&apos;;
import { HighlightDirective } from &apos;./highlight.directive&apos;;
import { TitleComponent }     from &apos;./title.component&apos;;
import { UserService }        from &apos;./user.service&apos;;

/* Contact Imports */
import
       { ContactModule }      from &apos;./contact/contact.module&apos;;

@NgModule({
  imports:      [ BrowserModule, ContactModule ],
  declarations: [ AppComponent, HighlightDirective, TitleComponent ],
  providers:    [ UserService ],
  bootstrap:    [ AppComponent ],
})
export class AppModule { }
</code><code language="ts" name="app/app.module.ts (v1)" format="linenums">import { NgModule }           from &apos;@angular/core&apos;;
import { BrowserModule }      from &apos;@angular/platform-browser&apos;;

/* App Root */
import
       { AppComponent }       from &apos;./app.component&apos;;
import { HighlightDirective } from &apos;./highlight.directive&apos;;
import { TitleComponent }     from &apos;./title.component&apos;;
import { UserService }        from &apos;./user.service&apos;;

/* Contact Imports */
import
       { ContactComponent }   from &apos;./contact/contact.component&apos;;
import { ContactService }     from &apos;./contact/contact.service&apos;;
import { AwesomePipe }        from &apos;./contact/awesome.pipe&apos;;

import {
  HighlightDirective as ContactHighlightDirective
} from &apos;./contact/highlight.directive&apos;;

import { FormsModule }        from &apos;@angular/forms&apos;;

@NgModule({
  imports: [ BrowserModule,  FormsModule ],
  declarations: [
    AppComponent, HighlightDirective, TitleComponent,
    AwesomePipe, ContactComponent, ContactHighlightDirective
  ],
  providers: [ ContactService, UserService ],
  bootstrap: [ AppComponent ]
})
export class AppModule { }
</code></code-tabs><h3 id="improvements">Improvements</h3><span>
</span><p>There&apos;s a lot to like in the revised <code>AppModule</code></p><span>
</span><ul>
<li>It does not change as the <em>Contact</em> domain grows.</li>
<li>It only changes when we add new modules.</li>
<li>It&apos;s simpler:<ul>
<li>Fewer import statements</li>
<li>No <code>FormsModule</code> import</li>
<li>No contact-specific declarations</li>
<li>No <code>ContactService</code> provider</li>
<li>No <code>HighlightDirective</code> conflict</li>
</ul>
</li>
</ul><span>
</span><p>Try this <code>ContactModule</code> version of the sample.</p><span>
</span><p><live-example embedded="" plnkr="contact.2" img="devguide/ngmodule/contact-2-plunker.png">Try the live example.</live-example></p><span>
</span><a id="lazy-load"></a><h2 id="lazy-loading-modules-with-the-router">Lazy loading modules with the Router</h2><span>
</span><p>The Heroic Staffing Agency sample app has evolved. 
It has two more modules, one for managing the heroes-on-staff and another for matching crises to the heroes.
Both modules are in the early stages of development. 
Their specifics aren&apos;t important to the story and we won&apos;t discuss every line of code.</p><span>
</span><div class="l-sub-section"><p>Examine and download the complete source for this version from the </p><span>
</span><p><live-example plnkr="pre-shared.3" img="devguide/ngmodule/v3-plunker.png">live example.</live-example></p><span>
</span></div><p>Some facets of the current application merit discussion.</p><span>
</span><ul>
<li>The app has three feature modules: Contact, Hero, and Crisis.</li>
<li>The Angular router helps users navigate among these modules.</li>
<li>The <code>ContactComponent</code> is the default destination when the app starts.</li>
<li>The <code>ContactModule</code> continues to be &quot;eagerly&quot; loaded when the application starts.</li>
<li><code>HeroModule</code> and the <code>CrisisModule</code> are lazy loaded.</li>
</ul><span>
</span><p><a id="app-component-template"></a>
Let&apos;s start at the top with the new <code>AppComponent</code> template:
a title, three links, and a <code>&lt;router-outlet&gt;</code>.</p><span>
</span><p>app/app.component.ts (v3 - Template)</p><code language="ts" format="">template: `
  &lt;app-title [subtitle]=&quot;subtitle&quot;&gt;&lt;/app-title&gt;
  &lt;nav&gt;
    &lt;a routerLink=&quot;contact&quot; routerLinkActive=&quot;active&quot;&gt;Contact&lt;/a&gt;
    &lt;a routerLink=&quot;crisis&quot;  routerLinkActive=&quot;active&quot;&gt;Crisis Center&lt;/a&gt;
    &lt;a routerLink=&quot;heroes&quot;  routerLinkActive=&quot;active&quot;&gt;Heroes&lt;/a&gt;
  &lt;/nav&gt;
  &lt;router-outlet&gt;&lt;/router-outlet&gt;
`
</code><p>The <code>&lt;app-contact&gt;</code> element is gone; we&apos;re routing to the <em>Contact</em> page now.</p><span>
</span><p>The <code>AppModule</code> has changed modestly:</p><span>
</span><p>app/app.module.ts (v3)</p><code language="ts" format="linenums">import { NgModule }           from &apos;@angular/core&apos;;
import { BrowserModule }      from &apos;@angular/platform-browser&apos;;

/* App Root */
import { AppComponent }       from &apos;./app.component.3&apos;;
import { HighlightDirective } from &apos;./highlight.directive&apos;;
import { TitleComponent }     from &apos;./title.component&apos;;
import { UserService }        from &apos;./user.service&apos;;

/* Feature Modules */
import { ContactModule }      from &apos;./contact/contact.module.3&apos;;
import { routing }            from &apos;./app.routing.3&apos;;

@NgModule({
  imports:      [
    BrowserModule,
    ContactModule,
    routing
  ],
  providers:    [ UserService ],
  declarations: [ AppComponent, HighlightDirective, TitleComponent ],
  bootstrap:    [ AppComponent ]
})
export class AppModule { }
</code><div class="l-sub-section"><p>Some file names bear a <code>.3</code> extension indicating
a difference with prior or future versions.
We&apos;ll explain differences that matter in due course.</p><span>
</span></div><p>The module still imports <code>ContactModule</code> so that its routes and components are mounted when the app starts. </p><span>
</span><p>The module does <em>not</em> import <code>HeroModule</code> or <code>CrisisModule</code>. 
They&apos;ll be fetched and mounted asynchronously when the user navigates to one of their routes.</p><span>
</span><p>The significant change from version 2 is the addition of a <strong><em>routing</em></strong> object to the <code>imports</code>.
The routing object, which provides a configured <code>Router</code> service, is defined in the <code>app.routing.ts</code> file.</p><span>
</span><h3 id="app-routing">App routing</h3><span>
</span><p>app/app.routing.ts</p><code language="ts" format="">import { ModuleWithProviders }  from &apos;@angular/core&apos;;
import { Routes, RouterModule } from &apos;@angular/router&apos;;

export const routes: Routes = [
  { path: &apos;&apos;, redirectTo: &apos;contact&apos;, pathMatch: &apos;full&apos;},
  { path: &apos;crisis&apos;, loadChildren: &apos;app/crisis/crisis.module#CrisisModule&apos; },
  { path: &apos;heroes&apos;, loadChildren: &apos;app/hero/hero.module#HeroModule&apos; }
];

export const routing: ModuleWithProviders = RouterModule.forRoot(routes);
</code><p>The router is the subject of <a href="https://angular.io/docs/ts/latest/guide/router.html">its own page</a> so we&apos;ll skip lightly over the details and 
concentrate on the intersection of Angular modules and routing.</p><span>
</span><p>This file defines three routes. </p><span>
</span><p>The first redirects the empty URL (e.g., <code>http://host.com/</code>) 
to another route whose path is <code>contact</code> (e.g., <code>http://host.com/contact</code>).</p><span>
</span><p>The <code>contact</code> route isn&apos;t defined here.
It&apos;s defined in the <em>Contact</em> feature&apos;s <em>own</em> routing file, <code>contact.routing.ts</code>.
It&apos;s standard practice for feature modules with routing components to define their own routes.
We&apos;ll get to that file in a moment.</p><span>
</span><p>The remaining two routes use lazy loading syntax to tell the router where to find the modules:</p><span>
</span><code language="ts" format="">{ path: &apos;crisis&apos;, loadChildren: &apos;app/crisis/crisis.module#CrisisModule&apos; },
{ path: &apos;heroes&apos;, loadChildren: &apos;app/hero/hero.module#HeroModule&apos; }
</code><div class="l-sub-section"><p>A lazy loaded module location is a <em>string</em>, not a <em>type</em>. 
In this app, the string identifies both the module <em>file</em> and the module <em>class</em>,
the latter separated from the former by a <code>#</code>.</p><span>
</span></div><h3 id="routermodule-forroot">RouterModule.forRoot</h3><span>
</span><p>The last line calls the <code>forRoot</code> static class method of the <code>RouterModule</code>, passing in the configuration.</p><span>
</span><code language="ts" format="">export const routing: ModuleWithProviders = RouterModule.forRoot(routes);
</code><p>The returned <code>routing</code> object is a <code>ModuleWithProviders</code> containing both the <code>RouterModule</code> directives
and the Dependency Injection providers that produce a configured <code>Router</code>. </p><span>
</span><p>This <code>routing</code> object is intended for the app <em>root</em> module <em>only</em>.</p><span>
</span><div class="alert is-critical"><p>Never call <code>RouterModule.forRoot</code> in a feature module.</p><span>
</span></div><p>Back in the root <code>AppModule</code>, we add this <code>routing</code> object to its <code>imports</code> list, 
and the app is ready to navigate.</p><span>
</span><p>app/app.module.ts (imports)</p><code language="ts" format="">imports:      [
  BrowserModule,
  ContactModule,
  routing
],
</code><h3 id="routing-to-a-feature-module">Routing to a feature module</h3><span>
</span><p>The <code>app/contact</code> folder holds a new file, <code>contact.routing.ts</code>.
It defines the <code>contact</code> route we mentioned a bit earlier and also creates a <code>routing</code> object like so:</p><span>
</span><p>app/contact/contact.routing.ts (routing)</p><code language="ts" format="">export const routing: ModuleWithProviders = RouterModule.forChild([
  { path: &apos;contact&apos;, component: ContactComponent}
]);
</code><p>This time we pass the route list to the <code>forChild</code> method of the <code>RouterModule</code>.
It produces a different kind of object intended for feature modules.</p><span>
</span><div class="alert is-important"><p>Always call <code>RouterModule.forChild</code> in a feature module.</p><span>
</span></div><div class="alert is-helpful"><p><strong><em>forRoot</em></strong> and <strong><em>forChild</em></strong> are conventional names for methods that
deliver different <code>import</code> values to root and feature modules.
Angular doesn&apos;t recognize them but Angular developers do.</p><span>
</span><p><a href="https://angular.io/docs/ts/latest/cookbook/ngmodule-faq.html#q-for-root">Follow this convention</a> if you write a similar module
that has both shared <a href="https://angular.io/docs/ts/latest/cookbook/ngmodule-faq.html#q-declarable"><em>declarables</em></a> and services.</p><span>
</span></div><p><code>ContactModule</code> has changed in two small but important details</p><span>
</span><code-tabs><code language="ts" name="app/contact/contact.module.3.ts" format="linenums">@NgModule({
  imports:      [ CommonModule, FormsModule, routing ],
  declarations: [ ContactComponent, HighlightDirective, AwesomePipe ],
  providers:    [ ContactService ]
})
export class ContactModule { }
</code><code language="ts" name="app/contact/contact.module.2.ts" format="linenums">@NgModule({
  imports:      [ CommonModule, FormsModule ],
  declarations: [ ContactComponent, HighlightDirective, AwesomePipe ],
  exports:      [ ContactComponent ],
  providers:    [ ContactService ]
})
export class ContactModule { }
</code></code-tabs><ol>
<li>It imports the <code>routing</code> object from <code>contact.routing.ts</code></li>
<li>It no longer exports <code>ContactComponent</code></li>
</ol><span>
</span><p>Now that we navigate to <code>ContactComponent</code> with the router there&apos;s no reason to make it public.
Nor does it need a selector. 
No template will ever again reference this <code>ContactComponent</code>.
It&apos;s gone from the <a href="https://angular.io/docs/ts/latest/guide/ngmodule.html#app-component-template"><em>AppComponent</em> template</a>.</p><span>
</span><a id="hero-module"></a><h3 id="lazy-loaded-routing-to-a-module">Lazy loaded routing to a module</h3><span>
</span><p>The lazy loaded <code>HeroModule</code> and <code>CrisisModule</code> follow the same principles as any feature module.
They don&apos;t look different from the eagerly loaded <code>ContactModule</code>.</p><span>
</span><p>The <code>HeroModule</code> is a bit more complex than the <code>CrisisModule</code> which makes it 
a more interesting and useful example. Here&apos;s its file structure:</p><span>
</span><div class="filetree"><p>hero</p><div class="children"><p>hero-detail.component.ts</p><p>hero-list.component.ts</p><p>hero.component.ts</p><p>hero.module.ts</p><p>hero.routing.ts</p><p>hero.service.ts</p><p>highlight.directive.ts</p></div></div><p>This is the child routing scenario familiar to readers of the <a href="https://angular.io/docs/ts/latest/guide/router.html#child-routing-component">Router</a> page.
The <code>HeroComponent</code> is the feature&apos;s top component and routing host. 
Its template has a <code>&lt;router-outlet&gt;</code> that displays either a list of heroes (<code>HeroList</code>) 
or an editor of a selected hero (<code>HeroDetail</code>).
Both components delegate to the <code>HeroService</code> to fetch and save data.</p><span>
</span><p>There&apos;s yet <em>another</em> <code>HighlightDirective</code> that colors elements in yet a different shade.
We should <a href="https://angular.io/docs/ts/latest/guide/ngmodule.html#shared-module" title="Shared modules">do something</a> about the repetition and inconsistencies.
We endure for now.</p><span>
</span><p>The <code>HeroModule</code> is a feature module like any other.</p><span>
</span><p>app/hero/hero.module.ts (class)</p><code language="ts" format="">@NgModule({
  imports: [ CommonModule, FormsModule, routing ],
  // TODO: Remove in RC 6
  providers: [ HeroService ],
  declarations: [
    HeroComponent, HeroDetailComponent, HeroListComponent,
    HighlightDirective
  ]
})
export class HeroModule { }
</code><p>It imports the <code>FormsModule</code> because the <code>HeroDetailComponent</code> template binds with <code>[(ngModel)]</code>. 
It imports a <code>routing</code> object from <code>hero.routing.ts</code> just as <code>ContactModule</code> and <code>CrisisModule</code> do.</p><span>
</span><p>The <code>CrisisModule</code> is much the same. There&apos;s nothing more to say that&apos;s new. </p><span>
</span><p><live-example embedded="" plnkr="pre-shared.3" img="devguide/ngmodule/v3-plunker.png">Try the live example.</live-example></p><span>
</span><a id="shared-module"></a><h2 id="shared-modules">Shared modules</h2><span>
</span><p>The app is shaping up. 
One thing we don&apos;t like is carrying three different versions of the <code>HighlightDirective</code>.
And there&apos;s a bunch of other stuff cluttering the app folder level that could be tucked away.</p><span>
</span><p>Let&apos;s add a <code>SharedModule</code> to hold the common components, directives, and pipes 
and share them with the modules that need them.</p><span>
</span><ul>
<li>create an <code>app/shared</code> folder</li>
<li>move the <code>AwesomePipe</code> and <code>HighlightDirective</code> from <code>app/contact</code> to <code>app/shared</code>.</li>
<li>delete the <code>HighlightDirective</code> classes from <code>app/</code> and <code>app/hero</code></li>
<li>create a <code>SharedModule</code> class to own the shared material</li>
<li>update other feature modules to import <code>SharedModule</code></li>
</ul><span>
</span><p>Most of this is familiar blocking and tackling. Here is the <code>SharedModule</code></p><span>
</span><p>app/app/shared/shared.module.ts</p><code language="ts" format="linenums">import { NgModule }            from &apos;@angular/core&apos;;
import { CommonModule }        from &apos;@angular/common&apos;;
import { FormsModule }         from &apos;@angular/forms&apos;;

import { AwesomePipe }         from &apos;./awesome.pipe&apos;;
import { HighlightDirective }  from &apos;./highlight.directive&apos;;

@NgModule({
  imports:      [ CommonModule ],
  declarations: [ AwesomePipe, HighlightDirective ],
  exports:      [ AwesomePipe, HighlightDirective,
                  CommonModule, FormsModule ]
})
export class SharedModule { }
</code><p>Some highlights</p><span>
</span><ul>
<li>It imports the <code>CommonModule</code> because its component needs common directives.</li>
<li>It declares and exports the utility pipe, directive, and component classes as expected.</li>
<li>It re-exports the <code>CommonModule</code> and <code>FormsModule</code></li>
</ul><span>
</span><h4 id="re-exporting-other-modules">Re-exporting other modules</h4><span>
</span><p>While reviewing our application, we noticed that many components requiring <code>SharedModule</code> directives
also use <code>NgIf</code> and <code>NgFor</code> from <code>CommonModule</code>
and bind to component properties with <code>[(ngModel)]</code>, a directive in the <code>FormsModule</code>.
Modules that declare these components would have to import <code>CommonModule</code>, <code>FormsModule</code> and <code>SharedModule</code>.</p><span>
</span><p>We can reduce the repetition by having <code>SharedModule</code> re-export <code>CommonModule</code> and <code>FormsModule</code>
so that importers of <code>SharedModule</code> get <code>CommonModule</code> and <code>FormsModule</code> <em>for free</em>.</p><span>
</span><p>As it happens, the components declared by <code>SharedModule</code> itself don&apos;t bind with <code>[(ngModel)]</code>. 
Technically,  there is no need for <code>SharedModule</code> to import <code>FormsModule</code>.</p><span>
</span><p><code>SharedModule</code> can still export <code>FormsModule</code> without listing it among its <code>imports</code>.</p><span>
</span><h3 id="why-_titlecomponent_-isn-t-shared">Why <em>TitleComponent</em> isn&apos;t shared</h3><span>
</span><p><code>SharedModule</code> exists to make commonly used components, directives and pipes available
for use in the templates of components in <em>many</em> other modules.</p><span>
</span><p>The <code>TitleComponent</code> is used <em>only once</em> by the <code>AppComponent</code>. 
There&apos;s no point in sharing it.</p><span>
</span><span>
</span><h3 id="why-_userservice_-isn-t-shared">Why <em>UserService</em> isn&apos;t shared</h3><span>
</span><p>While many components share the same service <em>instances</em>,
they rely on Angular dependency injection to do this kind of sharing, not the module system.</p><span>
</span><p>Several components of our sample inject the <code>UserService</code>.
There should be <em>only one</em> instance of the <code>UserService</code> in the entire application 
and <em>only one</em> provider of it.</p><span>
</span><p><code>UserService</code> is an application-wide singleton.
We don&apos;t want each module to have its own separate instance. 
Yet there is <a href="https://angular.io/docs/ts/latest/cookbook/ngmodule-faq.html#q-why-it-is-bad">a real danger</a> of that happening 
if the <code>SharedModule</code> provides the <code>UserService</code>.</p><span>
</span><div class="alert is-critical"><p>Do <strong>not</strong> specify app-wide singleton <code>providers</code> in a shared module.
A lazy loaded module that imports that shared module will make its own copy of the service.</p><span>
</span></div><a id="core-module"></a><h2 id="the-core-module">The Core module</h2><span>
</span><p>At the moment, our root folder is cluttered with the <code>UserService</code>
and the <code>TitleComponent</code> that only appears in the root <code>AppComponent</code>.
We did not include them in the <code>SharedModule</code> for reasons just explained.</p><span>
</span><p>Instead, we&apos;ll gather them in a single <code>CoreModule</code> that we <strong>import <em>once</em> when the app starts</strong>
and <em>never import anywhere else</em>.</p><span>
</span><p><strong>Steps:</strong></p><span>
</span><ul>
<li>create an <code>app/core</code> folder</li>
<li>move the <code>UserService</code> and <code>TitleComponent</code> from <code>app/</code> to <code>app/core</code></li>
<li>create a <code>CoreModule</code> class to own the core material</li>
<li>update the <code>AppRoot</code> module to  import <code>CoreModule</code></li>
</ul><span>
</span><p>Again, most of this is familiar blocking and tackling. The interesting part is the <code>CoreModule</code></p><span>
</span><p>app/app/core/core.module.ts</p><code language="ts" format="linenums">import {
  ModuleWithProviders, NgModule,
  Optional, SkipSelf }       from &apos;@angular/core&apos;;

import { CommonModule }      from &apos;@angular/common&apos;;

import { TitleComponent }    from &apos;./title.component&apos;;
import { UserService }       from &apos;./user.service&apos;;
@NgModule({
  imports:      [ CommonModule ],
  declarations: [ TitleComponent ],
  exports:      [ TitleComponent ],
  providers:    [ UserService ]
})
export class CoreModule {
}
</code><div class="l-sub-section"><p>We&apos;re importing some extra symbols from the Angular core library that we&apos;re not using yet.
They&apos;ll become relevant later in this page.</p><span>
</span></div><p>The <code>@NgModule</code> metadata should be familiar. 
We declare the <code>TitleComponent</code>  because this module <em>owns</em> it and we export it
because <code>AppComponent</code> (which is in <code>AppModule</code>) displays the title in its template.
<code>TitleComponent</code> needs the Angular <code>NgIf</code> directive that we import from <code>CommonModule</code>.</p><span>
</span><p><code>CoreModule</code> <em>provides</em> the <code>UserService</code>. Angular registers that provider with the app root injector,
making a singleton instance of the <code>UserService</code> available to any component that needs it, 
whether that component is eagerly or lazily loaded.</p><span>
</span><div class="l-sub-section"><h4 id="why-bother-">Why bother?</h4><span>
</span><p>This scenario is clearly contrived. 
The app is too small to worry about a single service file and a tiny, one-time component.</p><span>
</span><p>A <code>TitleComponent</code> sitting in the root folder isn&apos;t bothering anyone.
The root <code>AppModule</code> can register the <code>UserService</code> itself,
as it does currently, even if we decide to relocate the <code>UserService</code> file to the <code>app/core</code> folder.</p><span>
</span><p>Real world apps have more to worry about. 
They can have several single-use components (e.g., spinners, message toasts, and modal dialogs)
that appear only in the <code>AppComponent</code> template. 
We don&apos;t import them elsewhere so they&apos;re not <em>shared</em> in that sense. 
Yet they&apos;re too big and messy to leave loose in the root folder.</p><span>
</span><p>Apps often have many singleton services like this sample&apos;s <code>UserService</code>.
Each must be registered <em>exactly once</em>, in the app root injector, when the application starts.</p><span>
</span><p>While many Components inject such services in their constructors &#x2014;
and therefore require JavaScript <code>import</code> statements to import their symbols &#x2014;
no other component or module should define or re-create the services themselves.
Their <em>providers</em> are not shared.</p><span>
</span><p>We recommend collecting such single-use classes and hiding their gory details inside a <code>CoreModule</code>.
A simplified root <code>AppModule</code> imports <code>CoreModule</code> in its capacity as orchestrator of the application as a whole.</p><span>
</span></div><h2 id="cleanup">Cleanup</h2><span>
</span><p>Having refactored to a <code>CoreModule</code> and a <code>SharedModule</code>, it&apos;s time to cleanup the other modules. </p><span>
</span><h3 id="a-trimmer-_appmodule_">A trimmer <em>AppModule</em></h3><span>
</span><p>Here is the updated <code>AppModule</code> paired with version 3 for comparison:</p><span>
</span><code-tabs><code language="ts" name="app/app.module.ts (v4)" format="linenums">import { NgModule }       from &apos;@angular/core&apos;;
import { BrowserModule }  from &apos;@angular/platform-browser&apos;;

/* App Root */
import { AppComponent }   from &apos;./app.component&apos;;

/* Feature Modules */
import { ContactModule }  from &apos;./contact/contact.module&apos;;
import { CoreModule }     from &apos;./core/core.module&apos;;
import { routing }        from &apos;./app.routing&apos;;

@NgModule({
  imports: [
    BrowserModule,
    ContactModule,
    CoreModule,
    routing
  ],
  declarations: [ AppComponent ],
  bootstrap:    [ AppComponent ]
})
export class AppModule { }
</code><code language="ts" name="app/app.module.ts (v3)" format="linenums">import { NgModule }           from &apos;@angular/core&apos;;
import { BrowserModule }      from &apos;@angular/platform-browser&apos;;

/* App Root */
import { AppComponent }       from &apos;./app.component.3&apos;;
import { HighlightDirective } from &apos;./highlight.directive&apos;;
import { TitleComponent }     from &apos;./title.component&apos;;
import { UserService }        from &apos;./user.service&apos;;

/* Feature Modules */
import { ContactModule }      from &apos;./contact/contact.module.3&apos;;
import { routing }            from &apos;./app.routing.3&apos;;

@NgModule({
  imports:      [
    BrowserModule,
    ContactModule,
    routing
  ],
  providers:    [ UserService ],
  declarations: [ AppComponent, HighlightDirective, TitleComponent ],
  bootstrap:    [ AppComponent ]
})
export class AppModule { }
</code></code-tabs><p>Notice that <code>AppModule</code> is ...</p><span>
</span><ul>
<li>a little smaller because many <code>app/root</code> classes have moved to other modules.</li>
<li>stable because we&apos;ll add future components and providers to other modules, not this one.</li>
<li>delegating to imported modules rather than doing work.</li>
<li>focused on its main task, orchestrating the app as a whole.</li>
</ul><span>
</span><span>
</span><p>Here is the new <code>ContactModule</code> paired with the prior version:</p><span>
</span><code-tabs><code language="ts" name="app/contact/contact.module.ts (v4)" format="linenums">import { NgModule }           from &apos;@angular/core&apos;;
import { SharedModule }       from &apos;../shared/shared.module&apos;;

import { ContactComponent }   from &apos;./contact.component&apos;;
import { ContactService }     from &apos;./contact.service&apos;;
import { routing }            from &apos;./contact.routing&apos;;

@NgModule({
  imports:      [ SharedModule, routing ],
  declarations: [ ContactComponent ],
  providers:    [ ContactService ]
})
export class ContactModule { }
</code><code language="ts" name="app/contact/contact.module.ts (v3)" format="linenums">import { NgModule }           from &apos;@angular/core&apos;;
import { CommonModule }       from &apos;@angular/common&apos;;
import { FormsModule }        from &apos;@angular/forms&apos;;

import { AwesomePipe }        from &apos;./awesome.pipe&apos;;

import { ContactComponent }   from &apos;./contact.component.3&apos;;
import { ContactService }     from &apos;./contact.service&apos;;
import { HighlightDirective } from &apos;./highlight.directive&apos;;

import { routing }            from &apos;./contact.routing.3&apos;;

@NgModule({
  imports:      [ CommonModule, FormsModule, routing ],
  declarations: [ ContactComponent, HighlightDirective, AwesomePipe ],
  providers:    [ ContactService ]
})
export class ContactModule { }
</code></code-tabs><p>Notice that</p><span>
</span><ul>
<li>The <code>AwesomePipe</code> and <code>HighlightDirective</code> are gone.</li>
<li>The imports include <code>SharedModule</code> instead of <code>CommonModule</code> and <code>FormsModule</code></li>
<li>This new version is leaner and cleaner.</li>
</ul><span>
</span><a id="core-for-root"></a><h2 id="configure-core-services-with-_coremodule-forroot_">Configure core services with <em>CoreModule.forRoot</em></h2><span>
</span><p>A module that adds providers to the application can offer a facility for configuring those providers as well.</p><span>
</span><p>By convention, the <strong><em>forRoot</em></strong> static method both provides and configures services at the same time.
It takes a service configuration object and returns a
<a href="https://angular.io/docs/ts/latest/api/core/index/ModuleWithProviders-interface.html">ModuleWithProviders</a> which is
a simple object with two properties:</p><span>
</span><ul>
<li><code>ngModule</code> - the <code>CoreModule</code> class</li>
<li><code>providers</code> - the configured providers</li>
</ul><span>
</span><p>The root <code>AppModule</code> imports the <code>CoreModule</code> and adds the <code>providers</code> to the <code>AppModule</code> providers.</p><span>
</span><div class="l-sub-section"><p>More precisely, Angular accumulates all imported providers <em>before</em> appending the items listed in <code>@NgModule.providers</code>. 
This sequence ensures that whatever we add explicitly to the <code>AppModule</code> providers takes precedence 
over the providers of imported modules.</p><span>
</span></div><p>Let&apos;s add a <code>CoreModule.forRoot</code> method that configures the core <code>UserService</code>.</p><span>
</span><p>We&apos;ve extended the core <code>UserService</code> with an optional, injected <code>UserServiceConfig</code>.
If a <code>UserServiceConfig</code> exists, the <code>UserService</code> sets the user name from that config.</p><span>
</span><p>app/core/user.service.ts (constructor)</p><code language="ts" format="">constructor(@Optional() config: UserServiceConfig) {
  if (config) { this._userName = config.userName; }
}
</code><p>Here&apos;s <code>CoreModule.forRoot</code> that takes a <code>UserServiceConfig</code> object:</p><span>
</span><p>app/core/core.module.ts (forRoot)</p><code language="ts" format="">static forRoot(config: UserServiceConfig): ModuleWithProviders {
  return {
    ngModule: CoreModule,
    providers: [
      {provide: UserServiceConfig, useValue: config }
    ]
  };
}
</code><p>Lastly, we call it <em>within the</em> <code>imports</code> <em>list</em> of the <code>AppModule</code>.</p><span>
</span><p>app//app.module.ts (imports)</p><code language="ts" format="">  imports: [
    BrowserModule,
    ContactModule,
    CoreModule.forRoot({userName: &apos;Miss Marple&apos;}),
    routing
  ],
</code><p>The app displays &quot;Miss Marple&quot; as the user instead of the default &quot;Sherlock Holmes&quot;.</p><span>
</span><div class="alert is-important"><p>Call <code>forRoot</code> only in the root application module, <code>AppModule</code>.
Calling it in any other module, particularly in a lazy loaded module,
is contrary to the intent and is likely to produce a runtime error.</p><span>
</span><p>Remember to <em>import</em> the result; don&apos;t add it to any other <code>@NgModule</code> list.</p><span>
</span></div><a id="prevent-reimport"></a><h2 id="prevent-reimport-of-the-_coremodule_">Prevent reimport of the <em>CoreModule</em></h2><span>
</span><p>Only the root <code>AppModule</code> should import the <code>CoreModule</code>. 
<a href="https://angular.io/docs/ts/latest/cookbook/ngmodule-faq.html#q-why-it-is-bad">Bad things happen</a> if a lazy loaded module imports it.</p><span>
</span><p>We could <em>hope</em> that no developer makes that mistake. 
Or we can guard against it and fail fast by adding the following <code>CoreModule</code> constructor.</p><span>
</span><code language="ts" format="">constructor (@Optional() @SkipSelf() parentModule: CoreModule) {
  if (parentModule) {
    throw new Error(
      &apos;CoreModule is already loaded. Import it in the AppModule only&apos;);
  }
}
</code><p>The constructor tells Angular to inject the <code>CoreModule</code> into itself.
That seems dangerously circular.</p><span>
</span><p>The injection <em>would be circular</em> if Angular looked for <code>CoreModule</code> in the <em>current</em> injector.
The <code>@SkipSelf</code> decorator means &quot;<em>look for</em> <code>CoreModule</code> <em>in an ancestor injector, above me in the injector hierarchy.</em>&quot;</p><span>
</span><p>If the constructor executes as intended in the <code>AppModule</code>, 
there is no ancestor injector that could provide an instance of <code>CoreModule</code>.
The injector should give up.</p><span>
</span><p>By default the injector throws an error when it can&apos;t find a requested provider.
The <code>@Optional</code> decorator means not finding the service is OK. 
The injector returns <code>null</code>, the <code>parentModule</code> parameter is null,
and the constructor concludes uneventfully.</p><span>
</span><p>It&apos;s a different story if we improperly import <code>CoreModule</code> into a lazy loaded module such as <code>HeroModule</code> (try it).</p><span>
</span><p>Angular creates a lazy loaded module with its own injector, a <em>child</em> of the root injector.
<code>@SkipSelf</code> causes Angular to look for a <code>CoreModule</code> in the parent injector which this time is the root injector.
Of course it finds the instance imported by the root <code>AppModule</code>. 
Now <code>parentModule</code> exists and the constructor throws the error.</p><span>
</span><h3 id="conclusion">Conclusion</h3><span>
</span><p>You made it! You can examine and download the complete source for this final version from the live example.</p><span>
</span><span>
</span><h3 id="frequently-asked-questions">Frequently Asked Questions</h3><span>
</span><p>Now that you understand Angular Modules, you may be interested
in the companion <a href="https://angular.io/docs/ts/latest/cookbook/ngmodule-faq.html" title="Angular Module FAQs">Angular Module FAQs</a> cookbook
with its ready answers to specific design and implementation questions.</p><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--></div></div>
        </article>
      
        <article>
          <h3>Animations - ts</h3>
          <div><div class="showcase-content"><p>Motion is an important aspect in the design of modern web applications. We want our
user interfaces to have smooth transitions between states, and engaging animations
that call attention where it&apos;s needed. Well-designed animations can make a UI not only
more fun but also easier to use.</p><span>
</span><p>Angular&apos;s animation system gives us what we need to make the kinds of animations we want.
We can build animations that run with the same kind of native performance that we&apos;re used
to with pure CSS animations. But we can also have our animation logic tightly integrated
with the rest of our application code, where they can be easily triggered and controlled.</p><span>
</span><span>
</span><ul>
<li><a href="https://angular.io/docs/ts/latest/guide/animations.html#example-transitioning-between-states">Quickstart Example: Transitioning Between Two States</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/animations.html#states-and-transitions">States and Transitions</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/animations.html#example-entering-and-leaving">Example: Entering and Leaving</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/animations.html#example-entering-and-leaving-from-different-states">Example: Entering and Leaving from Different States</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/animations.html#animatable-properties-and-units">Animatable Properties and Units</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/animations.html#automatic-property-calculation">Automatic Property Calculation</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/animations.html#animation-timing">Animation Timing</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/animations.html#multi-step-animations-with-keyframes">Multi-Step Animations with Keyframes</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/animations.html#parallel-animation-groups">Parallel Animation Groups</a></li>
</ul><span>
</span><div class="l-sub-section"><p>The examples referenced in this chapter are available as a <live-example></live-example>.</p><span>
</span></div><a id="example-transitioning-between-states"></a><h2 id="quickstart-example-transitioning-between-two-states">Quickstart Example: Transitioning Between Two States</h2><span>
</span><figure><img src="https://angular.io/resources/images/devguide/animations/animation_basic_click.gif" alt="A simple transition animation" align="right"></figure><p>Let&apos;s build a simple animation that transitions an element between two states
driven by a model attribute.</p><span>
</span><p>Animations are defined inside <code>@Component</code> metadata. Before we can add some, we need
to import a few animation-specific functions:</p><span>
</span><code language="ts" format="">import {
  Component,
  Input,
  trigger,
  state,
  style,
  transition,
  animate
} from &apos;@angular/core&apos;;
</code><p>With these we can now define an <em>animation trigger</em> called <code>heroState</code> in the component
metadata. It has animated transitions between two states: <code>active</code> and <code>inactive</code>. When a
hero is active, we display the element in a slightly larger size and lighter color.</p><span>
</span><code language="ts" format="">  animations: [
    trigger(&apos;heroState&apos;, [
      state(&apos;inactive&apos;, style({
        backgroundColor: &apos;#eee&apos;,
        transform: &apos;scale(1)&apos;
      })),
      state(&apos;active&apos;,   style({
        backgroundColor: &apos;#cfd8dc&apos;,
        transform: &apos;scale(1.1)&apos;
      })),
      transition(&apos;inactive =&gt; active&apos;, animate(&apos;100ms ease-in&apos;)),
      transition(&apos;active =&gt; inactive&apos;, animate(&apos;100ms ease-out&apos;))
    ])
  ]
</code><div class="alert is-helpful"><p>In this example we are defining animation styles (color and transform) inline in the
animation metadata. In an upcoming release of Angular, support will be added for pulling
the styles in from the component CSS stylesheet instead.</p><span>
</span></div><p>We now have an animation defined but it is not yet used anywhere. We can change that by
attaching it to one or more elements in the component&apos;s template using the &quot;<code>[@triggerName]</code>&quot;
syntax:</p><span>
</span><code language="ts" format="">template: `
  &lt;ul&gt;
    &lt;li *ngFor=&quot;let hero of heroes&quot;
        [@heroState]=&quot;hero.state&quot;
        (click)=&quot;hero.toggleState()&quot;&gt;
      {{hero.name}}
    &lt;/li&gt;
  &lt;/ul&gt;
`,
</code><p>Here we&apos;ve applied the animation trigger to every element repeated by an <code>ngFor</code>. Each of
the repeated elements will animate independently. We&apos;re binding the value of the
attribute to the expression <code>hero.state</code>. We expect it to always be either <code>inactive</code>
or <code>active</code>, since that&apos;s what we have defined animation states for.</p><span>
</span><p>With this setup, an animated transition is shown whenever a hero object changes state!
Here&apos;s the full component implementation:</p><span>
</span><code language="ts" format="linenums">import {
  Component,
  Input,
  trigger,
  state,
  style,
  transition,
  animate
} from &apos;@angular/core&apos;;

import { Heroes } from &apos;./hero.service&apos;;

@Component({
  moduleId: module.id,
  selector: &apos;hero-list-basic&apos;,
  template: `
    &lt;ul&gt;
      &lt;li *ngFor=&quot;let hero of heroes&quot;
          [@heroState]=&quot;hero.state&quot;
          (click)=&quot;hero.toggleState()&quot;&gt;
        {{hero.name}}
      &lt;/li&gt;
    &lt;/ul&gt;
  `,
  styleUrls: [&apos;hero-list.component.css&apos;],
  animations: [
    trigger(&apos;heroState&apos;, [
      state(&apos;inactive&apos;, style({
        backgroundColor: &apos;#eee&apos;,
        transform: &apos;scale(1)&apos;
      })),
      state(&apos;active&apos;,   style({
        backgroundColor: &apos;#cfd8dc&apos;,
        transform: &apos;scale(1.1)&apos;
      })),
      transition(&apos;inactive =&gt; active&apos;, animate(&apos;100ms ease-in&apos;)),
      transition(&apos;active =&gt; inactive&apos;, animate(&apos;100ms ease-out&apos;))
    ])
  ]
})
export class HeroListBasicComponent {
  @Input() heroes: Heroes;
}
</code><h2 id="states-and-transitions">States and Transitions</h2><span>
</span><p>Angular animations are defined in terms of logical <strong>states</strong> and <strong>transitions</strong>
between states.</p><span>
</span><p>An animation state is a string value that we define in our application code. In the example
above we used the states <code>&apos;active&apos;</code> and <code>&apos;inactive&apos;</code> based on the logical state of
hero objects. The source of the state can be a simple object attribute as it was in this case,
or it can be a value computed in a method. The important thing is that we can read it into the
component&apos;s template.</p><span>
</span><p>We can define <em>styles</em> for each animation state:</p><span>
</span><code language="ts" format="">state(&apos;inactive&apos;, style({
  backgroundColor: &apos;#eee&apos;,
  transform: &apos;scale(1)&apos;
})),
state(&apos;active&apos;,   style({
  backgroundColor: &apos;#cfd8dc&apos;,
  transform: &apos;scale(1.1)&apos;
})),
</code><p>These <code>state</code> definitions specify the <em>end styles</em> of each state.
They are applied to the element once it has transitioned to that state, and will stay
<em>as long as it remains in that state</em>. In that sense, we are defining more than just
animations here. We&apos;re actually defining what styles the element has in different states.</p><span>
</span><p>Once we have states, we can define <em>transitions</em> between the states. Each transition
controls the timing of switching between one set of styles and the next:</p><span>
</span><code language="ts" format="">transition(&apos;inactive =&gt; active&apos;, animate(&apos;100ms ease-in&apos;)),
transition(&apos;active =&gt; inactive&apos;, animate(&apos;100ms ease-out&apos;))
</code><figure class="image-display"><img src="https://angular.io/resources/images/devguide/animations/ng_animate_transitions_inactive_active.png" alt="In Angular animations we defines states and transitions between states" width="400"></figure><p>If we have the same timing configuration for several transitions, we can combine
them into the same <code>transition</code> definition:</p><span>
</span><code language="ts" format="">transition(&apos;inactive =&gt; active, active =&gt; inactive&apos;,
 animate(&apos;100ms ease-out&apos;))
</code><p>When we have the same timing for both directions of a transition, as we do in the previous
example, we can use the <code>&lt;=&gt;</code> shorthand syntax:</p><span>
</span><code language="ts" format="">transition(&apos;inactive &lt;=&gt; active&apos;, animate(&apos;100ms ease-out&apos;))
</code><p>Sometimes we have styles that we want to apply during an animation but not keep around
after it finishes. We can define such styles inline in the <code>transition</code>. In this example,
the element receives one set of styles immediately and is then animated to the next.
When the transition finishes, none of these styles will be kept because they&apos;re not
defined in a <code>state</code>.</p><span>
</span><code language="ts" format="">transition(&apos;inactive =&gt; active&apos;, [
  style({
    backgroundColor: &apos;#cfd8dc&apos;,
    transform: &apos;scale(1.3)&apos;
  }),
  animate(&apos;80ms ease-in&apos;, style({
    backgroundColor: &apos;#eee&apos;,
    transform: &apos;scale(1)&apos;
  }))
]),
</code><h3 id="the-wildcard-state-">The wildcard state <code>*</code></h3><span>
</span><p>The <code>*</code> (&quot;wildcard&quot;) state matches <em>any</em> animation state. This is useful for defining styles and
transitions that should apply regardless of which state the animation is in. For example:</p><span>
</span><ul>
<li>The <code>active =&gt; *</code> transition applies when the element&apos;s state changes from <code>active</code> to anything else.</li>
<li>The <code>* =&gt; *</code> transition applies when <em>any</em> change between two states takes place.</li>
</ul><span>
</span><figure class="image-display"><img src="https://angular.io/resources/images/devguide/animations/ng_animate_transitions_inactive_active_wildcards.png" alt="The wildcard state can be used to match many different transitions at once" width="400"></figure><h3 id="the-void-state">The <code>void</code> state</h3><span>
</span><p>There&apos;s one special state called <code>void</code> that may apply to any animation. It applies
when the element is <em>not</em> attached to a view. This may be because it has not yet been
added or because it has been removed. The <code>void</code> state is useful for defining &quot;enter&quot; and
&quot;leave&quot; animations.</p><span>
</span><p>For example the <code>* =&gt; void</code> transition applies when the element leaves the view,
regardless of what state it was in before it left.</p><span>
</span><figure class="image-display"><img src="https://angular.io/resources/images/devguide/animations/ng_animate_transitions_void_in.png" alt="The void state can be used for enter and leave transitions" width="400"></figure><p>The wildcard state <code>*</code> also matches <code>void</code>.</p><span>
</span><h2 id="example-entering-and-leaving">Example: Entering and Leaving</h2><span>
</span><figure><img src="https://angular.io/resources/images/devguide/animations/animation_enter_leave.gif" alt="Enter and leave animations" align="right"></figure><p>Using the <code>void</code> and <code>*</code> states we can define transitions that animate the
entering and leaving of elements:</p><span>
</span><ul>
<li>Enter: <code>void =&gt; *</code></li>
<li>Leave: <code>* =&gt; void</code></li>
</ul><span>
</span><code language="ts" format="">animations: [
  trigger(&apos;flyInOut&apos;, [
    state(&apos;in&apos;, style({transform: &apos;translateX(0)&apos;})),
    transition(&apos;void =&gt; *&apos;, [
      style({transform: &apos;translateX(-100%)&apos;}),
      animate(100)
    ]),
    transition(&apos;* =&gt; void&apos;, [
      animate(100, style({transform: &apos;translateX(100%)&apos;}))
    ])
  ])
]
</code><p>Note that in this case we have the styles applied to the void state directly in the
transition definitions, and not in a separate <code>state(void)</code> definition. We do this because
we want the transforms to be different on enter and leave: The element enters from the left
and leaves to the right.</p><span>
</span><h2 id="example-entering-and-leaving-from-different-states">Example: Entering and Leaving from Different States</h2><span>
</span><figure><img src="https://angular.io/resources/images/devguide/animations/animation_enter_leave_states.gif" alt="Enter and leave animations combined with state animations" align="right"></figure><p>We can also combine this animation with the earlier state transition animation by
using the hero state as the animation state. What this will let us do is configure
different transitions for entering and leaving based on what the state of the hero
is:</p><span>
</span><ul>
<li>Inactive hero enter: <code>void =&gt; inactive</code></li>
<li>Active hero enter: <code>void =&gt; active</code></li>
<li>Inactive hero leave: <code>inactive =&gt; void</code></li>
<li>Active hero leave: <code>active =&gt; void</code></li>
</ul><span>
</span><p>We now have fine-grained control over each transition:</p><span>
</span><figure class="image-display"><img src="https://angular.io/resources/images/devguide/animations/ng_animate_transitions_inactive_active_void.png" alt="This example transitions between active, inactive, and void states" width="400"></figure><code language="ts" format="">animations: [
  trigger(&apos;heroState&apos;, [
    state(&apos;inactive&apos;, style({transform: &apos;translateX(0) scale(1)&apos;})),
    state(&apos;active&apos;,   style({transform: &apos;translateX(0) scale(1.1)&apos;})),
    transition(&apos;inactive =&gt; active&apos;, animate(&apos;100ms ease-in&apos;)),
    transition(&apos;active =&gt; inactive&apos;, animate(&apos;100ms ease-out&apos;)),
    transition(&apos;void =&gt; inactive&apos;, [
      style({transform: &apos;translateX(-100%) scale(1)&apos;}),
      animate(100)
    ]),
    transition(&apos;inactive =&gt; void&apos;, [
      animate(100, style({transform: &apos;translateX(100%) scale(1)&apos;}))
    ]),
    transition(&apos;void =&gt; active&apos;, [
      style({transform: &apos;translateX(0) scale(0)&apos;}),
      animate(200)
    ]),
    transition(&apos;active =&gt; void&apos;, [
      animate(200, style({transform: &apos;translateX(0) scale(0)&apos;}))
    ])
  ])
]
</code><h2 id="animatable-properties-and-units">Animatable Properties and Units</h2><span>
</span><p>Since Angular&apos;s animation support builds on top of Web Animations, we can animate any property
that the browser considers <em>animatable</em>. This includes positions, sizes, transforms, colors,
borders and many others. The W3C maintains
<a href="https://www.w3.org/TR/css3-transitions/#animatable-properties">a list of animatable properties</a>.</p><span>
</span><p>For positional properties that have a numeric value, we can define a unit by providing
the value as a string with the appropriate suffix:</p><span>
</span><span>
</span><p>For most dimensional properties we can also just define a number which is then assumed to be
in pixels:</p><span>
</span><ul>
<li><code>50</code> is the same as saying <code>&apos;50px&apos;</code></li>
</ul><span>
</span><h2 id="automatic-property-calculation">Automatic Property Calculation</h2><span>
</span><figure><img src="https://angular.io/resources/images/devguide/animations/animation_auto.gif" alt="Animation with automated height calculation" align="right"></figure><p>Sometimes the value of a dimensional style property that we want to
animate is not known until at runtime. For example, it is quite common for elements
to have widths and heights that depend on their content and the screen size. These
properties are often tricky to animate with CSS.</p><span>
</span><p>With Angular we can use a special <code>*</code> property value in these cases. What it means
is that the value of this property will be computed at runtime and then plugged into
the animation.</p><span>
</span><p>The &quot;leave&quot; animation in this example takes whatever height the element has before it
leaves and animates from that height to zero:</p><span>
</span><code language="ts" format="">animations: [
  trigger(&apos;shrinkOut&apos;, [
    state(&apos;in&apos;, style({height: &apos;*&apos;})),
    transition(&apos;* =&gt; void&apos;, [
      style({height: &apos;*&apos;}),
      animate(250, style({height: 0}))
    ])
  ])
]
</code><h2 id="animation-timing">Animation Timing</h2><span>
</span><p>There are three timing properties we can tune for every animated transition:
The duration, the delay, and the easing function. They are all combined into
a single transition <em>timing string</em>.</p><span>
</span><h3 id="duration">Duration</h3><span>
</span><p>The duration controls how long the animation takes to run from start to finish.
We can define a duration in three ways:</p><span>
</span><ul>
<li>As a plain number, in milliseconds: <code>100</code></li>
<li>In a string, as milliseconds: <code>&apos;100ms&apos;</code></li>
<li>In a string, as seconds: <code>&apos;0.1s&apos;</code></li>
</ul><span>
</span><h3 id="delay">Delay</h3><span>
</span><p>The delay controls how long to wait after an animation triggers before the
transition actually begins. We can define one by adding it in the same string
following the duration. It also has the same format options as the duration:</p><span>
</span><ul>
<li>Wait for 100ms and then run for 200ms: <code>&apos;0.2s 100ms&apos;</code></li>
</ul><span>
</span><h3 id="easing">Easing</h3><span>
</span><p>The <a href="http://easings.net/">easing function</a> controls how the animation accelerates
and decelerates during its runtime. For example, using an <code>ease-in</code> function means
the animation begins relatively slowly but then picks up speed as it progresses. We
can control the easing by adding it as a <em>third</em> value in the string after the duration
and the delay (or as the <em>second</em> value when there is no delay):</p><span>
</span><ul>
<li>Wait for 100ms and then run for 200ms, with easing: <code>&apos;0.2s 100ms ease-out&apos;</code></li>
<li>Run for 200ms, with easing: <code>&apos;0.2s ease-in-out&apos;</code></li>
</ul><span>
</span><figure><img src="https://angular.io/resources/images/devguide/animations/animation_timings.gif" alt="Animations with specific timings" align="right"></figure><h3 id="example">Example</h3><span>
</span><p>Here are a couple of custom timings in action. Both &quot;enter&quot; and &quot;leave&quot; last for
200 milliseconds but they have different easings. The leave begins after a
slight delay:</p><span>
</span><code language="ts" format="">animations: [
  trigger(&apos;flyInOut&apos;, [
    state(&apos;in&apos;, style({opacity: 1, transform: &apos;translateX(0)&apos;})),
    transition(&apos;void =&gt; *&apos;, [
      style({
        opacity: 0,
        transform: &apos;translateX(-100%)&apos;
      }),
      animate(&apos;0.2s ease-in&apos;)
    ]),
    transition(&apos;* =&gt; void&apos;, [
      animate(&apos;0.2s 10 ease-out&apos;, style({
        opacity: 0,
        transform: &apos;translateX(100%)&apos;
      }))
    ])
  ])
]
</code><h2 id="multi-step-animations-with-keyframes">Multi-Step Animations with Keyframes</h2><span>
</span><figure><img src="https://angular.io/resources/images/devguide/animations/animation_multistep.gif" alt="Animations with some bounce implemented with keyframes" align="right"></figure><p>With animation <em>keyframes</em> we can go beyond a simple transition between two
sets of styles to a more intricate animation that goes through one or more
intermediate styles in between.</p><span>
</span><p>For each keyframe, we can specify an <em>offset</em> that defines at which point
in the animation that keyframe applies. The offset is a number between zero,
which marks the beginning of the animation, and one, which marks the end.</p><span>
</span><p>In this example we add some &quot;bounce&quot; to our enter and leave animations with
keyframes:</p><span>
</span><code language="ts" format="">animations: [
  trigger(&apos;flyInOut&apos;, [
    state(&apos;in&apos;, style({transform: &apos;translateX(0)&apos;})),
    transition(&apos;void =&gt; *&apos;, [
      animate(300, keyframes([
        style({opacity: 0, transform: &apos;translateX(-100%)&apos;, offset: 0}),
        style({opacity: 1, transform: &apos;translateX(15px)&apos;,  offset: 0.3}),
        style({opacity: 1, transform: &apos;translateX(0)&apos;,     offset: 1.0})
      ]))
    ]),
    transition(&apos;* =&gt; void&apos;, [
      animate(300, keyframes([
        style({opacity: 1, transform: &apos;translateX(0)&apos;,     offset: 0}),
        style({opacity: 1, transform: &apos;translateX(-15px)&apos;, offset: 0.7}),
        style({opacity: 0, transform: &apos;translateX(100%)&apos;,  offset: 1.0})
      ]))
    ])
  ])
]
</code><p>Note that the offsets are <em>not</em> defined in terms of absolute time. They are relative
measures from 0 to 1. The final timeline of the animation will based on the combination
of keyframe offsets, duration, delay, and easing.</p><span>
</span><p>Defining offsets for keyframes is optional. If we omit them, offsets with even
spacing are automatically assigned. For example, three keyframes without predefined
offsets will receive offsets <code>0</code>, <code>0.5</code>, and <code>1</code>.</p><span>
</span><h2 id="parallel-animation-groups">Parallel Animation Groups</h2><span>
</span><figure><img src="https://angular.io/resources/images/devguide/animations/animation_groups.gif" alt="Parallel animations with different timings, implemented with groups" align="right"></figure><p>We&apos;ve already seen how we can animate multiple style properties at the same time:
Just put all of them into the same <code>style()</code> definition!</p><span>
</span><p>But we may also want to configure different <em>timings</em> for animations that happen
in parallel. For example, we may want to animate two CSS properties but use a
different easing function for each one.</p><span>
</span><p>For this we can use animation <em>groups</em>. In this example we use groups both on
enter and leave so that we can use two different timing configurations. Both
are applied to the same element in parallel, but run independent of each other:</p><span>
</span><code language="ts" format="">animations: [
  trigger(&apos;flyInOut&apos;, [
    state(&apos;in&apos;, style({width: 120, transform: &apos;translateX(0)&apos;, opacity: 1})),
    transition(&apos;void =&gt; *&apos;, [
      style({width: 10, transform: &apos;translateX(50px)&apos;, opacity: 0}),
      group([
        animate(&apos;0.3s 0.1s ease&apos;, style({
          transform: &apos;translateX(0)&apos;,
          width: 120
        })),
        animate(&apos;0.3s ease&apos;, style({
          opacity: 1
        }))
      ])
    ]),
    transition(&apos;* =&gt; void&apos;, [
      group([
        animate(&apos;0.3s ease&apos;, style({
          transform: &apos;translateX(50px)&apos;,
          width: 10
        })),
        animate(&apos;0.3s 0.2s ease&apos;, style({
          opacity: 0
        }))
      ])
    ])
  ])
]
</code><p>One group animates the element transform and width. The other animates the opacity.</p><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--></div></div>
        </article>
      
        <article>
          <h3>Attribute Directives</h3>
          <div><div class="showcase-content"><p>An <strong>Attribute</strong> directive changes the appearance or behavior of a DOM element.</p><span>
</span><p>In this chapter we will</p><span>
</span><ul>
<li><a href="https://angular.io/docs/ts/latest/guide/attribute-directives.html#write-directive">write an attribute directive to change the background color</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/attribute-directives.html#apply-directive">apply the attribute directive to an element in a template</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/attribute-directives.html#respond-to-user">respond to user-initiated events</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/attribute-directives.html#bindings">pass values into the directive using data binding</a></li>
</ul><span>
</span><p>Try the <live-example></live-example>.</p><span>
</span><h2 id="directives-overview">Directives overview</h2><span>
</span><p>There are three kinds of directives in Angular:</p><span>
</span><ol>
<li>Components</li>
<li>Structural directives  </li>
<li>Attribute directives</li>
</ol><span>
</span><p>A <em>Component</em> is really a directive with a template. 
It&apos;s the most common of the three directives and we tend to write lots of them as we build applications.</p><span>
</span><p><a href="https://angular.io/docs/ts/latest/guide/structural-directives.html"><em>Structural</em> directives</a> can change the DOM layout by adding and removing DOM elements. 
<a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#ngFor">NgFor</a> and <a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#ngIf">NgIf</a> are two familiar examples.</p><span>
</span><p>An <em>Attribute</em> directive can change the appearance or behavior of an element.
The built-in <a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#ngStyle">NgStyle</a> directive, for example,
can change several element styles at the same time.</p><span>
</span><p>We are going to write our own attribute directive to set an element&apos;s background color
when the user hovers over that element.</p><span>
</span><div class="l-sub-section"><p>We don&apos;t need <em>any</em> directive to simply set the background color.
We can set it with the special <a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#style-binding">Style Binding</a> like this:</p><span>
</span><code language="html" format="">&lt;p [style.background]=&quot;&apos;lime&apos;&quot;&gt;I am green with envy!&lt;/p&gt;
</code><p>That wouldn&apos;t be nearly as much fun as creating our own directive.</p><span>
</span><p>Besides, we&apos;re not just <em>setting</em> the color; we&apos;ll be <em>changing</em> the color
in response to a user action, a mouse hover.</p><span>
</span></div><a id="write-directive"></a><h2 id="build-a-simple-attribute-directive">Build a simple attribute directive</h2><span>
</span><p>An attribute directive minimally requires building a controller class annotated with 
<code>@Directive</code>, which specifies the selector identifying
the attribute associated with the directive. 
The controller class implements the desired directive behavior.</p><span>
</span><p>Let&apos;s build a small illustrative example together.</p><span>
</span><h3 id="our-first-draft">Our first draft</h3><span>
</span><p>Create a new project folder (<code>attribute-directives</code>) and follow the steps in the <a href="https://angular.io/docs/ts/latest/quickstart.html">QuickStart</a>.</p><span>
</span><p>Create the following source file in the indicated folder with the given code:</p><span>
</span><p>app/highlight.directive.ts</p><code language="ts" format="linenums">import { Directive, ElementRef, Input, Renderer } from &apos;@angular/core&apos;;

@Directive({ selector: &apos;[myHighlight]&apos; })
export class HighlightDirective {
    constructor(el: ElementRef, renderer: Renderer) {
       renderer.setElementStyle(el.nativeElement, &apos;backgroundColor&apos;, &apos;yellow&apos;);
    }
}
</code><p>We begin by importing some symbols from the Angular <code>core</code>.
We need the <code>Directive</code> symbol for the <code>@Directive</code> decorator.
We need the <code>ElementRef</code> to <a href="https://angular.io/docs/ts/latest/guide/dependency-injection.html">inject</a> into the directive&apos;s constructor
so we can access the DOM element.
We also need <code>Renderer</code> so we can change the DOM element&apos;s style.
We don&apos;t need <code>Input</code> immediately but we will need it later in the chapter.</p><span>
</span><p>Then we define the directive metadata in a configuration object passed
as an argument to the <code>@Directive</code> decorator function. </p><span>
</span><p><code>@Directive</code> requires a CSS selector to identify
the HTML in the template that is associated with our directive.
The <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Attribute_selectors">CSS selector for an attribute</a>
is the attribute name in square brackets.
Our directive&apos;s selector is <code>[myHighlight]</code>. 
Angular will locate all elements in the template that have an attribute named <code>myHighlight</code>. </p><span>
</span><div class="l-sub-section"><h3 id="why-not-call-it-highlight-">Why not call it &quot;highlight&quot;?</h3><span>
</span><p><em>highlight</em> is a nicer name than <em>myHighlight</em> and, technically, it would work if we called it that.</p><span>
</span><p>However, we recommend picking a selector name with a prefix to ensure
that it cannot conflict with any standard HTML attribute, now or in the future.
There is also less risk of colliding with a third-party directive name when we give ours a prefix.</p><span>
</span><p>We do <strong>not</strong> prefix our <code>highlight</code> directive name with <strong><code>ng</code></strong>.
That prefix belongs to Angular.</p><span>
</span><p>We need a prefix of our own, preferably short, and <code>my</code> will do for now.</p><span>
</span></div><p>After the <code>@Directive</code> metadata comes the directive&apos;s controller class, which contains the logic for the directive. We export `HighlightDirective` to make it accessible to other components.</p><p>Angular creates a new instance of the directive&apos;s controller class for
each matching element, injecting an Angular <code>ElementRef</code> and <code>Renderer</code>
into the constructor.
<code>ElementRef</code> is a service that grants us direct access to the DOM element
through its <code>nativeElement</code> property and with <code>Renderer</code> we can set the element style.</p><span>
</span><a id="apply-directive"></a><h2 id="apply-the-attribute-directive">Apply the attribute directive</h2><span>
</span><p>The <code>AppComponent</code> in this sample is a test harness for our <code>HighlightDirective</code>.
Let&apos;s give it a new template that 
applies the directive as an attribute to a paragraph (<code>p</code>) element.
In Angular terms, the <code>&lt;p&gt;</code> element will be the attribute <strong>host</strong>.</p><span>
</span><p>We&apos;ll put the template in its own <code>app.component.html</code>file that looks like this:</p><p>app/app.component.html</p><code language="html" format="">&lt;h1&gt;My First Attribute Directive&lt;/h1&gt;
&lt;p myHighlight&gt;Highlight me!&lt;/p&gt;
</code><p>A separate template file is clearly overkill for a 2-line template. 
Hang in there; we&apos;re going to expand it later.
Meanwhile, we&apos;ll revise the <code>AppComponent</code> to reference this template.</p><span>
</span><p>app/app.component.ts</p><code language="ts" format="linenums">import { Component } from &apos;@angular/core&apos;;

@Component({
  selector: &apos;my-app&apos;,
  templateUrl: &apos;app/app.component.html&apos;
})

export class AppComponent { }
</code><p>We&apos;ll add an <code>import</code> statement to fetch the &apos;Highlight&apos; directive and, 
added that class to the <code>declarations</code> NgModule metadata so that Angular 
will recognize our directive when it encounters <code>myHighlight</code> in the template. </p><span>
</span><p>app/app.module.ts</p><code language="ts" format="linenums">import { NgModule } from &apos;@angular/core&apos;;
import { BrowserModule } from &apos;@angular/platform-browser&apos;;

import { AppComponent } from &apos;./app.component&apos;;
import { HighlightDirective } from &apos;./highlight.directive&apos;;

@NgModule({
  imports: [ BrowserModule ],
  declarations: [
    AppComponent,
    HighlightDirective
  ],
  bootstrap: [ AppComponent ]
})
export class AppModule { }
</code><p>We run the app and see that our directive highlights the paragraph text.</p><span>
</span><figure class="image-display"><img src="https://angular.io/resources/images/devguide/attribute-directives/first-highlight.png" alt="First Highlight"></figure><div class="l-sub-section"><h3 id="your-directive-isn-t-working-">Your directive isn&apos;t working?</h3><span>
</span><p>Did you remember to add the directive to the the <code>declarations</code> attribute of <code>@NgModule</code>? It is easy to forget!</p><span>
</span><p>Open the console in the browser tools and look for an error like this:</p><span>
</span><code format="nocode">EXCEPTION: Template parse errors:
  Can&apos;t bind to &apos;myHighlight&apos; since it isn&apos;t a known property of &apos;p&apos;.</code><p>Angular detects that we&apos;re trying to bind to <em>something</em> but it doesn&apos;t know what.
We have to tell it by listing <code>HighlightDirective</code> in the <code>declarations</code> metadata array.</p><span>
</span></div><p>Let&apos;s recap what happened.</p><span>
</span><p>Angular found the <code>myHighlight</code> attribute on the <code>&lt;p&gt;</code> element. It created
an instance of the <code>HighlightDirective</code> class, 
injecting a reference to the element into the constructor 
where we set the <code>&lt;p&gt;</code> element&apos;s background style to yellow.</p><span>
</span><a id="respond-to-user"></a><h2 id="respond-to-user-action">Respond to user action</h2><span>
</span><p>We are not satisfied to simply set an element color.
Our directive should set the color in response to a user action.
Specifically, we want to set the color when the user hovers over an element.</p><span>
</span><p>We&apos;ll need to</p><span>
</span><ol>
<li>detect when the user hovers into and out of the element,</li>
<li>respond to those actions by setting and clearing the highlight color, respectively.</li>
</ol><span>
</span><p>We apply the <code>@HostListener</code> decorator to methods which are called when an event is raised.</p><span>
</span><code language="ts" format="">@HostListener(&apos;mouseenter&apos;) onMouseEnter() {
/* . . . */
}

@HostListener(&apos;mouseleave&apos;) onMouseLeave() {
/* . . . */
}
</code><div class="l-sub-section"><p>The <code>@HostListener</code> decorator refers to the DOM element that hosts our attribute directive, the <code>&lt;p&gt;</code> in our case.</p><span>
</span><p>We could have attached event listeners by manipulating the host DOM element directly, but
there are at least three problems with such an approach:</p><span>
</span><ol>
<li>We have to write the listeners correctly.</li>
<li>We must <em>detach</em> our listener when the directive is destroyed to avoid memory leaks.</li>
<li>We&apos;d be talking to DOM API directly which, we learned, is something to avoid.</li>
</ol><span>
</span><p>Let&apos;s roll with the <code>@HostListener</code> decorator. </p><span>
</span></div><p>Now we implement the two mouse event handlers:</p><span>
</span><code language="ts" format="">  @HostListener(&apos;mouseenter&apos;) onMouseEnter() {
    this.highlight(&apos;yellow&apos;);
  }

  @HostListener(&apos;mouseleave&apos;) onMouseLeave() {
    this.highlight(null);
  }

  private highlight(color: string) {
    this.renderer.setElementStyle(this.el.nativeElement, &apos;backgroundColor&apos;, color);
  }
</code><p>Notice that they delegate to a helper method that sets the color via a private local variable, <code>el</code>.
We revise the constructor to capture the <code>ElementRef.nativeElement</code> in this variable.</p><span>
</span><code language="ts" format="">constructor(private el: ElementRef, private renderer: Renderer) { }
</code><p>Here&apos;s the updated directive:</p><span>
</span><p>app/highlight.directive.ts</p><code language="ts" format="linenums">import { Directive, ElementRef, HostListener, Input, Renderer } from &apos;@angular/core&apos;;

@Directive({
  selector: &apos;[myHighlight]&apos;
})

export class HighlightDirective {
  constructor(private el: ElementRef, private renderer: Renderer) { }

  @HostListener(&apos;mouseenter&apos;) onMouseEnter() {
    this.highlight(&apos;yellow&apos;);
  }

  @HostListener(&apos;mouseleave&apos;) onMouseLeave() {
    this.highlight(null);
  }

  private highlight(color: string) {
    this.renderer.setElementStyle(this.el.nativeElement, &apos;backgroundColor&apos;, color);
  }

}
</code><p>We run the app and confirm that the background color appears as we move the mouse over the <code>p</code> and
disappears as we move out.</p><span>
</span><figure class="image-display"><img src="https://angular.io/resources/images/devguide/attribute-directives/highlight-directive-anim.gif" alt="Second Highlight"></figure><a id="bindings"></a><h2 id="configure-the-directive-with-binding">Configure the directive with binding</h2><span>
</span><p>Currently the highlight color is hard-coded within the directive. That&apos;s inflexible.
We should set the color externally with a binding like this:</p><span>
</span><code language="html" format="">&lt;p [myHighlight]=&quot;color&quot;&gt;Highlight me!&lt;/p&gt;
</code><p>We&apos;ll extend our directive class with a bindable <strong>input</strong> <code>highlightColor</code> property and use it when we highlight text.</p><span>
</span><p>Here is the final version of the class:</p><span>
</span><p>app/highlight.directive.ts (class)</p><code language="ts" format="">export class HighlightDirective {
  private _defaultColor = &apos;red&apos;;

  constructor(private el: ElementRef, private renderer: Renderer) { }

  @Input(&apos;myHighlight&apos;) highlightColor: string;

  @HostListener(&apos;mouseenter&apos;) onMouseEnter() {
    this.highlight(this.highlightColor || this._defaultColor);
  }
  @HostListener(&apos;mouseleave&apos;) onMouseLeave() {
    this.highlight(null);
  }

  private highlight(color: string) {
    this.renderer.setElementStyle(this.el.nativeElement, &apos;backgroundColor&apos;, color);
  }
}
</code><a id="input"></a><p>The new <code>highlightColor</code> property is called an <em>input</em> property because data flows from the binding expression into our directive.
Notice the <code>@Input()</code> decorator applied to the property.</p><span>
</span><p>app/highlight.directive.ts (color)</p><code language="ts" format="">@Input(&apos;myHighlight&apos;) highlightColor: string;
</code><p><code>@Input</code> adds metadata to the class that makes the <code>highlightColor</code> property available for 
property binding under the <code>myHighlight</code> alias. 
We must add this input metadata or Angular will reject the binding.
See the <a href="https://angular.io/docs/ts/latest/guide/attribute-directives.html#why-input">appendix</a> below to learn why.</p><span>
</span><div class="l-sub-section"><h3 id="-input-_alias_-">@Input(<em>alias</em>)</h3><span>
</span><p>The developer who uses this directive expects to bind to the attribute name, <code>myHighlight</code>.
The directive property name is <code>highlightColor</code>. That&apos;s a disconnect.</p><span>
</span><p>We could resolve the discrepancy by renaming the property to <code>myHighlight</code> and define it as follows:</p><span>
</span><code language="ts" format="">@Input() myHighlight: string;
</code><p>Maybe we don&apos;t want that property name inside the directive perhaps because it 
doesn&apos;t express our intention well. 
We can <strong>alias</strong> the <code>highlightColor</code> property with the attribute name by
passing <code>myHighlight</code> into the <code>@Input</code> decorator:</p><span>
</span><code language="ts" format="">@Input(&apos;myHighlight&apos;) highlightColor: string;
</code></div><p>Now that we&apos;re getting the highlight color as an input, we modify the <code>onMouseEnter()</code> method to use
it instead of the hard-coded color name.
We also define red as the default color to fallback on in case
the user neglects to bind with a color.</p><span>
</span><code language="ts" format="">@HostListener(&apos;mouseenter&apos;) onMouseEnter() {
  this.highlight(this.highlightColor || this._defaultColor);
}
</code><p>Now we&apos;ll update our <code>AppComponent</code> template to let 
users pick the highlight color and bind their choice to our directive.</p><span>
</span><p>Here is the updated template:</p><span>
</span><code language="html" format="">&lt;h1&gt;My First Attribute Directive&lt;/h1&gt;
&lt;h4&gt;Pick a highlight color&lt;/h4&gt;
&lt;div&gt;
  &lt;input type=&quot;radio&quot; name=&quot;colors&quot; (click)=&quot;color=&apos;lightgreen&apos;&quot;&gt;Green
  &lt;input type=&quot;radio&quot; name=&quot;colors&quot; (click)=&quot;color=&apos;yellow&apos;&quot;&gt;Yellow
  &lt;input type=&quot;radio&quot; name=&quot;colors&quot; (click)=&quot;color=&apos;cyan&apos;&quot;&gt;Cyan
&lt;/div&gt;
&lt;p [myHighlight]=&quot;color&quot;&gt;Highlight me!&lt;/p&gt;
</code><div class="l-sub-section"><h3 id="where-is-the-templated-color-property-">Where is the templated <em>color</em> property?</h3><span>
</span><p>The eagle-eyed may notice that the radio button click handlers in the template set a <code>color</code> property
and we are binding that <code>color</code> to the directive. 
We should expect to find a <code>color</code> on the host <code>AppComponent</code>.</p><span>
</span><p><strong>We never defined a color property for the host <em>AppComponent</em></strong>!
And yet this code works. Where is the template <code>color</code> value going?</p><span>
</span><p>Browser debugging reveals that Angular dynamically added a <code>color</code> property 
to the runtime instance of the <code>AppComponent</code>.</p><span>
</span><p>This is <em>convenient</em> behavior but it is also <em>implicit</em> behavior that could be confusing. 
While it&apos;s cool that this technique works, we recommend adding the <code>color</code> property to the <code>AppComponent</code>.</p><span>
</span></div><p>Here is our second version of the directive in action.</p><span>
</span><figure class="image-display"><img src="https://angular.io/resources/images/devguide/attribute-directives/highlight-directive-v2-anim.gif" alt="Highlight v.2"></figure><h2 id="bind-to-a-second-property">Bind to a second property</h2><span>
</span><p>Our directive only has a single, customizable property. What if we had <strong><em>two properties</em></strong>?</p><span>
</span><p>Let&apos;s allow the template developer to set the default color, the color that prevails until the user picks a highlight color.
We&apos;ll add a second <strong>input</strong> property to <code>HighlightDirective</code> called <code>defaultColor</code>:</p><span>
</span><code language="ts" format="">@Input() set defaultColor(colorName: string){
  this._defaultColor = colorName || this._defaultColor;
}
</code><p>The <code>defaultColor</code> property has a setter that overrides the hard-coded default color, &quot;red&quot;.
We don&apos;t need a getter.</p><span>
</span><p>How do we bind to it? We already &quot;burned&quot; the <code>myHighlight</code> attribute name as a binding target.</p><span>
</span><p>Remember that a <em>component is a directive too</em>. 
We can add as many component property bindings as we need by stringing them along in the template
as in this example that sets the <code>a</code>, <code>b</code>, <code>c</code> properties to the string literals &apos;a&apos;, &apos;b&apos;, and &apos;c&apos;. </p><span>
</span><code format=".">&lt;my-component [a]=&quot;&apos;a&apos;&quot; [b]=&quot;&apos;b&apos;&quot; [c]=&quot;&apos;c&apos;&quot;&gt;&lt;my-component&gt;</code><p>We do the same thing with an attribute directive.</p><span>
</span><code language="html" format="">&lt;p [myHighlight]=&quot;color&quot; [defaultColor]=&quot;&apos;violet&apos;&quot;&gt;
  Highlight me too!
&lt;/p&gt;
</code><p>Here we&apos;re binding the user&apos;s color choice to the <code>myHighlight</code> attribute as we did before.
We&apos;re <em>also</em> binding the literal string, &apos;violet&apos;, to the <code>defaultColor</code>.</p><span>
</span><p>Here is the final version of the directive in action.</p><span>
</span><figure class="image-display"><img src="https://angular.io/resources/images/devguide/attribute-directives/highlight-directive-final-anim.gif" alt="Final Highlight"></figure><h2 id="summary">Summary</h2><span>
</span><p>We now know how to</p><span>
</span><ul>
<li><a href="https://angular.io/docs/ts/latest/guide/attribute-directives.html#write-directive">build a simple <strong>attribute directive</strong> to attach behavior to an HTML element</a>,</li>
<li><a href="https://angular.io/docs/ts/latest/guide/attribute-directives.html#apply-directive">use that directive in a template</a>,</li>
<li><a href="https://angular.io/docs/ts/latest/guide/attribute-directives.html#respond-to-user">respond to <strong>events</strong> to change behavior based on an event</a>,</li>
<li>and <a href="https://angular.io/docs/ts/latest/guide/attribute-directives.html#bindings">use <strong>binding</strong> to pass values to the attribute directive</a>.</li>
</ul><span>
</span><p>The final source:</p><span>
</span><code-tabs><code language="ts" name="app.component.ts" format="linenums">import { Component } from &apos;@angular/core&apos;;

@Component({
  selector: &apos;my-app&apos;,
  templateUrl: &apos;app/app.component.html&apos;
})

export class AppComponent { }
</code><code language="html" name="app.component.html" format="linenums">&lt;h1&gt;My First Attribute Directive&lt;/h1&gt;
&lt;h4&gt;Pick a highlight color&lt;/h4&gt;
&lt;div&gt;
  &lt;input type=&quot;radio&quot; name=&quot;colors&quot; (click)=&quot;color=&apos;lightgreen&apos;&quot;&gt;Green
  &lt;input type=&quot;radio&quot; name=&quot;colors&quot; (click)=&quot;color=&apos;yellow&apos;&quot;&gt;Yellow
  &lt;input type=&quot;radio&quot; name=&quot;colors&quot; (click)=&quot;color=&apos;cyan&apos;&quot;&gt;Cyan
&lt;/div&gt;
&lt;p [myHighlight]=&quot;color&quot;&gt;Highlight me!&lt;/p&gt;

&lt;p [myHighlight]=&quot;color&quot; [defaultColor]=&quot;&apos;violet&apos;&quot;&gt;
  Highlight me too!
&lt;/p&gt;
</code><code language="ts" name="highlight.directive.ts" format="linenums">import { Directive, ElementRef, HostListener, Input, Renderer } from &apos;@angular/core&apos;;

@Directive({
  selector: &apos;[myHighlight]&apos;
})
export class HighlightDirective {
  private _defaultColor = &apos;red&apos;;

  constructor(private el: ElementRef, private renderer: Renderer) { }

  @Input() set defaultColor(colorName: string){
    this._defaultColor = colorName || this._defaultColor;
  }

  @Input(&apos;myHighlight&apos;) highlightColor: string;

  @HostListener(&apos;mouseenter&apos;) onMouseEnter() {
    this.highlight(this.highlightColor || this._defaultColor);
  }
  @HostListener(&apos;mouseleave&apos;) onMouseLeave() {
    this.highlight(null);
  }

  private highlight(color: string) {
    this.renderer.setElementStyle(this.el.nativeElement, &apos;backgroundColor&apos;, color);
  }
}
</code><code language="ts" name="app.module.ts" format="linenums">import { NgModule } from &apos;@angular/core&apos;;
import { BrowserModule } from &apos;@angular/platform-browser&apos;;

import { AppComponent } from &apos;./app.component&apos;;
import { HighlightDirective } from &apos;./highlight.directive&apos;;

@NgModule({
  imports: [ BrowserModule ],
  declarations: [
    AppComponent,
    HighlightDirective
  ],
  bootstrap: [ AppComponent ]
})
export class AppModule { }
</code><code language="ts" name="main.ts" format="linenums">import { platformBrowserDynamic } from &apos;@angular/platform-browser-dynamic&apos;;
import { AppModule } from &apos;./app.module&apos;;

platformBrowserDynamic().bootstrapModule(AppModule);
</code><code language="html
  " name="index.html" format="linenums">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Attribute Directives&lt;/title&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;styles.css&quot;&gt;

    &lt;!-- Polyfill(s) for older browsers --&gt;
    &lt;script src=&quot;node_modules/core-js/client/shim.min.js&quot;&gt;&lt;/script&gt;

    &lt;script src=&quot;node_modules/zone.js/dist/zone.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;node_modules/reflect-metadata/Reflect.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;node_modules/systemjs/dist/system.src.js&quot;&gt;&lt;/script&gt;

    &lt;script src=&quot;systemjs.config.js&quot;&gt;&lt;/script&gt;
    &lt;script&gt;
      System.import(&apos;app&apos;).catch(function(err){ console.error(err); });
    &lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;my-app&gt;loading...&lt;/my-app&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></code-tabs><a id="why-input"></a><h3 id="appendix-input-properties">Appendix: Input properties</h3><span>
</span><p>Earlier we declared the <code>highlightColor</code> property to be an <strong><em>input</em></strong> property of our
<code>HighlightDirective</code></p><span>
</span><p>We&apos;ve seen properties in bindings before. 
We never had to declare them as anything. Why now?</p><span>
</span><p>Angular makes a subtle but important distinction between binding <strong>sources</strong> and <strong>targets</strong>.</p><span>
</span><p>In all previous bindings, the directive or component property was a binding <strong><em>source</em></strong>.
A property is a <em>source</em> if it appears in the template expression to the <strong><em>right</em></strong> of the equals (=).</p><span>
</span><p>A property is a <em>target</em> when it appears in <strong>square brackets</strong> ([ ]) to the <strong>left</strong> of the equals (=) ...
as it is does when we bind to the <code>myHighlight</code> property of the <code>HighlightDirective</code>, </p><span>
</span><code language="html" format="">&lt;p [myHighlight]=&quot;color&quot;&gt;Highlight me!&lt;/p&gt;
</code><p>The &apos;color&apos; in <code>[myHighlight]=&quot;color&quot;</code> is a binding <strong><em>source</em></strong>.
A source property doesn&apos;t require a declaration.</p><span>
</span><p>The &apos;myHighlight&apos; in <code>[myHighlight]=&quot;color&quot;</code> <em>is</em> a binding <strong><em>target</em></strong>.
We must declare it as an <em>input</em> property.
Angular rejects the binding with a clear error if we don&apos;t.</p><span>
</span><p>Angular treats a <em>target</em> property differently for a good reason.
A component or directive in target position needs protection.</p><span>
</span><p>Imagine that our <code>HighlightDirective</code> did truly wonderous things.
We graciously made a gift of it to the world. </p><span>
</span><p>To our surprise, some people &#x2014; perhaps naively &#x2014;
started binding to <em>every</em> property of our directive. 
Not just the one or two properties we expected them to target. <em>Every</em> property.
That could really mess up our directive in ways we didn&apos;t anticipate and have no desire to support.</p><span>
</span><p>The <em>input</em> declaration ensures that consumers of our directive can only bind to
the properties of our public API ... nothing else.</p><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--></div></div>
        </article>
      
        <article>
          <h3>Component Styles</h3>
          <div><div class="showcase-content"><p>Angular 2 applications are styled with regular CSS. That means we can apply
everything we know about CSS stylesheets, selectors, rules, and media queries
to our Angular applications directly.</p><span>
</span><p>On top of this, Angular has the ability to bundle <em>component styles</em>
with our components enabling a more modular design than regular stylesheets.</p><span>
</span><p>In this chapter we learn how to load and apply these <em>component styles</em>.</p><span>
</span><span>
</span><ul>
<li><a href="https://angular.io/docs/ts/latest/guide/component-styles.html#using-component-styles">Using Component Styles</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/component-styles.html#special-selectors">Special selectors</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/component-styles.html#loading-styles">Loading Styles into Components</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/component-styles.html#view-encapsulation">Controlling View Encapsulation: Emulated, Native, and None</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/component-styles.html#inspect-generated-css">Appendix 1: Inspecting the generated runtime component styles</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/component-styles.html#relative-urls">Appendix 2: Loading Styles with Relative URLs</a></li>
</ul><span>
</span><p>Run the <live-example></live-example> of the code shown in this chapter.</p><span>
</span><h2 id="using-component-styles">Using Component Styles</h2><span>
</span><p>For every Angular 2 component we write, we may define not only an HTML template,
but also the CSS styles that go with that template, 
specifying any selectors, rules, and media queries that we need.</p><span>
</span><p>One way to do this is to set the <code>styles</code> property in the component metadata.
The <code>styles</code> property takes an array of strings that contain CSS code.
Usually we give it one string as in this example:</p><span>
</span><code language="ts" format="">@Component({
  selector: &apos;hero-app&apos;,
  template: `
    &lt;h1&gt;Tour of Heroes&lt;/h1&gt;
    &lt;hero-app-main [hero]=hero&gt;&lt;/hero-app-main&gt;`,
  styles: [&apos;h1 { font-weight: normal; }&apos;]
})
export class HeroAppComponent {
/* . . . */
}
</code><p>Component styles differ from traditional, global styles in a couple of ways.</p><span>
</span><p>Firstly, the selectors we put into a component&apos;s styles <em>only apply within the template
of that component</em>. The <code>h1</code> selector in the example above only applies to the <code>&lt;h1&gt;</code> tag
in the template of <code>HeroAppComponent</code>. Any <code>&lt;h1&gt;</code> elements elsewhere in
the application are unaffected.</p><span>
</span><p>This is a big improvement in modularity compared to how CSS traditionally works:</p><span>
</span><ol>
<li><p>We can use the CSS class names and selectors that make the most sense in the context of each component. </p>
</li>
<li><p>Class names and selectors are local to the component and won&apos;t collide with 
classes and selectors used elsewhere in the application.</p>
</li>
<li><p>Our component&apos;s styles <em>cannot</em> be changed by changes to styles elsewhere in the application.</p>
</li>
<li><p>We can co-locate the CSS code of each component with the TypeScript and HTML code of the component,
which leads to a neat and tidy project structure.</p>
</li>
<li><p>We can change or remove component CSS code in the future without trawling through the
whole application to see where else it may have been used. We just look at the component we&apos;re in.</p>
</li>
</ol><span>
</span><a id="special-selectors"></a><h2 id="special-selectors">Special selectors</h2><span>
</span><p>Component styles have a few special <em>selectors</em> from the world of 
<a href="https://www.w3.org/TR/css-scoping-1">shadow DOM style scoping</a>:</p><span>
</span><h3 id="-host">:host</h3><span>
</span><p>Use the <code>:host</code> pseudo-class selector to target styles in the element that <em>hosts</em> the component (as opposed to
targeting elements <em>inside</em> the component&apos;s template):</p><span>
</span><code language="css" format="">:host {
  display: block;
  border: 1px solid black;
}
</code><p>This is the <em>only</em> way we can target the host element. We cannot reach
it from inside the component with other selectors, because it is not part of the
component&apos;s own template. It is in a parent component&apos;s template.</p><span>
</span><p>Use the <em>function form</em> to apply host styles conditionally by 
including another selector inside parentheses after <code>:host</code>.</p><span>
</span><p>In the next example we target the host element again, but only when it also has the <code>active</code> CSS class.</p><span>
</span><code language="css" format="">:host(.active) {
  border-width: 3px;
}
</code><h3 id="-host-context">:host-context</h3><span>
</span><p>Sometimes it is useful to apply styles based on some condition <em>outside</em> a component&apos;s view.
For example, there may be a CSS theme class applied to the document <code>&lt;body&gt;</code> element, and
we want to change how our component looks based on that.</p><span>
</span><p>Use the <code>:host-context()</code> pseudo-class selector. It works just like the function
form of <code>:host()</code>. It looks for a CSS class in <em>any ancestor</em> of the component host element, all the way
up to the document root. It&apos;s useful when combined with another selector.</p><span>
</span><p>In the following example, we apply a <code>background-color</code> style to all <code>&lt;h2&gt;</code> elements <em>inside</em> the component, only
if some ancestor element has the CSS class <code>theme-light</code>.</p><span>
</span><code language="css" format="">:host-context(.theme-light) h2 {
  background-color: #eef;
}
</code><h3 id="-deep-">/deep/</h3><span>
</span><p>Component styles normally apply only to the HTML in the component&apos;s own template. </p><span>
</span><p>We can use the <code>/deep/</code> selector to force a style down through the child component tree into all the child component views.
The <code>/deep/</code> selector works to any depth of nested components, and it applies <em>both to the view
children and the content children</em> of the component. </p><span>
</span><p>In this example, we target all <code>&lt;h3&gt;</code> elements, from the host element down 
through this component to all of its child elements in the DOM: </p><span>
</span><code language="css" format="">:host /deep/ h3 {
  font-style: italic;
}
</code><p>The <code>/deep/</code> selector also has the alias <code>&gt;&gt;&gt;</code>. We can use either of the two interchangeably.</p><span>
</span><div class="alert is-important"><p>The <code>/deep/</code> and <code>&gt;&gt;&gt;</code> selectors should only be used with <strong>emulated</strong> view encapsulation.
This is the default and it is what we use most of the time. See the
<a href="https://angular.io/docs/ts/latest/guide/component-styles.html#view-encapsulation">Controlling View Encapsulation</a>
section for more details.</p><span>
</span></div><a id="loading-styles"></a><h2 id="loading-styles-into-components">Loading Styles into Components</h2><span>
</span><p>We have several ways to add styles to a component: </p><span>
</span><ul>
<li>inline in the template HTML</li>
<li>by setting <code>styles</code> or <code>styleUrls</code> metadata</li>
<li>with CSS imports</li>
</ul><span>
</span><p>The scoping rules outlined above apply to each of these loading patterns.</p><span>
</span><span>
</span><p>We can add a <code>styles</code> array property to the <code>@Component</code> decorator.
Each string in the array (usually just one string) defines the CSS.</p><span>
</span><code language="ts" format="linenums">@Component({
  selector: &apos;hero-app&apos;,
  template: `
    &lt;h1&gt;Tour of Heroes&lt;/h1&gt;
    &lt;hero-app-main [hero]=hero&gt;&lt;/hero-app-main&gt;`,
  styles: [&apos;h1 { font-weight: normal; }&apos;]
})
export class HeroAppComponent {
/* . . . */
}
</code><h3 id="template-inline-styles">Template Inline Styles</h3><span>
</span><p>We can embed styles directly into the HTML template by putting them
inside <code>&lt;style&gt;</code> tags.</p><span>
</span><code language="ts" format="linenums">@Component({
  selector: &apos;hero-controls&apos;,
  template: `
    &lt;style&gt;
      button {
        background-color: white;
        border: 1px solid #777;
      }
    &lt;/style&gt;
    &lt;h3&gt;Controls&lt;/h3&gt;
    &lt;button (click)=&quot;activate()&quot;&gt;Activate&lt;/button&gt;
  `
})
</code><span>
</span><p>We can load styles from external CSS files by adding a <code>styleUrls</code> attribute
into a component&apos;s <code>@Component</code> decorator:</p><span>
</span><code language="ts" format="linenums">@Component({
  selector: &apos;hero-details&apos;,
  template: `
    &lt;h2&gt;{{hero.name}}&lt;/h2&gt;
    &lt;hero-team [hero]=hero&gt;&lt;/hero-team&gt;
    &lt;ng-content&gt;&lt;/ng-content&gt;
  `,
  styleUrls: [&apos;app/hero-details.component.css&apos;]
})
export class HeroDetailsComponent {
/* . . . */
}
</code><div class="alert is-important"><p>The URL is <strong><em>relative to the application root</em></strong> which is usually the
location of the <code>index.html</code> web page that hosts the application. 
The style file URL is <em>not</em> relative to the component file.
That&apos;s why the example URL begins <code>app/</code>.
See <a href="https://angular.io/docs/ts/latest/guide/component-styles.html#relative-urls">Appendix 2</a> to specify a URL relative to the 
component file.</p><span>
</span></div><div class="l-sub-section"><p>Users of module bundlers like Webpack may also use the <code>styles</code> attribute
to load styles from external files at build time. They could write:</p><span>
</span><p><code>styles: [require(&apos;my.component.css&apos;)]</code></p><span>
</span><p>We set the <code>styles</code> property, <strong>not</strong> <code>styleUrls</code> property! The module 
bundler is loading the CSS strings, not Angular. 
Angular only sees the CSS strings <em>after</em> the bundler loads them. 
To Angular it is as if we wrote the <code>styles</code> array by hand. 
Refer to the module bundler&apos;s documentation for information on 
loading CSS in this manner.</p><span>
</span></div><span>
</span><p>We can also embed <code>&lt;link&gt;</code> tags into the component&apos;s HTML template. </p><span>
</span><p>As with <code>styleUrls</code>, the link tag&apos;s <code>href</code> URL is relative to the 
application root, not relative to the component file.</p><span>
</span><code language="ts" format="linenums">@Component({
  selector: &apos;hero-team&apos;,
  template: `
    &lt;link rel=&quot;stylesheet&quot; href=&quot;app/hero-team.component.css&quot;&gt;
    &lt;h3&gt;Team&lt;/h3&gt;
    &lt;ul&gt;
      &lt;li *ngFor=&quot;let member of hero.team&quot;&gt;
        {{member}}
      &lt;/li&gt;
    &lt;/ul&gt;`
})
</code><h3 id="css-imports">CSS @imports</h3><span>
</span><p>We can also import CSS files into our CSS files by using the standard CSS
<a href="https://developer.mozilla.org/en/docs/Web/CSS/@import"><code>@import</code> rule</a>.</p><span>
</span><p>In <em>this</em> case the URL is relative to the CSS file into which we are importing.</p><span>
</span><p>app/hero-details.component.css (excerpt)</p><code language="css" format="">@import &apos;hero-details-box.css&apos;;
</code><a id="view-encapsulation"></a><h2 id="controlling-view-encapsulation-native-emulated-and-none">Controlling View Encapsulation: Native, Emulated, and None</h2><span>
</span><p>As discussed above, component CSS styles are <em>encapsulated</em> into the component&apos;s own view and do
not affect the rest of the application.</p><span>
</span><p>We can control how this encapsulation happens on a <em>per
component</em> basis by setting the <em>view encapsulation mode</em> in the component metadata. There
are three modes to choose from:</p><span>
</span><ul>
<li><p><code>Native</code> view encapsulation uses the browser&apos;s native <a href="https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM">Shadow DOM</a>
implementation to attach a Shadow DOM to the component&apos;s host element, and then puts the component
view inside that Shadow DOM. The component&apos;s styles are included within the Shadow DOM.</p>
</li>
<li><p><code>Emulated</code> view encapsulation (<strong>the default</strong>) emulates the behavior of Shadow DOM by preprocessing
(and renaming) the CSS code to effectively scope the CSS to the component&apos;s view.
See <a href="https://angular.io/docs/ts/latest/guide/component-styles.html#inspect-generated-css">Appendix 1</a> for details.</p>
</li>
<li><p><code>None</code> means that Angular does no view encapsulation. 
Angular adds the CSS to the global styles. 
The scoping rules, isolations, and protections discussed earlier do not apply. 
This is essentially the same as pasting the component&apos;s styles into the HTML.</p>
</li>
</ul><span>
</span><p>Set the components encapsulation mode using the <code>encapsulation</code> property in the component metadata:</p><span>
</span><code language="ts" format="">// warning: few browsers support shadow DOM encapsulation at this time
encapsulation: ViewEncapsulation.Native
</code><p><code>Native</code> view encapsulation only works on <a href="http://caniuse.com/#feat=shadowdom">browsers that have native support
for Shadow DOM</a>. The support is still limited,
which is why <code>Emulated</code> view encapsulation is the default mode and recommended
in most cases.</p><span>
</span><a id="inspect-generated-css"></a><h2 id="appendix-1-inspecting-the-css-generated-in-emulated-view-encapsulation">Appendix 1: Inspecting The CSS Generated in Emulated View Encapsulation</h2><span>
</span><p>When using the default emulated view encapsulation, Angular preprocesses
all component styles so that they approximate the standard Shadow CSS scoping rules.</p><span>
</span><p>When we inspect the DOM of a running Angular application with emulated view
encapsulation enabled, we see that each DOM element has some extra attributes
attached to it:</p><span>
</span><code format="">&lt;hero-details _nghost-pmm-5&gt;
  &lt;h2 _ngcontent-pmm-5&gt;Mister Fantastic&lt;/h2&gt;
  &lt;hero-team _ngcontent-pmm-5 _nghost-pmm-6&gt;
    &lt;h3 _ngcontent-pmm-6&gt;Team&lt;/h3&gt;
  &lt;/hero-team&gt;
&lt;/hero-detail&gt;
</code><p>We see two kinds of generated attributes:</p><span>
</span><ul>
<li><p>An element that would be a Shadow DOM host in native encapsulation has a
generated <code>_nghost</code> attribute. This is typically the case for component host elements.</p>
</li>
<li><p>An element within a component&apos;s view has a <code>_ngcontent</code> attribute 
that identifies to which host&apos;s emulated Shadow DOM this element belongs.</p>
</li>
</ul><span>
</span><p>The exact values of these attributes are not important. They are automatically
generated and we never refer to them in application code. But they are targeted
by the generated component styles, which we&apos;ll find in the <code>&lt;head&gt;</code> section of the DOM:</p><span>
</span><code format="">[_nghost-pmm-5] {
  display: block;
  border: 1px solid black;
}

h3[_ngcontent-pmm-6] {
  background-color: white;
  border: 1px solid #777;
}
</code><p>These are the styles we wrote, post-processed so that each selector is augmented
with <code>_nghost</code> or <code>_ngcontent</code> attribute selectors. 
These extra selectors enable the scoping rules described in this guide.</p><span>
</span><p>We&apos;ll likely live with <em>emulated</em> mode until shadow DOM gains traction.</p><span>
</span><a id="relative-urls"></a><h2 id="appendix-2-loading-styles-with-relative-urls">Appendix 2: Loading Styles with Relative URLs</h2><span>
</span><p>It&apos;s common practice to split a component&apos;s code, HTML, and CSS into three separate files in the same directory:</p><span>
</span><code format="">quest-summary.component.ts
quest-summary.component.html
quest-summary.component.css
</code><p>We include the template and CSS files by setting the <code>templateUrl</code> and <code>styleUrls</code> metadata properties respectively.
Because these files are co-located with the component,
it would be nice to refer to them by name without also having to specify a path back to the root of the application.</p><span>
</span><p>We can change the way Angular calculates the full URL be setting the component metadata&apos;s <code>moduleId</code> property to <code>module.id</code>.</p><span>
</span><p>app/quest-summary.component.ts</p><code language="ts" format="linenums">@Component({
  moduleId: module.id,
  selector: &apos;quest-summary&apos;,
  templateUrl: &apos;quest-summary.component.html&apos;,
  styleUrls:  [&apos;quest-summary.component.css&apos;]
})
export class QuestSummaryComponent { }
</code><p>Learn more about <code>moduleId</code> in the <a href="https://angular.io/docs/ts/latest/cookbook/component-relative-paths.html">Component-Relative Paths</a> chapter.</p><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--></div></div>
        </article>
      
        <article>
          <h3>Hierarchical Dependency Injectors</h3>
          <div><div class="showcase-content"><p>We learned the basics of Angular Dependency injection in the
<a href="https://angular.io/docs/ts/latest/guide/dependency-injection.html">Dependency Injection</a> chapter.</p><span>
</span><p>Angular has a Hierarchical Dependency Injection system.
There is actually a tree of injectors
that parallel an application&apos;s component tree.
We can reconfigure the injectors at any level of that component tree with
interesting and useful results.</p><span>
</span><p>In this chapter we explore these points and write some code.</p><span>
</span><p>Try the <live-example></live-example>.</p><span>
</span><h2 id="the-injector-tree">The Injector Tree</h2><span>
</span><p>In the <a href="https://angular.io/docs/ts/latest/guide/dependency-injection.html">Dependency Injection</a> chapter
we learned how to configure a dependency injector and how to retrieve dependencies where we need them.</p><span>
</span><p>We oversimplified. In fact, there is no such thing as <strong><em>the</em></strong> injector!
An application may have multiple injectors!</p><span>
</span><p>An Angular application is a tree of components. Each component instance has its own injector!
The tree of components parallels the tree of injectors.</p><span>
</span><div class="l-sub-section"><p>Angular doesn&apos;t <em>literally</em> create a separate injector for each component.
Every component doesn&apos;t need its own injector and it would be horribly inefficient to create
masses of injectors for no good purpose.</p><span>
</span><p>But it is true that every component <strong><em>has an injector</em></strong> (even if it shares that injector with another component)
and there may be many different injector instances operating at different levels of the component tree.</p><span>
</span><p>It is useful to pretend that every component has its own injector.</p><span>
</span></div><p>Consider a simple variation on the Tour of Heroes application consisting of three different components:
<code>HeroesApp</code>, <code>HeroesListComponent</code> and <code>HeroesCardComponent</code>.
The <code>HeroesApp</code> holds a single instance of <code>HeroesListComponent</code>.
The new twist is that the <code>HeroesListComponent</code> may hold and manage multiple instances of the <code>HeroesCardComponent</code>.</p><span>
</span><p>The following diagram represents the state of the component tree when there are three instances of <code>HeroesCardComponent</code>
open simultaneously.</p><span>
</span><figure class="image-display"><img src="https://angular.io/resources/images/devguide/dependency-injection/component-hierarchy.png" alt="injector tree" width="500"></figure><p>Each component instance gets its own injector and an injector at one level is a child injector of the injector above it in the tree.</p><span>
</span><p>When a component at the bottom requests a dependency, Angular tries to satisfy that dependency with a provider registered in that component&apos;s own injector.
If the component&apos;s injector lacks the provider, it passes the request up to its parent component&apos;s injector.
If that injector can&apos;t satisfy the request, it passes it along to <em>its</em> parent component&apos;s injector.
The requests keep bubbling up until we find an injector that can handle the request or run out of component ancestors.
If we run out of ancestors, Angular throws an error.</p><span>
</span><div class="l-sub-section"><p>There&apos;s a third possibility. An intermediate component can declare that it is the &quot;host&quot; component.
The hunt for providers will climb no higher than the injector for this host component.
 We&apos;ll reserve discussion of this option for another day.</p><span>
</span></div><p>Such a proliferation of injectors makes little sense until we consider the possibility that injectors at different levels can be
configured with different providers. We don&apos;t <em>have</em> to reconfigure providers at every level. But we <em>can</em>.</p><span>
</span><p>If we don&apos;t reconfigure, the tree of injectors appears to be flat. All requests bubble up to the root 
<span if-docs="ts">NgModule</span> injector that we configured with the <code>bootstrapModule</code> method.</p><span>
</span><p>The ability to configure one or more providers at different levels opens up interesting and useful possibilities.</p><span>
</span><p>Let&#x2019;s return to our Car example.
Suppose we configured the root injector (marked as A) with providers for <code>Car</code>, <code>Engine</code> and <code>Tires</code>.
We create a child component (B) that defines its own providers for <code>Car</code> and <code>Engine</code>
This child is the parent of another component (C) that defines its own provider for <code>Car</code>.</p><span>
</span><p>Behind the scenes each component sets up its own injector with one or more providers defined for that component itself.</p><span>
</span><p>When we resolve an instance of <code>Car</code> at the deepest component (C),
its injector produces an instance of <code>Car</code> resolved by injector (C) with an <code>Engine</code> resolved by injector (B) and
<code>Tires</code> resolved by the root injector (A).</p><span>
</span><figure class="image-display"><img src="https://angular.io/resources/images/devguide/dependency-injection/injector-tree.png" alt="injector tree" width="600"></figure><h2 id="component-injectors">Component Injectors</h2><span>
</span><p>In the previous section, we talked about injectors and how they are organized like a tree. Lookups follow the injector tree upwards until they find the requested thing to inject. But when do we actually want to provide providers on the root injector and when do we want to provide them on a child injector?</p><span>
</span><p>Consider you are building a component to show a list of super heroes that displays each super hero in a card with its name and superpower. There should also be an edit button that opens up an editor to change the name and superpower of our hero.</p><span>
</span><p>One important aspect of the editing functionality is that we want to allow multiple heroes to be in edit mode at the same time and that one can always either commit or cancel the proposed changes.</p><span>
</span><p>Let&#x2019;s take a look at the <code>HeroesListComponent</code> which is the root component for this example.</p><span>
</span><p>app/heroes-list.component.ts</p><code language="ts" format="linenums">import { Component } from &apos;@angular/core&apos;;

import { EditItem } from &apos;./edit-item&apos;;
import { HeroesService } from &apos;./heroes.service&apos;;
import { Hero } from &apos;./hero&apos;;

@Component({
  selector: &apos;heroes-list&apos;,
  template: `
    &lt;div&gt;
      &lt;ul&gt;
        &lt;li *ngFor=&quot;let editItem of heroes&quot;&gt;
          &lt;hero-card
            [hidden]=&quot;editItem.editing&quot;
            [hero]=&quot;editItem.item&quot;&gt;
          &lt;/hero-card&gt;
          &lt;button
            [hidden]=&quot;editItem.editing&quot;
            (click)=&quot;editItem.editing = true&quot;&gt;
              edit
          &lt;/button&gt;
          &lt;hero-editor
            (saved)=&quot;onSaved(editItem, $event)&quot;
            (canceled)=&quot;onCanceled(editItem)&quot;
            [hidden]=&quot;!editItem.editing&quot;
            [hero]=&quot;editItem.item&quot;&gt;
          &lt;/hero-editor&gt;
        &lt;/li&gt;
      &lt;/ul&gt;
    &lt;/div&gt;`
})
export class HeroesListComponent {
  heroes: Array&lt;EditItem&lt;Hero&gt;&gt;;
  constructor(heroesService: HeroesService) {
    this.heroes = heroesService.getHeroes()
                               .map(item =&gt; new EditItem(item));
  }

  onSaved (editItem: EditItem&lt;Hero&gt;, updatedHero: Hero) {
    editItem.item = updatedHero;
    editItem.editing = false;
  }

  onCanceled (editItem: EditItem&lt;Hero&gt;) {
    editItem.editing = false;
  }
}
</code><p>Notice that it imports the <code>HeroService</code> that we&#x2019;ve used before so we can skip its declaration. The only difference is that we&#x2019;ve used a more formal approach for our <code>Hero</code>model and defined it upfront as such.</p><span>
</span><p>app/hero.ts</p><code language="ts" format="">export class Hero {
  name: string;
  power: string;
}
</code><p>Our <code>HeroesListComponent</code> defines a template that creates a list of <code>HeroCardComponent</code>s and <code>HeroEditorComponent</code>s, each bound to an instance of hero that is returned from the <code>HeroService</code>. Ok, that&#x2019;s not entirely true. It actually binds to an <code>EditItem&lt;Hero&gt;</code> which is a simple generic datatype that can wrap any type and indicate if the item being wrapped is currently being edited or not.</p><span>
</span><p>app/edit-item.ts</p><code language="ts" format="">export class EditItem&lt;T&gt; {
  editing: boolean;
  constructor (public item: T) {}
}
</code><p>But how is <code>HeroCardComponent</code> implemented? Let&#x2019;s take a look.</p><span>
</span><p>app/hero-card.component.ts</p><code language="ts" format="linenums">import { Component, Input } from &apos;@angular/core&apos;;

import { Hero } from &apos;./hero&apos;;

@Component({
  selector: &apos;hero-card&apos;,
  template: `
    &lt;div&gt;
      &lt;span&gt;Name:&lt;/span&gt;
      &lt;span&gt;{{hero.name}}&lt;/span&gt;
    &lt;/div&gt;`
})
export class HeroCardComponent {
  @Input() hero: Hero;
}
</code><p>The <code>HeroCardComponent</code> is basically a component that defines a template to render a hero. Nothing more.</p><span>
</span><p>Let&#x2019;s get to the interesting part and take a look at the <code>HeroEditorComponent</code></p><span>
</span><p>app/hero-editor.component.ts</p><code language="ts" format="linenums">import { Component, EventEmitter, Input, Output } from &apos;@angular/core&apos;;

import { RestoreService } from &apos;./restore.service&apos;;
import { Hero } from &apos;./hero&apos;;

@Component({
  selector: &apos;hero-editor&apos;,
  providers: [RestoreService],
  template: `
    &lt;div&gt;
      &lt;span&gt;Name:&lt;/span&gt;
      &lt;input [(ngModel)]=&quot;hero.name&quot;/&gt;
      &lt;div&gt;
        &lt;button (click)=&quot;onSaved()&quot;&gt;save&lt;/button&gt;
        &lt;button (click)=&quot;onCanceled()&quot;&gt;cancel&lt;/button&gt;
      &lt;/div&gt;
    &lt;/div&gt;`
})

export class HeroEditorComponent {
  @Output() canceled = new EventEmitter();
  @Output() saved = new EventEmitter();

  constructor(private restoreService: RestoreService&lt;Hero&gt;) {}

  @Input()
  set hero (hero: Hero) {
    this.restoreService.setItem(hero);
  }

  get hero () {
    return this.restoreService.getItem();
  }

  onSaved () {
    this.saved.next(this.restoreService.getItem());
  }

  onCanceled () {
    this.hero = this.restoreService.restoreItem();
    this.canceled.next(this.hero);
  }
}
</code><p>Now here it&#x2019;s getting interesting. The <code>HeroEditorComponent</code>defines a template with an input to change the name of the hero and a <code>cancel</code> and a <code>save</code> button. Remember that we said we want to have the flexibility to cancel our editing and restore the old value? This means we need to maintain two copies of our <code>Hero</code> that we want to edit. Thinking ahead, this is a perfect use case to abstract it into its own generic service since we have probably more cases like this in our app.</p><span>
</span><p>And this is where the <code>RestoreService</code> enters the stage.</p><span>
</span><p>app/restore.service.ts</p><code language="ts" format="linenums">export class RestoreService&lt;T&gt; {
  originalItem: T;
  currentItem: T;

  setItem (item: T) {
    this.originalItem = item;
    this.currentItem = this.clone(item);
  }

  getItem (): T {
    return this.currentItem;
  }

  restoreItem (): T {
    this.currentItem = this.originalItem;
    return this.getItem();
  }

  clone (item: T): T {
    // super poor clone implementation
    return JSON.parse(JSON.stringify(item));
  }
}
</code><p>All this tiny service does is define an API to set a value of any type which can be altered, retrieved or set back to its initial value. That&#x2019;s exactly what we need to implement the desired functionality.</p><span>
</span><p>Our <code>HeroEditComponent</code> uses this services under the hood for its <code>hero</code> property. It intercepts the <code>get</code> and <code>set</code> method to delegate the actual work to our <code>RestoreService</code> which in turn makes sure that we won&#x2019;t work on the original item but on a copy instead.</p><span>
</span><p>At this point we may be scratching our heads asking what this has to do with component injectors?
Look closely at the metadata for our <code>HeroEditComponent</code>. Notice the <code>providers</code> property.</p><span>
</span><code language="ts" format="">providers: [RestoreService],
</code><p>This adds a <code>RestoreService</code> provider to the injector of the <code>HeroEditComponent</code>.
Couldn&#x2019;t we simply alter our root <code>NgModule</code> to include this provider?</p><span>
</span><p>app/app.module.ts (bad-alternative)</p><code language="ts" format="">// Don&apos;t do this!
@NgModule({
  imports: [
    BrowserModule,
    FormsModule
  ],
  providers: [ HeroesService, RestoreService ],
  declarations: [ HeroesListComponent ],
  bootstrap: [
    HeroesListComponent,
    HeroCardComponent,
    HeroEditorComponent
  ]
})
</code><p>Technically we could, but our component wouldn&#x2019;t quite behave the way it is supposed to. Remember that each injector treats the services that it provides as singletons. However, in order to be able to have multiple instances of <code>HeroEditComponent</code> edit multiple heroes at the same time we need to have multiple instances of the <code>RestoreService</code>. More specifically, each instance of <code>HeroEditComponent</code> needs to be bound to its own instance of the <code>RestoreService</code>.</p><span>
</span><p>By configuring a provider for the <code>RestoreService</code> on the <code>HeroEditComponent</code>, we get exactly one new instance of the <code>RestoreService</code>per <code>HeroEditComponent</code>.</p><span>
</span><p>Does that mean that services aren&#x2019;t singletons anymore in Angular 2? Yes and no.
There can be only one instance of a service type in a particular injector.
But we&apos;ve learned that we can have multiple injectors operating at different levels of the application&apos;s component tree.
Any of those injectors could have its own instance of the service.</p><span>
</span><p>If we defined a <code>RestoreService</code> provider only on the root component,
we would have exactly one instance of that service and it would be shared across the entire application.</p><span>
</span><p>That&#x2019;s clearly not what we want in this scenario. We want each component to have its own instance of the <code>RestoreService</code>.
Defining (or redefining) a provider at the component level creates a new instance of the service for each new instance
of that component. We&apos;ve made the <code>RestoreService</code> a kind of &quot;private&quot; singleton for each <code>HeroEditComponent</code>,
scoped to that component instance and its child components.</p><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--></div></div>
        </article>
      
        <article>
          <h3>HTTP Client</h3>
          <div><div class="showcase-content"><p><a href="https://tools.ietf.org/html/rfc2616">HTTP</a> is the primary protocol for browser/server communication.</p><span>
</span><div class="l-sub-section"><p>The <a href="https://tools.ietf.org/html/rfc6455"><code>WebSocket</code></a> protocol is another important communication technology;
we won&apos;t cover it in this chapter.</p><span>
</span></div><p>Modern browsers support two HTTP-based APIs: 
<a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest">XMLHttpRequest (XHR)</a> and 
<a href="https://en.wikipedia.org/wiki/JSONP">JSONP</a>. A few browsers also support
<a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">Fetch</a>. </p><span>
</span><p>The Angular HTTP library simplifies application programming of the <strong>XHR</strong> and <strong>JSONP</strong> APIs
as we&apos;ll learn in this chapter covering:</p><span>
</span><ul>
<li><a href="https://angular.io/docs/ts/latest/guide/server-communication.html#http-client">HTTP client sample overview</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/server-communication.html#fetch-data">Fetch data with http.get</a></li><li if-docs="ts"> <a href="https://angular.io/docs/ts/latest/guide/server-communication.html#rxjs">RxJS Observable of HTTP Responses</a></li>
<li if-docs="ts"> <a href="https://angular.io/docs/ts/latest/guide/server-communication.html#enable-rxjs-operators">Enabling RxJS Operators</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/server-communication.html#extract-data">Extract JSON data</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/server-communication.html#error-handling">Error handling</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/server-communication.html#update">Send data to the server</a></li><li if-docs="ts"> <a href="https://angular.io/docs/ts/latest/guide/server-communication.html#promises">Promises instead of observables</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/server-communication.html#cors">Cross-origin requests: Wikipedia example</a><ul if-docs="ts"> 
  <li> <a href="https://angular.io/docs/ts/latest/guide/server-communication.html#search-parameters">Set query string parameters</a></li>
  <li> <a href="https://angular.io/docs/ts/latest/guide/server-communication.html#more-observables">Debounce search term input</a></li>
</ul></li>
<li><a href="https://angular.io/docs/ts/latest/guide/server-communication.html#in-mem-web-api">Appendix: the in-memory web api service</a></li>
</ul><span>
</span><p>We illustrate these topics with code that you can <live-example>run live</live-example>.</p><span>
</span><h1 id="demos">Demos</h1><span>
</span><p>This chapter describes server communication with the help of the following demos</p><span>
</span><ul>
<li><a href="https://angular.io/docs/ts/latest/guide/server-communication.html#http-client">HTTP client: Tour of Heroes with Observables</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/server-communication.html#promises">HTTP client: Tour of Heroes with Promises</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/server-communication.html#cors">JSONP client: Wikipedia to fetch data from a service that does not support CORS</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/server-communication.html#more-observables">JSONP client: Wikipedia using observable operators to reduce server calls</a></li>
</ul><span>
</span><p>These demos are orchestrated by the root <code>AppComponent</code></p><span>
</span><p>app/app.component.ts</p><code language="ts" format="linenums">import { Component }         from &apos;@angular/core&apos;;

// Add the RxJS Observable operators we need in this app.
import &apos;./rxjs-operators&apos;;

@Component({
  selector: &apos;my-app&apos;,
  template: `
    &lt;hero-list&gt;&lt;/hero-list&gt;
    &lt;hero-list-promise&gt;&lt;/hero-list-promise&gt;
    &lt;my-wiki&gt;&lt;/my-wiki&gt;
    &lt;my-wiki-smart&gt;&lt;/my-wiki-smart&gt;
  `
})
export class AppComponent { }
</code><p>There is nothing remarkable here <em>except</em> for the import of RxJS operators.</p><span>
</span><code language="ts" format="">// Add the RxJS Observable operators we need in this app.
import &apos;./rxjs-operators&apos;;
</code><p>We&apos;ll talk about that <a href="https://angular.io/docs/ts/latest/guide/server-communication.html#rxjs">below</a> when we&apos;re ready to explore observables.</p><span>
</span><p>First, we have to configure our application to use server communication facilities.</p><span>
</span><h1 id="providing-http-services">Providing HTTP Services</h1><span>
</span><p>We use the Angular <code>Http</code> client to communicate with a server using a familiar HTTP request/response protocol.
The <code>Http</code> client is one of a family of services in the Angular HTTP library.</p><span>
</span><div class="l-sub-section"><p>SystemJS knows how to load services from the Angular HTTP library when we import from the <code>@angular/http</code> module
because we registered that module name in the <code>system.config</code> file.</p><span>
</span></div><p>Before we can use the <code>Http</code> client , we&apos;ll have to register it as a service provider with the Dependency Injection system.</p><span>
</span><p>In this demo, we register providers by importing other NgModules to our root NgModule.</p><span>
</span><p>app/app.module.ts (v1)</p><code language="ts" format="">import { NgModule } from &apos;@angular/core&apos;;
import { BrowserModule } from &apos;@angular/platform-browser&apos;;
import { FormsModule } from &apos;@angular/forms&apos;;
import { HttpModule, JsonpModule } from &apos;@angular/http&apos;;

import { AppComponent } from &apos;./app.component&apos;;

@NgModule({
  imports: [
    BrowserModule,
    FormsModule,
    HttpModule,
    JsonpModule
  ],
  declarations: [ AppComponent ],
  bootstrap:    [ AppComponent ]
})
export class AppModule { }
</code><p>We begin by importing the symbols we need, most of them familiar by now. 
The newcomers are the <code>HttpModule</code> and the <code>JsonpModule</code> from the Angular HTTP library.</p><span>
</span><p>We add these modules to the application by passing them to the <code>imports</code> array in our root NgModule.</p><span>
</span><div class="l-sub-section"><p>We need the HttpModule to make HTTP calls.
We don&apos;t need the JsonpModule for plain HTTP.
We will demonstrate JSONP support later in this chapter.
We&apos;re loading its module now to save time.</p><span>
</span></div><h1 id="the-tour-of-heroes-_http_-client-demo">The Tour of Heroes <em>HTTP</em> Client Demo</h1><span>
</span><p>Our first demo is a mini-version of the <a href="https://angular.io/docs/ts/latest/tutorial">tutorial</a>&apos;s &quot;Tour of Heroes&quot; (ToH) application.
This version gets some heroes from the server, displays them in a list, lets us add new heroes, and saves them to the server.
We use the Angular <code>Http</code> client to communicate via <code>XMLHttpRequest (XHR)</code>.</p><span>
</span><p>It works like this.</p><span>
</span><figure class="image-display"><img src="https://angular.io/resources/images/devguide/server-communication/http-toh.gif" alt="ToH mini app" width="250"></figure><p>This demo has a single component, the <code>HeroListComponent</code>.  Here&apos;s its template:</p><span>
</span><p>app/toh/hero-list.component.html (template)</p><code language="html" format="linenums">&lt;h1&gt;Tour of Heroes ({{mode}})&lt;/h1&gt;
&lt;h3&gt;Heroes:&lt;/h3&gt;
&lt;ul&gt;
  &lt;li *ngFor=&quot;let hero of heroes&quot;&gt;
    {{hero.name}}
  &lt;/li&gt;
&lt;/ul&gt;
New hero name:
&lt;input #newHeroName /&gt;
&lt;button (click)=&quot;addHero(newHeroName.value); newHeroName.value=&apos;&apos;&quot;&gt;
  Add Hero
&lt;/button&gt;
&lt;div class=&quot;error&quot; *ngIf=&quot;errorMessage&quot;&gt;{{errorMessage}}&lt;/div&gt;
</code><p>It presents the list of heroes with an <code>ngFor</code>. 
Below the list is an input box and an <em>Add Hero</em> button where we can enter the names of new heroes
and add them to the database. 
We use a <a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#ref-vars">template reference variable</a>, <code>newHeroName</code>, to access the 
value of the input box in the <code>(click)</code> event binding.
When the user clicks the button, we pass that value to the component&apos;s <code>addHero</code> method and then
clear it to make it ready for a new hero name.</p><span>
</span><p>Below the button is an area for an error message.</p><span>
</span><a id="oninit"></a><a id="HeroListComponent"></a><h2 id="the-herolistcomponent-class">The <em>HeroListComponent</em> class</h2><span>
</span><p>Here&apos;s the component class:</p><span>
</span><p>app/toh/hero-list.component.ts (class)</p><code language="ts" format="linenums">export class HeroListComponent implements OnInit {
  errorMessage: string;
  heroes: Hero[];
  mode = &apos;Observable&apos;;

  constructor (private heroService: HeroService) {}

  ngOnInit() { this.getHeroes(); }

  getHeroes() {
    this.heroService.getHeroes()
                     .subscribe(
                       heroes =&gt; this.heroes = heroes,
                       error =&gt;  this.errorMessage = &lt;any&gt;error);
  }

  addHero (name: string) {
    if (!name) { return; }
    this.heroService.addHero(name)
                     .subscribe(
                       hero  =&gt; this.heroes.push(hero),
                       error =&gt;  this.errorMessage = &lt;any&gt;error);
  }
}
</code><p>Angular <a href="https://angular.io/docs/ts/latest/guide/dependency-injection.html">injects</a> a <code>HeroService</code> into the constructor
and the component calls that service to fetch and save data.</p><span>
</span><p>The component <strong>does not talk directly to the Angular <code>Http</code> client</strong>!
The component doesn&apos;t know or care how we get the data. 
It delegates to the <code>HeroService</code>.</p><span>
</span><p>This is a golden rule: <strong>always delegate data access to a supporting service class</strong>.</p><span>
</span><p>Although <em>at runtime</em> the component requests heroes immediately after creation, 
we do <strong>not</strong> call the service&apos;s <code>get</code> method in the component&apos;s constructor.
We call it inside the <code>ngOnInit</code> <a href="https://angular.io/docs/ts/latest/guide/lifecycle-hooks.html">lifecycle hook</a> instead
and count on Angular to call <code>ngOnInit</code> when it instantiates this component. </p><span>
</span><div class="l-sub-section"><p>This is a <em>best practice</em>. 
Components are easier to test and debug when their constructors are simple and all real work 
(especially calling a remote server) is handled in a separate method.</p><span>
</span></div><p>The service&apos;s <code>getHeroes()</code> and <code>addHero()</code> methods return an <code>Observable</code> of hero data that the Angular <code>Http</code> client fetched from the server.</p><span>
</span><p><em>Observables</em> are a big topic, beyond the scope of this chapter. 
But we need to know a little about them to appreciate what is going on here.</p><span>
</span><p>We should think of an <code>Observable</code> as a stream of events published by some source.
We listen for events in this stream by <strong><em>subscribing</em></strong> to the <code>Observable</code>. 
In these subscriptions we specify the actions to take when the web request
produces a success event (with the hero data in the event payload) or a fail event (with the error in the payload).</p><span>
</span><p>With our basic intuitions about the component squared away, we&apos;re ready to look inside the <code>HeroService</code>.</p><span>
</span><a id="HeroService"></a><h2 id="fetch-data-with-the-heroservice-">Fetch data with the <strong>HeroService</strong></h2><span>
</span><p>In many of our previous samples we faked the interaction with the server by
returning mock heroes in a service like this one:</p><span>
</span><code language="ts" format="">import { Injectable } from &apos;@angular/core&apos;;

import { Hero } from &apos;./hero&apos;;
import { HEROES } from &apos;./mock-heroes&apos;;

@Injectable()
export class HeroService {
  getHeroes(): Promise&lt;Hero[]&gt; {
    return Promise.resolve(HEROES);
  }
}
</code><p>In this chapter, we revise that <code>HeroService</code> to get the heroes from the server using the Angular <code>Http</code> client service: </p><span>
</span><p>app/toh/hero.service.ts (revised)</p><code language="ts" format="linenums">import { Injectable }     from &apos;@angular/core&apos;;
import { Http, Response } from &apos;@angular/http&apos;;

import { Hero }           from &apos;./hero&apos;;
import { Observable }     from &apos;rxjs/Observable&apos;;

@Injectable()
export class HeroService {
  constructor (private http: Http) {}

  private heroesUrl = &apos;app/heroes&apos;;  // URL to web API

  getHeroes (): Observable&lt;Hero[]&gt; {
    return this.http.get(this.heroesUrl)
                    .map(this.extractData)
                    .catch(this.handleError);
  }
  private extractData(res: Response) {
    let body = res.json();
    return body.data || { };
  }

  private handleError (error: any) {
    // In a real world app, we might use a remote logging infrastructure
    // We&apos;d also dig deeper into the error to get a better message
    let errMsg = (error.message) ? error.message :
      error.status ? `${error.status} - ${error.statusText}` : &apos;Server error&apos;;
    console.error(errMsg); // log to console instead
    return Observable.throw(errMsg);
  }
}
</code><p>Notice that the Angular <code>Http</code> client service is
<a href="https://angular.io/docs/ts/latest/guide/dependency-injection.html">injected</a> into the <code>HeroService</code> constructor.</p><span>
</span><code language="ts" format="">constructor (private http: Http) {}
</code><p>Look closely at how we call <code>http.get</code></p><span>
</span><p>app/toh/hero.service.ts (getHeroes)</p><code language="ts" format="">getHeroes (): Observable&lt;Hero[]&gt; {
  return this.http.get(this.heroesUrl)
                  .map(this.extractData)
                  .catch(this.handleError);
}
</code><p>We pass the resource URL to <code>get</code> and it calls the server which should return heroes.</p><span>
</span><div class="l-sub-section"><p>It <em>will</em> return heroes once we&apos;ve set up the <a href="https://angular.io/docs/ts/latest/guide/server-communication.html#in-mem-web-api">in-memory web api</a>
described in the appendix below.
Alternatively, we can (temporarily) target a JSON file by changing the endpoint URL:</p><span>
</span><code language="ts" format="">private heroesUrl = &apos;app/heroes.json&apos;; // URL to JSON file
</code></div><p><a id="rxjs"></a>
The return value may surprise us. 
Many of us who are familiar with asynchronous methods in modern JavaScript would expect the <code>get</code> method to return a 
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">promise</a>.
We&apos;d expect to chain a call to <code>then()</code> and extract the heroes.
Instead we&apos;re calling a <code>map()</code> method. 
Clearly this is not a promise.</p><span>
</span><p>In fact, the <code>http.get</code> method returns an <strong>Observable</strong> of HTTP Responses (<code>Observable&lt;Response&gt;</code>) from the RxJS library
and <code>map</code> is one of the RxJS <em>operators</em>.</p><span>
</span><h1 id="rxjs-library">RxJS Library</h1><span>
</span><p><a href="https://github.com/ReactiveX/RxJS">RxJS</a> (&quot;Reactive Extensions&quot;) is a 3rd party library, endorsed by Angular,
that implements the <a href="https://www.youtube.com/watch?v=UHI0AzD_WfY" title="Rob Wormald on observables"><em>asynchronous observable</em></a> pattern.</p><span>
</span><p>All of our Developer Guide samples have installed the RxJS npm package and loaded via <code>system.js</code>
because observables are used widely in Angular applications.
We certainly need it now when working with the HTTP client.
And we must take a critical extra step to make RxJS observables usable.</p><span>
</span><h3 id="enable-rxjs-operators">Enable RxJS Operators</h3><span>
</span><p>The RxJS library is quite large. 
Size matters when we build a production application and deploy it to mobile devices.
We should include only those features that we actually need.</p><span>
</span><p>Accordingly, Angular exposes a stripped down version of <code>Observable</code> in the <code>rxjs/Observable</code> module, 
a version that lacks most of the operators including some we&apos;d like to use here
such as the <code>map</code> method we called above in <code>getHeroes</code>.</p><span>
</span><p>It&apos;s up to us to add the operators we need. </p><span>
</span><p>We could add <em>every</em> RxJS operators with a single import statement. 
While that is the easiest thing to do, we&apos;d pay a penalty in extended launch time and application size
because the full library is so big. We only use a few operators in our app.</p><span>
</span><p>Instead, we&apos;ll import each <code>Observable</code> operator and static class method, one-by-one, until we have a custom <em>Observable</em> implementation tuned
precisely to our requirements. We&apos;ll put the <code>import</code> statements in one <code>app/rxjs-operators.ts</code> file.</p><span>
</span><p>app/rxjs-operators.ts</p><code language="ts" format="">// import &apos;rxjs/Rx&apos;; // adds ALL RxJS statics &amp; operators to Observable

// See node_module/rxjs/Rxjs.js
// Import just the rxjs statics and operators we need for THIS app.

// Statics
import &apos;rxjs/add/observable/throw&apos;;

// Operators
import &apos;rxjs/add/operator/catch&apos;;
import &apos;rxjs/add/operator/debounceTime&apos;;
import &apos;rxjs/add/operator/distinctUntilChanged&apos;;
import &apos;rxjs/add/operator/map&apos;;
import &apos;rxjs/add/operator/switchMap&apos;;
import &apos;rxjs/add/operator/toPromise&apos;;
</code><p>If we forget an operator, the TypeScript compiler will warn that it&apos;s missing and we&apos;ll update this file.</p><span>
</span><div class="l-sub-section"><p>We don&apos;t need <em>all</em> of these particular operators in the <code>HeroService</code> &#x2014; just <code>map</code>, <code>catch</code> and <code>throw</code>.
We&apos;ll need the other operators later, in a <em>Wiki</em> example <a href="https://angular.io/docs/ts/latest/guide/server-communication.html#more-observables">below</a>.</p><span>
</span></div><p>Finally, we import <code>rxjs-operator</code><em>itself</em> in our <code>app.component.ts</code>:</p><span>
</span><p>app/app.component.ts (import rxjs)</p><code language="ts" format="">// Add the RxJS Observable operators we need in this app.
import &apos;./rxjs-operators&apos;;
</code><p>Let&apos;s return to our study of the <code>HeroService</code>.</p><span>
</span><l-main-section></l-main-section><a id="extract-data"></a><h2 id="process-the-response-object">Process the response object</h2><span>
</span><p>Remember that our <code>getHeroes()</code> method mapped the <code>http.get</code> response object to heroes with an <code>extractData</code> helper method:</p><span>
</span><p>app/toh/hero.service.ts (excerpt)</p><code language="ts" format="">private extractData(res: Response) {
  let body = res.json();
  return body.data || { };
}
</code><p>The <code>response</code> object does not hold our data in a form we can use directly. 
To make it useful in our application we must parse the response data into a JSON object</p><span>
</span><h4 id="parse-to-json">Parse to JSON</h4><span>
</span><p>The response data are in JSON string form.
We must parse that string into JavaScript objects which we do by calling <code>response.json()</code>.</p><span>
</span><div class="l-sub-section"><p>This is not Angular&apos;s own design. 
The Angular HTTP client follows the Fetch specification for the
<a href="https://fetch.spec.whatwg.org/#response-class">response object</a> returned by the <code>Fetch</code> function.
That spec defines a <code>json()</code> method that parses the response body into a JavaScript object.</p><span>
</span></div><div class="l-sub-section"><p>We shouldn&apos;t expect the decoded JSON to be the heroes array directly.
The server we&apos;re calling always wraps JSON results in an object with a <code>data</code>
property. We have to unwrap it to get the heroes.
This is conventional web api behavior, driven by 
<a href="https://www.owasp.org/index.php/OWASP_AJAX_Security_Guidelines#Always_return_JSON_with_an_Object_on_the_outside">security concerns</a>.</p><span>
</span></div><div class="alert is-important"><p>Make no assumptions about the server API. 
Not all servers return an object with a <code>data</code> property.</p><span>
</span></div><h3 id="do-not-return-the-response-object">Do not return the response object</h3><span>
</span><p>Our <code>getHeroes()</code> could have returned the HTTP response. Bad idea! 
The point of a data service is to hide the server interaction details from consumers.
The component that calls the <code>HeroService</code> wants heroes. 
It has no interest in what we do to get them.
It doesn&apos;t care where they come from.
And it certainly doesn&apos;t want to deal with a response object.</p><span>
</span><div class="callout is-important"><header>HTTP GET is delayed </header><p>The <code>http.get</code> does <strong>not send the request just yet!</strong> This observable is
<a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/gettingstarted/creating.md#cold-vs-hot-observables"><em>cold</em></a>
which means the request won&apos;t go out until something <em>subscribes</em> to the observable.
That <em>something</em> is the <a href="https://angular.io/docs/ts/latest/guide/server-communication.html#subscribe">HeroListComponent</a>.</p><span>
</span></div><a id="error-handling"></a><h3 id="always-handle-errors">Always handle errors</h3><span>
</span><p>Whenever we deal with I/O we must be prepared for something to go wrong as it surely will. 
We should catch errors in the <code>HeroService</code> and do something with them. 
We may also pass an error message back to the component for presentation to the user
but only if we can say something the user can understand and act upon.</p><span>
</span><p>In this simple app we provide rudimentary error handling in both the service and the component.</p><span>
</span><p>The eagle-eyed reader may have spotted our use of the <code>catch</code> operator in conjunction with a <code>handleError</code> method.
We haven&apos;t discussed so far how that actually works. </p><span>
</span><p>We use the Observable <code>catch</code> operator on the service level.
It takes an error handling function with an error object as the argument.
Our service handler, <code>handleError</code>, logs the response to the console, 
transforms the error into a user-friendly message, and returns the message in a new, failed observable via <code>Observable.throw</code>.</p><span>
</span><p>app/toh/hero.service.ts (excerpt)</p><code language="ts" format="">getHeroes (): Observable&lt;Hero[]&gt; {
  return this.http.get(this.heroesUrl)
                  .map(this.extractData)
                  .catch(this.handleError);
}
private handleError (error: any) {
  // In a real world app, we might use a remote logging infrastructure
  // We&apos;d also dig deeper into the error to get a better message
  let errMsg = (error.message) ? error.message :
    error.status ? `${error.status} - ${error.statusText}` : &apos;Server error&apos;;
  console.error(errMsg); // log to console instead
  return Observable.throw(errMsg);
}
</code><a id="subscribe"></a><a id="hero-list-component"></a><h4><b>HeroListComponent</b> error handling</h4><p>Back in the <code>HeroListComponent</code>, where we called <code>heroService.getHeroes()</code>, 
we supply the <code>subscribe</code> function with a second function parameter to handle the error message.
It sets an <code>errorMessage</code> variable which we&apos;ve bound conditionally in the <code>HeroListComponent</code> template.</p><span>
</span><p>app/toh/hero-list.component.ts (getHeroes)</p><code language="ts" format="">getHeroes() {
  this.heroService.getHeroes()
                   .subscribe(
                     heroes =&gt; this.heroes = heroes,
                     error =&gt;  this.errorMessage = &lt;any&gt;error);
}
</code><div class="l-sub-section"><p>Want to see it fail? Reset the api endpoint in the <code>HeroService</code> to a bad value. Remember to restore it!</p><span>
</span></div><a id="update"></a><span>
</span><a id="post"></a><h2 id="send-data-to-the-server">Send data to the server</h2><span>
</span><p>So far we&apos;ve seen how to retrieve data from a remote location using an HTTP service. 
Let&apos;s add the ability to create new heroes and save them in the backend.</p><span>
</span><p>We&apos;ll create an easy method for the <code>HeroListComponent</code> to call, an <code>addHero()</code> method that takes
just the name of a new hero:</p><span>
</span><code language="ts" format="">addHero (name: string): Observable&lt;Hero&gt; {
</code><p>To implement it, we need to know some details about the server&apos;s api for creating heroes.</p><span>
</span><p><a href="https://angular.io/docs/ts/latest/guide/server-communication.html#server">Our data server</a> follows typical REST guidelines.
It expects a <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9.5"><code>POST</code></a> request
at the same endpoint where we <code>GET</code> heroes.
It expects the new hero data to arrive in the body of the request, 
structured like a <code>Hero</code> entity but without the <code>id</code> property.
The body of the request should look like this:</p><span>
</span><code format="." language="javascript">{ &quot;name&quot;: &quot;Windstorm&quot; }</code><p>The server will generate the <code>id</code> and return the entire <code>JSON</code> representation
of the new hero including its generated id. The hero arrives tucked inside a response object
with its own <code>data</code> property.</p><span>
</span><p>Now that we know how the API works, we implement <code>addHero()</code>like this:</p><span>
</span><p>app/toh/hero.service.ts (additional imports)</p><code language="ts" format="">import { Headers, RequestOptions } from &apos;@angular/http&apos;;
</code><p>app/toh/hero.service.ts (addHero)</p><code language="ts" format="">  addHero (name: string): Observable&lt;Hero&gt; {
    let body = JSON.stringify({ name });
    let headers = new Headers({ &apos;Content-Type&apos;: &apos;application/json&apos; });
    let options = new RequestOptions({ headers: headers });

    return this.http.post(this.heroesUrl, body, options)
                    .map(this.extractData)
                    .catch(this.handleError);
  }
</code><span>
</span><p>The <code>Content-Type</code> header allows us to inform the server that the body will represent JSON.</p><span>
</span><p><a href="https://angular.io/docs/ts/latest/api/http/index/Headers-class.html">Headers</a> are one of the <a href="https://angular.io/docs/ts/latest/api/http/index/RequestOptions-class.html">RequestOptions</a>.
Compose the options object and pass it in as the <em>third</em> parameter of the <code>post</code> method, as shown above.</p><span>
</span><h3 id="body">Body</h3><span>
</span><p>Despite the content type being specified as JSON, the POST body must actually be a <em>string</em>.
Hence, we explicitly encode the JSON hero content before passing it in as the body argument.</p><span>
</span><div class="l-sub-section"><p>We may be able to skip the <code>JSON.stringify</code> step in the near future.</p><span>
</span></div><h3 id="json-results">JSON results</h3><span>
</span><p>As with <code>getHeroes()</code>, we <a href="https://angular.io/docs/ts/latest/guide/server-communication.html#extract-data">extract the data</a> from the response using the
<code>extractData()</code> helper.</p><span>
</span><p>Back in the <code>HeroListComponent</code>, we see that <em>its</em> <code>addHero()</code> method subscribes to the observable returned by the <em>service&apos;s</em> <code>addHero()</code> method.
When the data, arrive it pushes the new hero object into its <code>heroes</code> array for presentation to the user.</p><span>
</span><p>app/toh/hero-list.component.ts (addHero)</p><code language="ts" format="">addHero (name: string) {
  if (!name) { return; }
  this.heroService.addHero(name)
                   .subscribe(
                     hero  =&gt; this.heroes.push(hero),
                     error =&gt;  this.errorMessage = &lt;any&gt;error);
}
</code><h2 id="promises">Fall back to Promises</h2><p>Although the Angular <code>http</code> client API returns an <code>Observable&lt;Response&gt;</code> we can turn it into a 
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">Promise<response></response></a> if we prefer.
It&apos;s easy to do and a promise-based version looks much like the observable-based version in simple cases.</p><span>
</span><div class="l-sub-section"><p>While promises may be more familiar, observables have many advantages. 
Don&apos;t rush to promises until you give observables a chance.</p><span>
</span></div><p>Let&apos;s rewrite the <code>HeroService</code> using promises , highlighting just the parts that are different.</p><span>
</span><code-tabs><code language="ts" name="app/toh/hero.service.promise.ts (promise-based)" format="linenums">getHeroes (): Promise&lt;Hero[]&gt; {
  return this.http.get(this.heroesUrl)
                  .toPromise()
                  .then(this.extractData)
                  .catch(this.handleError);
}

addHero (name: string): Promise&lt;Hero&gt; {
  let body = JSON.stringify({ name });
  let headers = new Headers({ &apos;Content-Type&apos;: &apos;application/json&apos; });
  let options = new RequestOptions({ headers: headers });

  return this.http.post(this.heroesUrl, body, options)
             .toPromise()
             .then(this.extractData)
             .catch(this.handleError);
}

private extractData(res: Response) {
  let body = res.json();
  return body.data || { };
}

private handleError (error: any) {
  // In a real world app, we might use a remote logging infrastructure
  // We&apos;d also dig deeper into the error to get a better message
  let errMsg = (error.message) ? error.message :
    error.status ? `${error.status} - ${error.statusText}` : &apos;Server error&apos;;
  console.error(errMsg); // log to console instead
  return Promise.reject(errMsg);
}
</code><code language="ts" name="app/toh/hero.service.ts (observable-based)" format="linenums">  getHeroes (): Observable&lt;Hero[]&gt; {
    return this.http.get(this.heroesUrl)
                    .map(this.extractData)
                    .catch(this.handleError);
  }

  addHero (name: string): Observable&lt;Hero&gt; {
    let body = JSON.stringify({ name });
    let headers = new Headers({ &apos;Content-Type&apos;: &apos;application/json&apos; });
    let options = new RequestOptions({ headers: headers });

    return this.http.post(this.heroesUrl, body, options)
                    .map(this.extractData)
                    .catch(this.handleError);
  }

  private extractData(res: Response) {
    let body = res.json();
    return body.data || { };
  }

  private handleError (error: any) {
    // In a real world app, we might use a remote logging infrastructure
    // We&apos;d also dig deeper into the error to get a better message
    let errMsg = (error.message) ? error.message :
      error.status ? `${error.status} - ${error.statusText}` : &apos;Server error&apos;;
    console.error(errMsg); // log to console instead
    return Observable.throw(errMsg);
  }
</code></code-tabs><p>Converting from an observable to a promise is as simple as calling <code>toPromise(success, fail)</code>.</p><span>
</span><p>We move the observable&apos;s <code>map</code> callback to the first <em>success</em> parameter and its <code>catch</code> callback to the second <em>fail</em> parameter
and we&apos;re done!
Or we can follow the promise <code>then.catch</code> pattern as we do in the second <code>addHero</code> example.</p><span>
</span><p>Our <code>errorHandler</code> forwards an error message as a failed promise instead of a failed Observable.</p><span>
</span><p>The diagnostic <em>log to console</em> is just one more <code>then</code> in the promise chain.</p><span>
</span><p>We have to adjust the calling component to expect a <code>Promise</code> instead of an <code>Observable</code>.</p><span>
</span><code-tabs><code language="ts" name="app/toh/hero-list.component.promise.ts (promise-based)" format="linenums">getHeroes() {
  this.heroService.getHeroes()
                   .then(
                     heroes =&gt; this.heroes = heroes,
                     error =&gt;  this.errorMessage = &lt;any&gt;error);
}

addHero (name: string) {
  if (!name) { return; }
  this.heroService.addHero(name)
                   .then(
                     hero  =&gt; this.heroes.push(hero),
                     error =&gt;  this.errorMessage = &lt;any&gt;error);
}
</code><code language="ts" name="app/toh/hero-list.component.ts (observable-based)" format="linenums">  getHeroes() {
    this.heroService.getHeroes()
                     .subscribe(
                       heroes =&gt; this.heroes = heroes,
                       error =&gt;  this.errorMessage = &lt;any&gt;error);
  }

  addHero (name: string) {
    if (!name) { return; }
    this.heroService.addHero(name)
                     .subscribe(
                       hero  =&gt; this.heroes.push(hero),
                       error =&gt;  this.errorMessage = &lt;any&gt;error);
  }
</code></code-tabs><p>The only obvious difference is that we call <code>then</code> on the returned promise instead of <code>subscribe</code>.
We give both methods the same functional arguments. </p><span>
</span><div class="l-sub-section"><p>The less obvious but critical difference is that these two methods return very different results!</p><span>
</span><p>The promise-based <code>then</code> returns another promise. We can keep chaining more <code>then</code> and <code>catch</code> calls, getting a new promise each time.</p><span>
</span><p>The <code>subscribe</code> method returns a <code>Subscription</code>. A <code>Subscription</code> is not another <code>Observable</code>. 
It&apos;s the end of the line for observables. We can&apos;t call <code>map</code> on it or call <code>subscribe</code> again.
The <code>Subscription</code> object has a different purpose, signified by its primary method, <code>unsubscribe</code>.</p><span>
</span><p>Learn more about observables to understand the implications and consequences of subscriptions.</p><span>
</span></div><h2 id="cors">Cross-origin requests: Wikipedia example</h2><p>We just learned how to make <code>XMLHttpRequests</code> using the Angular <code>Http</code> service. 
This is the most common approach for server communication. 
It doesn&apos;t work in all scenarios.</p><span>
</span><p>For security reasons, web browsers block <code>XHR</code> calls to a remote server whose origin is different from the origin of the web page.
The <em>origin</em> is the combination of URI scheme, hostname and port number. 
This is called the <a href="https://en.wikipedia.org/wiki/Same-origin_policy">Same-origin Policy</a>.</p><span>
</span><div class="l-sub-section"><p>Modern browsers do allow <code>XHR</code> requests to servers from a different origin if the server supports the 
<a href="https://en.wikipedia.org/wiki/Cross-origin_resource_sharing">CORS</a> protocol.
If the server requires user credentials, we&apos;ll enable them in the <a href="https://angular.io/docs/ts/latest/guide/server-communication.html#headers">request headers</a>.</p><span>
</span></div><p>Some servers do not support CORS but do support an older, read-only alternative called <a href="https://en.wikipedia.org/wiki/JSONP">JSONP</a>.
Wikipedia is one such server.</p><span>
</span><h3 id="search-wikipedia">Search wikipedia</h3><span>
</span><p>Let&apos;s build a simple search that shows suggestions from wikipedia as we type in a text box.</p><span>
</span><figure class="image-display"><img src="https://angular.io/resources/images/devguide/server-communication/wiki-1.gif" alt="Wikipedia search app (v.1)" width="250"></figure><p>Wikipedia offers a modern <code>CORS</code> API and a legacy <code>JSONP</code> search API. Let&apos;s use the latter for this example.
The Angular <code>Jsonp</code> service both extends the <code>Http</code> service for JSONP and restricts us to <code>GET</code> requests. 
All other HTTP methods throw an error because JSONP is a read-only facility. </p><span>
</span><p>As always, we wrap our interaction with an Angular data access client service inside a dedicated service, here called <code>WikipediaService</code>.</p><span>
</span><p>app/wiki/wikipedia.service.ts</p><code language="ts" format="linenums">import { Injectable } from &apos;@angular/core&apos;;
import { Jsonp, URLSearchParams } from &apos;@angular/http&apos;;

@Injectable()
export class WikipediaService {
  constructor(private jsonp: Jsonp) {}

  search (term: string) {

    let wikiUrl = &apos;http://en.wikipedia.org/w/api.php&apos;;

    let params = new URLSearchParams();
    params.set(&apos;search&apos;, term); // the user&apos;s search value
    params.set(&apos;action&apos;, &apos;opensearch&apos;);
    params.set(&apos;format&apos;, &apos;json&apos;);
    params.set(&apos;callback&apos;, &apos;JSONP_CALLBACK&apos;);

    // TODO: Add error handling
    return this.jsonp
               .get(wikiUrl, { search: params })
               .map(response =&gt; &lt;string[]&gt; response.json()[1]);
  }
}
</code><p>The constructor expects Angular to inject its <code>jsonp</code> service. 
We made that service available by importing the <code>JsonpModule</code> into our root NgModule.</p><span>
</span><a id="query-parameters"></a><h3 id="search-parameters">Search parameters</h3><span>
</span><p>The <a href="https://www.mediawiki.org/wiki/API:Opensearch">Wikipedia &apos;opensearch&apos; API</a>
expects four parameters (key/value pairs) to arrive in the request URL&apos;s query string.
The keys are <code>search</code>, <code>action</code>, <code>format</code>, and <code>callback</code>.
The value of the <code>search</code> key is the user-supplied search term to find in Wikipedia.
The other three are the fixed values &quot;opensearch&quot;, &quot;json&quot;, and &quot;JSONP_CALLBACK&quot; respectively.</p><span>
</span><div class="l-sub-section"><p>The <code>JSONP</code> technique requires that we pass a callback function name to the server in the query string: <code>callback=JSONP_CALLBACK</code>.
The server uses that name to build a JavaScript wrapper function in its response which Angular ultimately calls to extract the data.
All of this happens under the hood.</p><span>
</span></div><p>If we&apos;re looking for articles with the word &quot;Angular&quot;, we could construct the query string by hand and call <code>jsonp</code> like this:</p><span>
</span><code language="ts" format="">let queryString =
  `?search=${term}&amp;action=opensearch&amp;format=json&amp;callback=JSONP_CALLBACK`;

return this.jsonp
           .get(wikiUrl + queryString)
           .map(response =&gt; &lt;string[]&gt; response.json()[1]);
</code><p>In more parameterized examples we might prefer to build the query string with the Angular <code>URLSearchParams</code> helper as shown here:</p><span>
</span><p>app/wiki/wikipedia.service.ts (search parameters)</p><code language="ts" format="">let params = new URLSearchParams();
params.set(&apos;search&apos;, term); // the user&apos;s search value
params.set(&apos;action&apos;, &apos;opensearch&apos;);
params.set(&apos;format&apos;, &apos;json&apos;);
params.set(&apos;callback&apos;, &apos;JSONP_CALLBACK&apos;);
</code><p>This time we call <code>jsonp</code> with <em>two</em> arguments: the <code>wikiUrl</code> and an options object whose <code>search</code> property is the <code>params</code> object.</p><span>
</span><p>app/wiki/wikipedia.service.ts (call jsonp)</p><code language="ts" format="">// TODO: Add error handling
return this.jsonp
           .get(wikiUrl, { search: params })
           .map(response =&gt; &lt;string[]&gt; response.json()[1]);
</code><p><code>Jsonp</code> flattens the <code>params</code> object into the same query string we saw earlier before putting the request on the wire.</p><span>
</span><a id="wikicomponent"></a><h3 id="the-wikicomponent">The WikiComponent</h3><span>
</span><p>Now that we have a service that can query the Wikipedia API, 
we turn to the component that takes user input and displays search results.</p><span>
</span><p>app/wiki/wiki.component.ts</p><code language="ts" format="linenums">import { Component }        from &apos;@angular/core&apos;;
import { Observable }       from &apos;rxjs/Observable&apos;;

import { WikipediaService } from &apos;./wikipedia.service&apos;;

@Component({
  selector: &apos;my-wiki&apos;,
  template: `
    &lt;h1&gt;Wikipedia Demo&lt;/h1&gt;
    &lt;p&gt;&lt;i&gt;Fetches after each keystroke&lt;/i&gt;&lt;/p&gt;

    &lt;input #term (keyup)=&quot;search(term.value)&quot;/&gt;

    &lt;ul&gt;
      &lt;li *ngFor=&quot;let item of items | async&quot;&gt;{{item}}&lt;/li&gt;
    &lt;/ul&gt;
  `,
  providers: [WikipediaService]
})
export class WikiComponent {
  items: Observable&lt;string[]&gt;;

  constructor (private wikipediaService: WikipediaService) {}

  search (term: string) {
    this.items = this.wikipediaService.search(term);
  }
}
</code><p>The component presents an <code>&lt;input&gt;</code> element <em>search box</em> to gather search terms from the user. 
and calls a <code>search(term)</code> method after each <code>keyup</code> event.</p><span>
</span><p>The <code>search(term)</code> method delegates to our <code>WikipediaService</code> which returns an observable array of string results (<code>Observable&lt;string[]&gt;</code>). 
Instead of subscribing to the observable inside the component as we did in the <code>HeroListComponent</code>, 
we forward the observable result to the template (via <code>items</code>) where the <a href="https://angular.io/docs/ts/latest/guide/pipes.html#async-pipe">async pipe</a>
in the <code>ngFor</code> handles the subscription.</p><span>
</span><div class="l-sub-section"><p>We often use the <a href="https://angular.io/docs/ts/latest/guide/pipes.html#async-pipe">async pipe</a> in read-only components where the component has no need to interact with the data.
We couldn&apos;t use the pipe in the <code>HeroListComponent</code> because the &quot;add hero&quot; feature pushes newly created heroes into the list.</p><span>
</span></div><h2 id="our-wasteful-app">Our wasteful app</h2><span>
</span><p>Our wikipedia search makes too many calls to the server. 
It is inefficient and potentially expensive on mobile devices with limited data plans.</p><span>
</span><h3 id="1-wait-for-the-user-to-stop-typing">1. Wait for the user to stop typing</h3><span>
</span><p>At the moment we call the server after every key stroke.
The app should only make requests when the user <em>stops typing</em> .
Here&apos;s how it <em>should</em> work &#x2014; and <em>will</em> work  &#x2014;  when we&apos;re done refactoring:</p><span>
</span><figure class="image-display"><img src="https://angular.io/resources/images/devguide/server-communication/wiki-2.gif" alt="Wikipedia search app (v.2)" width="250"></figure><h3 id="2-search-when-the-search-term-changes">2. Search when the search term changes</h3><span>
</span><p>Suppose the user enters the word <em>angular</em> in the search box and pauses for a while. 
The application issues a search request for <em>Angular</em>.</p><span>
</span><p>Then the user backspaces over the last three letters, <em>lar</em>, and immediately re-types <em>lar</em> before pausing once more.
The search term is still &quot;angular&quot;. The app shouldn&apos;t make another request.</p><span>
</span><h3 id="3-cope-with-out-of-order-responses">3. Cope with out-of-order responses</h3><span>
</span><p>The user enters <em>angular</em>, pauses, clears the search box, and enters <em>http</em>. 
The application issues two search requests, one for <em>angular</em> and one for <em>http</em>. </p><span>
</span><p>Which response will arrive first? We can&apos;t be sure. 
A load balancer could dispatch the requests to two different servers with different response times.
The results from the first <em>angular</em> request might arrive after the later <em>http</em> results.
The user will be confused if we display the <em>angular</em> results to the <em>http</em> query.</p><span>
</span><p>When there are multiple requests in-flight, the app should present the responses
in the original request order. That won&apos;t happen if <em>angular</em> results arrive last.</p><span>
</span><span>
</span><h2 id="more-fun-with-observables">More fun with Observables</h2><span>
</span><p>We can address these problems and improve our app with the help of some nifty observable operators. </p><span>
</span><p>We could make our changes to the <code>WikipediaService</code>. 
But we sense that our concerns are driven by the user experience so we update the component class instead.</p><span>
</span><p>app/wiki/wiki-smart.component.ts</p><code language="ts" format="linenums">import { Component }        from &apos;@angular/core&apos;;
import { Observable }       from &apos;rxjs/Observable&apos;;
import { Subject }          from &apos;rxjs/Subject&apos;;

import { WikipediaService } from &apos;./wikipedia.service&apos;;

@Component({
  selector: &apos;my-wiki-smart&apos;,
  template: `
    &lt;h1&gt;Smarter Wikipedia Demo&lt;/h1&gt;
    &lt;p&gt;&lt;i&gt;Fetches when typing stops&lt;/i&gt;&lt;/p&gt;

    &lt;input #term (keyup)=&quot;search(term.value)&quot;/&gt;

    &lt;ul&gt;
      &lt;li *ngFor=&quot;let item of items | async&quot;&gt;{{item}}&lt;/li&gt;
    &lt;/ul&gt;
  `,
  providers: [WikipediaService]
})
export class WikiSmartComponent {

  constructor (private wikipediaService: WikipediaService) { }

  private searchTermStream = new Subject&lt;string&gt;();

  search(term: string) { this.searchTermStream.next(term); }

  items: Observable&lt;string[]&gt; = this.searchTermStream
    .debounceTime(300)
    .distinctUntilChanged()
    .switchMap((term: string) =&gt; this.wikipediaService.search(term));
}
</code><p>We made no changes to the template or metadata, confining them all to the component class.
Let&apos;s review those changes.</p><span>
</span><h3 id="create-a-stream-of-search-terms">Create a stream of search terms</h3><span>
</span><p>We&apos;re binding to the search box <code>keyup</code> event and calling the component&apos;s <code>search</code> method after each keystroke.</p><span>
</span><p>We turn these events into an observable stream of search terms using a <code>Subject</code> 
which we import from the RxJS observable library:</p><span>
</span><code language="ts" format="">import { Subject }          from &apos;rxjs/Subject&apos;;
</code><p>Each search term is a string, so we create a new <code>Subject</code> of type <code>string</code> called <code>searchTermStream</code>.
After every keystroke, the <code>search</code> method adds the search box value to that stream
via the subject&apos;s <code>next</code> method.</p><span>
</span><code language="ts" format="">private searchTermStream = new Subject&lt;string&gt;();

search(term: string) { this.searchTermStream.next(term); }
</code><h3 id="listen-for-search-terms">Listen for search terms</h3><span>
</span><p>Earlier, we passed each search term directly to the service and bound the template to the service results.
Now we listen to the <em>stream of terms</em>, manipulating the stream before it reaches the <code>WikipediaService</code>.</p><span>
</span><code language="ts" format="">items: Observable&lt;string[]&gt; = this.searchTermStream
  .debounceTime(300)
  .distinctUntilChanged()
  .switchMap((term: string) =&gt; this.wikipediaService.search(term));
</code><p>We wait for the user to stop typing for at least 300 milliseconds 
(<a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/debounce.md">debounceTime</a>).
Only changed search values make it through to the service 
(<a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/distinctuntilchanged.md">distinctUntilChanged</a>).</p><span>
</span><p>The <code>WikipediaService</code> returns a separate observable of string arrays (<code>Observable&lt;string[]&gt;</code>) for each request.
We could have multiple requests <em>in flight</em>, all awaiting the server&apos;s reply,
which means multiple <em>observables-of-strings</em> could arrive at any moment in any order.</p><span>
</span><p>The <a href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/operators/flatmaplatest.md">switchMap</a>
(formerly known as <code>flatMapLatest</code>) returns a new observable that combines these <code>WikipediaService</code> observables, 
re-arranges them in their original request order,
and delivers to subscribers only the most recent search results. </p><span>
</span><p>The displayed list of search results stays in sync with the user&apos;s sequence of search terms.</p><span>
</span><div class="l-sub-section"><p>We added the <code>debounceTime</code>, <code>distinctUntilChanged</code>, and <code>switchMap</code> operators to the RxJS <code>Observable</code> class
in <code>rxjs-operators</code> as <a href="https://angular.io/docs/ts/latest/guide/server-communication.html#rxjs">described above</a></p><span>
</span></div><a id="in-mem-web-api"></a><h2 id="appendix-tour-of-heroes-in-memory-server">Appendix: Tour of Heroes in-memory server</h2><span>
</span><p>If we only cared to retrieve data, we could tell Angular to get the heroes from a <code>heroes.json</code> file like this one:</p><span>
</span><p>app/heroes.json</p><code language="json" format=".">{
  &quot;data&quot;: [
    { &quot;id&quot;: &quot;1&quot;, &quot;name&quot;: &quot;Windstorm&quot; },
    { &quot;id&quot;: &quot;2&quot;, &quot;name&quot;: &quot;Bombasto&quot; },
    { &quot;id&quot;: &quot;3&quot;, &quot;name&quot;: &quot;Magneta&quot; },
    { &quot;id&quot;: &quot;4&quot;, &quot;name&quot;: &quot;Tornado&quot; }
  ]
}
</code><div class="l-sub-section"><p>We wrap the heroes array in an object with a <code>data</code> property for the same reason that a data server does:
to mitigate the <a href="http://stackoverflow.com/questions/3503102/what-are-top-level-json-arrays-and-why-are-they-a-security-risk">security risk</a>
posed by top-level JSON arrays. </p><span>
</span></div><p>We&apos;d set the endpoint to the JSON file like this:</p><span>
</span><code language="ts" format="">private heroesUrl = &apos;app/heroes.json&apos;; // URL to JSON file
</code><p>The <em>get heroes</em> scenario would work.
But we want to <em>save</em> data too. We can&apos;t save changes to a JSON file. We need a web API server.
We didn&apos;t want the hassle of setting up and maintaining a real server for this chapter.
So we turned to an <em>in-memory web API simulator</em> instead.</p><span>
</span><div class="l-sub-section"><p>The in-memory web api is not part of the Angular core. 
It&apos;s an optional service in its own <code>angular2-in-memory-web-api</code> library
that we installed with npm (see <code>package.json</code>) and 
registered for module loading by SystemJS (see <code>systemjs.config.js</code>)</p><span>
</span></div><p>The in-memory web API gets its data from a custom application class with a <code>createDb()</code>
method that returns a map whose keys are collection names and whose values 
are arrays of objects in those collections.</p><span>
</span><p>Here&apos;s the class we created for this sample based on the JSON data:</p><span>
</span><p>app/hero-data.ts</p><code language="ts" format="">import { InMemoryDbService } from &apos;angular2-in-memory-web-api&apos;;
export class HeroData implements InMemoryDbService {
  createDb() {
    let heroes = [
      { id: &apos;1&apos;, name: &apos;Windstorm&apos; },
      { id: &apos;2&apos;, name: &apos;Bombasto&apos; },
      { id: &apos;3&apos;, name: &apos;Magneta&apos; },
      { id: &apos;4&apos;, name: &apos;Tornado&apos; }
    ];
    return {heroes};
  }
}
</code><p>Ensure that the <code>HeroService</code> endpoint refers to the web API:</p><span>
</span><code language="ts" format="">private heroesUrl = &apos;app/heroes&apos;;  // URL to web API
</code><p>Finally, redirect client HTTP requests to the in-memory web API.</p><span>
</span><p>This redirection is easy to configure with the in-memory web API service module.
by adding the <code>InMemoryWebApiModule</code> to the <code>AppModule.imports</code> list.
At the same time, we calling its <code>forRoot</code> configuration method with the <code>HeroData</code> class.</p><span>
</span><code language="ts" format="">InMemoryWebApiModule.forRoot(HeroData)
</code><h3 id="how-it-works">How it works</h3><span>
</span><p>Angular&apos;s <code>http</code> service delegates the client/server communication tasks
to a helper service called the <code>XHRBackend</code>. </p><span>
</span><p>Using standard Angular provider registration techniques, the <code>InMemoryWebApiModule</code> 
replaces the default <code>XHRBackend</code> service with its own in-memory alternative. 
The <code>forRoot</code> method initialize the in-memory web API with <em>seed data</em> from the mock hero dataset at the same time.</p><span>
</span><div class="l-sub-section"><p>The <code>forRoot</code> method name is a strong reminder that you should only call the <code>InMemoryWebApiModule</code> <em>once</em>
while setting the metadata for the root <code>AppModule</code>. Don&apos;t call it again!.</p><span>
</span></div><p>Here is the revised (and final) version of <span ngio-ex="">app/app.module.ts&gt;</span> demonstrating these steps.</p><span>
</span><p>app/app.module.ts (excerpt)</p><code language="ts" format="">import { NgModule } from &apos;@angular/core&apos;;
import { BrowserModule } from &apos;@angular/platform-browser&apos;;
import { FormsModule } from &apos;@angular/forms&apos;;
import { HttpModule, JsonpModule }  from &apos;@angular/http&apos;;

import { InMemoryWebApiModule }     from &apos;angular2-in-memory-web-api&apos;;
import { HeroData }                 from &apos;./hero-data&apos;;

import { AppComponent }             from &apos;./app.component&apos;;

import { HeroListComponent }        from &apos;./toh/hero-list.component&apos;;
import { HeroListPromiseComponent } from &apos;./toh/hero-list.component.promise&apos;;

import { WikiComponent }      from &apos;./wiki/wiki.component&apos;;
import { WikiSmartComponent } from &apos;./wiki/wiki-smart.component&apos;;

@NgModule({
  imports: [
    BrowserModule,
    FormsModule,
    HttpModule,
    JsonpModule,
    InMemoryWebApiModule.forRoot(HeroData)
  ],
  declarations: [
    AppComponent,
    HeroListComponent,
    HeroListPromiseComponent,
    WikiComponent,
    WikiSmartComponent
  ],
  bootstrap: [ AppComponent ]
})
export class AppModule { }
</code><p>See the full source code in the <live-example></live-example>.</p><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--></div></div>
        </article>
      
        <article>
          <h3>Lifecycle Hooks</h3>
          <div><div class="showcase-content"><span>
</span><p>A Component has a lifecycle managed by Angular itself. Angular creates it, renders it, creates and renders its children,
checks it when its data-bound properties change, and destroys it before removing it from the DOM.</p><span>
</span><p>Angular offers <strong>component lifecycle hooks</strong>
that give us visibility into these key moments and the ability to act when they occur.</p><span>
</span><p>We cover these hooks in this chapter and demonstrate how they work in code.</p><span>
</span><ul>
<li><a href="https://angular.io/docs/ts/latest/guide/lifecycle-hooks.html#hooks-overview">The lifecycle hooks</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/lifecycle-hooks.html#hook-sequence">The hook-call sequence</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/lifecycle-hooks.html#other-lifecycles">Other Angular lifecycle hooks</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/lifecycle-hooks.html#the-sample">The lifecycle sample</a><ul>
<li><a href="https://angular.io/docs/ts/latest/guide/lifecycle-hooks.html#peek-a-boo">All</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/lifecycle-hooks.html#spy">Spying OnInit and OnDestroy</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/lifecycle-hooks.html#onchanges">OnChanges</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/lifecycle-hooks.html#docheck">DoCheck</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/lifecycle-hooks.html#afterview">AfterViewInit and AfterViewChecked</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/lifecycle-hooks.html#aftercontent">AfterContentInit and AfterContentChecked</a></li>
</ul>
</li>
</ul><span>
</span><p>Try the <live-example></live-example>.</p><span>
</span><a id="hooks-overview"></a><h2 id="component-lifecycle-hooks">Component lifecycle Hooks</h2><span>
</span><p>Directive and component instances have a lifecycle
as Angular creates, updates, and destroys them.</p><span>
</span><p>Developers can tap into key moments in that lifecycle by implementing
one or more of the <em>Lifecycle Hook</em> interfaces in the Angular <code>core</code> library.</p><span>
</span><p>Each interface has a single hook method whose name is the interface name prefixed with <code>ng</code>.
For example, the <code>OnInit</code> interface has a hook method named <code>ngOnInit</code>.
We might implement it in a component class like this:</p><span>
</span><p>peek-a-boo.component.ts (excerpt)</p><code language="ts" format="">export class PeekABoo implements OnInit {
  constructor(private logger: LoggerService) { }

  // implement OnInit&apos;s `ngOnInit` method
  ngOnInit() { this.logIt(`OnInit`); }

  protected logIt(msg: string) {
    this.logger.log(`#${nextId++} ${msg}`);
  }
}
</code><p>No directive or component will implement all of them and some of the hooks only make sense for components.
Angular only calls a directive/component hook method <em>if it is defined</em>.</p><span>
</span><div class="l-sub-section"><h3 id="interface-optional-">Interface optional?</h3><span>
</span><p>The interfaces are optional for JavaScript and Typescript developers from a purely technical perspective.
The JavaScript language doesn&apos;t have interfaces.
Angular can&apos;t see TypeScript interfaces at runtime because they disappear from the transpiled JavaScript.</p><span>
</span><p>Fortunately, they aren&apos;t necessary.
We don&apos;t have to add the lifecycle hook interfaces to our directives and components to benefit from the hooks themselves.</p><span>
</span><p>Angular instead inspects our directive and component classes and calls the hook methods <em>if they are defined</em>.
Angular will find and call methods like <code>ngOnInit()</code>, with or without the interfaces.</p><span>
</span><p>Nonetheless, we strongly recommend adding interfaces to TypeScript directive classes
in order to benefit from strong typing and editor tooling.</p><span>
</span></div><p>Here are the component lifecycle hook methods:</p><span>
</span><h3 id="directives-and-components">Directives and Components</h3><span>
</span><table width="100%"><colgroup><col width="20%"><col width="80%"></colgroup><tbody><tr><th>Hook</th><th>Purpose</th></tr><tr><td>ngOnInit</td><td><p>Initialize the directive/component after Angular initializes the data-bound input properties.</p>
</td></tr><tr><td>ngOnChanges</td><td><p>Respond after Angular sets a data-bound input property.
The method receives a <code>changes</code> object of current and previous values.</p>
</td></tr><tr><td>ngDoCheck</td><td><p>Detect and act upon changes that Angular can&apos;t or won&apos;t
detect on its own. Called every change detection run.</p>
</td></tr><tr><td>ngOnDestroy</td><td><p>Cleanup just before Angular destroys the directive/component.
Unsubscribe observables and detach event handlers to avoid memory leaks.</p>
</td></tr></tbody></table><h3 id="components-only">Components only</h3><span>
</span><table width="100%"><colgroup><col width="20%"><col width="80%"></colgroup><tbody><tr><th>Hook</th><th>Purpose</th></tr><tr><td>ngAfterContentInit</td><td><p>After Angular projects external content into its view.</p>
</td></tr><tr><td>ngAfterContentChecked</td><td><p>After Angular checks the bindings of the external content that it projected into its view.</p>
</td></tr><tr><td>ngAfterViewInit</td><td><p>After Angular creates the component&apos;s view(s).</p>
</td></tr><tr><td>ngAfterViewChecked</td><td><p>After Angular checks the bindings of the component&apos;s view(s).</p>
</td></tr></tbody></table><p>Angular does not call the hook methods in this order.</p><span>
</span><a id="hook-sequence"></a><h2 id="lifecycle-sequence">Lifecycle sequence</h2><span>
</span><p><em>After</em> Angular creates a component/directive by <code>new</code>-ing its constructor,
it calls the lifecycle hook methods in the following sequence at specific moments:</p><span>
</span><table width="100%"><colgroup><col width="20%"><col width="80%"></colgroup><tbody><tr><th>Hook</th><th>Timing</th></tr><tr><td>ngOnChanges</td><td><p>before <code>ngOnInit</code> and when a data-bound input property value changes.</p>
</td></tr><tr><td>ngOnInit</td><td><p>after the first <code>ngOnChanges</code>.</p>
</td></tr><tr><td>ngDoCheck</td><td><p>during every Angular change detection cycle.</p>
</td></tr><tr><td>ngAfterContentInit</td><td><p>after projecting content into the component.</p>
</td></tr><tr><td>ngAfterContentChecked</td><td><p>after every check of projected component content.</p>
</td></tr><tr><td>ngAfterViewInit</td><td><p>after initializing the component&apos;s views and child views.</p>
</td></tr><tr><td>ngAfterViewChecked</td><td><p>after every check of the component&apos;s views and child views.</p>
</td></tr><tr><td>ngOnDestroy</td><td><p>just before Angular destroys the directive/component.</p>
</td></tr></tbody></table><a id="other-lifecycles"></a><h2 id="other-lifecycle-hooks">Other lifecycle hooks</h2><span>
</span><p>Other Angular sub-systems may have their own lifecycle hooks apart from the component hooks we&apos;ve listed.</p><span>
</span><p>3rd party libraries might implement their hooks as well in order to give us, the developers, more
control over how these libraries are used.</p><span>
</span><h2 id="lifecycle-exercises">Lifecycle exercises</h2><span>
</span><p>The <live-example></live-example>
demonstrates the lifecycle hooks in action through a series of exercises
presented as components under the control of the root <code>AppComponent</code>.</p><span>
</span><p>They follow a common pattern:  a <em>parent</em> component serves as a test rig for
a <em>child</em> component that illustrates one or more of the lifecycle hook methods.</p><span>
</span><p>Here&apos;s a brief description of each exercise:</p><span>
</span><table width="100%"><colgroup><col width="20%"><col width="80%"></colgroup><tbody><tr><th>Component</th><th>Description</th></tr><tr><td><a href="https://angular.io/docs/ts/latest/guide/lifecycle-hooks.html#peek-a-boo">Peek-a-boo</a></td><td><p>Demonstrates every lifecycle hook.
Each hook method writes to the on-screen log.</p>
</td></tr><tr><td><a href="https://angular.io/docs/ts/latest/guide/lifecycle-hooks.html#spy">Spy</a></td><td><p>Directives have lifecycle hooks too.
We create a <code>SpyDirective</code> that logs when the element it spies upon is
created or destroyed using the <code>ngOnInit</code> and <code>ngOnDestroy</code> hooks.</p>
<p>We apply the <code>SpyDirective</code> to a <code>&lt;div&gt;</code> in an <code>ngFor</code> <em>hero</em> repeater
managed by the parent <code>SpyComponent</code>.</p>
</td></tr><tr><td><a href="https://angular.io/docs/ts/latest/guide/lifecycle-hooks.html#onchanges">OnChanges</a></td><td><p>See how Angular calls the <code>ngOnChanges</code> hook with a <code>changes</code> object
every time one of the component input properties changes.
Shows how to interpret the <code>changes</code> object.</p>
</td></tr><tr><td><a href="https://angular.io/docs/ts/latest/guide/lifecycle-hooks.html#docheck">DoCheck</a></td><td><p>Implements an <code>ngDoCheck</code> method with custom change detection.
See how often Angular calls this hook and watch it post changes to a log.</p>
</td></tr><tr><td><a href="https://angular.io/docs/ts/latest/guide/lifecycle-hooks.html#afterview">AfterView</a></td><td><p>Shows what Angular means by a <em>view</em>.
Demonstrates the <code>ngAfterViewInit</code> and <code>ngAfterViewChecked</code> hooks.</p>
</td></tr><tr><td><a href="https://angular.io/docs/ts/latest/guide/lifecycle-hooks.html#aftercontent">AfterContent</a></td><td><p>Shows how to project external content into a component and
how to distinguish projected content from a component&apos;s view children.
Demonstrates the <code>ngAfterContentInit</code> and <code>ngAfterContentChecked</code> hooks.</p>
</td></tr><tr><td>Counter</td><td><p>Demonstrates a combination of a component and a directive
each with its own hooks.</p>
<p>In this example, a <code>CounterComponent</code> logs a change (via <code>ngOnChanges</code>)
every time the parent component increments its input counter property.
Meanwhile, we apply the <code>SpyDirective</code> from the previous example
to the <code>CounterComponent</code> log and watch log entries be created and destroyed.</p>
</td></tr></tbody></table><p>We discuss the exercises in further detail over this chapter as we learn more about the lifecycle hooks.</p><span>
</span><a id="peek-a-boo"></a><h2 id="peek-a-boo-all-hooks">Peek-a-boo: all hooks</h2><span>
</span><p>The <code>PeekABooComponent</code> demonstrates all of the hooks in one component.</p><span>
</span><p>In real life, we&apos;d rarely if ever implement all of the interfaces like this.
We do so in peek-a-boo in order to watch Angular call the hooks in the expected order.</p><span>
</span><p>In this snapshot, we clicked the <em>Create...</em> button and then the <em>Destroy...</em> button.</p><span>
</span><figure class="image-display"><img src="https://angular.io/resources/images/devguide/lifecycle-hooks/peek-a-boo.png" alt="Peek-a-boo"></figure><p>The sequence of log messages follows the prescribed hook calling order:
<code>OnChanges</code>, <code>OnInit</code>, <code>DoCheck</code>&#xA0;(3x), <code>AfterContentInit</code>, <code>AfterContentChecked</code>&#xA0;(3x),
<code>AfterViewInit</code>, <code>AfterViewChecked</code>&#xA0;(3x), and <code>OnDestroy</code>.</p><span>
</span><div class="l-sub-section"><p>The constructor isn&apos;t an Angular hook <em>per se</em>.
We log in it to confirm that input properties (the <code>name</code> property in this case) have no assigned values at construction.</p><span>
</span></div><p>Had we clicked the <em>Update Hero</em> button, we&apos;d have seen another <code>OnChanges</code> and two more triplets of
<code>DoCheck</code>, <code>AfterContentChecked</code> and <code>AfterViewChecked</code>.
Clearly these three hooks fire a <em>lot</em> and we must keep the logic we put in these hooks
as lean as possible!</p><span>
</span><p>Our next examples focus on hook details.</p><span>
</span><h2 id="spying-oninit-and-ondestroy-">Spying <em>OnInit</em> and <em>OnDestroy</em></h2><span>
</span><p>We&apos;re going undercover for these two hooks. We want to know when an element is initialized or destroyed,
but we don&apos;t want <em>it</em> to know we&apos;re watching.</p><span>
</span><p>This is the perfect infiltration job for a directive.
Our heroes will never know it&apos;s there.</p><span>
</span><div class="l-sub-section"><p>Kidding aside, we&apos;re emphasizing two key points:</p><span>
</span><ol>
<li><p>Angular calls hook methods for <em>directives</em> as well as components.</p>
</li>
<li><p>A spy directive can gives us insight into a DOM object that we cannot change directly.
Obviously we can&apos;t change the implementation of a native <code>div</code>.
We can&apos;t modify a third party component either.
But we can watch both with a directive.</p>
</li>
</ol><span>
</span></div><p>Our sneaky spy directive is simple,  consisting almost entirely of <code>ngOnInit</code> and <code>ngOnDestroy</code> hooks
that log messages to the parent via an injected <code>LoggerService</code>.</p><span>
</span><code language="ts" format="">// Spy on any element to which it is applied.
// Usage: &lt;div mySpy&gt;...&lt;/div&gt;
@Directive({selector: &apos;[mySpy]&apos;})
export class SpyDirective implements OnInit, OnDestroy {

  constructor(private logger: LoggerService) { }

  ngOnInit()    { this.logIt(`onInit`); }

  ngOnDestroy() { this.logIt(`onDestroy`); }

  private logIt(msg: string) {
    this.logger.log(`Spy #${nextId++} ${msg}`);
  }
}
</code><p>We can apply the spy to any native or component element and it&apos;ll be initialized and destroyed
at the same time as that element.
Here we attach it to the repeated hero <code>&lt;div&gt;</code></p><span>
</span><code language="html" format="">&lt;div *ngFor=&quot;let hero of heroes&quot; mySpy class=&quot;heroes&quot;&gt;
  {{hero}}
&lt;/div&gt;
</code><p>Each spy&apos;s birth and death marks the birth and death of the attached hero <code>&lt;div&gt;</code>
with an entry in the <em>Hook Log</em> as we see here:</p><span>
</span><figure class="image-display"><img src="https://angular.io/resources/images/devguide/lifecycle-hooks/spy-directive.gif" alt="Spy Directive"></figure><p>Adding a hero results in a new hero <code>&lt;div&gt;</code>. The spy&apos;s <code>ngOnInit</code> logs that event.
We see a new entry for each hero.</p><span>
</span><p>The <em>Reset</em> button clears the <code>heroes</code> list.
Angular removes all hero divs from the DOM and destroys their spy directives at the same time.
The spy&apos;s <code>ngOnDestroy</code> method reports its last moments.</p><span>
</span><p>The <code>ngOnInit</code> and <code>ngOnDestroy</code> methods have more vital roles to play in real applications.
Let&apos;s see why we need them.</p><span>
</span><h3 id="oninit">OnInit</h3><span>
</span><p>We turn to <code>ngOnInit</code> for two main reasons:</p><span>
</span><ol>
<li>To perform complex initializations shortly after construction</li>
<li>To set up the component after Angular sets the input properties</li>
</ol><span>
</span><p>An <code>ngOnInit</code> often fetches data for the component as shown in the
<a href="https://angular.io/docs/ts/latest/tutorial/toh-pt4.html#oninit">Tutorial</a> and <a href="https://angular.io/docs/ts/latest/guide/server-communication.html#oninit">HTTP</a> chapters.</p><span>
</span><p>We don&apos;t fetch data in a component constructor. Why?
Because experienced developers agree that components should be cheap and safe to construct.
We shouldn&apos;t worry that a new component will try to contact a remote server when
created under test or before we decide to display it.
Constructors should do no more than set the initial local variables to simple values.</p><span>
</span><p>When a component must start working <em>soon</em> after creation,
we can count on Angular to call the <code>ngOnInit</code> method to jumpstart it.
That&apos;s where the heavy initialization logic belongs.</p><span>
</span><p>Remember also that a directive&apos;s data-bound input properties are not set until <em>after construction</em>.
That&apos;s a problem if we need to initialize the directive based on those properties.
They&apos;ll have been set when our <code>ngOninit</code> runs.</p><span>
</span><div class="l-sub-section"><p>Our first opportunity to access those properties is the <code>ngOnChanges</code> method which
Angular calls before <code>ngOnInit</code>. But Angular calls <code>ngOnChanges</code> many times after that.
It only calls <code>ngOnInit</code> once.</p><span>
</span></div><h3 id="ondestroy">OnDestroy</h3><span>
</span><p>Put cleanup logic in <code>ngOnDestroy</code>, the logic that <em>must</em> run before Angular destroys the directive.</p><span>
</span><p>This is the time to notify another part of the application that this component is going away.</p><span>
</span><p>This is the place to free resources that won&apos;t be garbage collected automatically.
Unsubscribe from observables and DOM events. Stop interval timers.
Unregister all callbacks that this directive registered with global or application services.
We risk memory leaks if we neglect to do so.</p><span>
</span><h2 id="onchanges">OnChanges</h2><span>
</span><p>We monitor the <code>OnChanges</code> hook in this example.
Angular calls its <code>ngOnChanges</code> method whenever it detects changes to <strong><em>input properties</em></strong> of the component (or directive).</p><span>
</span><p>Here is our implementation of the hook.</p><span>
</span><p>OnChangesComponent (ngOnChanges)</p><code language="ts" format="">ngOnChanges(changes: {[propertyName: string]: SimpleChange}) {
  for (let propName in changes) {
    let chng = changes[propName];
    let cur  = JSON.stringify(chng.currentValue);
    let prev = JSON.stringify(chng.previousValue);
    this.changeLog.push(`${propName}: currentValue = ${cur}, previousValue = ${prev}`);
  }
}
</code><p>The <code>ngOnChanges</code> method takes an object that maps each changed property name to a
<a href="https://angular.io/docs/ts/latest/api/core/index/SimpleChange-class.html">SimpleChange</a> object with the current and previous property values.
We iterate over the changed properties and log them.</p><span>
</span><p>The input properties for our example <code>OnChangesComponent</code> are <code>hero</code> and <code>power</code>.</p><span>
</span><code language="ts" format="">@Input() hero: Hero;
@Input() power: string;
</code><p>The parent binds to them like this:</p><span>
</span><code language="html" format="">&lt;on-changes [hero]=&quot;hero&quot; [power]=&quot;power&quot;&gt;&lt;/on-changes&gt;
</code><p>Here&apos;s the sample in action as we make changes.</p><span>
</span><figure class="image-display"><img src="https://angular.io/resources/images/devguide/lifecycle-hooks/on-changes-anim.gif" alt="OnChanges"></figure><p>We see log entries as the string value of the <em>power</em> property changes. But the <code>ngOnChanges</code> did not catch changes to <code>hero.name</code>
That&apos;s surprising at first.</p><span>
</span><p>Angular only calls the hook when the value of the input property changes.
The value of the <code>hero</code> property is the <em>reference to the hero object</em>.
Angular doesn&apos;t care that the hero&apos;s own <code>name</code> property changed.
The hero object <em>reference</em> didn&apos;t change so, from Angular&apos;s perspective, there is no change to report!</p><span>
</span><h2 id="docheck">DoCheck</h2><span>
</span><p>We can use the <code>DoCheck</code> hook to detect and act upon changes that Angular doesn&apos;t catch on its own.</p><span>
</span><div class="l-sub-section"><p>With this method we can detect a change that Angular overlooked.
What we do with that information to refresh the display is a separate matter.</p><span>
</span></div><p>The <em>DoCheck</em> sample extends the <em>OnChanges</em> sample with this implementation of <code>DoCheck</code>:</p><span>
</span><p>DoCheckComponent (ngDoCheck)</p><code language="ts" format="">ngDoCheck() {

  if (this.hero.name !== this.oldHeroName) {
    this.changeDetected = true;
    this.changeLog.push(`DoCheck: Hero name changed to &quot;${this.hero.name}&quot; from &quot;${this.oldHeroName}&quot;`);
    this.oldHeroName = this.hero.name;
  }

  if (this.power !== this.oldPower) {
    this.changeDetected = true;
    this.changeLog.push(`DoCheck: Power changed to &quot;${this.power}&quot; from &quot;${this.oldPower}&quot;`);
    this.oldPower = this.power;
  }

  if (this.changeDetected) {
      this.noChangeCount = 0;
  } else {
      // log that hook was called when there was no relevant change.
      let count = this.noChangeCount += 1;
      let noChangeMsg = `DoCheck called ${count}x when no change to hero or power`;
      if (count === 1) {
        // add new &quot;no change&quot; message
        this.changeLog.push(noChangeMsg);
      } else {
        // update last &quot;no change&quot; message
        this.changeLog[this.changeLog.length - 1] = noChangeMsg;
      }
  }

  this.changeDetected = false;
}
</code><p>We manually check everything that we care about, capturing and comparing against previous values.
We write a special message to the log when there are no substantive changes
to the hero or the power so we can keep an eye on the method&apos;s performance characteristics.</p><span>
</span><p>The results are illuminating:</p><span>
</span><figure class="image-display"><img src="https://angular.io/resources/images/devguide/lifecycle-hooks/do-check-anim.gif" alt="DoCheck"></figure><p>We now are able to detect when the hero&apos;s <code>name</code> has changed. But we must be careful.</p><span>
</span><p>The <code>ngDoCheck</code> hook is called with enormous frequency &#x2014;
after <em>every</em> change detection cycle no matter where the change occurred.
It&apos;s called over twenty times in this example before the user can do anything.</p><span>
</span><p>Most of these initial checks are triggered by Angular&apos;s first rendering of <em>unrelated data elsewhere on the page</em>.
Mere mousing into another input box triggers a call.
Relatively few calls reveal actual changes to pertinent data.
Clearly our implementation must be very lightweight or the user experience may suffer.</p><span>
</span><h2 id="afterview">AfterView</h2><span>
</span><p>The <em>AfterView</em> sample explores the <code>AfterViewInit</code> and <code>AfterViewChecked</code> hooks that Angular calls
<em>after</em> it creates a component&apos;s child views.</p><span>
</span><p>Here&apos;s a child view that displays a hero&apos;s name in an input box:</p><span>
</span><p>ChildComponent</p><code language="ts" format="">@Component({
  selector: &apos;my-child-view&apos;,
  template: &apos;&lt;input [(ngModel)]=&quot;hero&quot;&gt;&apos;
})
export class ChildViewComponent {
  hero = &apos;Magneta&apos;;
}
</code><p>The <code>AfterViewComponent</code> displays this child view <em>within its template</em>:</p><span>
</span><p>AfterViewComponent (template)</p><code language="ts" format="">template: `
  &lt;div&gt;-- child view begins --&lt;/div&gt;
    &lt;my-child-view&gt;&lt;/my-child-view&gt;
  &lt;div&gt;-- child view ends --&lt;/div&gt;`
</code><p>The following hooks take action based on changing values <em>within the child view</em>
which we can only reach by querying for the child view via the property decorated with
<a href="https://angular.io/docs/ts/latest/api/core/index/ViewChild-var.html">@ViewChild</a>.</p><span>
</span><p>AfterViewComponent (class excerpts)</p><code language="ts" format="">export class AfterViewComponent implements  AfterViewChecked, AfterViewInit {
  private prevHero = &apos;&apos;;

  // Query for a VIEW child of type `ChildViewComponent`
  @ViewChild(ChildViewComponent) viewChild: ChildViewComponent;

  ngAfterViewInit() {
    // viewChild is set after the view has been initialized
    this.logIt(&apos;AfterViewInit&apos;);
    this.doSomething();
  }

  ngAfterViewChecked() {
    // viewChild is updated after the view has been checked
    if (this.prevHero === this.viewChild.hero) {
      this.logIt(&apos;AfterViewChecked (no change)&apos;);
    } else {
      this.prevHero = this.viewChild.hero;
      this.logIt(&apos;AfterViewChecked&apos;);
      this.doSomething();
    }
  }
  // ...
}
</code><h3 id="abide-by-the-unidirectional-data-flow-rule">Abide by the unidirectional data flow rule</h3><span>
</span><p>The <code>doSomething</code> method updates the screen when the hero name exceeds 10 characters.</p><span>
</span><p>AfterViewComponent (doSomething)</p><code language="ts" format="">// This surrogate for real business logic sets the `comment`
private doSomething() {
  let c = this.viewChild.hero.length &gt; 10 ? `That&apos;s a long name` : &apos;&apos;;
  if (c !== this.comment) {
    // Wait a tick because the component&apos;s view has already been checked
    this.logger.tick_then(() =&gt; this.comment = c);
  }
}
</code><p>Why does the <code>doSomething</code> method wait a tick before updating <code>comment</code>?</p><span>
</span><p>Because we must adhere to Angular&apos;s unidirectional data flow rule which says that
we may not update the view <em>after</em> it has been composed.
Both hooks fire after the component&apos;s view has been composed.</p><span>
</span><p>Angular throws an error if we update component&apos;s data-bound <code>comment</code> property immediately (try it!).</p><span>
</span><p>The <code>LoggerService.tick</code> methods, which are implemented by a call to <code>setTimeout</code>, postpone the update one turn of the of the browser&apos;s JavaScript cycle ... and that&apos;s long enough.</p><span>
</span><p>Here&apos;s <em>AfterView</em> in action</p><span>
</span><figure class="image-display"><img src="https://angular.io/resources/images/devguide/lifecycle-hooks/after-view-anim.gif" alt="AfterView"></figure><p>Notice that Angular frequently calls <code>AfterViewChecked</code>, often when there are no changes of interest.
Write lean hook methods to avoid performance problems.</p><span>
</span><h2 id="aftercontent">AfterContent</h2><span>
</span><p>The <em>AfterContent</em> sample explores the <code>AfterContentInit</code> and <code>AfterContentChecked</code> hooks that Angular calls
<em>after</em> Angular projects external content into the component.</p><span>
</span><h3 id="content-projection">Content projection</h3><span>
</span><p><em>Content projection</em> is a way to import HTML content from outside the component and insert that content
into the component&apos;s template in a designated spot.</p><span>
</span><div class="l-sub-section"><p>Angular 1 developers know this technique as <em>transclusion</em>.</p><span>
</span></div><p>We&apos;ll illustrate with a variation on the <a href="https://angular.io/docs/ts/latest/guide/lifecycle-hooks.html#afterview">previous</a> example
whose behavior and output is almost the same.</p><span>
</span><p>This time, instead of including the child view within the template, we&apos;ll import it from
the <code>AfterContentComponent</code>&apos;s parent. Here&apos;s the parent&apos;s template.</p><span>
</span><p>AfterContentParentComponent (template excerpt)</p><code language="ts" format="">`&lt;after-content&gt;
   &lt;my-child&gt;&lt;/my-child&gt;
 &lt;/after-content&gt;`
</code><p>Notice that the <code>&lt;my-child&gt;</code> tag is tucked between the <code>&lt;after-content&gt;</code> tags.
We never put content between a component&apos;s element tags <em>unless we intend to project that content
into the component</em>.</p><span>
</span><p>Now look at the component&apos;s template:</p><span>
</span><p>AfterContentComponent (template)</p><code language="ts" format="">template: `
  &lt;div&gt;-- projected content begins --&lt;/div&gt;
    &lt;ng-content&gt;&lt;/ng-content&gt;
  &lt;div&gt;-- projected content ends --&lt;/div&gt;`
</code><p>The <code>&lt;ng-content&gt;</code> tag is a <em>placeholder</em> for the external content.
They tell Angular where to insert that content.
In this case, the projected content is the <code>&lt;my-child&gt;</code> from the parent.</p><span>
</span><figure class="image-display"><img src="https://angular.io/resources/images/devguide/lifecycle-hooks/projected-child-view.png" width="230" alt="Projected Content"></figure><div class="l-sub-section"><p>The tell-tale signs of <em>content projection</em> are (a) HTML between component element tags
and (b) the presence of <code>&lt;ng-content&gt;</code> tags in the component&apos;s template.</p><span>
</span></div><h3 id="aftercontent-hooks">AfterContent hooks</h3><span>
</span><p><em>AfterContent</em> hooks are similar to the <em>AfterView</em> hooks. The key difference is the kind of child component
that we&apos;re looking for.</p><span>
</span><ul>
<li><p>The <em>AfterView</em> hooks concern <code>ViewChildren</code>, the child components whose element tags
appear <em>within</em> the component&apos;s template.</p>
</li>
<li><p>The <em>AfterContent</em> hooks concern <code>ContentChildren</code>, the child components that Angular
projected into the component.</p>
</li>
</ul><span>
</span><p>The following <em>AfterContent</em> hooks take action based on changing values in a  <em>content child</em>
which we can only reach by querying for it via the property decorated with
<a href="https://angular.io/docs/ts/latest/api/core/index/ContentChild-var.html">@ContentChild</a>.</p><span>
</span><p>AfterContentComponent (class excerpts)</p><code language="ts" format="">export class AfterContentComponent implements AfterContentChecked, AfterContentInit {
  private prevHero = &apos;&apos;;
  comment = &apos;&apos;;

  // Query for a CONTENT child of type `ChildComponent`
  @ContentChild(ChildComponent) contentChild: ChildComponent;

  ngAfterContentInit() {
    // contentChild is set after the content has been initialized
    this.logIt(&apos;AfterContentInit&apos;);
    this.doSomething();
  }

  ngAfterContentChecked() {
    // contentChild is updated after the content has been checked
    if (this.prevHero === this.contentChild.hero) {
      this.logIt(&apos;AfterContentChecked (no change)&apos;);
    } else {
      this.prevHero = this.contentChild.hero;
      this.logIt(&apos;AfterContentChecked&apos;);
      this.doSomething();
    }
  }
  // ...
}
</code><h3 id="no-unidirectional-flow-worries">No unidirectional flow worries</h3><span>
</span><p>This component&apos;s <code>doSomething</code> method update&apos;s the component&apos;s data-bound <code>comment</code> property immediately.
There&apos;s no <a href="https://angular.io/docs/ts/latest/guide/lifecycle-hooks.html#wait-a-tick">need to wait</a>.</p><span>
</span><p>Recall that Angular calls both <em>AfterContent</em> hooks before calling either of the <em>AfterView</em> hooks.
Angular completes composition of the projected content <em>before</em> finishing the composition of this component&apos;s view.
We still have a window of opportunity to modify that view.</p><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--></div></div>
        </article>
      
        <article>
          <h3>Npm Packages</h3>
          <div><div class="showcase-content"><p>Angular applications and Angular itself depend upon features and functionality provided by a variety of third-party packages.
These packages are maintained and installed with the Node Package Manager (<a href="https://docs.npmjs.com/" target="_blank">npm</a>).</p><span>
</span><div class="l-sub-section"><p>Node.js and npm are essential to Angular 2 development. </p><span>
</span><p><a href="https://docs.npmjs.com/getting-started/installing-node" target="_blank" title="Installing Node.js and updating npm">
Get them now</a> if they&apos;re not already installed on your machine.</p><span>
</span><p><strong>Verify that you are running node <code>v4.x.x</code> or higher and npm <code>3.x.x</code> or higher</strong>
by running the commands <code>node -v</code> and <code>npm -v</code> in a terminal/console window.
Older versions produce errors.</p><span>
</span><p>We recommend <a href="https://github.com/creationix/nvm">nvm</a> for managing multiple versions of node and npm. You may need <a href="https://github.com/creationix/nvm">nvm</a> if you already have projects running on your machine that use other versions of node and npm.</p><span>
</span></div><p>We recommend a comprehensive starter-set of packages as specified in the <code>dependencies</code> and <code>devDependencies</code>
sections of the QuickStart
<a href="https://docs.npmjs.com/files/package.json" target="_blank">package.json</a> file:</p><span>
</span><p>package.json (dependencies)</p><code language="json" format=".">{
  &quot;dependencies&quot;: {
    &quot;@angular/common&quot;: &quot;2.0.0-rc.6&quot;,
    &quot;@angular/compiler&quot;: &quot;2.0.0-rc.6&quot;,
    &quot;@angular/compiler-cli&quot;: &quot;0.6.0&quot;,
    &quot;@angular/core&quot;: &quot;2.0.0-rc.6&quot;,
    &quot;@angular/forms&quot;: &quot;2.0.0-rc.6&quot;,
    &quot;@angular/http&quot;: &quot;2.0.0-rc.6&quot;,
    &quot;@angular/platform-browser&quot;: &quot;2.0.0-rc.6&quot;,
    &quot;@angular/platform-browser-dynamic&quot;: &quot;2.0.0-rc.6&quot;,
    &quot;@angular/router&quot;: &quot;3.0.0-rc.2&quot;,
    &quot;@angular/upgrade&quot;: &quot;2.0.0-rc.6&quot;,
    &quot;core-js&quot;: &quot;^2.4.1&quot;,
    &quot;reflect-metadata&quot;: &quot;^0.1.3&quot;,
    &quot;rxjs&quot;: &quot;5.0.0-beta.11&quot;,
    &quot;systemjs&quot;: &quot;0.19.27&quot;,
    &quot;zone.js&quot;: &quot;^0.6.17&quot;,
    &quot;angular2-in-memory-web-api&quot;: &quot;0.0.18&quot;,
    &quot;bootstrap&quot;: &quot;^3.3.6&quot;
  },
  &quot;devDependencies&quot;: {
    &quot;concurrently&quot;: &quot;^2.2.0&quot;,
    &quot;lite-server&quot;: &quot;^2.2.2&quot;,
    &quot;typescript&quot;: &quot;^1.8.10&quot;,
    &quot;typings&quot;: &quot;^1.3.2&quot;
  }
}</code><p>You can use other packages but we recommend <em>this particular set</em> to start with because (a) they  work well together and 
(b) they include everything you&apos;ll need to build and run the sample applications in this series.</p><span>
</span><div class="l-sub-section"><p>Note: A cookbook or guide page may require an additional library such as <em>jQuery</em>.</p><span>
</span></div><p>You&apos;ll install more than you need for QuickStart. 
No worries! 
You only serve to the client those packages that the application actually requests.</p><span>
</span><p>This page explains what each package does. You can make substitutions later to suit your tastes and experience.</p><span>
</span><h2 id="-dependencies-and-devdependencies-"><em>dependencies</em> and <em>devDependencies</em></h2><span>
</span><p>The <code>package.json</code> includes two sets of packages, 
<a href="https://angular.io/docs/ts/latest/guide/npm-packages.html#dependencies">dependencies</a> and <a href="https://angular.io/docs/ts/latest/guide/npm-packages.html#dev-dependencies">devDependencies</a>.</p><span>
</span><p>The <em>dependencies</em> are essential to <em>running</em> the application. 
The <em>devDependencies</em> are only necessary to <em>develop</em> the application. 
You can exclude them from production installations by adding <code>--production</code> to the install command, as follows:</p><span>
</span><code format="." language="bash">npm install my-application --production
</code><a id="dependencies"></a><h2 id="-dependencies-"><em>dependencies</em></h2><span>
</span><p>The <code>dependencies</code> section of <code>package.json</code> contains:</p><span>
</span><ul>
<li><p><strong><em>Features</em></strong> - Feature packages give the application framework and utility capabilities.</p>
</li>
<li><p><strong><em>Polyfills</em></strong> - Polyfills plug gaps in the browser&apos;s JavaScript implementation.</p>
</li>
<li><p><strong><em>Other</em></strong> - Other libraries that support the application such as <code>bootstrap</code> for HTML widgets and styling.</p>
</li>
</ul><span>
</span><h3 id="feature-packages">Feature Packages</h3><span>
</span><p><strong><em>@angular/core</em></strong> - Critical runtime parts of the framework needed by every application. 
Includes all metadata decorators, <code>Component</code>, <code>Directive</code>,  dependency injection, and the component lifecycle hooks.</p><span>
</span><p><strong><em>@angular/common</em></strong> - The commonly needed services, pipes, and directives provided by the Angular team.</p><span>
</span><p><strong><em>@angular/compiler</em></strong> - Angular&apos;s <em>Template Compiler</em>. 
It understands templates and can convert them to code that makes the application run and render. 
Typically you don&#x2019;t interact with the compiler directly; rather, you use it indirectly via <code>platform-browser-dynamic</code> or the offline template compiler.</p><span>
</span><p><strong><em>@angular/platform-browser</em></strong> - Everything DOM and browser related, especially the pieces that help render into DOM.
This package also includes the bootstrapStatic method for bootstrapping applications for production builds that pre-compile templates offline.</p><span>
</span><p><strong><em>@angular/platform-browser-dynamic</em></strong> - Includes <a href="https://angular.io/docs/ts/latest/api/core/index/Provider-type-alias.html">Providers</a> and a <a href="https://angular.io/docs/ts/latest/guide/ngmodule.html#!#bootstrap">bootstrap</a> method for applications that
compile templates on the client. Don&#x2019;t use offline compilation.
Use this package for bootstrapping during development and for bootstrapping plunker samples.</p><span>
</span><p><strong><em>@angular/http</em></strong> - Angular&apos;s http client.</p><span>
</span><p><strong><em>@angular/router</em></strong> - Component router.</p><span>
</span><p><strong><em>@angular/upgrade</em></strong> - Set of utilities for upgrading Angular 1 applications.</p><span>
</span><p><strong><em><a href="https://github.com/systemjs/systemjs">system.js</a></em></strong> -  A dynamic module loader compatible with the 
<a href="http://www.2ality.com/2014/09/es6-modules-final.html">ES2015 module</a> specification.
Other viable choices include the well-regarded <a href="https://webpack.github.io/">webpack</a>.</p><span>
</span><p>Your future applications are likely to require additional packages that provide
HTML controls, themes, data access, and various utilities.</p><span>
</span><a id="polyfills"></a><h3 id="polyfill-packages">Polyfill packages</h3><span>
</span><p>Angular requires certain <a href="https://en.wikipedia.org/wiki/Polyfill">polyfills</a> in the application environment.
Install these polyfills using the npm packages that Angular lists in the <em>peerDependencies</em> section of its <code>package.json</code>.</p><span>
</span><p>You must list these packages in the <code>dependencies</code> section of your own <code>package.json</code>.</p><span>
</span><div class="l-sub-section"><p>For background on this requirement, see <a href="https://angular.io/docs/ts/latest/guide/npm-packages.html#why-peer-dependencies">Why peerDependencies?</a>.</p><span>
</span></div><p><strong><em>core-js</em></strong> - Patches the global context (window) with essential features of ES2015 (ES6).
 You may substitute an alternative polyfill that provides the same core APIs. 
 When these APIs are implemented by the major browsers, this dependency will become unnecessary.</p><span>
</span><p><strong><em>reflect-metadata</em></strong> - A dependency shared between Angular and the <strong><em>TypeScript compiler</em></strong>. 
You can update a TypeScript package without upgrading Angular, 
which is why this is a dependency of the application and not a dependency of Angular.</p><span>
</span><p><strong><em>rxjs</em></strong> - A polyfill for the <a href="https://github.com/zenparsing/es-observable">Observables specification</a> currently before the 
<a href="http://www.ecma-international.org/memento/TC39.htm">TC39</a> committee that determines standards for the JavaScript language.
You can pick a preferred version of <em>rxjs</em> (within a compatible version range) 
without waiting for Angular updates.</p><span>
</span><p><strong><em>zone.js</em></strong> - A polyfill for the <a href="https://gist.github.com/mhevery/63fdcdf7c65886051d55">Zone specification</a> currently before the 
<a href="http://www.ecma-international.org/memento/TC39.htm">TC39</a> committee that determines standards for the JavaScript language.
You can pick a preferred version of <em>zone.js</em> to use (within a compatible version range) 
without waiting for Angular updates.</p><span>
</span><a id="other"></a><h3 id="other-helper-libraries">Other helper libraries</h3><span>
</span><p><strong><em>angular2-in-memory-web-api</em></strong> - An Angular-supported library that simulates a remote server&apos;s web api 
without requiring an actual server or real http calls. 
Good for demos, samples, and early stage development (before we even have a server).
Read about it in the <a href="https://angular.io/docs/ts/latest/guide/server-communication.html#appendix-tour-of-heroes-in-memory-server">Http Client</a> page.</p><span>
</span><p><strong><em>bootstrap</em></strong> - <a href="http://getbootstrap.com/">Bootstrap</a> is a popular HTML and CSS framework for designing responsive web apps.
Some of the samples improve their appearance with <em>bootstrap</em>.</p><span>
</span><a id="dev-dependencies"></a><h2 id="-devdependencies-"><em>devDependencies</em></h2><span>
</span><p>The packages listed in the <em>devDependencies</em> section of the <code>package.json</code> help you develop the application.
You don&apos;t have to deploy them with the production application although there is no harm in doing so.</p><span>
</span><p><strong><em><a href="https://www.npmjs.com/package/concurrently">concurrently</a></em></strong> - 
A utility to run multiple <em>npm</em> commands concurrently on OS/X, Windows, and Linux operating systems.</p><span>
</span><p><strong><em><a href="https://www.npmjs.com/package/lite-server">lite-server</a></em></strong> - 
A light-weight, static file server, by <a href="http://johnpapa.net/">John Papa</a> 
with excellent support for Angular apps that use routing.</p><span>
</span><p><strong><em><a href="https://www.npmjs.com/package/typescript">typescript</a></em></strong> - 
The TypeScript language server, including the <em>tsc</em> TypeScript compiler.</p><span>
</span><p><strong><em><a href="https://www.npmjs.com/package/typings">typings</a></em></strong> - A manager for TypeScript definition files.
Read more about it in the <a href="https://angular.io/docs/ts/latest/guide/typescript-configuration.html#typings">TypeScript Configuration</a> page.</p><span>
</span><a id="why-peer-dependencies"></a><h2 id="why-peerdependencies-">Why <em>peerDependencies</em>?</h2><span>
</span><p>There isn&apos;t a <em>peerDependencies</em> section in the QuickStart <code>package.json</code>. 
But Angular has a <em>peerDependencies</em> section in 
<em>its</em> package.json, which has important consequences for your application. </p><span>
</span><p>It explains why you load the <a href="https://angular.io/docs/ts/latest/guide/npm-packages.html#polyfills">polyfill</a> <em>dependency</em> packages in the QuickStart <code>package.json</code>,
and why you&apos;ll need those packages in your own applications.</p><span>
</span><p>An explanation of <a href="https://nodejs.org/en/blog/npm/peer-dependencies/">peer dependencies</a> follows.</p><span>
</span><p>Packages depend on other packages. For example, your application depends on the Angular package.</p><span>
</span><p>Two packages, &quot;A&quot; and &quot;B&quot;, could depend on the same third package &quot;C&quot;. 
&quot;A&quot; and &quot;B&quot; might both list &quot;C&quot; among their <em>dependencies</em>.</p><span>
</span><p>What if &quot;A&quot; and &quot;B&quot; depend on different versions of &quot;C&quot; (&quot;C1&quot; and &quot;C2&quot;). The npm package system supports that. 
It installs &quot;C1&quot; in the <code>node_modules</code> folder for &quot;A&quot; and &quot;C2&quot; in the <code>node_modules</code> folder for &quot;B&quot;.
Now &quot;A&quot; and &quot;B&quot; have their own copies of &quot;C&quot; and they run without interferring with one another.</p><span>
</span><p>But there is a problem. Package &quot;A&quot; may require the presence of &quot;C1&quot; without actually calling upon it directly.
&quot;A&quot; may only work if <em>everyone is using &quot;C1&quot;</em>. It falls down if any part of the application relies on &quot;C2&quot;.</p><span>
</span><p>The solution is for &quot;A&quot; to declare that &quot;C1&quot; is a <em>peer dependency</em>.</p><span>
</span><p>The difference between a <code>dependency</code> and a <code>peerDependency</code> is roughly this:</p><span>
</span><blockquote>
<p>A <strong>dependency</strong> says, &quot;I need this thing directly available to <em>me</em>.&quot;</p>
<p>A <strong>peerDependency</strong> says, &quot;If you want to use me, you need this thing available to <em>you</em>.&quot;</p>
</blockquote><span>
</span><p>The Angular <code>package.json</code> specifies several <em>peer dependency</em> packages, 
each pinned to a particular version of a third-party package.</p><span>
</span><h3 id="we-must-install-angular-s-peerdependencies-ourselves-">We must install Angular&apos;s <em>peerDependencies</em> ourselves.</h3><span>
</span><p>When <em>npm</em> installs packages listed in <em>your</em> <code>dependencies</code> section,
it also installs the packages listed within <em>their</em> packages <code>dependencies</code> sections.
The process is recursive.</p><span>
</span><p>However, as of version 3, <em>npm</em> does <em>not</em> install packages listed in <em>peerDependencies</em> sections.</p><span>
</span><p>This means that when your application installs Angular, <strong><em>npm</em> doesn&apos;t automatically install
the packages listed in Angular&apos;s <em>peerDependencies</em> section</strong>.</p><span>
</span><p>Fortunately, <em>npm</em> issues a warning (a) When any <em>peer dependencies</em> are missing, or (b)
When the application or any of its other dependencies
installs a different version of a <em>peer dependency</em>. </p><span>
</span><p>These warnings guard against accidental failures due to version mismatches.
They leave you in control of package and version resolution.</p><span>
</span><p>It is your responsibility to list all <em>peer dependency</em> packages <strong>among your own <em>devDependencies</em></strong>.</p><span>
</span><div class="l-sub-section"><h4 id="the-future-of-peerdependencies-">The future of <em>peerDependencies</em></h4><span>
</span><p>The Angular polyfill dependencies are hard requirements. Currently, there is no way to make them optional.</p><span>
</span><p>However, there is an npm feature request for &quot;optional peerDependencies,&quot; which would allow you to model this relationship better. 
When this feature request is implemented, Angular will switch from <em>peerDependencies</em> to <em>optionalPeerDependencies</em> for all polyfills.</p><span>
</span></div><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--></div></div>
        </article>
      
        <article>
          <h3>Pipes - ts</h3>
          <div><div class="showcase-content"><p>Every application starts out with what seems like a simple task: get data, transform them, and show them to users.
Getting data could be as simple as creating a local variable or as complex as streaming data over a Websocket.</p><span>
</span><p>Once data arrive, we could push their raw <code>toString</code> values directly to the view.
That rarely makes for a good user experience.
E.g., almost everyone prefers a simple birthday date like
<samp>April 15, 1988</samp> to the original raw string format
&#x2014; <samp>Fri Apr 15 1988 00:00:00 GMT-0700 (Pacific Daylight Time)</samp>.</p><span>
</span><p>Clearly some values benefit from a bit of massage. We soon discover that we
desire many of the same transformations repeatedly, both within and across many applications.
We almost think of them as styles.
In fact, we&apos;d like to apply them in our HTML templates as we do styles.</p><span>
</span><p>Introducing Angular pipes, a way to write display-value transformations that we can declare in our HTML!
Try the <live-example></live-example>.</p><span>
</span><h2 id="using-pipes">Using Pipes</h2><span>
</span><p>A pipe takes in data as input and transforms it to a desired output.
We&apos;ll illustrate by transforming a component&apos;s birthday property into
a human-friendly date.</p><span>
</span><p>app/hero-birthday1.component.ts</p><code language="ts" format="">import { Component } from &apos;@angular/core&apos;;

@Component({
  selector: &apos;hero-birthday&apos;,
  template: `&lt;p&gt;The hero&apos;s birthday is {{ birthday | date }}&lt;/p&gt;`
})
export class HeroBirthdayComponent {
  birthday = new Date(1988, 3, 15); // April 15, 1988
}
</code><p>Focus on the component&apos;s template.</p><span>
</span><code language="html" format="">&lt;p&gt;The hero&apos;s birthday is {{ birthday | date }}&lt;/p&gt;
</code><p>Inside the interpolation expression we flow the component&apos;s <code>birthday</code> value through the
<a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#pipe">pipe operator</a> ( | ) to the <a href="https://angular.io/docs/ts/latest/api/common/index/DatePipe-class.html">Date pipe</a>
function on the right. All pipes work this way.</p><span>
</span><div class="l-sub-section"><p>The <code>Date</code> and <code>Currency</code> pipes need the <strong>ECMAScript Internationalization API</strong>.
Safari and other older browsers don&apos;t support it. We can add support with a polyfill.</p><span>
</span><code language="html">&lt;script src=&quot;https://cdn.polyfill.io/v2/polyfill.min.js?features=Intl.~locale.en&quot;&gt;&lt;/script&gt;
</code></div><h2 id="built-in-pipes">Built-in pipes</h2><span>
</span><p>Angular comes with a stock of pipes such as
<code>DatePipe</code>, <code>UpperCasePipe</code>, <code>LowerCasePipe</code>, <code>CurrencyPipe</code>, and <code>PercentPipe</code>.
They are all immediately available for use in any template.</p><span>
</span><div class="l-sub-section"><p>Learn more about these and many other built-in pipes in the <a href="https://angular.io/docs/ts/latest/api/#!?apiFilter=pipe">API Reference</a>;
filter for entries that include the word &quot;pipe&quot;.</p><span>
</span><p>Angular 2 doesn&apos;t have a <code>FilterPipe</code> or an <code>OrderByPipe</code> for reasons explained in an <a href="https://angular.io/docs/ts/latest/guide/pipes.html#no-filter-pipe">appendix below</a>.</p><span>
</span></div><h2 id="parameterizing-a-pipe">Parameterizing a Pipe</h2><span>
</span><p>A pipe may accept any number of optional parameters to fine-tune its output.
We add parameters to a pipe by following the pipe name with a colon ( : ) and then the parameter value
(e.g., <code>currency:&apos;EUR&apos;</code>). If our pipe accepts multiple parameters, we separate the values with colons (e.g. <code>slice:1:5</code>)</p><span>
</span><p>We&apos;ll modify our birthday template to give the date pipe a format parameter.
After formatting the hero&apos;s April 15th birthday, it should render as <strong><samp>04/15/88</samp></strong>:</p><span>
</span><code language="html" format="">&lt;p&gt;The hero&apos;s birthday is {{ birthday | date:&quot;MM/dd/yy&quot; }} &lt;/p&gt;
</code><p>The parameter value can be any valid
<a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#template-expressions">template expression</a>
such as a string literal or a component property.
In other words, we can control the format through a binding the same way we control the birthday value through a binding.</p><span>
</span><p>Let&apos;s write a second component that <em>binds</em> the pipe&apos;s format parameter
to the component&apos;s <code>format</code> property. Here&apos;s the template for that component:</p><span>
</span><p>app/hero-birthday2.component.ts (template)</p><code language="ts" format="">template: `
  &lt;p&gt;The hero&apos;s birthday is {{ birthday | date:format }}&lt;/p&gt;
  &lt;button (click)=&quot;toggleFormat()&quot;&gt;Toggle Format&lt;/button&gt;
`
</code><p>We also added a button to the template and bound its click event to the component&apos;s <code>toggleFormat()</code> method.
That method toggles the component&apos;s <code>format</code> property between a short form
(<code>&apos;shortDate&apos;</code>) and a longer form (<code>&apos;fullDate&apos;</code>).</p><span>
</span><p>app/hero-birthday2.component.ts (class)</p><code language="ts" format="">export class HeroBirthday2Component {
  birthday = new Date(1988, 3, 15); // April 15, 1988
  toggle = true; // start with true == shortDate

  get format()   { return this.toggle ? &apos;shortDate&apos; : &apos;fullDate&apos;; }
  toggleFormat() { this.toggle = !this.toggle; }
}
</code><p>As we click the button, the displayed date alternates between
&quot;<strong><samp>04/15/1988</samp></strong>&quot; and
&quot;<strong><samp>Friday, April 15, 1988</samp></strong>&quot;.</p><span>
</span><figure class="image-display"><img src="https://angular.io/resources/images/devguide/pipes/date-format-toggle-anim.gif" alt="Date Format Toggle"></figure><div class="l-sub-section"><p>Learn more about the <code>DatePipes</code> format options in the <a href="https://angular.io/docs/ts/latest/api/common/index/DatePipe-class.html">API Docs</a>.</p><span>
</span></div><h2 id="chaining-pipes">Chaining pipes</h2><span>
</span><p>We can chain pipes together in potentially useful combinations.
In the following example, we chain the birthday to the <code>DatePipe</code> and on to the <code>UpperCasePipe</code>
so we can display the birthday in uppercase. The following birthday displays as
<strong><samp>APR 15, 1988</samp></strong>.</p><span>
</span><code language="html" format="">The chained hero&apos;s birthday is
{{ birthday | date | uppercase}}
</code><p>This example &#x2014; which displays <strong><samp>FRIDAY, APRIL 15, 1988</samp></strong> &#x2014;
chains the same pipes as above, but passes in a parameter to <code>date</code> as well.</p><span>
</span><code language="html" format="">The chained hero&apos;s birthday is
{{  birthday | date:&apos;fullDate&apos; | uppercase}}
</code><h2 id="custom-pipes">Custom Pipes</h2><span>
</span><p>We can write our own custom pipes.
Here&apos;s a custom pipe named <code>ExponentialStrengthPipe</code> that can boost a hero&apos;s powers:</p><span>
</span><p>app/exponential-strength.pipe.ts</p><code language="ts" format="">import { Pipe, PipeTransform } from &apos;@angular/core&apos;;
/*
 * Raise the value exponentially
 * Takes an exponent argument that defaults to 1.
 * Usage:
 *   value | exponentialStrength:exponent
 * Example:
 *   {{ 2 |  exponentialStrength:10}}
 *   formats to: 1024
*/
@Pipe({name: &apos;exponentialStrength&apos;})
export class ExponentialStrengthPipe implements PipeTransform {
  transform(value: number, exponent: string): number {
    let exp = parseFloat(exponent);
    return Math.pow(value, isNaN(exp) ? 1 : exp);
  }
}
</code><p>This pipe definition reveals several key points:</p><span>
</span><ul>
<li><p>A pipe is a class decorated with pipe metadata.</p>
</li>
<li><p>The pipe class implements the <code>PipeTransform</code> interface&apos;s <code>transform</code> method that
accepts an input value followed by optional parameters and returns the transformed value.</p>
</li>
<li><p>There will be one additional argument to the <code>transform</code> method for each parameter passed to the pipe.
Our pipe has one such parameter: the <code>exponent</code>.</p>
</li>
<li><p>We tell Angular that this is a pipe by applying the
<code>@Pipe</code> decorator which we import from the core Angular library.</p>
</li>
<li><p>The <code>@Pipe</code> decorator allows us to define the
 pipe name that we&apos;ll use within template expressions. It must be a valid JavaScript identifier.
 Our pipe&apos;s name is <code>exponentialStrength</code>.</p>
</li>
</ul><span>
</span><div class="l-sub-section"><h3 id="the-pipetransform-interface">The <em>PipeTransform</em> Interface</h3><span>
</span><p>The <code>transform</code> method is essential to a pipe.
The <code>PipeTransform</code> <em>interface</em> defines that method and guides both tooling and the compiler.
It is technically optional; Angular looks for and executes the <code>transform</code> method regardless.</p><span>
</span></div><p>Now we need a component to demonstrate our pipe.</p><span>
</span><p>app/power-booster.component.ts</p><code language="ts" format="">import { Component } from &apos;@angular/core&apos;;

@Component({
  selector: &apos;power-booster&apos;,
  template: `
    &lt;h2&gt;Power Booster&lt;/h2&gt;
    &lt;p&gt;Super power boost: {{2 | exponentialStrength: 10}}&lt;/p&gt;
  `
})
export class PowerBoosterComponent { }
</code><figure class="image-display"><img src="https://angular.io/resources/images/devguide/pipes/power-booster.png" alt="Power Booster"></figure><p>Two things to note:</p><span>
</span><ol>
<li><p>We use our custom pipe the same way we use the built-in pipes.</p>
</li>
<li><p>We must include our pipe in the <code>declarations</code> array of the AppModule.</p>
</li>
</ol><span>
</span><div class="callout is-helpful"><header>Remember the declarations array!</header><p>Angular reports an error if we neglect to list our custom pipe.
We didn&apos;t list the <code>DatePipe</code> in our previous example because all
Angular built-in pipes are pre-registered.
Custom pipes must be registered manually.</p><span>
</span></div><p>If we try the <live-example></live-example>,
we can probe its behavior by changing the value and the optional exponent in the template.</p><span>
</span><h2 id="power-boost-calculator-extra-credit-">Power Boost Calculator (extra-credit)</h2><span>
</span><p>It&apos;s not much fun updating the template to test our custom pipe.
We could upgrade the example to a &quot;Power Boost Calculator&quot; that combines
our pipe and two-way data binding with <code>ngModel</code>.</p><span>
</span><p>/app/power-boost-calculator.component.ts</p><code language="ts" format="">import { Component } from &apos;@angular/core&apos;;

@Component({
  selector: &apos;power-boost-calculator&apos;,
  template: `
    &lt;h2&gt;Power Boost Calculator&lt;/h2&gt;
    &lt;div&gt;Normal power: &lt;input [(ngModel)]=&quot;power&quot;&gt;&lt;/div&gt;
    &lt;div&gt;Boost factor: &lt;input [(ngModel)]=&quot;factor&quot;&gt;&lt;/div&gt;
    &lt;p&gt;
      Super Hero Power: {{power | exponentialStrength: factor}}
    &lt;/p&gt;
  `
})
export class PowerBoostCalculatorComponent {
  power = 5;
  factor = 1;
}
</code><figure class="image-display"><img src="https://angular.io/resources/images/devguide/pipes/power-boost-calculator-anim.gif" alt="Power Boost Calculator"></figure><a id="change-detection"></a><h2 id="pipes-and-change-detection">Pipes and Change Detection</h2><span>
</span><p>Angular looks for changes to data-bound values through a <em>change detection</em> process that runs after every JavaScript event:
every keystroke, mouse move, timer tick, and server response. This could be expensive.
Angular strives to lower the cost whenever possible and appropriate.</p><span>
</span><p>Angular picks a simpler, faster change detection algorithm when we use a pipe. Let&apos;s see how.</p><span>
</span><h3 id="no-pipe">No pipe</h3><span>
</span><p>The component in our next example uses the default, aggressive change detection strategy to monitor and update
its display of every hero in the <code>heroes</code> array. Here&apos;s the template:</p><span>
</span><p>app/flying-heroes.component.html (v1)</p><code language="html" format="">New hero:
  &lt;input type=&quot;text&quot; #box
          (keyup.enter)=&quot;addHero(box.value); box.value=&apos;&apos;&quot;
          placeholder=&quot;hero name&quot;&gt;
  &lt;button (click)=&quot;reset()&quot;&gt;Reset&lt;/button&gt;
  &lt;div *ngFor=&quot;let hero of heroes&quot;&gt;
    {{hero.name}}
  &lt;/div&gt;
</code><p>The companion component class provides heroes, adds new heroes into the array, and can reset the array.</p><span>
</span><p>app/flying-heroes.component.ts (v1)</p><code language="ts" format="">export class FlyingHeroesComponent {
  heroes: any[] = [];
  canFly = true;
  constructor() { this.reset(); }

  addHero(name: string) {
    name = name.trim();
    if (!name) { return; }
    let hero = {name, canFly: this.canFly};
    this.heroes.push(hero);
  }

  reset() { this.heroes = HEROES.slice(); }
}
</code><p>We can add a new hero and Angular updates the display when we do.
The <code>reset</code> button replaces <code>heroes</code> with a new array of the original heroes and Angular updates the display when we do.
If we added the ability to remove or change a hero, Angular would detect those changes too and update the display as well.</p><span>
</span><h3 id="flying-heroes-pipe">Flying Heroes pipe</h3><span>
</span><p>Let&apos;s add a <code>FlyingHeroesPipe</code> to the <code>*ngFor</code> repeater that filters the list of heroes to just those heroes who can fly.</p><span>
</span><p>app/flying-heroes.component.html (flyers)</p><code language="html" format="">&lt;div *ngFor=&quot;let hero of (heroes | flyingHeroes)&quot;&gt;
  {{hero.name}}
&lt;/div&gt;
</code><p>Here&apos;s the <code>FlyingHeroesPipe</code> implementation which follows the pattern for custom pipes we saw earlier.</p><span>
</span><p>app/flying-heroes.pipe.ts</p><code language="ts" format="">import { Pipe, PipeTransform } from &apos;@angular/core&apos;;

import { Flyer } from &apos;./heroes&apos;;

@Pipe({ name: &apos;flyingHeroes&apos; })
export class FlyingHeroesPipe implements PipeTransform {
  transform(allHeroes: Flyer[]) {
    return allHeroes.filter(hero =&gt; hero.canFly);
  }
}
</code><p>When we run the sample now we see odd behavior (try it in the <live-example></live-example>).
Every hero we add is a flying hero but none of them are displayed.</p><span>
</span><p>Although we&apos;re not getting the behavior we want, Angular isn&apos;t broken.
It&apos;s just using a different change detection algorithm &#x2014; one that ignores changes to the list or any of its items.</p><span>
</span><p>Look at how we&apos;re adding a new hero:</p><span>
</span><code language="ts" format="">this.heroes.push(hero);
</code><p>We&apos;re adding the new hero into the <code>heroes</code> array.  The reference to the array hasn&apos;t changed.
It&apos;s the same array. That&apos;s all Angular cares about. From its perspective, <em>same array, no change, no display update</em>.</p><span>
</span><p>We can fix that. Let&apos;s create a new array with the new hero appended and assign that to <code>heroes</code>.
This time Angular detects that the array reference has changed.
It executes the pipe and updates the display with the new array which includes the new flying hero.</p><span>
</span><p><em>If we <strong>mutate</strong> the array, no pipe is invoked and no display updated;
if we <strong>replace</strong> the array, then the pipe executes and the display is updated</em>.
The <em>Flying Heroes</em> extends the
code with checkbox switches and additional displays to help us experience these effects.</p><span>
</span><figure class="image-display"><img src="https://angular.io/resources/images/devguide/pipes/flying-heroes-anim.gif" alt="Flying Heroes"></figure><p>Replacing the array is an efficient way to signal to Angular that it should update the display.
When do we replace the array? When the data change.
That&apos;s an easy rule to follow in <em>this toy</em> example
where the only way to change the data is by adding a new hero.</p><span>
</span><p>More often we don&apos;t know when the data have changed,
especially in applications that mutate data in many ways,
perhaps in application locations far away.
A component in such an application usually can&apos;t know about those changes.
Moreover, it&apos;s unwise to distort our component design to accommodate a pipe.
We strive as much as possible to keep the component class independent of the HTML.
The component should be unaware of pipes.</p><span>
</span><p>Perhaps we should consider a different kind of pipe for filtering flying heroes, an <em>impure pipe</em>.</p><span>
</span><h2 id="pure-and-impure-pipes">Pure and Impure Pipes</h2><span>
</span><p>There are two categories of pipes: <strong>pure</strong> and <strong>impure</strong>.
Pipes are pure by default. Every pipe we&apos;ve seen so far has been pure.
We make a pipe impure by setting its pure flag to false. We could make the <code>FlyingHeroesPipe</code>
impure like this:</p><span>
</span><code language="ts" format="">@Pipe({
  name: &apos;flyingHeroesImpure&apos;,
  pure: false
})
</code><p>Before we do that, let&apos;s understand the difference between <em>pure</em> and <em>impure</em>, starting with a <em>pure</em> pipe.</p><span>
</span><h3 id="pure-pipes">Pure pipes</h3><span>
</span><p>Angular executes a <em>pure pipe</em> only when it detects a <em>pure change</em> to the input value.
A <strong><em>pure change</em></strong> is <em>either</em> a change to a primitive input value (<code>String</code>, <code>Number</code>, <code>Boolean</code>, <code>Symbol</code>)
<em>or</em> a changed object reference (<code>Date</code>, <code>Array</code>, <code>Function</code>, <code>Object</code>).</p><span>
</span><p>Angular ignores changes <em>within</em> (composite) objects.
It won&apos;t call a pure pipe if we change an input month, add to an input array, or update an input object property.</p><span>
</span><p>This may seem restrictive but is is also fast.
An object reference check is fast &#x2014; much faster than a deep check for
differences &#x2014; so Angular can quickly determine if it can skip both the
pipe execution and a view update.</p><span>
</span><p>For this reason, we prefer a pure pipe if we can live with the change detection strategy.
When we can&apos;t, we <em>may</em> turn to the impure pipe.</p><span>
</span><div class="l-sub-section"><p>Or we might not use a pipe at all.
It may be better to pursue the pipe&apos;s purpose with a property of the component,
a point we take up later.</p><span>
</span></div><h3 id="impure-pipes">Impure pipes</h3><span>
</span><p>Angular executes an <em>impure pipe</em>  during <em>every</em> component change detection cycle.
An impure pipe will be called a lot, as often as every keystroke or mouse-move.</p><span>
</span><p>With that concern in mind, we must implement an impure pipe with great care.
An expensive, long-running pipe could destroy the user experience.</p><span>
</span><span>
</span><h3 id="an-impure-flyingheroespipe-">An impure <em>FlyingHeroesPipe</em></h3><span>
</span><p>A flip of the switch turns our <code>FlyingHeroesPipe</code> into a <code>FlyingHeroesImpurePipe</code>.
Here&apos;s the complete implementation:</p><span>
</span><code-tabs><code language="ts" name="FlyingHeroesImpurePipe" format=".">@Pipe({
  name: &apos;flyingHeroesImpure&apos;,
  pure: false
})
export class FlyingHeroesImpurePipe extends FlyingHeroesPipe {}
</code><code language="ts" name="FlyingHeroesPipe" format=".">import { Pipe, PipeTransform } from &apos;@angular/core&apos;;

import { Flyer } from &apos;./heroes&apos;;

@Pipe({ name: &apos;flyingHeroes&apos; })
export class FlyingHeroesPipe implements PipeTransform {
  transform(allHeroes: Flyer[]) {
    return allHeroes.filter(hero =&gt; hero.canFly);
  }
}
</code></code-tabs><p>We inherit from <code>FlyingHeroesPipe</code> to prove the point that nothing changed internally.
The only difference is the <code>pure</code> flag in the pipe metadata.</p><span>
</span><p>This is a good candidate for an impure pipe because the <code>transform</code> function is trivial and fast.</p><span>
</span><code language="ts" format="">return allHeroes.filter(hero =&gt; hero.canFly);
</code><p>app/flying-heroes-impure.component.html (FlyingHeroesImpureComponent)</p><code language="html" format="">&lt;div *ngFor=&quot;let hero of (heroes | flyingHeroesImpure)&quot;&gt;
  {{hero.name}}
&lt;/div&gt;
</code><p>The only substantive change is the pipe in the template.
We can confirm in the <live-example></live-example> that the <em>flying heroes</em>
display updates as we enter new heroes even when we mutate the <code>heroes</code> array.</p><span>
</span><h3 id="async-pipe">The impure <i>AsyncPipe</i></h3><p>The Angular <code>AsyncPipe</code> is an interesting example of an impure pipe.
The <code>AsyncPipe</code> accepts a <code>Promise</code> or <code>Observable</code> as input
and subscribes to the input automatically, eventually returning the emitted value(s).</p><span>
</span><p>It is also stateful.
The pipe maintains a subscription to the input <code>Observable</code> and
keeps delivering values from that <code>Observable</code> as they arrive.</p><span>
</span><p>In this next example, we bind an <code>Observable</code> of message strings 
(<code>message$</code>) to a view with the <code>async</code> pipe.</p><span>
</span><p>app/hero-async-message.component.ts</p><code language="ts" format="linenums">import { Component } from &apos;@angular/core&apos;;
import { Observable } from &apos;rxjs/Rx&apos;;

@Component({
  selector: &apos;hero-message&apos;,
  template: `
    &lt;h2&gt;Async Hero Message and AsyncPipe&lt;/h2&gt;
    &lt;p&gt;Message: {{ message$ | async }}&lt;/p&gt;
    &lt;button (click)=&quot;resend()&quot;&gt;Resend&lt;/button&gt;`,
})
export class HeroAsyncMessageComponent {
  message$: Observable&lt;string&gt;;

  private messages = [
    &apos;You are my hero!&apos;,
    &apos;You are the best hero!&apos;,
    &apos;Will you be my hero?&apos;
  ];

  constructor() { this.resend(); }

  resend() {
    this.message$ = Observable.interval(500)
      .map(i =&gt; this.messages[i])
      .take(this.messages.length);
  }
}
</code><p>The Async pipe saves boilerplate in the component code.
The component doesn&apos;t have to subscribe to the async data source,
it doesn&apos;t extract the resolved values and expose them for binding,
and the component doesn&apos;t have to unsubscribe when it is destroyed
(a potent source of memory leaks).</p><span>
</span><h3 id="an-impure-caching-pipe">An impure caching pipe</h3><span>
</span><p>Let&apos;s write one more impure pipe, a pipe that makes an HTTP request to the server.
Normally, that&apos;s a horrible idea.
It&apos;s probably a horrible idea no matter what we do.
We&apos;re forging ahead anyway to make a point.
Remember that impure pipes are called every few microseconds.
If we&apos;re not careful, this pipe will punish the server with requests.</p><span>
</span><p>We are careful. Our pipe only makes a server call if the request URL has changed.
It caches the request URL and waits for a result which it also caches when it arrives.
The pipe returns the cached result (which is null while a request is in flight)
after every Angular call and only contacts the server as necessary.</p><span>
</span><p>Here&apos;s the code, which uses the <a href="https://angular.io/docs/ts/latest/guide/server-communication.html">Angular http</a> facility
to retrieve a <code>heroes.json</code> file:</p><span>
</span><p>app/fetch-json.pipe.ts</p><code language="ts" format="linenums">import { Pipe, PipeTransform } from &apos;@angular/core&apos;;
import { Http }                from &apos;@angular/http&apos;;

@Pipe({
  name: &apos;fetch&apos;,
  pure: false
})
export class FetchJsonPipe  implements PipeTransform {
  private fetchedJson: any = null;
  private prevUrl = &apos;&apos;;

  constructor(private _http: Http) { }

  transform(url: string): any {
    if (url !== this.prevUrl) {
      this.prevUrl = url;
      this.fetchedJson = null;
      this._http.get(url)
        .map( result =&gt; result.json() )
        .subscribe( result =&gt; this.fetchedJson = result );
    }

    return this.fetchedJson;
  }
}
</code><p>Then we demonstrate it in a harness component whose template defines two bindings to this pipe.</p><span>
</span><p>app/hero-list.component.ts (template)</p><code language="ts" format="linenums">template: `
  &lt;h2&gt;Heroes from JSON File&lt;/h2&gt;

  &lt;div *ngFor=&quot;let hero of (&apos;heroes.json&apos; | fetch) &quot;&gt;
    {{hero.name}}
  &lt;/div&gt;

  &lt;p&gt;Heroes as JSON:
  {{&apos;heroes.json&apos; | fetch | json}}
  &lt;/p&gt;
`
</code><p>Despite the two bindings and what we know to be frequent pipe calls,
the nework tab in the browser developer tools confirms that there is only one request for the file.</p><span>
</span><p>The component renders like this:</p><span>
</span><figure class="image-display"><img src="https://angular.io/resources/images/devguide/pipes/hero-list.png" alt="Hero List"></figure><h3 id="-jsonpipe-"><em>JsonPipe</em></h3><span>
</span><p>The second binding involving the <code>FetchPipe</code> uses more pipe chaining.
We take the same fetched results displayed in the first binding
and display them again, this time in JSON format by chaining through to the built-in <code>JsonPipe</code>.</p><span>
</span><div class="callout is-helpful"><header>Debugging with the json pipe</header><p>The <a href="https://angular.io/docs/ts/latest/api/common/index/JsonPipe-class.html">JsonPipe</a>
provides an easy way to diagnosis a mysteriously failing data binding or
inspect an object for future binding.</p><span>
</span></div><p>Here&apos;s the complete component implementation:</p><span>
</span><p>app/hero-list.component.ts</p><code language="ts" format="linenums">import { Component } from &apos;@angular/core&apos;;

@Component({
  selector: &apos;hero-list&apos;,
  template: `
    &lt;h2&gt;Heroes from JSON File&lt;/h2&gt;

    &lt;div *ngFor=&quot;let hero of (&apos;heroes.json&apos; | fetch) &quot;&gt;
      {{hero.name}}
    &lt;/div&gt;

    &lt;p&gt;Heroes as JSON:
    {{&apos;heroes.json&apos; | fetch | json}}
    &lt;/p&gt;
  `
})
export class HeroListComponent { }
</code><a id="pure-pipe-pure-fn"></a><h3 id="pure-pipes-and-pure-functions">Pure pipes and pure functions</h3><span>
</span><p>A pure pipe uses pure functions.
Pure functions process inputs and return values without detectable side-effects.
Given the same input they should always return the same output.</p><span>
</span><p>The pipes we saw earlier in this chapter were implemented with pure functions.
The built-in <code>DatePipe</code> is a pure pipe with a pure function implementation.
So is our <code>ExponentialStrengthPipe</code>.
So is our <code>FlyingHeroesPipe</code>.
A few steps back we reviewed the <code>FlyingHeroesImpurePipe</code> &#x2014; <em>an impure pipe with a pure function</em>.</p><span>
</span><p>But a <em>pure pipe</em> must always be implemented with a <em>pure function</em>. Failure to heed this warning will bring about many a console errors regarding expressions that have changed after they were checked.</p><span>
</span><h2 id="next-steps">Next Steps</h2><span>
</span><p>Pipes are a great way to encapsulate and share common display-value
transformations. We use them like styles, dropping them
into our templates expressions to enrich the appeal and usability
of our views.</p><span>
</span><p>Explore Angular&apos;s inventory of built-in pipes in the <a href="https://angular.io/docs/ts/latest/api/#!?apiFilter=pipe">API Reference</a>.
Try writing a custom pipe and perhaps contributing it to the community.</p><span>
</span><a id="no-filter-pipe"></a><h2 id="no-filterpipe-or-orderbypipe-">No <em>FilterPipe</em> or <em>OrderByPipe</em></h2><span>
</span><p>Angular does not ship with pipes for filtering or sorting lists.
Developers familiar with Angular 1 know these as <code>filter</code> and <code>orderBy</code>.
There are no equivalents in Angular 2.</p><span>
</span><p>This is not an oversight. Angular 2 is unlikely to offer such pipes because
(a) they perform poorly and (b) they prevent aggressive minification.
Both <code>filter</code> and <code>orderBy</code> require parameters that reference object properties.
We learned earlier that such pipes must be  <a href="https://angular.io/docs/ts/latest/guide/pipes.html#pure-and-impure-pipes"><em>impure</em></a> and that
Angular calls impure pipes in almost every change detection cycle.</p><span>
</span><p>Filtering and especially sorting are expensive operations.
The user experience can degrade severely for even moderate sized lists when Angular calls these pipe methods many times per second.
The <code>filter</code> and <code>orderBy</code> have often been abused in Angular 1 apps, leading to complaints that Angular itself is slow.
That charge is fair in the indirect sense that Angular 1 prepared this performance trap
by offering <code>filter</code> and <code>orderBy</code> in the first place.</p><span>
</span><p>The minification hazard is also compelling if less obvious. Imagine a sorting pipe applied to a list of heroes.
We might sort the list by hero <code>name</code> and <code>planet</code> of origin properties something like this:</p><span>
</span><code language="html">&lt;!-- NOT REAL CODE! --&gt;
&lt;div *ngFor=&quot;let hero of heroes | orderBy:&apos;name,planet&apos;&quot;&gt;&lt;/div&gt;</code><p>We identify the sort fields by text strings, expecting the pipe to reference a property value by indexing
(e.g., <code>hero[&apos;name&apos;]</code>).
Unfortunately, aggressive minification <em>munges</em> the <code>Hero</code> property names so that <code>Hero.name</code> and <code>Hero.planet</code>
becomes something like <code>Hero.a</code> and <code>Hero.b</code>. Clearly <code>hero[&apos;name&apos;]</code> is not going to work.</p><span>
</span><p>Some of us may not care to minify this aggressively. That&apos;s <em>our</em> choice.
But the Angular product should not prevent someone else from minifying aggressively.
Therefore, the Angular team decided that everything shipped in Angular will minify safely.</p><span>
</span><p>The Angular team and many experienced Angular developers strongly recommend that you move
filtering and sorting logic into the component itself.
The component can expose a <code>filteredHeroes</code> or <code>sortedHeroes</code> property and take control
over when and how often to execute the supporting logic.
Any capabilities that you would have put in a pipe and shared across the app can be
written in a filtering/sorting service and injected into the component.</p><span>
</span><p>If these performance and minification considerations do not apply to you, you can always create your own such pipes
(along the lines of the <a href="https://angular.io/docs/ts/latest/guide/pipes.html#impure-flying-heroes">FlyingHeroesPipe</a>) or find them in the community.</p><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--></div></div>
        </article>
      
        <article>
          <h3>Routing & Navigation</h3>
          <div><div class="showcase-content"><p>The Angular <strong><em>Component Router</em></strong> enables navigation from one <a href="https://angular.io/docs/ts/latest/guide/glossary.html#view">view</a> to the next
as users perform application tasks.</p><span>
</span><p>We cover the router&apos;s primary features in this chapter, illustrating them through the evolution
of a small application that we can <live-example>run live</live-example>.</p><span>
</span><div class="l-sub-section"><img src="https://angular.io/resources/images/devguide/plunker-separate-window-button.png" alt="pop out the window" align="right"><p>To see the URL changes in the browser address bar,
pop out the preview window by clicking the blue &apos;X&apos; button in the upper right corner.</p><span>
</span></div><h2 id="overview">Overview</h2><span>
</span><p>The browser is a familiar model of application navigation.
We enter a URL in the address bar and the browser navigates to a corresponding page.
We click links on the page and the browser navigates to a new page.
We click the browser&apos;s back and forward buttons and the browser navigates
backward and forward through the history of pages we&apos;ve seen.</p><span>
</span><p>The Angular <strong><em>Component Router</em></strong> (&quot;the router&quot;) borrows from this model.
It can interpret a browser URL as an instruction
to navigate to a client-generated view and pass optional parameters along to the supporting view component
to help it decide what specific content to present.
We can bind the router to links on a page and it will navigate to
the appropriate application view when the user clicks a link.
We can navigate imperatively when the user clicks a button, selects from a drop box,
or in response to some other stimulus from any source. And the router logs activity
in the browser&apos;s history journal so the back and forward buttons work as well.</p><span>
</span><p>We&apos;ll learn many router details in this chapter which covers</p><span>
</span><ul>
<li>Setting the <a href="https://angular.io/docs/ts/latest/guide/router.html#base-href">base href</a></li>
<li>Importing from the <a href="https://angular.io/docs/ts/latest/guide/router.html#import">router library</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/router.html#route-config">configuring the router</a></li>
<li>the <a href="https://angular.io/docs/ts/latest/guide/router.html#link-parameters-array">link parameters array</a> that propels router navigation</li>
<li>navigating when the user clicks a data-bound <a href="https://angular.io/docs/ts/latest/guide/router.html#router-link">RouterLink</a></li>
<li>navigating under <a href="https://angular.io/docs/ts/latest/guide/router.html#navigate">program control</a></li>
<li>toggling css classes for the <a href="https://angular.io/docs/ts/latest/guide/router.html#router-link-active">active router link</a></li>
<li>embedding critical information in the URL with <a href="https://angular.io/docs/ts/latest/guide/router.html#route-parameters">route parameters</a></li>
<li>providing non-critical information in <a href="https://angular.io/docs/ts/latest/guide/router.html#optional-route-parameters">optional route parameters</a></li>
<li>add <a href="https://angular.io/docs/ts/latest/guide/router.html#child-routing-component">child routes</a> under a feature section</li>
<li><a href="https://angular.io/docs/ts/latest/guide/router.html#redirect">redirecting</a> from one route to another</li>
<li>confirming or canceling navigation with <a href="https://angular.io/docs/ts/latest/guide/router.html#guards">guards</a><ul>
<li><a href="https://angular.io/docs/ts/latest/guide/router.html#can-activate-guard">CanActivate</a> to prevent navigation to a route</li>
<li><a href="https://angular.io/docs/ts/latest/guide/router.html#can-deactivate-guard">CanDeactivate</a> to prevent navigation away from the current route</li>
<li><a href="https://angular.io/docs/ts/latest/guide/router.html#resolve-guard">Resolve</a> to pre-fetch data before activating a route</li>
</ul>
</li>
<li>providing optional information across routes with <a href="https://angular.io/docs/ts/latest/guide/router.html#query-parameters">query parameters</a></li>
<li>jumping to anchor elements using a <a href="https://angular.io/docs/ts/latest/guide/router.html#fragment">fragment</a></li>
<li>loading feature areas <a href="https://angular.io/docs/ts/latest/guide/router.html#asynchronous-routing">asynchronously</a></li>
<li>choosing the &quot;HTML5&quot; or &quot;hash&quot; <a href="https://angular.io/docs/ts/latest/guide/router.html#browser-url-styles">URL style</a></li>
</ul><span>
</span><p>We proceed in phases marked by milestones building from a simple two-pager with placeholder views
up to a modular, multi-view design with child routes.</p><span>
</span><p>But first, an overview of router basics.</p><span>
</span><h2 id="the-basics">The Basics</h2><span>
</span><p>Let&apos;s begin with a few core concepts of the Component Router.
Then we can explore the details through a sequence of examples.</p><span>
</span><h3 id="-lt-base-href-"><em>&lt;base href&gt;</em></h3><span>
</span><p>Most routing applications should add a <code>&lt;base&gt;</code> element to the <strong><code>index.html</code></strong> as the first child in the  <code>&lt;head&gt;</code> tag
to tell the router how to compose navigation URLs.</p><span>
</span><p>If the <code>app</code> folder is the application root, as it is for our sample application,
set the <code>href</code> value <em>exactly</em> as shown here.</p><span>
</span><p>index.html (base-href)</p><code language="html" format="">&lt;base href=&quot;/&quot;&gt;
</code><h3 id="router-imports">Router imports</h3><span>
</span><p>The Angular Component Router is an optional service that presents a particular component view for a given URL.
It is not part of the Angular 2 core. It is in its own library package, <code>@angular/router</code>.
We import what we need from it as we would from any other Angular package.</p><span>
</span><p>app/app.routing.ts (import)</p><code language="ts" format="">import { Routes, RouterModule }   from &apos;@angular/router&apos;;
</code><div class="l-sub-section"><p>We cover other options in the <a href="https://angular.io/docs/ts/latest/guide/router.html#browser-url-styles">details below</a>.</p><span>
</span></div><h3 id="configuration">Configuration</h3><span>
</span><p>The application will have one <em><code>router</code></em>. When the browser&apos;s URL changes, the router looks for a corresponding <strong><code>Route</code></strong>
from which it can determine the component to display.</p><span>
</span><p>A router has no routes until we configure it.
We bootstrap our application with an array of routes that we&apos;ll provide to our <strong><code>RouterModule.forRoot</code></strong> function.</p><span>
</span><p>In the following example, we configure our application with four route definitions.</p><span>
</span><p>app/app.routing.ts (excerpt)</p><code language="ts" format="">import { Routes, RouterModule } from &apos;@angular/router&apos;;

const appRoutes: Routes = [
  { path: &apos;crisis-center&apos;, component: CrisisCenterComponent },
  {
    path: &apos;heroes&apos;,
    component: HeroListComponent,
    data: {
      title: &apos;Heroes List&apos;
    }
  },
  { path: &apos;hero/:id&apos;, component: HeroDetailComponent },
  { path: &apos;**&apos;, component: PageNotFoundComponent }
];

export const appRoutingProviders: any[] = [

];

export const routing: ModuleWithProviders = RouterModule.forRoot(appRoutes);
</code><div class="l-sub-section"><p>The <code>Routes</code> is an array of <em>routes</em> that describe how to navigate.
Each <em>Route</em> maps a URL <code>path</code> to a component.</p><span>
</span><p>There are no <strong>leading slashes</strong> in our <strong>path</strong>. The router parses and builds the URL for us,
allowing us to use relative and absolute paths when navigating between application views.</p><span>
</span><p>The <code>data</code> property in the second route is a place to store arbitrary data associated with each
specific route. This data is accessible within each activated route and can be used to store
items such as page titles, breadcrumb text and other read-only data. We&apos;ll use the <a href="https://angular.io/docs/ts/latest/guide/router.html#resolve-guard">resolve guard</a>
to retrieve additional data later in the chapter.</p><span>
</span><p>The <code>:id</code> in the third route is a token for a route parameter. In a URL such as <code>/hero/42</code>, &quot;42&quot;
is the value of the <code>id</code> parameter. The corresponding <code>HeroDetailComponent</code>
will use that value to find and present the hero whose <code>id</code> is 42.
We&apos;ll learn more about route parameters later in this chapter.</p><span>
</span><p>The <code>**</code> in the fourth route denotes a <strong>wildcard</strong> path for our route. The router will match this route
if the URL requested doesn&apos;t match any paths for routes defined in our configuration. This is useful for
displaying a 404 page or redirecting to another route.</p><span>
</span></div><p>We export the <code>routing</code> constant so we can import it into our <code>app.module.ts</code> file where we&apos;ll add
a configured <em>Router</em> module to our root NgModule imports.</p><span>
</span><p>Next we open <code>app.module.ts</code> where we must register our routing, routing providers, and declare our two route components.</p><span>
</span><p>app/app.module.ts (basic setup)</p><code language="ts" format="">import { AppComponent }       from &apos;./app.component&apos;;
import { routing,
         appRoutingProviders } from &apos;./app.routing&apos;;

import { HeroListComponent }    from &apos;./hero-list.component&apos;;
import { CrisisListComponent }  from &apos;./crisis-list.component&apos;;

@NgModule({
  imports: [
    BrowserModule,
    FormsModule,
    routing
  ],
  declarations: [
    AppComponent,
    HeroListComponent,
    CrisisListComponent
  ],
  providers: [
    appRoutingProviders
  ],
  bootstrap: [ AppComponent ]
})
</code><h3 id="router-outlet">Router Outlet</h3><span>
</span><p>Given this configuration, when the browser URL for this application becomes <code>/heroes</code>,
the router matches that URL to the <code>Route</code> path <code>/heroes</code> and displays the <code>HeroListComponent</code>
in a <strong><code>RouterOutlet</code></strong> that we&apos;ve placed in the host view&apos;s HTML.</p><span>
</span><code language="html">&lt;!-- Routed views go here --&gt;
&lt;router-outlet&gt;&lt;/router-outlet&gt;</code><span>
</span><p>Now we have routes configured and a place to render them, but
how do we navigate? The URL could arrive directly from the browser address bar.
But most of the time we navigate as a result of some user action such as the click of
an anchor tag.</p><span>
</span><p>We add a <strong><code>RouterLink</code></strong> directive to the anchor tag. Since
we know our link doesn&apos;t contain any dynamic information, we can use a one-time binding to our route <em>path</em>.</p><span>
</span><p>If our <code>RouterLink</code> needed to be more dynamic we could bind to a template expression that
returns an array of route link parameters (the <strong>link parameters array</strong>). The router ultimately resolves that array
into a URL and a component view.</p><span>
</span><p>We also add a <strong><code>RouterLinkActive</code></strong> directive to each anchor tag to add or remove CSS classes to the
element when the associated <em>RouterLink</em> becomes active. The directive can be added directly on the element
or on its parent element.</p><span>
</span><p>We see such bindings in the following <code>AppComponent</code> template:</p><span>
</span><code language="ts" format="">template: `
  &lt;h1&gt;Component Router&lt;/h1&gt;
  &lt;nav&gt;
    &lt;a routerLink=&quot;/crisis-center&quot; routerLinkActive=&quot;active&quot;&gt;Crisis Center&lt;/a&gt;
    &lt;a routerLink=&quot;/heroes&quot; routerLinkActive=&quot;active&quot;&gt;Heroes&lt;/a&gt;
  &lt;/nav&gt;
  &lt;router-outlet&gt;&lt;/router-outlet&gt;
`
</code><div class="l-sub-section"><p>We&apos;re adding two anchor tags with <code>RouterLink</code> and <code>RouterLinkActive</code> directives.
We bind each <code>RouterLink</code> to a string containing the path of a route.
&apos;/crisis-center&apos; and &apos;/heroes&apos; are the paths of the <code>Routes</code> we configured above.</p><span>
</span><p>We&apos;ll learn to write link expressions &#x2014; and why they are arrays &#x2014;
<a href="https://angular.io/docs/ts/latest/guide/router.html#link-parameters-array">later</a> in the chapter.</p><span>
</span><p>We define <code>active</code> as the CSS class we want toggled to each <code>RouterLink</code> when they become
the current route using the <code>RouterLinkActive</code> directive. We could add multiple classes to
the <code>RouterLink</code> if we so desired.</p><span>
</span></div><h3 id="router-state">Router State</h3><span>
</span><p>After the end of each successful navigation lifecycle, the router builds a tree of <code>ActivatedRoute</code> objects
that make up the current state of the router. We can access the current <code>RouterState</code> from anywhere in our
application using the <code>Router</code> service and the <code>routerState</code> property.</p><span>
</span><p>The router state provides us with methods to traverse up and down the route tree from any activated route
to get information we may need from parent, child and sibling routes.</p><span>
</span><h3 id="let-s-summarize">Let&apos;s summarize</h3><span>
</span><p>The application is provided with a configured router.
The component has a <code>RouterOutlet</code> where it can display views produced by the router.
It has <code>RouterLink</code>s that users can click to navigate via the router.</p><span>
</span><p>Here are the key <em>Component Router</em> terms and their meanings:</p><span>
</span><table><tbody><tr><th>Router Part</th><th>Meaning</th></tr><tr><td><code>Router</code></td><td>Displays the application component for the active URL.
Manages navigation from one component to the next.</td></tr><tr><td><code>RouterModule</code></td><td>A separate Angular module that provides the necessary service providers
and directives for navigating through application views.</td></tr><tr><td><code>Routes</code></td><td>Defines an array of Routes, each mapping a URL path to a component.</td></tr><tr><td><code>Route</code></td><td>Defines how the router should navigate to a component based on a URL pattern.
Most routes consist of a path and a component type.</td></tr><tr><td><code>RouterOutlet</code></td><td>The directive (<code>&lt;router-outlet&gt;</code>) that marks where the router should display a view.</td></tr><tr><td><code>RouterLink</code></td><td>The directive for binding a clickable HTML element to
a route. Clicking an anchor tag with a <code>routerLink</code> directive
that is bound to a <i>string</i> or a <i>Link Parameters Array</i> triggers a navigation.</td></tr><tr><td><code>RouterLinkActive</code></td><td>The directive for adding/removing classes from an HTML element when an associated
routerLink contained on or inside the element becomes active/inactive.</td></tr><tr><td><code>ActivatedRoute</code></td><td>A service that is provided to each route component that contains route specific
information such as route parameters, static data, resolve data, global query params and the global fragment.</td></tr><tr><td><code>RouterState</code></td><td>The current state of the router including a tree of the currently activated
routes in our application along convenience methods for traversing the route tree.</td></tr><tr><td><code><i>Link Parameters Array</i></code></td><td>An array that the router interprets into a routing instruction.
We can bind a <code>RouterLink</code> to that array or pass the array as an argument to
the <code>Router.navigate</code> method.</td></tr><tr><td><code><i>Routing Component</i></code></td><td>An Angular component with a <code>RouterOutlet</code> that displays views based on router navigations.</td></tr></tbody></table><p>We&apos;ve barely touched the surface of the router and its capabilities.</p><span>
</span><p>The following detail sections describe a sample routing application
as it evolves over a sequence of milestones.
We strongly recommend taking the time to read and understand this story.</p><span>
</span><h2 id="the-sample-application">The Sample Application</h2><span>
</span><p>We have an application in mind as we move from milestone to milestone.</p><span>
</span><div class="l-sub-section"><p>While we make incremental progress toward the ultimate sample application, this chapter is not a tutorial.
We discuss code and design decisions pertinent to routing and application design.
We gloss over everything in between.</p><span>
</span><p>The full source is available in the <live-example></live-example>.</p><span>
</span></div><p>Our client is the Hero Employment Agency.
Heroes need work and The Agency finds Crises for them to solve.</p><span>
</span><p>The application has two main feature areas:</p><span>
</span><ol>
<li>A <em>Crisis Center</em> where we maintain the list of crises for assignment to heroes.</li>
<li>A <em>Heroes</em> area where we maintain the list of heroes employed by The Agency.</li>
</ol><span>
</span><p>Run the <live-example></live-example>.
It opens in the <em>Crisis Center</em>.  We&apos;ll come back to that.</p><span>
</span><p>Click the <em>Heroes</em> link. We&apos;re presented with a list of Heroes.</p><span>
</span><figure class="image-display"><img src="https://angular.io/resources/images/devguide/router/hero-list.png" alt="Hero List" width="250"></figure><p>We select one and the application takes us to a hero editing screen.</p><span>
</span><figure class="image-display"><img src="https://angular.io/resources/images/devguide/router/hero-detail.png" alt="Crisis Center Detail" width="250"></figure><p>Our changes take effect immediately. We click the &quot;Back&quot; button and the
app returns us to the Heroes list.</p><span>
</span><p>We could have clicked the browser&apos;s back button instead.
That would have returned us to the Heroes List as well.
Angular app navigation updates the browser history as normal web navigation does.</p><span>
</span><p>Now click the <em>Crisis Center</em> link. We go to the <em>Crisis Center</em> and its list of ongoing crises.</p><span>
</span><figure class="image-display"><img src="https://angular.io/resources/images/devguide/router/crisis-center-list.png" alt="Crisis Center List"></figure><p>We select one and the application takes us to a crisis editing screen.</p><span>
</span><figure class="image-display"><img src="https://angular.io/resources/images/devguide/router/crisis-center-detail.png" alt="Crisis Center Detail"></figure><p>This is a bit different from the <em>Hero Detail</em>. <em>Hero Detail</em> saves the changes as we type.
In <em>Crisis Detail</em> our changes are temporary until we either save or discard them by pressing the &quot;Save&quot; or &quot;Cancel&quot; buttons.
Both buttons navigate back to the <em>Crisis Center</em> and its list of crises.</p><span>
</span><p>Suppose we click a crisis, make a change, but <strong><em>do not click either button</em></strong>.
Maybe we click the browser back button instead. Maybe we click the &quot;Heroes&quot; link.</p><span>
</span><p>Do either. Up pops a dialog box.</p><span>
</span><figure class="image-display"><img src="https://angular.io/resources/images/devguide/router/confirm-dialog.png" alt="Confirm Dialog" width="300"></figure><p>We can say &quot;OK&quot; and lose our changes or click &quot;Cancel&quot; and continue editing.</p><span>
</span><p>The router supports a <code>CanDeactivate</code> guard that gives us a chance to clean-up
or ask the user&apos;s permission before navigating away from the current view.</p><span>
</span><p>Here we see an entire user session that touches all of these features.</p><span>
</span><a id="full-app-demo"></a><figure class="image-display"><img src="https://angular.io/resources/images/devguide/router/router-anim.gif" alt="App in action"></figure><p>Here&apos;s a diagram of all application routing options:</p><span>
</span><figure class="image-display"><img src="https://angular.io/resources/images/devguide/router/complete-nav.png" alt="Navigation diagram"></figure><p>This app illustrates the router features we&apos;ll cover in this chapter</p><span>
</span><ul>
<li>organizing the application features into modules</li>
<li>navigating to a component (<em>Heroes</em> link to &quot;Heroes List&quot;)</li>
<li>including a route parameter (passing the Hero <code>id</code> while routing to the &quot;Hero Detail&quot;)</li>
<li>child routes (the <em>Crisis Center</em> has its own routes)</li>
<li>the <code>CanActivate</code> guard (checking route access)</li>
<li>the <code>CanDeactivate</code> guard (ask permission to discard unsaved changes)</li>
<li>the <code>Resolve</code> guard (pre-fetching route data)</li>
<li>lazy loading feature area modules</li>
</ul><span>
</span><a id="getting-started"></a><h2 id="milestone-1-getting-started-with-the-router">Milestone #1: Getting Started with the Router</h2><span>
</span><p>Let&apos;s begin with a simple version of the app that navigates between two empty views.</p><span>
</span><figure class="image-display"><img src="https://angular.io/resources/images/devguide/router/router-1-anim.gif" alt="App in action"></figure><a id="base-href"></a><h3 id="set-the-lt-base-href-">Set the <em>&lt;base href&gt;</em></h3><span>
</span><p>The Component Router uses the browser&apos;s
<a href="https://developer.mozilla.org/en-US/docs/Web/API/History_API#Adding_and_modifying_history_entries">history.pushState</a>
for navigation. Thanks to <code>pushState</code>, we can make our in-app URL paths look the way we want them to
look, e.g. <code>localhost:3000/crisis-center</code>. Our in-app URLs can be indistinguishable from server URLs.</p><span>
</span><p>Modern HTML 5 browsers were the first to support <code>pushState</code> which is why many people refer to these URLs as
&quot;HTML 5 style&quot; URLs.</p><span>
</span><p>We must <strong>add a <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base">&lt;base href&gt; element</a> tag</strong>
to the <code>index.html</code> to make <code>pushState</code> routing work.
The browser also needs the base <code>href</code> value to prefix <em>relative</em> URLs when downloading and linking to
css files, scripts, and images.</p><span>
</span><p>Add the base element just after the  <code>&lt;head&gt;</code> tag.
If the <code>app</code> folder is the application root, as it is for our application,
set the <code>href</code> value in <strong><code>index.html</code></strong> <em>exactly</em> as shown here.</p><span>
</span><p>index.html (base-href)</p><code language="html" format="">&lt;base href=&quot;/&quot;&gt;
</code><div class="l-sub-section"><p>HTML 5 style navigation is the Component Router default.
Learn why &quot;HTML 5&quot; style is preferred, how to adjust its behavior, and how to switch to the
older hash (#) style if necessary in the <a href="https://angular.io/docs/ts/latest/guide/router.html#browser-url-styles">Browser URL Styles</a> appendix below.</p><span>
</span></div><div class="l-sub-section"><h4 id="live-example-note">Live example note</h4><span>
</span><p>We have to get tricky when we run the live example because the host service sets
the application base address dynamically. That&apos;s why we replace the <code>&lt;base href...&gt;</code> with a
script that writes a <code>&lt;base&gt;</code> tag on the fly to match.</p><span>
</span><code format="">&lt;script&gt;document.write(&apos;&lt;base href=&quot;&apos; + document.location + &apos;&quot; /&gt;&apos;);&lt;/script&gt;</code><p>We should only need this trick for the live example, not production code.</p><span>
</span></div><h3 id="configure-the-routes-for-the-router">Configure the routes for the Router</h3><span>
</span><p>We begin by importing some symbols from the router library.</p><span>
</span><p>The Component Router is in its own <code>@angular/router</code> package.
It&apos;s not part of the Angular 2 core. The router is an optional service because not all applications
need routing and, depending on your requirements, you may need a different routing library.</p><span>
</span><p>We teach our router how to navigate by configuring it with routes.
We recommend creating a separate <code>app.routing.ts</code> file dedicated to this purpose.</p><span>
</span><div class="l-sub-section"><p>Defining configuration in a separate file paves the way for a future
in which we load routing configuration immediately but <em>delay
loading the components themselves</em> until the user needs them.</p><span>
</span><p>Such <a href="https://angular.io/docs/ts/latest/guide/router.html#asynchronous-routing"><em>asynchronous routing</em></a> can make our application launch more quickly.</p><span>
</span></div><p>Here is our first configuration. We pass the array of routes to the <code>RouterModule.forRoot</code> method
which returns a module containing the configured <code>Router</code> service provider ... and some other,
unseen providers that the routing library requires. We export this as the <code>routing</code> token.</p><span>
</span><p>app/app.routing.ts (excerpt)</p><code language="ts" format="">import { ModuleWithProviders } from &apos;@angular/core&apos;;
import { Routes, RouterModule } from &apos;@angular/router&apos;;

import { CrisisListComponent }  from &apos;./crisis-list.component&apos;;
import { HeroListComponent }    from &apos;./hero-list.component&apos;;

const appRoutes: Routes = [
  { path: &apos;crisis-center&apos;, component: CrisisListComponent },
  { path: &apos;heroes&apos;, component: HeroListComponent }
];

export const appRoutingProviders: any[] = [

];

export const routing: ModuleWithProviders = RouterModule.forRoot(appRoutes);
</code><div class="l-sub-section"><p>We also export an empty <code>appRoutingProviders</code> array
so we can simplify registration of router dependencies later in <code>app.module.ts</code>.
We don&apos;t have any providers to register right now. But we will.</p><span>
</span></div><a id="route-config"></a><h4 id="define-routes">Define routes</h4><p>A router must be configured with a list of route definitions.</p><span>
</span><p>Our first configuration defines an array of two routes with simple paths leading to the
<code>CrisisListComponent</code> and <code>HeroListComponent</code> components.</p><span>
</span><p>Each definition translates to a <a href="https://angular.io/docs/ts/latest/api/router/index/Route-interface.html">Route</a> object which has a
<code>path</code>, the URL path segment for this route, and a
<code>component</code>, the component associated with this route.</p><span>
</span><p>The router draws upon its registry of such route definitions when the browser URL changes
or when our code tells the router to navigate along a route path.</p><span>
</span><p>In plain English, we might say of the first route:</p><span>
</span><ul>
<li><p><em>When the browser&apos;s location URL changes to match the path segment <code>/crisis-center</code>, create or retrieve an instance of
the <code>CrisisListComponent</code> and display its view.</em></p>
</li>
<li><p><em>When the application requests navigation to the path <code>/crisis-center</code>, create or retrieve an instance of
the <code>CrisisListComponent</code>, display its view, and update the browser&apos;s address location and history with the URL
for that path.</em></p>
</li>
</ul><span>
</span><h4 id="register-providers">Register routing in the root NgModule</h4><p>Our app launches from the <code>app.module.ts</code> file in the <code>/app</code> folder.</p><span>
</span><p>We import the <code>routing</code> token we exported from the <code>app.routing.ts</code> file and add it to the <code>imports</code> array.</p><span>
</span><p>We import our <code>CrisisListComponent</code> and <code>HeroListComponent</code> components and add them to our <em>declarations</em>
so they will be registered within our root NgModule.</p><span>
</span><p>We also import the <code>appRoutingProviders</code> array and add it to the <code>providers</code> array.</p><span>
</span><p>app/app.module.ts (excerpt)</p><code language="ts" format="">import { NgModule }       from &apos;@angular/core&apos;;
import { BrowserModule }  from &apos;@angular/platform-browser&apos;;
import { FormsModule }    from &apos;@angular/forms&apos;;


import { AppComponent }       from &apos;./app.component&apos;;
import { routing,
         appRoutingProviders } from &apos;./app.routing&apos;;

import { HeroListComponent }    from &apos;./hero-list.component&apos;;
import { CrisisListComponent }  from &apos;./crisis-list.component&apos;;

@NgModule({
  imports: [
    BrowserModule,
    FormsModule,
    routing
  ],
  declarations: [
    AppComponent,
    HeroListComponent,
    CrisisListComponent
  ],
  providers: [
    appRoutingProviders
  ],
  bootstrap: [ AppComponent ]
})
export class AppModule {
}
</code><p>Providing the router module in our root NgModule makes the Router available everywhere in our application.</p><span>
</span><h3 id="shell">The <i>AppComponent</i> shell</h3><p>The root <code>AppComponent</code> is the application shell. It has a title at the top, a navigation bar with two links,
and a <em>Router Outlet</em> at the bottom where the router swaps views on and off the page. Here&apos;s what we mean:</p><span>
</span><figure class="image-display"><img src="https://angular.io/resources/images/devguide/router/shell-and-outlet.png" alt="Shell" width="300"></figure><a id="shell-template"></a><p>The corresponding component template looks like this:</p><span>
</span><code language="ts" format="">template: `
  &lt;h1&gt;Component Router&lt;/h1&gt;
  &lt;nav&gt;
    &lt;a routerLink=&quot;/crisis-center&quot; routerLinkActive=&quot;active&quot;&gt;Crisis Center&lt;/a&gt;
    &lt;a routerLink=&quot;/heroes&quot; routerLinkActive=&quot;active&quot;&gt;Heroes&lt;/a&gt;
  &lt;/nav&gt;
  &lt;router-outlet&gt;&lt;/router-outlet&gt;
`
</code><a id="router-outlet"></a><h3 id="-routeroutlet-"><em>RouterOutlet</em></h3><span>
</span><p><code>RouterOutlet</code> is a component from the router library.
The router displays views within the bounds of the <code>&lt;router-outlet&gt;</code> tags.</p><span>
</span><div class="l-sub-section"><p>A template may hold exactly one <strong><em>unnamed</em></strong> <code>&lt;router-outlet&gt;</code>.
The router supports multiple <em>named</em> outlets, a feature we&apos;ll cover in future.</p><span>
</span></div><a id="router-link"></a><span>
</span><p>Above the outlet, within the anchor tags, we see <a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#property-binding">Property Bindings</a> to
the <code>RouterLink</code> directive that look like <code>routerLink=&quot;...&quot;</code>. We imported <code>RouterLink</code> from the router library.</p><span>
</span><p>The links in this example each have a string path, the path of a route that
we configured earlier. We don&apos;t have route parameters yet.</p><span>
</span><p>We can also add more contextual information to our <code>RouterLink</code> by providing query string parameters
or a URL fragment for jumping to different areas on our page. Query string parameters
are provided through the <code>[queryParams]</code> binding which takes an object (e.g. <code>{ name: &apos;value&apos; }</code>), while the URL fragment
takes a single value bound to the <code>[fragment]</code> input binding.</p><span>
</span><div class="l-sub-section"><p>Learn about the how we can also use the <strong>link parameters array</strong> in the <a href="https://angular.io/docs/ts/latest/guide/router.html#link-parameters-array">appendix below</a>.</p><span>
</span></div><a id="router-link-active"></a><p>On each anchor tag, we also see <a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#property-binding">Property Bindings</a> to
the <code>RouterLinkActive</code> directive that look like <code>routerLinkActive=&quot;...&quot;</code>.</p><span>
</span><p>The template expression to the right of the equals (=) contains our space-delimited string of CSS classes.
We can also bind to the <code>RouterLinkActive</code> directive using an array of classes
such as <code>[routerLinkActive]=&quot;[&apos;...&apos;]&quot;</code>.</p><span>
</span><p>The <code>RouterLinkActive</code> directive toggles css classes for active <code>RouterLink</code>s based on the current <code>RouterState</code>.
This cascades down through each level in our route tree, so parent and child router links can be active at the same time.
To override this behavior, we can bind to the <code>[routerLinkActiveOptions]</code> input binding with the <code>{ exact: true }</code> expression.
By using <code>{ exact: true }</code>, a given <code>RouterLink</code> will only be active if its URL is an exact match to the current URL.</p><span>
</span><h3 id="router-directives"><i>Router Directives</i></h3><p><code>RouterLink</code>, <code>RouterLinkActive</code> and <code>RouterOutlet</code> are directives provided by the Angular <code>RouterModule</code> package.
They are readily available for us to use in our template.</p><span>
</span><p>The current state of <code>app.component.ts</code> looks like this:</p><span>
</span><p>app/app.component.ts (excerpt)</p><code language="ts" format="">import { Component } from &apos;@angular/core&apos;;

@Component({
  selector: &apos;my-app&apos;,
  template: `
    &lt;h1&gt;Component Router&lt;/h1&gt;
    &lt;nav&gt;
      &lt;a routerLink=&quot;/crisis-center&quot; routerLinkActive=&quot;active&quot;&gt;Crisis Center&lt;/a&gt;
      &lt;a routerLink=&quot;/heroes&quot; routerLinkActive=&quot;active&quot;&gt;Heroes&lt;/a&gt;
    &lt;/nav&gt;
    &lt;router-outlet&gt;&lt;/router-outlet&gt;
  `
})
export class AppComponent { }
</code><h3 id="-getting-started-wrap-up">&quot;Getting Started&quot; wrap-up</h3><span>
</span><p>We&apos;ve got a very basic, navigating app, one that can switch between two views
when the user clicks a link.</p><span>
</span><p>We&apos;ve learned how to</p><span>
</span><ul>
<li>load the router library</li>
<li>add a nav bar to the shell template with anchor tags, <code>routerLink</code>  and <code>routerLinkActive</code> directives</li>
<li>add a <code>router-outlet</code> to the shell template where views will be displayed</li>
<li>configure the router module with <code>RouterModule.forRoot</code></li>
<li>set the router to compose &quot;HTML 5&quot; browser URLs.</li>
</ul><span>
</span><p>The rest of the starter app is mundane, with little interest from a router perspective.
Here are the details for readers inclined to build the sample through to this milestone.</p><span>
</span><p>Our starter app&apos;s structure looks like this:</p><span>
</span><div class="filetree"><p>router-sample</p><div class="children"><div class="file"><span>app</span><div class="children"><p>app.component.ts</p><p>app.module.ts</p><p>app.routing.ts</p><p>crisis-list.component.ts</p><p>hero-list.component.ts</p><p>main.ts</p></div></div><p>node_modules ...</p><p>typings ...</p><p>index.html</p><p>package.json</p><p>styles.css</p><p>tsconfig.json</p><p>typings.json</p></div></div><p>Here are the files discussed in this milestone</p><span>
</span><code-tabs><code language="ts" name="app.component.ts" format="linenums">import { Component } from &apos;@angular/core&apos;;

@Component({
  selector: &apos;my-app&apos;,
  template: `
    &lt;h1&gt;Component Router&lt;/h1&gt;
    &lt;nav&gt;
      &lt;a routerLink=&quot;/crisis-center&quot; routerLinkActive=&quot;active&quot;&gt;Crisis Center&lt;/a&gt;
      &lt;a routerLink=&quot;/heroes&quot; routerLinkActive=&quot;active&quot;&gt;Heroes&lt;/a&gt;
    &lt;/nav&gt;
    &lt;router-outlet&gt;&lt;/router-outlet&gt;
  `
})
export class AppComponent { }
</code><code language="ts" name="app.module.ts" format="linenums">import { NgModule }       from &apos;@angular/core&apos;;
import { BrowserModule }  from &apos;@angular/platform-browser&apos;;
import { FormsModule }    from &apos;@angular/forms&apos;;


import { AppComponent }       from &apos;./app.component&apos;;
import { routing,
         appRoutingProviders } from &apos;./app.routing&apos;;

import { HeroListComponent }    from &apos;./hero-list.component&apos;;
import { CrisisListComponent }  from &apos;./crisis-list.component&apos;;

@NgModule({
  imports: [
    BrowserModule,
    FormsModule,
    routing
  ],
  declarations: [
    AppComponent,
    HeroListComponent,
    CrisisListComponent
  ],
  providers: [
    appRoutingProviders
  ],
  bootstrap: [ AppComponent ]
})
export class AppModule {
}
</code><code language="ts" name="app.routing.ts" format="linenums">import { ModuleWithProviders } from &apos;@angular/core&apos;;
import { Routes, RouterModule } from &apos;@angular/router&apos;;

import { CrisisListComponent }  from &apos;./crisis-list.component&apos;;
import { HeroListComponent }    from &apos;./hero-list.component&apos;;

const appRoutes: Routes = [
  { path: &apos;crisis-center&apos;, component: CrisisListComponent },
  { path: &apos;heroes&apos;, component: HeroListComponent }
];

export const appRoutingProviders: any[] = [

];

export const routing: ModuleWithProviders = RouterModule.forRoot(appRoutes);
</code><code language="ts" name="main.ts" format="linenums">import { platformBrowserDynamic } from &apos;@angular/platform-browser-dynamic&apos;;

import { AppModule } from &apos;./app.module&apos;;

platformBrowserDynamic().bootstrapModule(AppModule);
</code><code language="ts" name="hero-list.component.ts" format="linenums">import { Component } from &apos;@angular/core&apos;;

@Component({
  template: `
    &lt;h2&gt;HEROES&lt;/h2&gt;
    &lt;p&gt;Get your heroes here&lt;/p&gt;`
})
export class HeroListComponent { }
</code><code language="ts" name="crisis-list.component.ts" format="linenums">import { Component } from &apos;@angular/core&apos;;

@Component({
  template: `
    &lt;h2&gt;CRISIS CENTER&lt;/h2&gt;
    &lt;p&gt;Get your crisis here&lt;/p&gt;`
})
export class CrisisListComponent { }
</code><code language="html" name="index.html" format="linenums">&lt;html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;!-- Set the base href --&gt;
    &lt;base href=&quot;/&quot;&gt;
    &lt;title&gt;Router Sample&lt;/title&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;styles.css&quot;&gt;

    &lt;!-- Polyfill(s) for older browsers --&gt;
    &lt;script src=&quot;node_modules/core-js/client/shim.min.js&quot;&gt;&lt;/script&gt;

    &lt;script src=&quot;node_modules/zone.js/dist/zone.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;node_modules/reflect-metadata/Reflect.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;node_modules/systemjs/dist/system.src.js&quot;&gt;&lt;/script&gt;

    &lt;script src=&quot;systemjs.config.js&quot;&gt;&lt;/script&gt;
    &lt;script&gt;
      System.import(&apos;app&apos;)
            .catch(function(err){ console.error(err); });
    &lt;/script&gt;
  &lt;/head&gt;

  &lt;body&gt;
    &lt;my-app&gt;loading...&lt;/my-app&gt;
  &lt;/body&gt;

&lt;/html&gt;
</code></code-tabs><h2 id="milestone-2-the-heroes-feature">Milestone #2: The Heroes Feature</h2><span>
</span><p>We&apos;ve seen how to navigate using the <code>RouterLink</code> directive.</p><span>
</span><p>Now we&apos;ll learn some new tricks such as how to</p><span>
</span><ul>
<li>organize our app and routes into <em>feature areas</em> using modules</li>
<li>navigate imperatively from one component to another</li>
<li>pass information in route parameters</li>
</ul><span>
</span><p>To demonstrate, we&apos;ll build out the <em>Heroes</em> feature.</p><span>
</span><h3 id="the-heroes-feature-area-">The Heroes &quot;feature area&quot;</h3><span>
</span><p>A typical application has multiple <em>feature areas</em>, each an island of functionality
with its own workflow(s), dedicated to a particular business purpose.</p><span>
</span><p>We could continue to add files to the <code>app/</code> folder.
That&apos;s unrealistic and ultimately not maintainable.
We think it&apos;s better to put each feature area in its own folder.</p><span>
</span><p>Our first step is to <strong>create a separate <code>app/heroes/</code> folder</strong>
and add <em>Hero Management</em> feature files there.</p><span>
</span><p>We won&apos;t be creative about it. Our example is pretty much a
copy of the code and capabilities in the &quot;<a href="https://angular.io/docs/ts/latest/tutorial/index.html">Tutorial: Tour of Heroes</a>&quot;.</p><span>
</span><p>Here&apos;s how the user will experience this version of the app</p><span>
</span><figure class="image-display"><img src="https://angular.io/resources/images/devguide/router/router-2-anim.gif" alt="App in action"></figure><h3 id="add-heroes-functionality">Add Heroes functionality</h3><span>
</span><p>We want to break our app out into different <em>submodules</em> that we then import
into our main module so it can make use of them. First, we&apos;ll create a <code>heroes.module.ts</code>
in our heroes folder.</p><span>
</span><p>We delete the placeholder <code>hero-list.component.ts</code> that&apos;s in
the <code>app/</code> folder.</p><span>
</span><p>We create a new <code>hero-list.component.ts</code> in the <code>app/heroes/</code>
folder and copy over the contents of the final <code>heroes.component.ts</code> from the tutorial.
We copy the <code>hero-detail.component.ts</code> and the <code>hero.service.ts</code> files
into the <code>heroes/</code> folder.</p><span>
</span><p>We provide the <code>HeroService</code> in the <code>providers</code> array of our <code>Heroes</code> module
so its available to all components within our module.</p><span>
</span><p>Our <code>Heroes</code> module is ready for routing.</p><span>
</span><p>app/heroes/heroes.module.ts (excerpt)</p><code language="ts" format="">import { NgModule }       from &apos;@angular/core&apos;;
import { CommonModule }   from &apos;@angular/common&apos;;
import { FormsModule }    from &apos;@angular/forms&apos;;

import { HeroListComponent }    from &apos;./hero-list.component&apos;;
import { HeroDetailComponent }  from &apos;./hero-detail.component&apos;;

import { HeroService } from &apos;./hero.service&apos;;

@NgModule({
  imports: [
    CommonModule,
    FormsModule
  ],
  declarations: [
    HeroListComponent,
    HeroDetailComponent
  ],
  providers: [
    HeroService
  ]
})
export class HeroesModule {}
</code><p>When we&apos;re done organizing, we have four <em>Hero Management</em> files:</p><span>
</span><div class="filetree"><p>app/heroes</p><div class="children"><p>hero-detail.component.ts</p><p>hero-list.component.ts</p><p>hero.service.ts</p><p>heroes.module.ts</p></div></div><p>Now it&apos;s time for some surgery to bring these files and the rest of the app
into alignment with our application router.</p><span>
</span><h3 id="-hero-feature-routing-requirements"><em>Hero</em> feature routing requirements</h3><span>
</span><p>The new Heroes feature has two interacting components, the list and the detail.
The list view is self-sufficient; we navigate to it, it gets a list of heroes and displays them.
It doesn&apos;t need any outside information.</p><span>
</span><p>The detail view is different. It displays a particular hero. It can&apos;t know which hero on its own.
That information must come from outside.</p><span>
</span><p>In our example, when the user selects a hero from the list, we navigate to the detail view to show that hero.
We&apos;ll tell the detail view which hero to display by including the selected hero&apos;s id in the route URL.</p><span>
</span><h3 id="-hero-feature-route-configuration"><em>Hero</em> feature route configuration</h3><span>
</span><p>We recommend giving each feature area its own route configuration file.</p><span>
</span><p>Create a new <code>heroes.routing.ts</code> in the <code>heroes</code> folder like this:</p><span>
</span><p>app/heroes/heroes.routing.ts (excerpt)</p><code language="ts" format="">import { ModuleWithProviders }  from &apos;@angular/core&apos;;
import { Routes, RouterModule } from &apos;@angular/router&apos;;

import { HeroListComponent }    from &apos;./hero-list.component&apos;;
import { HeroDetailComponent }  from &apos;./hero-detail.component&apos;;

const heroesRoutes: Routes = [
  { path: &apos;heroes&apos;,  component: HeroListComponent },
  { path: &apos;hero/:id&apos;, component: HeroDetailComponent }
];

export const heroesRouting: ModuleWithProviders = RouterModule.forChild(heroesRoutes);
</code><p>We use the same techniques we learned for <code>app.routing.ts</code>.</p><span>
</span><p>We import the two components from their new locations in the <code>app/heroes/</code> folder, define the two hero routes.
and add export our <code>heroesRouting</code> that returns configured <code>RouterModule</code> for our submodule.</p><span>
</span><p>Now that we have routes for our <code>Heroes</code> module, we&apos;ll need to register them with the <em>Router</em>.
We&apos;ll import the <em>RouterModule</em> like we did in the root NgModule, but there is a slight difference here.
In our root routing setup, we used the static <strong>forRoot</strong> method to register our routes and application level
service providers. Since we are in a submodule, we&apos;ll use <strong>Router.forChild</strong> method to only register additional routes. We do this
because the <em>Router</em> will combine all the provided routes from the submodule together and build our configuration. This allows us to continue defining
our feature-specific routes without modifying our main route configuration.</p><span>
</span><p>We import our <code>heroesRouting</code> token from <code>heroes.routing.ts</code> into our <code>Heroes</code> module and register the routing.</p><span>
</span><p>app/heroes/heroes.module.ts (heroes routing)</p><code language="ts" format="">import { heroesRouting } from &apos;./heroes.routing&apos;;

@NgModule({
  imports: [
    CommonModule,
    FormsModule,
    heroesRouting
  ],
  declarations: [
    HeroListComponent,
    HeroDetailComponent
  ],
  providers: [
    HeroService
  ]
})
</code><h3 id="route-definition-with-a-parameter">Route definition with a parameter</h3><span>
</span><p>The route to <code>HeroDetailComponent</code> has a twist.</p><span>
</span><code language="ts" format="">{ path: &apos;hero/:id&apos;, component: HeroDetailComponent }
</code><p>Notice the <code>:id</code> token in the path. That creates a slot in the path for a <strong>Route Parameter</strong>.
In this case, we&apos;re expecting the router to insert the <code>id</code> of a hero into that slot.</p><span>
</span><p>If we tell the router to navigate to the detail component and display &quot;Magneta&quot;, we expect hero <code>id</code> (15) to appear in the
browser URL like this:</p><span>
</span><code format="." language="bash">localhost:3000/hero/15</code><p>If a user enters that URL into the browser address bar, the router should recognize the
pattern and go to the same &quot;Magneta&quot; detail view.</p><span>
</span><div class="l-sub-section"><h4 id="route-parameter-required-or-optional-">Route parameter: Required or optional?</h4><span>
</span><p>Embedding the route parameter token, <code>:id</code>, in the route definition path is a good choice for our scenario
because the <code>id</code> is <em>required</em> by the <code>HeroDetailComponent</code> and because
the value <code>15</code> in the path clearly distinguishes the route to &quot;Magneta&quot; from
a route for some other hero.</p><span>
</span><p>An <a href="https://angular.io/docs/ts/latest/guide/router.html#optional-route-parameter">optional-route-parameter</a> might be a better choice if we were passing an <em>optional</em> value to <code>HeroDetailComponent</code>.</p><span>
</span></div><span>
</span><p><em>We won&apos;t navigate to the detail component by clicking a link</em>
so we won&apos;t be adding a new <code>RouterLink</code> anchor tag to the shell.</p><span>
</span><p>Instead, when the user <em>clicks</em> a hero in the list, we&apos;ll <em>command</em> the router
to navigate to the hero detail view for the selected hero.</p><span>
</span><p>We&apos;ll adjust the <code>HeroListComponent</code> to implement these tasks, beginning with its constructor
which acquires the router service and the <code>HeroService</code> by dependency injection:</p><span>
</span><p>app/heroes/hero-list.component.ts (constructor)</p><code language="ts" format="">constructor(
  private router: Router,
  private service: HeroService) { }
</code><p>We make a few changes to the template:</p><span>
</span><code language="ts" format="">template: `
  &lt;h2&gt;HEROES&lt;/h2&gt;
  &lt;ul class=&quot;items&quot;&gt;
    &lt;li *ngFor=&quot;let hero of heroes&quot;
      (click)=&quot;onSelect(hero)&quot;&gt;
      &lt;span class=&quot;badge&quot;&gt;{{hero.id}}&lt;/span&gt; {{hero.name}}
    &lt;/li&gt;
  &lt;/ul&gt;
`
</code><p>The template defines an <code>*ngFor</code> repeater such as <a href="https://angular.io/docs/ts/latest/guide/displaying-data.html#ngFor">we&apos;ve seen before</a>.
There&apos;s a <code>(click)</code> <a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#event-binding">EventBinding</a> to the component&apos;s <code>onSelect</code> method
which we implement as follows:</p><span>
</span><code language="ts" format="">  onSelect(hero: Hero) {
    this.router.navigate([&apos;/hero&apos;, hero.id]);
  }
</code><p>It calls the router&apos;s <strong><code>navigate</code></strong> method with a <strong>Link Parameters Array</strong>. We can use this same syntax
with a <code>RouterLink</code> if we want to use it in HTML rather than code.</p><span>
</span><h3 id="route-parameters">Setting the route parameters in the list view</h3><p>We&apos;re navigating to the <code>HeroDetailComponent</code> where we expect to see the details of the selected hero.
We&apos;ll need <em>two</em> pieces of information: the destination and the hero&apos;s <code>id</code>.</p><span>
</span><p>Accordingly, the <em>link parameters array</em> has <em>two</em> items:  the <strong>path</strong> of the destination route and a <strong>route parameter</strong> that specifies the
<code>id</code> of the selected hero.</p><span>
</span><code language="ts" format="">[&apos;/hero&apos;, hero.id] // { 15 }
</code><p>The router composes the appropriate two-part destination URL from this array:</p><span>
</span><code language="bash">localhost:3000/hero/15
</code><a id="get-route-parameter"> </a><h3 id="getting-the-route-parameter-in-the-details-view">Getting the route parameter in the details view</h3><span>
</span><p>How does the target <code>HeroDetailComponent</code> learn about that <code>id</code>?
Certainly not by analyzing the URL!  That&apos;s the router&apos;s job.</p><span>
</span><p>The router extracts the route parameter (<code>id:15</code>) from the URL and supplies it to
the <code>HeroDetailComponent</code> via the <strong>ActivatedRoute</strong> service.</p><span>
</span><a id="hero-detail-ctor"></a><p>As usual, we write a constructor that asks Angular to inject services
that the component requires and reference them as private variables.</p><span>
</span><p>app/heroes/hero-detail.component.ts (constructor)</p><code language="ts" format="">constructor(
  private route: ActivatedRoute,
  private router: Router,
  private service: HeroService) {}
</code><p>Later, in the <code>ngOnInit</code> method,
we use the <code>ActivatedRoute</code> service to retrieve the parameters for our route.
Since our parameters are provided as an <code>Observable</code>, we <em>subscribe</em> to them for the <code>id</code> parameter by name and
tell the <code>HeroService</code> to fetch the hero with that <code>id</code>. We&apos;ll keep a reference to this <code>Subscription</code> so we can
tidy things up later.</p><span>
</span><code language="ts" format="">private sub: Subscription;

ngOnInit() {
  this.sub = this.route.params.subscribe(params =&gt; {
     let id = +params[&apos;id&apos;]; // (+) converts string &apos;id&apos; to a number
     this.service.getHero(id).then(hero =&gt; this.hero = hero);
   });
}
</code><div class="l-sub-section"><p>Angular calls the <code>ngOnInit</code> method shortly after creating an instance of the <code>HeroDetailComponent</code>.</p><span>
</span><p>We put the data access logic in the <code>ngOnInit</code> method rather than inside the constructor
to improve the component&apos;s testability.
We explore this point in greater detail in the <a href="https://angular.io/docs/ts/latest/guide/router.html#onInit">OnInit appendix</a> below.</p><span>
</span></div><p>Eventually, we&apos;ll navigate somewhere else.
The router will remove this component from the DOM and destroy it.
We need to clean up after ourselves before that happens.
Specifically, we <strong>must unsubscribe</strong> before Angular destroys the component.
<em>Failure to do so could create a memory leak.</em></p><span>
</span><p>We unsubscribe from our <code>Observable</code> in the <code>ngOnDestroy</code> method.</p><span>
</span><code language="ts" format="">ngOnDestroy() {
  this.sub.unsubscribe();
}
</code><div class="l-sub-section"><p>Learn about the <code>ngOnInit</code> and <code>ngOnDestroy</code> methods in the
<a href="https://angular.io/docs/ts/latest/guide/lifecycle-hooks.html">Lifecycle Hooks</a> chapter.</p><span>
</span></div><h4 id="reuse">Observable <i>params</i> and component re-use</h4><p>In this example, we subscribe to the route params <code>Observable</code>.
That implies that the route params can change during the lifetime of this component.</p><span>
</span><p>They might. By default, the router reuses a component instance when it re-navigates to the same component type
without visiting a different component first. The parameters can change between each re-use.</p><span>
</span><p>Suppose a parent component navigation bar had &quot;forward&quot; and &quot;back&quot; buttons
that scrolled through the list of heroes.
Each click navigated imperatively to the <code>HeroDetailComponent</code> with the next or previous <code>id</code>.</p><span>
</span><p>We don&apos;t want the router to remove the current <code>HeroDetailComponent</code> instance from the
DOM only to re-create it for the next <code>id</code>.
That could be visibly jarring.
Better to simply re-use the same component instance and update the parameter.</p><span>
</span><p>But <code>ngOnInit</code> is only called once per instantiation.
We need a way to detect when the route parameters change from <em>within the same instance</em>.
The observable <code>params</code> property handles that beautifully.</p><span>
</span><h4 id="snapshot"><i>Snapshot</i>: the no-observable alternative</h4><p>This application won&apos;t reuse the <code>HeroDetailComponent</code>.
We always return to the hero list to select another hero to view.
There&apos;s no way to navigate from hero detail to hero detail
without visiting the list component in between.
That means we get a new <code>HeroDetailComponent</code> instance every time.</p><span>
</span><p>Suppose we know for certain that <code>HeroDetailComponent</code> will <em>never, never, ever</em>
be re-used. We&apos;ll always re-create the component each time we navigate to it.</p><span>
</span><p>The router offers a <em>Snapshot</em> alternative that gives us the initial value of the route parameters.
We don&apos;t need to subscribe. We don&apos;t have to unsubscribe in <code>ngOnDestroy</code>.
It&apos;s much simpler to write and read:</p><span>
</span><code language="ts" format="">ngOnInit() {
  // (+) converts string &apos;id&apos; to a number
  let id = +this.route.snapshot.params[&apos;id&apos;];
  this.service.getHero(id).then(hero =&gt; this.hero = hero);
}
</code><div class="l-sub-section"><p><strong>Remember:</strong> we only get the <em>initial</em> value of the parameters with this technique.
Stick with the observable <code>params</code> approach if there&apos;s even a chance that we might navigate
to this component multiple times in a row.
We are leaving the observable <code>params</code> strategy in place just in case.</p><span>
</span></div><span>
</span><p>The <code>HeroDetailComponent</code> has a &quot;Back&quot; button wired to its <code>gotoHeroes</code> method that navigates imperatively
back to the <code>HeroListComponent</code>.</p><span>
</span><p>The router <code>navigate</code> method takes the same one-item <em>link parameters array</em>
that we can bind to a <code>[routerLink]</code> directive.
It holds the <strong>path to the <code>HeroListComponent</code></strong>:</p><span>
</span><code language="ts" format="">gotoHeroes() { this.router.navigate([&apos;/heroes&apos;]); }
</code><h3 id="merge-hero-routes">Import hero module into root NgModule</h3><p>Our heroes feature is ready, but application doesn&apos;t know about our heroes module yet.
We&apos;ll need to import it into the root NgModule we defined in <code>app.module.ts</code>.</p><span>
</span><p>Update <code>app.module.ts</code> as follows:</p><span>
</span><p>app/app.module.ts (heroes module import)</p><code language="ts" format="">import { HeroesModule }         from &apos;./heroes/heroes.module&apos;;

import { CrisisListComponent }  from &apos;./crisis-list.component&apos;;

@NgModule({
  imports: [
    BrowserModule,
    FormsModule,
    routing,
    HeroesModule
  ],
  declarations: [
    AppComponent,
    CrisisListComponent
  ],
  providers: [
    appRoutingProviders
  ],
  bootstrap: [ AppComponent ]
})
</code><p>We imported the <code>HeroesModule</code> and added it to our root NgModule <code>imports</code>.</p><span>
</span><p>We removed the <code>HeroListComponent</code> from the root NgModule&apos;s <code>declarations</code> because its being provided by the <code>HeroesModule</code>
now. This is important because their can be only <strong>one</strong> owner for a declared component. In our case, the <code>Heroes</code> module is
the owner of the <code>Heroes</code> components and is making them available to the root NgModule.</p><span>
</span><p>As a result, the <code>app.module.ts</code> no longer has specific knowledge of the hero feature, its components, or its route details.
We can evolve the hero feature with more components and different routes.
That&apos;s a key benefit of creating a separate module for each feature area.</p><span>
</span><p>Since our <code>Heroes</code> routes are defined within our submodule, we can also remove our initial <code>heroes</code> route from the <code>app.routing.ts</code>.</p><span>
</span><p>app/app.routing.ts (v2)</p><code language="ts" format="">import { ModuleWithProviders }  from &apos;@angular/core&apos;;
import { Routes, RouterModule } from &apos;@angular/router&apos;;

import { CrisisListComponent } from &apos;./crisis-center/crisis-list.component&apos;;

const appRoutes: Routes = [
  { path: &apos;crisis-center&apos;, component: CrisisListComponent }
];

export const appRoutingProviders: any[] = [

];

export const routing: ModuleWithProviders = RouterModule.forRoot(appRoutes);
</code><h3 id="heroes-app-wrap-up">Heroes App Wrap-up</h3><span>
</span><p>We&apos;ve reached the second milestone in our router education.</p><span>
</span><p>We&apos;ve learned how to</p><span>
</span><ul>
<li>organize our app into <em>feature areas</em></li>
<li>navigate imperatively from one component to another</li>
<li>pass information along in route parameters and subscribe to them in our component</li>
<li>import our feature area NgModule into our root NgModule</li>
</ul><span>
</span><p>After these changes, the folder structure looks like this:</p><span>
</span><div class="filetree"><p>router-sample</p><div class="children"><p>app</p><div class="children"><p>heroes</p><div class="children"><p>hero-detail.component.ts</p><p>hero-list.component.ts</p><p>hero.service.ts</p><p>heroes.module.ts</p><p>heroes.routing.ts</p></div><p>app.component.ts</p><p>app.module.ts</p><p>app.routing.ts</p><p>crisis-list.component.ts</p><p>main.ts</p></div><p>node_modules ...</p><p>typings ...</p><p>index.html</p><p>package.json</p><p>styles.css</p><p>tsconfig.json</p><p>typings.json</p></div></div><span>
</span><h3 id="the-heroes-app-code">The Heroes App code</h3><span>
</span><p>Here are the relevant files for this version of the sample application.</p><span>
</span><code-tabs><code language="ts" name="app.component.ts" format="linenums">import { Component } from &apos;@angular/core&apos;;

@Component({
  selector: &apos;my-app&apos;,
  template: `
    &lt;h1&gt;Component Router&lt;/h1&gt;
    &lt;nav&gt;
      &lt;a routerLink=&quot;/crisis-center&quot; routerLinkActive=&quot;active&quot;&gt;Crisis Center&lt;/a&gt;
      &lt;a routerLink=&quot;/heroes&quot; routerLinkActive=&quot;active&quot;&gt;Heroes&lt;/a&gt;
    &lt;/nav&gt;
    &lt;router-outlet&gt;&lt;/router-outlet&gt;
  `
})
export class AppComponent { }
</code><code language="ts" name="app.module.ts" format="linenums">import { NgModule }       from &apos;@angular/core&apos;;
import { BrowserModule }  from &apos;@angular/platform-browser&apos;;
import { FormsModule }    from &apos;@angular/forms&apos;;

import { AppComponent }       from &apos;./app.component&apos;;
import { routing,
         appRoutingProviders } from &apos;./app.routing&apos;;

import { HeroesModule }         from &apos;./heroes/heroes.module&apos;;

import { CrisisListComponent }  from &apos;./crisis-list.component&apos;;

@NgModule({
  imports: [
    BrowserModule,
    FormsModule,
    routing,
    HeroesModule
  ],
  declarations: [
    AppComponent,
    CrisisListComponent
  ],
  providers: [
    appRoutingProviders
  ],
  bootstrap: [ AppComponent ]
})
export class AppModule {
}
</code><code language="ts" name="app.routing.ts" format="linenums">import { ModuleWithProviders }  from &apos;@angular/core&apos;;
import { Routes, RouterModule } from &apos;@angular/router&apos;;

import { CrisisListComponent } from &apos;./crisis-center/crisis-list.component&apos;;

const appRoutes: Routes = [
  { path: &apos;crisis-center&apos;, component: CrisisListComponent }
];

export const appRoutingProviders: any[] = [

];

export const routing: ModuleWithProviders = RouterModule.forRoot(appRoutes);
</code><code language="ts" name="hero-list.component.ts" format="linenums">// TODO SOMEDAY: Feature Componetized like HeroCenter
import { Component, OnInit }   from &apos;@angular/core&apos;;
import { Router }              from &apos;@angular/router&apos;;

import { Hero, HeroService }   from &apos;./hero.service&apos;;

@Component({
  template: `
    &lt;h2&gt;HEROES&lt;/h2&gt;
    &lt;ul class=&quot;items&quot;&gt;
      &lt;li *ngFor=&quot;let hero of heroes&quot;
        (click)=&quot;onSelect(hero)&quot;&gt;
        &lt;span class=&quot;badge&quot;&gt;{{hero.id}}&lt;/span&gt; {{hero.name}}
      &lt;/li&gt;
    &lt;/ul&gt;
  `
})
export class HeroListComponent implements OnInit {
  heroes: Hero[];

  constructor(
    private router: Router,
    private service: HeroService) { }

  ngOnInit() {
    this.service.getHeroes().then(heroes =&gt; this.heroes = heroes);
  }

  onSelect(hero: Hero) {
    this.router.navigate([&apos;/hero&apos;, hero.id]);
  }
}
</code><code language="ts" name="hero-detail.component.ts" format="linenums">import { Component, OnInit, OnDestroy } from &apos;@angular/core&apos;;
import { Router, ActivatedRoute }       from &apos;@angular/router&apos;;

import { Hero, HeroService } from &apos;./hero.service&apos;;
import { Subscription } from &apos;rxjs/Subscription&apos;;

@Component({
  template: `
  &lt;h2&gt;HEROES&lt;/h2&gt;
  &lt;div *ngIf=&quot;hero&quot;&gt;
    &lt;h3&gt;&quot;{{hero.name}}&quot;&lt;/h3&gt;
    &lt;div&gt;
      &lt;label&gt;Id: &lt;/label&gt;{{hero.id}}&lt;/div&gt;
    &lt;div&gt;
      &lt;label&gt;Name: &lt;/label&gt;
      &lt;input [(ngModel)]=&quot;hero.name&quot; placeholder=&quot;name&quot;/&gt;
    &lt;/div&gt;
    &lt;p&gt;
      &lt;button (click)=&quot;gotoHeroes()&quot;&gt;Back&lt;/button&gt;
    &lt;/p&gt;
  &lt;/div&gt;
  `
})
export class HeroDetailComponent implements OnInit, OnDestroy  {
  hero: Hero;
  private sub: Subscription;

  constructor(
    private route: ActivatedRoute,
    private router: Router,
    private service: HeroService) {}

  ngOnInit() {
    this.sub = this.route.params.subscribe(params =&gt; {
       let id = +params[&apos;id&apos;]; // (+) converts string &apos;id&apos; to a number
       this.service.getHero(id).then(hero =&gt; this.hero = hero);
     });
  }

  ngOnDestroy() {
    this.sub.unsubscribe();
  }

  gotoHeroes() { this.router.navigate([&apos;/heroes&apos;]); }
}
</code><code language="ts" name="hero.service.ts" format="linenums">import { Injectable } from &apos;@angular/core&apos;;

export class Hero {
  constructor(public id: number, public name: string) { }
}

let HEROES = [
  new Hero(11, &apos;Mr. Nice&apos;),
  new Hero(12, &apos;Narco&apos;),
  new Hero(13, &apos;Bombasto&apos;),
  new Hero(14, &apos;Celeritas&apos;),
  new Hero(15, &apos;Magneta&apos;),
  new Hero(16, &apos;RubberMan&apos;)
];

let heroesPromise = Promise.resolve(HEROES);

@Injectable()
export class HeroService {
  getHeroes() { return heroesPromise; }

  getHero(id: number | string) {
    return heroesPromise
      .then(heroes =&gt; heroes.find(hero =&gt; hero.id === +id));
  }
}
</code><code language="ts" name="heroes.module.ts" format="linenums">import { NgModule }       from &apos;@angular/core&apos;;
import { CommonModule }   from &apos;@angular/common&apos;;
import { FormsModule }    from &apos;@angular/forms&apos;;

import { HeroListComponent }    from &apos;./hero-list.component&apos;;
import { HeroDetailComponent }  from &apos;./hero-detail.component&apos;;

import { HeroService } from &apos;./hero.service&apos;;

import { heroesRouting } from &apos;./heroes.routing&apos;;

@NgModule({
  imports: [
    CommonModule,
    FormsModule,
    heroesRouting
  ],
  declarations: [
    HeroListComponent,
    HeroDetailComponent
  ],
  providers: [
    HeroService
  ]
})
export class HeroesModule {}
</code><code language="ts" name="heroes.routing.ts" format="linenums">import { ModuleWithProviders }  from &apos;@angular/core&apos;;
import { Routes, RouterModule } from &apos;@angular/router&apos;;

import { HeroListComponent }    from &apos;./hero-list.component&apos;;
import { HeroDetailComponent }  from &apos;./hero-detail.component&apos;;

const heroesRoutes: Routes = [
  { path: &apos;heroes&apos;,  component: HeroListComponent },
  { path: &apos;hero/:id&apos;, component: HeroDetailComponent }
];

export const heroesRouting: ModuleWithProviders = RouterModule.forChild(heroesRoutes);
</code></code-tabs><h2 id="milestone-3-the-crisis-center">Milestone #3: The Crisis Center</h2><span>
</span><p>The <em>Crisis Center</em> is a fake view at the moment. Time to make it useful.</p><span>
</span><p>The new <em>Crisis Center</em> begins as a virtual copy of the <em>Heroes</em> module.
We create a new <code>app/crisis-center</code> folder, copy the Hero files,
and change every mention of &quot;hero&quot; to &quot;crisis&quot;.</p><span>
</span><p>A <code>Crisis</code> has an <code>id</code> and <code>name</code>, just like a <code>Hero</code>
The new <code>CrisisListComponent</code> displays lists of crises.
When the user selects a crisis, the app navigates to the <code>CrisisDetailComponent</code>
for display and editing of the crisis name.</p><span>
</span><p>Voil&#xE0;, another feature module!</p><span>
</span><p>There&apos;s no point to this exercise unless we can learn something.
We do have new ideas and techniques in mind:</p><span>
</span><ul>
<li><p>We&apos;d like our route URLs to branch in to child route trees that reflect the component trees in our feature areas.</p>
</li>
<li><p>The application should navigate to the <em>Crisis Center</em> by default.</p>
</li>
<li><p>The router should prevent navigation away from the detail view while there are pending changes.</p>
</li>
<li><p>The user should be able to cancel unwanted changes.</p>
</li>
<li><p>The router should block access to certain features until the user logs-in.</p>
</li>
<li><p>Our <code>CrisisService</code> is only needed within the <em>Crisis Center</em> module.
We should limit access to it to that module.</p>
</li>
<li><p>Changes to a submodule such as <em>Crisis Center</em> shouldn&apos;t provoke changes to the root <code>NgModule</code> or
any other feature&apos;s component.
We need to <a href="https://blog.8thlight.com/uncle-bob/2014/05/08/SingleReponsibilityPrinciple.html"><em>separate our concerns</em></a>.</p>
</li>
</ul><span>
</span><p>We&apos;ll address all of these issues in the <em>Crisis Center</em>
starting with the introduction of <strong>child routes</strong></p><span>
</span><div class="l-sub-section"><p>We&apos;ll leave <em>Heroes</em> in its less-than-perfect state to
serve as a contrast with what we believe to be a superior <em>Crisis Center</em> design.</p><span>
</span></div><h3 id="a-crisis-center-with-child-routes">A Crisis Center with child routes</h3><span>
</span><p>We&apos;ll organize the <em>Crisis Center</em> to conform to the following recommended pattern for Angular applications.</p><span>
</span><ul>
<li>each feature area in its own folder within a defined module</li>
<li>each area with its own area root component</li>
<li>each area root component with its own router-outlet and child routes</li>
<li>area routes rarely (if ever) cross</li>
</ul><span>
</span><p>If we had many feature areas, their component trees might look like this:</p><span>
</span><figure class="image-display"><img src="https://angular.io/resources/images/devguide/router/component-tree.png" alt="Component Tree"></figure><a id="child-routing-component"></a><h3 id="child-routing-component">Child Routing Component</h3><span>
</span><p>Add the following <code>crisis-center.component.ts</code> to the <code>crisis-center</code> folder:</p><span>
</span><p>app/crisis-center/crisis-center.component.ts (minus imports)</p><code language="ts" format="">@Component({
  template:  `
    &lt;h2&gt;CRISIS CENTER&lt;/h2&gt;
    &lt;router-outlet&gt;&lt;/router-outlet&gt;
  `
})
export class CrisisCenterComponent { }
</code><p>The <code>CrisisCenterComponent</code> is much like the <code>AppComponent</code> shell.</p><span>
</span><ul>
<li><p>It is the root of the <em>Crisis Center</em> area
just as <code>AppComponent</code> is the root of the entire application.</p>
</li>
<li><p>It is a shell for the crisis management feature area
just as the <code>AppComponent</code> is a shell to manage the high-level workflow.</p>
</li>
<li><p>It is dead simple &#x2014; simpler even than the <code>AppComponent</code> template.
It has no content, no links, just a <code>&lt;router-outlet&gt;</code> for the <em>Crisis Center</em> child views.</p>
</li>
</ul><span>
</span><p>Unlike <code>AppComponent</code> (and most other components), it <strong>lacks a selector</strong>.
It doesn&apos;t need one. We don&apos;t <em>embed</em> this component in a parent template.
We <em>navigate</em> to it from the outside, via the router.</p><span>
</span><div class="l-sub-section"><p>We <em>can</em> give it a selector. There&apos;s no harm in it.
Our point is that we don&apos;t <em>need</em> one because we only <em>navigate</em> to it.</p><span>
</span></div><h3 id="service-isolation">Service isolation</h3><span>
</span><p>The <code>CrisisService</code> is neither needed nor wanted outside the <em>Crisis Center</em> domain.
Instead of registering it with the root NgModule&apos;s providers &#x2014;
which makes it visible everywhere &#x2014;
we register the <code>CrisisService</code> in the <code>CrisisCenterModule</code> providers array.</p><span>
</span><code language="ts" format="">providers: [
  CrisisService
]
</code><p>This limits the scope of the <code>CrisisService</code> to the <em>Crisis Center</em> routes.
No module outside of the <em>Crisis Center</em> can access it.</p><span>
</span><p>There&apos;s a practical benefit to restricting its scope in this way.</p><span>
</span><p>First we can evolve the service independently of the rest of the application
without fear of breaking what should be unrelated modules.</p><span>
</span><p>Second, we can delay loading this service into memory until we need it.
We can remove it from the application launch bundle,
reducing the size of the initial payload and improving performance.
We can load it optionally, <a href="https://angular.io/docs/ts/latest/guide/router.html#asynchronous-routing">asynchronously</a> with the other <em>Crisis Center</em> components
if and when the user begins that workflow.</p><span>
</span><h3 id="child-route-configuration">Child Route Configuration</h3><span>
</span><p>The <code>CrisisCenterComponent</code> is a <em>Routing Component</em> like the <code>AppComponent</code>.
It has its own <code>RouterOutlet</code> and its own child routes.</p><span>
</span><p>We create a <code>crisis-center.routing.ts</code> file as we did the <code>heroes.routing.ts</code> file.
But this time we define <strong>child routes</strong> <em>within</em> the parent <code>crisis-center</code> route.</p><span>
</span><p>app/crisis-center/crisis-center.routing.ts (Routes)</p><code language="ts" format="">const crisisCenterRoutes: Routes = [
  {
    path: &apos;crisis-center&apos;,
    component: CrisisCenterComponent,
    children: [
      { path: &apos;:id&apos;,  component: CrisisDetailComponent },
      { path: &apos;&apos;,     component: CrisisListComponent }
    ]
  }
];

export const crisisCenterRouting: ModuleWithProviders = RouterModule.forChild(crisisCenterRoutes);
</code><p>Notice that the parent <code>crisis-center</code> route has a <code>children</code> property
with an array of two routes.
These two routes navigate to the two <em>Crisis Center</em> child components,
<code>CrisisListComponent</code> and <code>CrisisDetailComponent</code>.</p><span>
</span><p>There are some <em>important differences</em> in the treatment of these routes.</p><span>
</span><p>First, the router displays the components of these child routes in the <code>RouterOutlet</code>
of the <code>CrisisCenterComponent</code>, not in the <code>RouterOutlet</code> of the <code>AppComponent</code> shell.</p><span>
</span><p>Second, the child paths <em>extend</em> the path of their parent route.</p><span>
</span><p>Normally paths that begin with <code>/</code> refer to the root of the application.
Here they are appended to the path to the <code>CrisisCenterComponent</code>.</p><span>
</span><p>To write an URL that navigates to the <code>CrisisListComponent</code>, we&apos;d append its child route path,  <code>/</code>,
to <code>/crisis-center</code>.</p><span>
</span><p>To write an URL that navigates to the <code>CrisisDetailComponent</code>, we&apos;d append the child route path,  <code>/</code>,
followed by the crisis id, yielding something like:</p><span>
</span><code>localhost:3000/crisis-center/2
</code><p>Here&apos;s the complete <code>crisis-center.routing.ts</code> with its imports.</p><span>
</span><p>app/crisis-center/crisis-center.routing.ts (excerpt)</p><code language="ts" format="">import { ModuleWithProviders }   from &apos;@angular/core&apos;;
import { Routes, RouterModule }  from &apos;@angular/router&apos;;

import { CrisisDetailComponent } from &apos;./crisis-detail.component&apos;;
import { CrisisListComponent }   from &apos;./crisis-list.component&apos;;
import { CrisisCenterComponent } from &apos;./crisis-center.component&apos;;

const crisisCenterRoutes: Routes = [
  {
    path: &apos;crisis-center&apos;,
    component: CrisisCenterComponent,
    children: [
      { path: &apos;:id&apos;,  component: CrisisDetailComponent },
      { path: &apos;&apos;,     component: CrisisListComponent }
    ]
  }
];

export const crisisCenterRouting: ModuleWithProviders = RouterModule.forChild(crisisCenterRoutes);
</code><h3 id="import-crisis-module">Import crisis center module into the root NgModule routes</h3><p>As with the <code>Heroes</code> module, we must import the <code>Crisis Center</code> module into the root NgModule:</p><span>
</span><p>app/app.module.ts (Crisis Center Module)</p><code language="ts" format="">import { NgModule }       from &apos;@angular/core&apos;;
import { BrowserModule }  from &apos;@angular/platform-browser&apos;;
import { FormsModule }    from &apos;@angular/forms&apos;;

import { AppComponent }       from &apos;./app.component&apos;;
import { routing,
         appRoutingProviders } from &apos;./app.routing&apos;;

import { HeroesModule }           from &apos;./heroes/heroes.module&apos;;
import { CrisisCenterModule }     from &apos;./crisis-center/crisis-center.module&apos;;

import { DialogService }  from &apos;./dialog.service&apos;;

@NgModule({
  imports: [
    BrowserModule,
    FormsModule,
    routing,
    HeroesModule,
    CrisisCenterModule
  ],
  declarations: [
    AppComponent
  ],
  providers: [
    appRoutingProviders,
    DialogService
  ],
  bootstrap: [ AppComponent ]
})
export class AppModule {
}
</code><p>We also remove the initial crisis center route from our <code>app.routing.ts</code>. Our routes
are now being provided by our <code>HeroesModule</code> and our <code>CrisisCenter</code> submodules. We&apos;ll keep our <code>app.routing.ts</code> file
for general routes which we&apos;ll cover later in the chapter.</p><span>
</span><p>app/app.routing.ts (v3)</p><code language="ts" format="">import { ModuleWithProviders }   from &apos;@angular/core&apos;;
import { Routes, RouterModule }  from &apos;@angular/router&apos;;

const appRoutes: Routes = [

];

export const appRoutingProviders: any[] = [

];

export const routing: ModuleWithProviders = RouterModule.forRoot(appRoutes);
</code><a id="redirect"></a><h3 id="redirecting-routes">Redirecting routes</h3><span>
</span><p>When the application launches, the initial URL in the browser bar is something like:</p><span>
</span><code>localhost:3000
</code><p>That doesn&apos;t match any of our configured routes which means that our application won&apos;t display any component when it&apos;s launched.
The user must click one of the navigation links to trigger a navigation and display something.</p><span>
</span><p>We prefer that the application display the list of crises as it would if the user clicked the &quot;Crisis Center&quot; link or pasted <code>localhost:3000/crisis-center/</code> into the address bar.
This is our intended default route.</p><span>
</span><p>The preferred solution is to add a <code>redirect</code> route that transparently translates from the initial relative URL (<code>&apos;&apos;</code>)
to the desired default path (<code>/crisis-center</code>):</p><span>
</span><code language="ts" format="">{
  path: &apos;&apos;,
  redirectTo: &apos;/crisis-center&apos;,
  pathMatch: &apos;full&apos;
},
</code><p>A redirect route requires a <code>pathMatch</code> property to tell the router how to match a URL to the path of a route.
In this app, the router should select the route to the <code>CrisisListComponent</code> when the <em>entire URL</em> matches <code>&apos;&apos;</code>,
so we set the <code>pathMatch</code> value to <code>&apos;full&apos;</code>.</p><span>
</span><div class="l-sub-section"><p>Technically, <code>pathMatch = &apos;full&apos;</code> results in a route hit when the <em>remaining</em>, unmatched segments of the URL match <code>&apos;&apos;</code>.
In our example, the redirect is at the top level of the route configuration tree so the <em>remaining</em> URL and the <em>entire</em> URL
are the same thing.</p><span>
</span><p>The other possible <code>pathMatch</code> value is <code>&apos;prefix&apos;</code> which tells the router
to match the redirect route when the <em>remaining</em> URL <strong><em>begins</em></strong> with the redirect route&apos;s <em>prefix</em> path.</p><span>
</span><p>That&apos;s not what we want to do here. If the <code>pathMatch</code> value were <code>&apos;prefix&apos;</code>,
<em>every</em> URL would match <code>&apos;&apos;</code>.
We could never navigate to <code>/crisis-center/1</code> because the redirect route would match first and
send us to the <code>CrisisListComponent</code>.</p><span>
</span><p>We should redirect to the <code>CrisisListComponent</code> <em>only</em> when the <em>entire (remaining)</em> url is  <code>&apos;&apos;</code>.</p><span>
</span><p>Learn more in Victor Savkin&apos;s blog
<a href="http://victorsavkin.com/post/146722301646/angular-router-empty-paths-componentless-routes">post on redirects</a>.</p><span>
</span><p>We&apos;ll discuss redirects in more detail in a future update to this chapter.</p><span>
</span></div><p>The updated route definitions look like this:</p><span>
</span><p>app/crisis-center/crisis-center.routing.ts (routes v2)</p><code language="ts" format="">const crisisCenterRoutes: Routes = [
  {
    path: &apos;&apos;,
    redirectTo: &apos;/crisis-center&apos;,
    pathMatch: &apos;full&apos;
  },
  {
    path: &apos;crisis-center&apos;,
    component: CrisisCenterComponent,
    children: [
      { path: &apos;:id&apos;,  component: CrisisDetailComponent },
      { path: &apos;&apos;,     component: CrisisListComponent }
    ]
  }
];

export const crisisCenterRouting: ModuleWithProviders = RouterModule.forChild(crisisCenterRoutes);
</code><h2 id="guards">Route Guards</h2><p>At the moment, <em>any</em> user can navigate <em>anywhere</em> in the application <em>anytime</em>.</p><span>
</span><p>That&apos;s not always the right thing to do.</p><span>
</span><ul>
<li>Perhaps the user is not authorized to navigate to the target component.</li>
<li>Maybe the user must login (<em>authenticate</em>) first.</li>
<li>Maybe we should fetch some data before we display the target component.</li>
<li>We might want to save pending changes before leaving a component.</li>
<li>We might ask the user if it&apos;s OK to discard pending changes rather than save them.</li>
</ul><span>
</span><p>We can add <strong><em>guards</em></strong> to our route configuration to handle these scenarios.</p><span>
</span><p>A guard&apos;s return value controls the router&apos;s behavior:</p><span>
</span><ul>
<li>if it returns <code>true</code>, the navigation process continues</li>
<li>if it returns <code>false</code>, the navigation process stops and the user stays put</li>
</ul><span>
</span><div class="l-sub-section"><p>The guard can also tell the router to navigate elsewhere, effectively canceling the current navigation.</p><span>
</span></div><p>The guard <em>might</em> return its boolean answer synchronously.
But in many cases, the guard can&apos;t produce an answer synchronously.
The guard could ask the user a question, save changes to the server, or fetch fresh data.
These are all asynchronous operations.</p><span>
</span><p>Accordingly, a routing guard can return an <code>Observable&lt;boolean&gt;</code> or a <code>Promise&lt;boolean&gt;</code> and the
router will wait for the observable to resolve to <code>true</code> or <code>false</code>.</p><span>
</span><p>The router supports three kinds of guards:</p><span>
</span><ol>
<li><p><a href="https://angular.io/docs/ts/latest/api/router/index/CanActivate-interface.html">CanActivate</a> to mediate navigation <em>to</em> a route.</p>
</li>
<li><p><a href="https://angular.io/docs/ts/latest/api/router/index/CanDeactivate-interface.html">CanDeactivate</a> to mediate navigation <em>away</em> from the current route.</p>
</li>
<li><p><a href="https://angular.io/docs/ts/latest/api/router/index/Resolve-interface.html">Resolve</a> to perform route data retrieval before <em>before</em> route activation.</p>
</li>
</ol><span>
</span><div class="l-sub-section"><p>We&apos;ll examine other router guards in a future update to this chapter.</p><span>
</span></div><p>We can have multiple guards at every level of a routing hierarchy.
The router checks the <code>CanDeactivate</code> guards first, from deepest child route to the top.
Then it checks the <code>CanActivate</code> guards from the top down to the deepest child route.
If <em>any</em> guard returns false, pending guards that have not completed will be canceled,
and the entire navigation is canceled.</p><span>
</span><p>Let&apos;s look at some examples.</p><span>
</span><h2 id="router-lifecycle-hooks">Router Lifecycle Hooks</h2><span>
</span><p>TODO: Pausing activation</p><span>
</span><a id="can-activate-guard"></a><h3 id="-canactivate-requiring-authentication"><em>CanActivate</em>: requiring authentication</h3><span>
</span><p>Applications often restrict access to a feature area based on who the user is.
We could permit access only to authenticated users or to users with a specific role.
We might block or limit access until the user&apos;s account is activated.</p><span>
</span><p>The <code>CanActivate</code> guard is the tool to manage these navigation business rules.</p><span>
</span><h4 id="add-a-crisis-admin-feature">Add a crisis admin feature</h4><span>
</span><p>We intend to extend the Crisis Center with some new <em>administrative</em> features.
Those features aren&apos;t defined yet. So we add the following placeholder component.</p><span>
</span><p>app/crisis-center/crisis-admin.component.ts (excerpt)</p><code language="ts" format="">import { Component } from &apos;@angular/core&apos;;

@Component({
  template:  `
    &lt;h3&gt;CRISIS ADMINISTRATION&lt;/h3&gt;
    &lt;p&gt;Manage your crises here&lt;/p&gt;
  `
})
export class CrisisAdminComponent { }
</code><p>Next, we add a child route to the <code>crisis-center.routes</code> with the path, <code>/admin</code>.</p><span>
</span><p>app/crisis-center/crisis-center.routing.ts (admin route)</p><code language="ts" format="">{
  path: &apos;admin&apos;,
  component: CrisisAdminComponent
},
</code><p>And we add a link to the <code>AppComponent</code> shell that users can click to get to this feature.</p><span>
</span><p>app/app.component.ts (template)</p><code language="ts" format="">template: `
  &lt;h1 class=&quot;title&quot;&gt;Component Router&lt;/h1&gt;
  &lt;nav&gt;
    &lt;a routerLink=&quot;/crisis-center&quot; routerLinkActive=&quot;active&quot;
       [routerLinkActiveOptions]=&quot;{ exact: true }&quot;&gt;Crisis Center&lt;/a&gt;
    &lt;a routerLink=&quot;/heroes&quot; routerLinkActive=&quot;active&quot;&gt;Heroes&lt;/a&gt;
    &lt;a routerLink=&quot;/crisis-center/admin&quot; routerLinkActive=&quot;active&quot;&gt;Crisis Admin&lt;/a&gt;
  &lt;/nav&gt;
  &lt;router-outlet&gt;&lt;/router-outlet&gt;
`
</code><div class="l-sub-section"><p>Since our admin <code>RouterLink</code> is a child route of our <code>Crisis Center</code>, we only want the <code>Crisis Center</code>
link to be active when we visit that route. We&apos;ve added an additional binding to our <code>/crisis-center</code> routerLink,
<code>[routerLinkActiveOptions]=&quot;{ exact: true }&quot;</code> which will only mark the <code>/crisis-center</code> link as active when
we navigate the to <code>/crisis-center</code> URL and not when we navigate to one its child routes.</p><span>
</span></div><h4 id="guard-the-admin-feature">Guard the admin feature</h4><span>
</span><p>Currently every route within our <em>Crisis Center</em> is open to everyone.
The new <em>admin</em> feature should be accessible only to authenticated users.</p><span>
</span><p>We could hide the link until the user logs in. But that&apos;s tricky and difficult to maintain.</p><span>
</span><p>Instead we&apos;ll write a <code>CanActivate</code> guard to redirect anonymous users to the login page when they try to reach the admin component.</p><span>
</span><p>This is a general purpose guard &#x2014; we can imagine other features that require authenticated users &#x2014;
so we create an <code>auth-guard.service.ts</code> in the application root folder.</p><span>
</span><p>At the moment we&apos;re interested in seeing how guards work so our first version does nothing useful.
It simply logs to console and <code>returns</code> true immediately, allowing navigation to proceed:</p><span>
</span><p>app/auth-guard.service.ts (excerpt)</p><code language="ts" format="">import { Injectable }     from &apos;@angular/core&apos;;
import { CanActivate }    from &apos;@angular/router&apos;;

@Injectable()
export class AuthGuard implements CanActivate {
  canActivate() {
    console.log(&apos;AuthGuard#canActivate called&apos;);
    return true;
  }
}
</code><p>Next we open <code>crisis-center.routing.ts</code>, import the <code>AuthGuard</code> class, and
update the admin route with a <code>CanActivate</code> guard property that references it:</p><span>
</span><p>app/crisis-center/crisis-center.routing.ts (guarded admin route)</p><code language="ts" format="">{
  path: &apos;admin&apos;,
  component: CrisisAdminComponent,
  canActivate: [AuthGuard]
},
</code><p>Our admin feature is now protected by the guard, albeit protected poorly.</p><span>
</span><h4 id="teach-authguard-to-authenticate">Teach <em>AuthGuard</em> to authenticate</h4><span>
</span><p>Let&apos;s make our <code>AuthGuard</code> at least pretend to authenticate.</p><span>
</span><p>The <code>AuthGuard</code> should call an application service that can login a user and retain information about the current user.
Here&apos;s a demo <code>AuthService</code>:</p><span>
</span><p>app/auth.service.ts (excerpt)</p><code language="ts" format="">import { Injectable } from &apos;@angular/core&apos;;

import { Observable } from &apos;rxjs/Observable&apos;;
import &apos;rxjs/add/observable/of&apos;;
import &apos;rxjs/add/operator/do&apos;;
import &apos;rxjs/add/operator/delay&apos;;

@Injectable()
export class AuthService {
  isLoggedIn: boolean = false;

  // store the URL so we can redirect after logging in
  redirectUrl: string;

  login() {
    return Observable.of(true).delay(1000).do(val =&gt; this.isLoggedIn = true);
  }

  logout() {
    this.isLoggedIn = false;
  }
}
</code><p>Although it doesn&apos;t actually log in, it has what we need for this discussion.
It has an <code>isLoggedIn</code> flag to tell us whether the user is authenticated.
Its <code>login</code> method simulates an API call to an external service by returning an observable that resolves successfully after a short pause.
The <code>redirectUrl</code> property will store our attempted URL so we can navigate to it after authenticating.</p><span>
</span><p>Let&apos;s revise our <code>AuthGuard</code> to call it.</p><span>
</span><p>app/auth-guard.service.ts (v2)</p><code language="ts" format="">import { Injectable }             from &apos;@angular/core&apos;;
import { CanActivate, Router,
         ActivatedRouteSnapshot,
         RouterStateSnapshot }    from &apos;@angular/router&apos;;
import { AuthService }            from &apos;./auth.service&apos;;

@Injectable()
export class AuthGuard implements CanActivate {
  constructor(private authService: AuthService, private router: Router) {}

  canActivate(route: ActivatedRouteSnapshot, state: RouterStateSnapshot) {
    if (this.authService.isLoggedIn) { return true; }

    // Store the attempted URL for redirecting
    this.authService.redirectUrl = state.url;

    // Navigate to the login page
    this.router.navigate([&apos;/login&apos;]);
    return false;
  }
}
</code><p>Notice that we <em>inject</em> the <code>AuthService</code> and the <code>Router</code> in the constructor.
We haven&apos;t provided the <code>AuthService</code> yet but it&apos;s good to know that we can inject helpful services into our routing guards.</p><span>
</span><p>This guard returns a synchronous boolean result.
If the user is logged in, it returns true and the navigation continues.</p><span>
</span><p>The <code>ActivatedRouteSnapshot</code> contains the <em>future</em> route that will be activated and the <code>RouterStateSnapshot</code>
contains the <em>future</em> <code>RouterState</code> of our application, should we pass through our guard check.</p><span>
</span><p>If the user is not logged in, we store the attempted URL the user came from using the <code>RouterStateSnapshot.url</code> and
tell the router to navigate to a login page &#x2014; a page we haven&apos;t created yet.
This secondary navigation automatically cancels the current navigation; we return <code>false</code> just to be clear about that.</p><span>
</span><h4 id="add-the-logincomponent-">Add the <em>LoginComponent</em></h4><span>
</span><p>We need a <code>LoginComponent</code> for the user to log in to the app. After logging in, we&apos;ll redirect
to our stored URL if available, or use the default URL.
There is nothing new about this component or the way we wire it into the router configuration.</p><span>
</span><p>We&apos;ll register a <code>/login</code> route in our <code>app.routing.ts</code> and add the necessary providers to the <code>appRoutingProviders</code>
array we created earlier. In our <code>app.module.ts</code>, we&apos;ll import the <code>LoginComponent</code> and add it to our root NgModule <code>declarations</code>.</p><span>
</span><code-tabs><code language="ts" name="app/app.module.ts" format="linenums">import { NgModule }       from &apos;@angular/core&apos;;
import { BrowserModule }  from &apos;@angular/platform-browser&apos;;
import { FormsModule }    from &apos;@angular/forms&apos;;

import { AppComponent }       from &apos;./app.component&apos;;
import { routing,
         appRoutingProviders } from &apos;./app.routing&apos;;

import { HeroesModule } from &apos;./heroes/heroes.module&apos;;

import { LoginComponent } from &apos;./login.component&apos;;

import { DialogService }  from &apos;./dialog.service&apos;;

@NgModule({
  imports: [
    BrowserModule,
    FormsModule,
    routing,
    HeroesModule
  ],
  declarations: [
    AppComponent,
    LoginComponent
  ],
  providers: [
    appRoutingProviders,
    DialogService
  ],
  bootstrap: [ AppComponent ]
})
export class AppModule {
}
</code><code language="ts" name="app/app.routing.ts" format="linenums">import { ModuleWithProviders }   from &apos;@angular/core&apos;;
import { Routes, RouterModule }  from &apos;@angular/router&apos;;

import { loginRoutes,
         authProviders }      from &apos;./login.routing&apos;;

const appRoutes: Routes = [
  ...loginRoutes
];

export const appRoutingProviders: any[] = [
  authProviders
];

export const routing: ModuleWithProviders = RouterModule.forRoot(appRoutes);
</code><code language="ts" name="app/login.component.ts" format="linenums">import { Component }   from &apos;@angular/core&apos;;
import { Router }      from &apos;@angular/router&apos;;
import { AuthService } from &apos;./auth.service&apos;;

@Component({
  template: `
    &lt;h2&gt;LOGIN&lt;/h2&gt;
    &lt;p&gt;{{message}}&lt;/p&gt;
    &lt;p&gt;
      &lt;button (click)=&quot;login()&quot;  *ngIf=&quot;!authService.isLoggedIn&quot;&gt;Login&lt;/button&gt;
      &lt;button (click)=&quot;logout()&quot; *ngIf=&quot;authService.isLoggedIn&quot;&gt;Logout&lt;/button&gt;
    &lt;/p&gt;`
})
export class LoginComponent {
  message: string;

  constructor(public authService: AuthService, public router: Router) {
    this.setMessage();
  }

  setMessage() {
    this.message = &apos;Logged &apos; + (this.authService.isLoggedIn ? &apos;in&apos; : &apos;out&apos;);
  }

  login() {
    this.message = &apos;Trying to log in ...&apos;;

    this.authService.login().subscribe(() =&gt; {
      this.setMessage();
      if (this.authService.isLoggedIn) {
        // Get the redirect URL from our auth service
        // If no redirect has been set, use the default
        let redirect = this.authService.redirectUrl ? this.authService.redirectUrl : &apos;/crisis-center/admin&apos;;

        // Redirect the user
        this.router.navigate([redirect]);
      }
    });
  }

  logout() {
    this.authService.logout();
    this.setMessage();
  }
}
</code><code language="ts
  " name="app/login.routing.ts" format="linenums">import { Routes }         from &apos;@angular/router&apos;;
import { AuthGuard }      from &apos;./auth-guard.service&apos;;
import { AuthService }    from &apos;./auth.service&apos;;
import { LoginComponent } from &apos;./login.component&apos;;

export const loginRoutes: Routes = [
  { path: &apos;login&apos;, component: LoginComponent }
];

export const authProviders = [
  AuthGuard,
  AuthService
];
</code></code-tabs><h3 id="can-deactivate-guard"><i>CanDeactivate</i>: handling unsaved changes</h3><p>Back in the &quot;Heroes&quot; workflow, the app accepts every change to a hero immediately without hesitation or validation.</p><span>
</span><p>In the real world, we might have to accumulate the users changes.
We might have to validate across fields. We might have to validate on the server.
We might have to hold changes in a pending state until the user confirms them <em>as a group</em> or
cancels and reverts all changes.</p><span>
</span><p>What do we do about unapproved, unsaved changes when the user navigates away?
We can&apos;t just leave and risk losing the user&apos;s changes; that would be a terrible experience.</p><span>
</span><p>We&apos;d like to pause and let the user decide what to do.
If the user cancels, we&apos;ll stay put and allow more changes.
If the user approves, the app can save.</p><span>
</span><p>We still might delay navigation until the save succeeds.
If we let the user move to the next screen immediately and
the save failed (perhaps the data are ruled invalid), we would have lost the context of the error.</p><span>
</span><p>We can&apos;t block while waiting for the server &#x2014; that&apos;s not possible in a browser.
We need to stop the navigation while we wait, asynchronously, for the server
to return with its answer.</p><span>
</span><p>We need the <code>CanDeactivate</code> guard.</p><span>
</span><h3 id="cancel-and-save">Cancel and Save</h3><span>
</span><p>Our sample application doesn&apos;t talk to a server.
Fortunately, we have another way to demonstrate an asynchronous router hook.</p><span>
</span><p>Users update crisis information in the <code>CrisisDetailComponent</code>.
Unlike the <code>HeroDetailComponent</code>, the user changes do not update the
crisis entity immediately. We update the entity when the user presses the <em>Save</em> button.
We discard the changes if the user presses he <em>Cancel</em> button.</p><span>
</span><p>Both buttons navigate back to the crisis list after save or cancel.</p><span>
</span><p>app/crisis-center/crisis-detail.component.ts (excerpt)</p><code language="ts" format="">export class CrisisDetailComponent implements OnInit, OnDestroy {

  crisis: Crisis;
  editName: string;
  private sub: Subscription;

  cancel() {
    this.gotoCrises();
  }

  save() {
    this.crisis.name = this.editName;
    this.gotoCrises();
  }
}
</code><p>What if the user tries to navigate away without saving or canceling?
The user could push the browser back button or click the heroes link.
Both actions trigger a navigation.
Should the app save or cancel automatically?</p><span>
</span><p>We&apos;ll do neither. Instead we&apos;ll ask the user to make that choice explicitly
in a confirmation dialog box that <em>waits asynchronously for the user&apos;s
answer</em>.</p><span>
</span><div class="l-sub-section"><p>We could wait for the user&apos;s answer with synchronous, blocking code.
Our app will be more responsive ... and can do other work ...
by waiting for the user&apos;s answer asynchronously. Waiting for the user asynchronously
is like waiting for the server asynchronously.</p><span>
</span></div><p>The <code>DialogService</code> (provided in the root <code>NgModule</code> for app-wide use) does the asking.</p><span>
</span><p>It returns a <a href="http://exploringjs.com/es6/ch_promises.html">promise</a> that
<em>resolves</em> when the user eventually decides what to do: either
to discard changes and navigate away (<code>true</code>) or to preserve the pending changes and stay in the crisis editor (<code>false</code>).</p><span>
</span><a id="CanDeactivate"></a><p>We create a <code>Guard</code> that will check for the presence of a <code>canDeactivate</code> function in our component, in this
case being <code>CrisisDetailComponent</code>. We don&apos;t need to know the details of how our <code>CrisisDetailComponent</code> confirms deactivation.
This makes our guard reusable, which is an easy win for us.</p><span>
</span><p>app/can-deactivate-guard.service.ts</p><code language="ts" format="linenums">import { Injectable }    from &apos;@angular/core&apos;;
import { CanDeactivate } from &apos;@angular/router&apos;;
import { Observable }    from &apos;rxjs/Observable&apos;;

export interface CanComponentDeactivate {
 canDeactivate: () =&gt; boolean | Observable&lt;boolean&gt;;
}

@Injectable()
export class CanDeactivateGuard implements CanDeactivate&lt;CanComponentDeactivate&gt; {
  canDeactivate(component: CanComponentDeactivate): Observable&lt;boolean&gt; | Promise&lt;boolean&gt; | boolean {
    return component.canDeactivate ? component.canDeactivate() : true;
  }
}
</code><p>Alternatively, We could make a component-specific <code>CanDeactivate</code> guard for our <code>CrisisDetailComponent</code>. The <code>canDeactivate</code> method provides us
with the current instance of our <code>component</code>, the current <code>ActivatedRoute</code> and <code>RouterStateSnapshot</code> in case we needed to access
some external information. This would be useful if we only wanted to use this guard for this component and needed to ask the component&apos;s
properties in or to confirm whether the router should allow navigation away from it.</p><span>
</span><p>app/can-deactivate-guard.service.ts (component-specific)</p><code language="ts" format="">import { Injectable }           from &apos;@angular/core&apos;;
import { CanDeactivate,
         ActivatedRouteSnapshot,
         RouterStateSnapshot }  from &apos;@angular/router&apos;;
import { Observable }           from &apos;rxjs/Observable&apos;;

import { CrisisDetailComponent } from &apos;./crisis-center/crisis-detail.component&apos;;

@Injectable()
export class CanDeactivateGuard implements CanDeactivate&lt;CrisisDetailComponent&gt; {

  canDeactivate(
    component: CrisisDetailComponent,
    route: ActivatedRouteSnapshot,
    state: RouterStateSnapshot
  ): Observable&lt;boolean&gt; | Promise&lt;boolean&gt; | boolean {
    // Get the Crisis Center ID
    console.log(route.params[&apos;id&apos;]);

    // Get the current URL
    console.log(state.url);

    // Allow synchronous navigation (`true`) if no crisis or the crisis is unchanged
    if (!component.crisis || component.crisis.name === component.editName) {
      return true;
    }
    // Otherwise ask the user with the dialog service and return its
    // promise which resolves to true or false when the user decides
    return component.dialogService.confirm(&apos;Discard changes?&apos;);
  }
}
</code><p>Looking back at our <code>CrisisDetailComponent</code>, we have implemented our confirmation workflow for unsaved changes.</p><span>
</span><p>app/crisis-center/crisis-detail.component.ts (excerpt)</p><code language="ts" format="">canDeactivate(): Observable&lt;boolean&gt; | Promise&lt;boolean&gt; | boolean {
  // Allow synchronous navigation (`true`) if no crisis or the crisis is unchanged
  if (!this.crisis || this.crisis.name === this.editName) {
    return true;
  }
  // Otherwise ask the user with the dialog service and return its
  // promise which resolves to true or false when the user decides
  return this.dialogService.confirm(&apos;Discard changes?&apos;);
}
</code><p>Notice that the <code>canDeactivate</code> method <em>can</em> return synchronously;
it returns <code>true</code> immediately if there is no crisis or there are no pending changes.
But it can also return a <code>Promise</code> or an <code>Observable</code> and the router will wait for that
to resolve to truthy (navigate) or falsey (stay put).</p><span>
</span><p>We add the <code>Guard</code> to our crisis detail route in <code>crisis-center.routing.ts</code> using the <code>canDeactivate</code> array.</p><span>
</span><p>app/crisis-center/crisis-center.routing.ts</p><code language="ts" format="linenums">import { ModuleWithProviders }   from &apos;@angular/core&apos;;
import { Routes, RouterModule }  from &apos;@angular/router&apos;;

import { CrisisDetailComponent } from &apos;./crisis-detail.component&apos;;
import { CrisisListComponent }   from &apos;./crisis-list.component&apos;;
import { CrisisCenterComponent } from &apos;./crisis-center.component&apos;;
import { CrisisAdminComponent }  from &apos;./crisis-admin.component&apos;;

import { CanDeactivateGuard }    from &apos;../can-deactivate-guard.service&apos;;
import { AuthGuard }             from &apos;../auth-guard.service&apos;;

const crisisCenterRoutes: Routes = [
  {
    path: &apos;&apos;,
    redirectTo: &apos;/crisis-center&apos;,
    pathMatch: &apos;full&apos;
  },
  {
    path: &apos;crisis-center&apos;,
    component: CrisisCenterComponent,
    children: [
      {
        path: &apos;admin&apos;,
        component: CrisisAdminComponent,
        canActivate: [AuthGuard]
      },
      {
        path: &apos;:id&apos;,
        component: CrisisDetailComponent,
        canDeactivate: [CanDeactivateGuard]
      },
      {
        path: &apos;&apos;,
        component: CrisisListComponent
      }
    ]
  }
];

export const crisisCenterRouting: ModuleWithProviders = RouterModule.forChild(crisisCenterRoutes);
</code><p>We also need to add the <code>Guard</code> to our main <code>appRoutingProviders</code> so the <code>Router</code> can inject it during the navigation process.</p><span>
</span><code language="ts" format="linenums">import { ModuleWithProviders }   from &apos;@angular/core&apos;;
import { Routes, RouterModule }  from &apos;@angular/router&apos;;

import { loginRoutes,
         authProviders }      from &apos;./login.routing&apos;;

const appRoutes: Routes = [
  ...loginRoutes
];

export const appRoutingProviders: any[] = [
  authProviders
];

export const routing: ModuleWithProviders = RouterModule.forRoot(appRoutes);
</code><p>Now we have given our user a safeguard against unsaved changes.</p><span>
</span><a id="Resolve"></a><h3 id="resolve-guard"><i>Resolve</i>: pre-fetching component data</h3><p>In our <code>Hero Detail</code> and <code>Crisis Detail</code>, we waited until the route was activated to fetch our respective hero or crisis.</p><span>
</span><p>This worked well for us, but we can always do better.
If we were using a real world api, there may be some delay in when the data we want to display gets returned.
We don&apos;t want to display a blank component until the data loads in this situation.</p><span>
</span><p>We&apos;d like to pre-fetch data from the server so it&apos;s ready the moment our route is activated.
We&apos;d also like to handle the situation where our data fails to load or some other error condition occurs.
This would help us in our <code>Crisis Center</code> if we navigated to an <code>id</code> that doesn&apos;t return a record.
We could send the user back to the <code>Crisis List</code> where we only show valid crisis centers.
We want to delay rendering of our route component until all necessary data has been fetched or some action
has occurred.</p><span>
</span><p>We need the <code>Resolve</code> guard.</p><span>
</span><h3 id="preload-route-information">Preload route information</h3><span>
</span><p>We&apos;ll update our <code>Crisis Detail</code> route to resolve our Crisis before loading the route, or if the user happens to
navigate to an invalid crisis center <code>:id</code>, we&apos;ll navigate back to our list of existing crises.</p><span>
</span><p>Like the <code>CanActivate</code> and <code>CanDeactivate</code> guards, the <strong><code>Resolve</code></strong> guard is an interface we can implement as a service
to resolve route data synchronously or asynchronously. In our <code>Crisis Detail</code> component, we used the <code>ngOnInit</code> to retrieve the <code>Crisis</code>
information. We also navigated the user away from the route if the <code>Crisis</code> was not found. It would be more efficient to perform this
action before the route is ever activated.</p><span>
</span><p>We&apos;ll create a <code>CrisisDetailResolve</code> service that will handle retrieving the <code>Crisis</code> and navigating the user away if the <code>Crisis</code> does
not exist. Then we can be assured that when we activate the <code>CrisisDetailComponent</code>, the associated Crisis will already be available
for display.</p><span>
</span><p>Let&apos;s create our <code>crisis-detail-resolve.service.ts</code> file within our <code>Crisis Center</code> feature area.</p><span>
</span><p>app/crisis-center/crisis-detail-resolve.service.ts</p><code language="ts" format="linenums">import { Injectable }             from &apos;@angular/core&apos;;
import { Router, Resolve,
         ActivatedRouteSnapshot } from &apos;@angular/router&apos;;
import { Observable }             from &apos;rxjs/Observable&apos;;

import { Crisis, CrisisService } from &apos;./crisis.service&apos;;

@Injectable()
export class CrisisDetailResolve implements Resolve&lt;Crisis&gt; {
  constructor(private cs: CrisisService, private router: Router) {}

  resolve(route: ActivatedRouteSnapshot): Observable&lt;any&gt; | Promise&lt;any&gt; | any {
    let id = +route.params[&apos;id&apos;];

    return this.cs.getCrisis(id).then(crisis =&gt; {
      if (crisis) {
        return crisis;
      } else { // id not found
        this.router.navigate([&apos;/crisis-center&apos;]);
        return false;
      }
    });
  }
}
</code><p>We&apos;ll take the relevant parts of the <code>ngOnInit</code> lifecycle hook in our <code>CrisisDetailComponent</code> and moved them into our <code>CrisisDetailResolve</code> guard.
We import the <code>Crisis</code> model and <code>CrisisService</code> and also the <code>Router</code> for navigation from our resolve implementation. We want to be explicit about
the data we are resolving, so we implement the <code>Resolve</code> interface with a type of <code>Crisis</code>. This lets us know that what we will resolve will match our
<code>Crisis</code> model. We inject the <code>CrisisService</code> and <code>Router</code> and implement the <code>resolve</code> method that supports a <code>Promise</code>, <code>Observable</code> or a synchronous
return value.</p><span>
</span><p>We&apos;ll use our <code>CrisisService.getCrisis</code> method that returns a promise to prevent our route from loading until the data is fetched. If we don&apos;t find a valid <code>Crisis</code>,
we navigate the user back to the <code>CrisisList</code>, canceling the previous in-flight navigation to the crisis details.</p><span>
</span><p>Now that our guard is ready, we&apos;ll import it in our <code>crisis-center.routing.ts</code> and use the <code>resolve</code> object in our route configuration.</p><span>
</span><p>app/crisis-center/crisis-center.routing.ts (resolve)</p><code language="ts" format="">import { CrisisDetailResolve }   from &apos;./crisis-detail-resolve.service&apos;;

      {
        path: &apos;:id&apos;,
        component: CrisisDetailComponent,
        canDeactivate: [CanDeactivateGuard],
        resolve: {
          crisis: CrisisDetailResolve
        }
      },
</code><p>We&apos;ll add the <code>CrisisDetailResolve</code> service to our crisis center module&apos;s <code>providers</code>, so its available to the <code>Router</code> during the navigation process.</p><span>
</span><p>app/crisis-center/crisis-center.module.ts (crisis detail resolve provider)</p><code language="ts" format="">import { CrisisDetailResolve }  from &apos;./crisis-detail-resolve.service&apos;;

  providers: [
    CrisisService,
    CrisisDetailResolve
  ]
</code><p>Now that we&apos;ve added our <code>Resolve</code> guard to fetch data before the route loads, we no longer need to do this once we get into our <code>CrisisDetailComponent</code>.
We&apos;ll update the <code>CrisisDetailComponent</code> to use the <code>ActivatedRoute.data</code>, which is where our <code>crisis</code> property from our <code>Resolve</code> guard will be provided.
Once activated, all we need to do is set our local <code>crisis</code> and <code>editName</code> properties from our resolved <code>Crisis</code> information. We no longer need to subscribe
and unsubscribe to the <code>ActivatedRoute</code> params to fetch the <code>Crisis</code> because it is being provided synchronously at the time the route component is activated.</p><span>
</span><p>app/crisis-center/crisis-detail.component.ts (ngOnInit v2)</p><code language="ts" format="">ngOnInit() {
  this.route.data.forEach((data: { crisis: Crisis }) =&gt; {
    this.editName = data.crisis.name;
    this.crisis = data.crisis;
  });
}
</code><p><strong>Two critical points</strong></p><span>
</span><ol>
<li><p>The router interface is optional. We don&apos;t inherit from a base class. We simply implement the interface method or not.</p>
</li>
<li><p>We rely on the router to call the guard. We don&apos;t worry about all the ways that the user
could navigate away. That&apos;s the router&apos;s job.
We simply write this class and let the router take it from there.</p>
</li>
</ol><span>
</span><p>The relevant <em>Crisis Center</em> code for this milestone is</p><span>
</span><code-tabs><code language="ts" name="app.component.ts" format="linenums">import { Component }          from &apos;@angular/core&apos;;

@Component({
  selector: &apos;my-app&apos;,
  template: `
    &lt;h1 class=&quot;title&quot;&gt;Component Router&lt;/h1&gt;
    &lt;nav&gt;
      &lt;a routerLink=&quot;/crisis-center&quot; routerLinkActive=&quot;active&quot;
         [routerLinkActiveOptions]=&quot;{ exact: true }&quot;&gt;Crisis Center&lt;/a&gt;
      &lt;a routerLink=&quot;/heroes&quot; routerLinkActive=&quot;active&quot;&gt;Heroes&lt;/a&gt;
      &lt;a routerLink=&quot;/crisis-center/admin&quot; routerLinkActive=&quot;active&quot;&gt;Crisis Admin&lt;/a&gt;
      &lt;a routerLink=&quot;/login&quot; routerLinkActive=&quot;active&quot;&gt;Login&lt;/a&gt;
    &lt;/nav&gt;
    &lt;router-outlet&gt;&lt;/router-outlet&gt;
  `
})
export class AppComponent {
}
</code><code language="ts" name="crisis-center.component.ts" format="linenums">// #docplaster
import { Component } from &apos;@angular/core&apos;;

@Component({
  template:  `
    &lt;h2&gt;CRISIS CENTER&lt;/h2&gt;
    &lt;router-outlet&gt;&lt;/router-outlet&gt;
  `
})
export class CrisisCenterComponent { }
</code><code language="ts" name="crisis-center.routing.ts" format="linenums">import { ModuleWithProviders }   from &apos;@angular/core&apos;;
import { Routes, RouterModule }  from &apos;@angular/router&apos;;

import { CrisisCenterComponent } from &apos;./crisis-center.component&apos;;
import { CrisisDetailComponent } from &apos;./crisis-detail.component&apos;;
import { CrisisListComponent }   from &apos;./crisis-list.component&apos;;
import { CrisisAdminComponent }  from &apos;./crisis-admin.component&apos;;

import { CanDeactivateGuard }    from &apos;../can-deactivate-guard.service&apos;;
import { AuthGuard }             from &apos;../auth-guard.service&apos;;
import { CrisisDetailResolve }   from &apos;./crisis-detail-resolve.service&apos;;


const crisisCenterRoutes: Routes = [
  {
    path: &apos;&apos;,
    component: CrisisCenterComponent,
    children: [
      {
        path: &apos;admin&apos;,
        component: CrisisAdminComponent,
        canActivate: [AuthGuard]
      },
      {
        path: &apos;:id&apos;,
        component: CrisisDetailComponent,
        canDeactivate: [CanDeactivateGuard],
        resolve: {
          crisis: CrisisDetailResolve
        }
      },
      {
        path: &apos;&apos;,
        component: CrisisListComponent
      }
    ]
  }
];

export const crisisCenterRouting: ModuleWithProviders = RouterModule.forChild(crisisCenterRoutes);
</code><code language="ts" name="crisis-list.component.ts" format="linenums">import { Component, OnInit, OnDestroy } from &apos;@angular/core&apos;;
import { ActivatedRoute, Router }       from &apos;@angular/router&apos;;

import { Crisis, CrisisService } from &apos;./crisis.service&apos;;
import { Subscription }          from &apos;rxjs/Subscription&apos;;

@Component({
  template: `
    &lt;ul class=&quot;items&quot;&gt;
      &lt;li *ngFor=&quot;let crisis of crises&quot;
        (click)=&quot;onSelect(crisis)&quot;&gt;
        &lt;span class=&quot;badge&quot;&gt;{{crisis.id}}&lt;/span&gt; {{crisis.name}}
      &lt;/li&gt;
    &lt;/ul&gt;
  `,
})
export class CrisisListComponent implements OnInit, OnDestroy {
  crises: Crisis[];
  selectedId: number;
  private sub: Subscription;

  constructor(
    private service: CrisisService,
    private route: ActivatedRoute,
    private router: Router) {}

  ngOnInit() {
    this.sub = this.route
      .params
      .subscribe(params =&gt; {
        this.selectedId = +params[&apos;id&apos;];
        this.service.getCrises()
          .then(crises =&gt; this.crises = crises);
      });
  }

  ngOnDestroy() {
    this.sub.unsubscribe();
  }

  onSelect(crisis: Crisis) {
    // Absolute link
    this.router.navigate([&apos;/crisis-center&apos;, crisis.id]);
  }
}
</code><code language="ts" name="crisis-detail.component.ts" format="linenums">import { Component, OnInit }      from &apos;@angular/core&apos;;
import { Router, ActivatedRoute } from &apos;@angular/router&apos;;

import { Crisis }         from &apos;./crisis.service&apos;;
import { DialogService }  from &apos;../dialog.service&apos;;
import { Observable }     from &apos;rxjs/Observable&apos;;

@Component({
  template: `
  &lt;div *ngIf=&quot;crisis&quot;&gt;
    &lt;h3&gt;&quot;{{editName}}&quot;&lt;/h3&gt;
    &lt;div&gt;
      &lt;label&gt;Id: &lt;/label&gt;{{crisis.id}}&lt;/div&gt;
    &lt;div&gt;
      &lt;label&gt;Name: &lt;/label&gt;
      &lt;input [(ngModel)]=&quot;editName&quot; placeholder=&quot;name&quot;/&gt;
    &lt;/div&gt;
    &lt;p&gt;
      &lt;button (click)=&quot;save()&quot;&gt;Save&lt;/button&gt;
      &lt;button (click)=&quot;cancel()&quot;&gt;Cancel&lt;/button&gt;
    &lt;/p&gt;
  &lt;/div&gt;
  `,
  styles: [&apos;input {width: 20em}&apos;]
})

export class CrisisDetailComponent implements OnInit {
  crisis: Crisis;
  editName: string;

  constructor(
    private route: ActivatedRoute,
    private router: Router,
    public dialogService: DialogService
    ) { }

  ngOnInit() {
    this.route.data.forEach((data: { crisis: Crisis }) =&gt; {
      this.editName = data.crisis.name;
      this.crisis = data.crisis;
    });
  }

  cancel() {
    this.gotoCrises();
  }

  save() {
    this.crisis.name = this.editName;
    this.gotoCrises();
  }

  canDeactivate(): Observable&lt;boolean&gt; | Promise&lt;boolean&gt; | boolean {
    // Allow synchronous navigation (`true`) if no crisis or the crisis is unchanged
    if (!this.crisis || this.crisis.name === this.editName) {
      return true;
    }
    // Otherwise ask the user with the dialog service and return its
    // promise which resolves to true or false when the user decides
    return this.dialogService.confirm(&apos;Discard changes?&apos;);
  }

  gotoCrises() {
    let crisisId = this.crisis ? this.crisis.id : null;
    // Pass along the hero id if available
    // so that the CrisisListComponent can select that hero.
    // Add a totally useless `foo` parameter for kicks.
    // Absolute link
    this.router.navigate([&apos;/crisis-center&apos;, { id: crisisId, foo: &apos;foo&apos; }]);
  }
}
</code><code language="ts" name="crisis-detail-resolve.service.ts" format="linenums">import { Injectable }             from &apos;@angular/core&apos;;
import { Router, Resolve,
         ActivatedRouteSnapshot } from &apos;@angular/router&apos;;
import { Observable }             from &apos;rxjs/Observable&apos;;

import { Crisis, CrisisService } from &apos;./crisis.service&apos;;

@Injectable()
export class CrisisDetailResolve implements Resolve&lt;Crisis&gt; {
  constructor(private cs: CrisisService, private router: Router) {}

  resolve(route: ActivatedRouteSnapshot): Observable&lt;any&gt; | Promise&lt;any&gt; | any {
    let id = +route.params[&apos;id&apos;];

    return this.cs.getCrisis(id).then(crisis =&gt; {
      if (crisis) {
        return crisis;
      } else { // id not found
        this.router.navigate([&apos;/crisis-center&apos;]);
        return false;
      }
    });
  }
}
</code><code language="ts
  " name="crisis.service.ts" format="linenums">export class Crisis {
  constructor(public id: number, public name: string) { }
}

const CRISES = [
  new Crisis(1, &apos;Dragon Burning Cities&apos;),
  new Crisis(2, &apos;Sky Rains Great White Sharks&apos;),
  new Crisis(3, &apos;Giant Asteroid Heading For Earth&apos;),
  new Crisis(4, &apos;Procrastinators Meeting Delayed Again&apos;),
];

let crisesPromise = Promise.resolve(CRISES);

import { Injectable } from &apos;@angular/core&apos;;

@Injectable()
export class CrisisService {

  static nextCrisisId = 100;

  getCrises() { return crisesPromise; }

  getCrisis(id: number | string) {
    return crisesPromise
      .then(crises =&gt; crises.find(crisis =&gt; crisis.id === +id));
  }

}
</code></code-tabs><code-tabs><code language="ts" name="auth-guard.service.ts" format="linenums">import { Injectable }             from &apos;@angular/core&apos;;
import { CanActivate, Router,
         ActivatedRouteSnapshot,
         RouterStateSnapshot }    from &apos;@angular/router&apos;;
import { AuthService }            from &apos;./auth.service&apos;;

@Injectable()
export class AuthGuard implements CanActivate {
  constructor(private authService: AuthService, private router: Router) {}

  canActivate(route: ActivatedRouteSnapshot, state: RouterStateSnapshot) {
    if (this.authService.isLoggedIn) { return true; }

    // Store the attempted URL for redirecting
    this.authService.redirectUrl = state.url;

    // Navigate to the login page
    this.router.navigate([&apos;/login&apos;]);
    return false;
  }
}
</code><code language="ts
  " name="can-deactivate-guard.service.ts" format="linenums">import { Injectable }    from &apos;@angular/core&apos;;
import { CanDeactivate } from &apos;@angular/router&apos;;
import { Observable }    from &apos;rxjs/Observable&apos;;

export interface CanComponentDeactivate {
 canDeactivate: () =&gt; boolean | Observable&lt;boolean&gt;;
}

@Injectable()
export class CanDeactivateGuard implements CanDeactivate&lt;CanComponentDeactivate&gt; {
  canDeactivate(component: CanComponentDeactivate): Observable&lt;boolean&gt; | Promise&lt;boolean&gt; | boolean {
    return component.canDeactivate ? component.canDeactivate() : true;
  }
}
</code></code-tabs><h2 id="milestone-4-route-parameters">Milestone #4: Route Parameters</h2><span>
</span><p>We use <a href="https://angular.io/docs/ts/latest/guide/router.html#route-parameters"><em>route parameters</em></a> to specify a <em>required</em> parameter value <em>within</em> the route URL
as we do when navigating to the <code>HeroDetailComponent</code> in order to view-and-edit the hero with <em>id:15</em>.</p><span>
</span><code format="." language="bash">localhost:3000/hero/15</code><p>Sometimes we wish to add <em>optional</em> information to a route request.
For example, the <code>HeroListComponent</code> doesn&apos;t need help to display a list of heroes.
But it might be nice if the previously-viewed hero were pre-selected when returning from the <code>HeroDetailComponent</code>.</p><span>
</span><figure class="image-display"><img src="https://angular.io/resources/images/devguide/router/selected-hero.png" alt="Selected hero"></figure><p>That becomes possible if we can include hero Magneta&apos;s <code>id</code> in the URL when we
return from the <code>HeroDetailComponent</code>, a scenario we&apos;ll pursue in a moment.</p><span>
</span><p>Optional information takes other forms. Search criteria are often loosely structured, e.g., <code>name=&apos;wind*&apos;</code>.
Multiple values are common &#x2014; <code>after=&apos;12/31/2015&apos; &amp; before=&apos;1/1/2017&apos;</code> &#x2014; in no particular order &#x2014;
 <code>before=&apos;1/1/2017&apos; &amp; after=&apos;12/31/2015&apos;</code> &#x2014; in a variety of formats &#x2014; <code>during=&apos;currentYear&apos;</code> .</p><span>
</span><p>These kinds of parameters don&apos;t fit easily in a URL <em>path</em>. Even if we could define a suitable URL token scheme,
doing so greatly complicates the pattern matching required to translate an incoming URL to a named route.</p><span>
</span><p>Optional parameters are the ideal vehicle for conveying arbitrarily complex information during navigation.
Optional parameters aren&apos;t involved in pattern matching and affords enormous flexibility of expression.</p><span>
</span><p>The Component Router supports navigation with optional parameters as well as required route parameters.
We define <em>optional</em> parameters in an <em>object</em> after we define our required route parameters.</p><span>
</span><h3 id="route-parameters-required-or-optional-">Route Parameters: Required or Optional?</h3><span>
</span><p>There is no hard-and-fast rule. In general,</p><span>
</span><p><em>prefer a required route parameter when</em></p><span>
</span><ul>
<li>the value is required.</li>
<li>the value is necessary to distinguish one route path from another.</li>
</ul><span>
</span><p><em>prefer an optional parameter when</em></p><span>
</span><ul>
<li>the value is complex and/or multi-variate.</li>
</ul><span>
</span><span>
</span><h3 id="route-parameter">Route parameter</h3><span>
</span><p>When navigating to the <code>HeroDetailComponent</code> we specified the <code>id</code> of the hero-to-edit in the
<em>route parameter</em> and made it the second item of the <a href="https://angular.io/docs/ts/latest/guide/router.html#link-parameters-array"><em>link parameters array</em></a>.</p><span>
</span><code language="ts" format="">[&apos;/hero&apos;, hero.id] // { 15 }
</code><p>The router embedded the <code>id</code> value in the navigation URL because we had defined it
as a route parameter with an <code>:id</code> placeholder token in the route <code>path</code>:</p><span>
</span><code language="ts" format="">{ path: &apos;hero/:id&apos;, component: HeroDetailComponent }
</code><p>When the user clicks the back button, the <code>HeroDetailComponent</code> constructs another <em>link parameters array</em>
which it uses to navigate back to the <code>HeroListComponent</code>.</p><span>
</span><code language="ts" format="">gotoHeroes() { this.router.navigate([&apos;/heroes&apos;]); }
</code><p>This array lacks a route parameter because we had no reason to send information to the <code>HeroListComponent</code>.</p><span>
</span><p>Now we have a reason. We&apos;d like to send the id of the current hero with the navigation request so that the
<code>HeroListComponent</code> can highlight that hero in its list.</p><span>
</span><p>We do that with an object that contains our optional <code>id</code> parameter.
We also defined a junk parameter (<code>foo</code>) that the <code>HeroListComponent</code> should ignore.
Here&apos;s the revised navigation statement:</p><span>
</span><code language="ts" format="">gotoHeroes() {
  let heroId = this.hero ? this.hero.id : null;
  // Pass along the hero id if available
  // so that the HeroList component can select that hero.
  this.router.navigate([&apos;/heroes&apos;, { id: heroId, foo: &apos;foo&apos; }]);
}
</code><p>The application still works. Clicking &quot;back&quot; returns to the hero list view.</p><span>
</span><p>Look at the browser address bar.</p><span>
</span><div class="l-sub-section"><img src="https://angular.io/resources/images/devguide/plunker-separate-window-button.png" alt="pop out the window" align="right"><p>When running in plunker, pop out the preview window by clicking the blue &apos;X&apos; button in the upper right corner.</p><span>
</span></div><p>It should look something like this, depending on where you run it:</p><span>
</span><code language="bash">localhost:3000/heroes;id=15;foo=foo
</code><p>The <code>id</code> value appears in the URL as (<code>;id=15;foo=foo</code>), not in the URL path.
The path for the &quot;Heroes&quot; route doesn&apos;t have an <code>:id</code> token.</p><span>
</span><p>The optional route parameters are not separated by &quot;?&quot; and &quot;&amp;&quot;.
They are <strong>separated by semicolons (;)</strong>
This is <em>matrix URL</em> notation &#x2014; something we may not have seen before.</p><span>
</span><div class="l-sub-section"><p><em>Matrix URL</em> notation is an idea first floated
in a <a href="http://www.w3.org/DesignIssues/MatrixURIs.html">1996 proposal</a> by the founder of the web, Tim Berners-Lee.</p><span>
</span><p>Although matrix notation never made it into the HTML standard, it is legal and
it became popular among browser routing systems as a way to isolate parameters
belonging to parent and child routes. The Angular Component Router is such a system.</p><span>
</span><p>The syntax may seem strange to us but users are unlikely to notice or care
as long as the URL can be emailed and pasted into a browser address bar
as this one can.</p><span>
</span></div><h3 id="route-parameters-in-the-activatedroute-service">Route parameters in the <em>ActivatedRoute</em> service</h3><span>
</span><p>The list of heroes is unchanged. No hero row is highlighted.</p><span>
</span><div class="l-sub-section"><p>The <live-example></live-example> <em>does</em> highlight the selected
row because it demonstrates the final state of the application which includes the steps we&apos;re <em>about</em> to cover.
At the moment we&apos;re describing the state of affairs <em>prior</em> to those steps.</p><span>
</span></div><p>The <code>HeroListComponent</code> isn&apos;t expecting any parameters at all and wouldn&apos;t know what to do with them.
Let&apos;s change that.</p><span>
</span><p>When navigating from the <code>HeroListComponent</code> to the <code>HeroDetailComponent</code>
we subscribed the route params <code>Observable</code> and made it available to the <code>HeroDetailComponent</code>
in the <code>ActivatedRoute</code> service. We injected that service in the constructor of the <code>HeroDetailComponent</code>.</p><span>
</span><p>This time we&apos;ll be navigating in the opposite direction, from the <code>HeroDetailComponent</code> to the <code>HeroListComponent</code>.</p><span>
</span><p>First we extend the router import statement to include the <code>ActivatedRoute</code> service symbol;</p><span>
</span><p>app/heroes/hero-list.component.ts (import)</p><code language="ts" format="">import { Router, ActivatedRoute } from &apos;@angular/router&apos;;
</code><p>Then we use the <code>ActivatedRoute</code> to access the <code>params</code> <em>Observable</em> so we can subscribe
and extract the <code>id</code> parameter as the <code>selectedId</code>:</p><span>
</span><p>app/heroes/hero-list.component.ts (constructor)</p><code language="ts" format="">  private selectedId: number;
  private sub: Subscription;

  constructor(
    private service: HeroService,
    private route: ActivatedRoute,
    private router: Router) {}

  ngOnInit() {
    this.sub = this.route
      .params
      .subscribe(params =&gt; {
        this.selectedId = +params[&apos;id&apos;];
        this.service.getHeroes()
          .then(heroes =&gt; this.heroes = heroes);
      });
  }

  ngOnDestroy() {
    this.sub.unsubscribe();
  }
</code><div class="l-sub-section"><p>All route/query parameters are strings.
The (+) in front of the <code>params[&apos;id&apos;]</code> expression is a JavaScript trick to convert the string to an integer.</p><span>
</span></div><p>We add an <code>isSelected</code> method that returns true when a hero&apos;s id matches the selected id.</p><span>
</span><p>app/heroes/hero-list.component.ts (isSelected)</p><code language="ts" format="">isSelected(hero: Hero) { return hero.id === this.selectedId; }
</code><p>Finally, we update our template with a <a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#class-binding">Class Binding</a> to that <code>isSelected</code> method.
The binding adds the <code>selected</code> CSS class when the method returns <code>true</code> and removes it when <code>false</code>.
Look for it within the repeated <code>&lt;li&gt;</code> tag as shown here:</p><span>
</span><p>app/heroes/hero-list.component.ts (template)</p><code language="ts" format="">template: `
  &lt;h2&gt;HEROES&lt;/h2&gt;
  &lt;ul class=&quot;items&quot;&gt;
    &lt;li *ngFor=&quot;let hero of heroes&quot;
      [class.selected]=&quot;isSelected(hero)&quot;
      (click)=&quot;onSelect(hero)&quot;&gt;
      &lt;span class=&quot;badge&quot;&gt;{{hero.id}}&lt;/span&gt; {{hero.name}}
    &lt;/li&gt;
  &lt;/ul&gt;
`
</code><p>When the user navigates from the heroes list to the &quot;Magneta&quot; hero and back, &quot;Magneta&quot; appears selected:</p><span>
</span><figure class="image-display"><img src="https://angular.io/resources/images/devguide/router/selected-hero.png" alt="Selected List"></figure><p>The optional <code>foo</code> route parameter is harmless and continues to be ignored.</p><span>
</span><a id="query-parameters"></a><a id="fragment"></a><h3 id="query-parameters-and-fragments">Query Parameters and Fragments</h3><span>
</span><p>In our <a href="https://angular.io/docs/ts/latest/guide/router.html#optional-route-parameters">route parameters</a> example, we only dealt with parameters specific to
our route, but what if we wanted optional parameters available to all routes? This is where our
query parameters come into play and serve a special purpose in our application.</p><span>
</span><p><a href="https://en.wikipedia.org/wiki/Fragment_identifier">Fragments</a> refer to certain elements on the page
identified with an <code>id</code> attribute.</p><span>
</span><p>We&apos;ll update our <code>AuthGuard</code> to provide a <code>session_id</code> query that will remain after navigating to another route.</p><span>
</span><p>We&apos;ll also provide an arbitrary <code>anchor</code> fragment, which we would use to jump to a certain point on our page.</p><span>
</span><p>We&apos;ll add the <code>NavigationExtras</code> object to our <code>router.navigate</code> method that navigates us to our <code>/login</code> route.</p><span>
</span><p>app/auth-guard.service.ts (v3)</p><code language="ts" format="">import { Injectable }             from &apos;@angular/core&apos;;
import { CanActivate, Router,
         ActivatedRouteSnapshot,
         RouterStateSnapshot,
         NavigationExtras }       from &apos;@angular/router&apos;;
import { AuthService }            from &apos;./auth.service&apos;;

@Injectable()
export class AuthGuard implements CanActivate {
  constructor(private authService: AuthService, private router: Router) {}

  canActivate(route: ActivatedRouteSnapshot, state: RouterStateSnapshot) {
    if (this.authService.isLoggedIn) { return true; }

    // Store the attempted URL for redirecting
    this.authService.redirectUrl = state.url;

    // Create a dummy session id
    let sessionId = 123456789;

    // Set our navigation extras object
    // that contains our global query params and fragment
    let navigationExtras: NavigationExtras = {
      queryParams: { &apos;session_id&apos;: sessionId },
      fragment: &apos;anchor&apos;
    };

    // Navigate to the login page with extras
    this.router.navigate([&apos;/login&apos;], navigationExtras);
    return false;
  }
}
</code><p>We can also <strong>preserve</strong> query parameters and fragments across navigations without having to re-provide them
when navigating. In our <code>LoginComponent</code>, we&apos;ll add an <em>object</em> as the second argument in our <code>router.navigate</code> function
and provide the <code>preserveQueryParams</code> and <code>preserveFragment</code> to pass along the current query parameters
and fragment to the next route.</p><span>
</span><p>app/login.component.ts (preserve)</p><code language="ts" format="">// Set our navigation extras object
// that passes on our global query params and fragment
let navigationExtras: NavigationExtras = {
  preserveQueryParams: true,
  preserveFragment: true
};

// Redirect the user
this.router.navigate([redirect], navigationExtras);
</code><p>Since we&apos;ll be navigating to our <em>Crisis Admin</em> route after logging in, we&apos;ll update it to handle our
query parameters and fragment.</p><span>
</span><p>app/crisis-center/crisis-admin.component.ts (v2)</p><code language="ts" format="">import { Component, OnInit }  from &apos;@angular/core&apos;;
import { ActivatedRoute }     from &apos;@angular/router&apos;;
import { Observable }         from &apos;rxjs/Observable&apos;;
import &apos;rxjs/add/operator/map&apos;;

@Component({
  template:  `
    &lt;h3&gt;CRISIS ADMINISTRATION&lt;/h3&gt;
    &lt;p&gt;Manage your crises here&lt;/p&gt;

    &lt;p&gt;Session ID: {{ sessionId | async }}&lt;/p&gt;
    &lt;a id=&quot;anchor&quot;&gt;&lt;/a&gt;
    &lt;p&gt;Token: {{ token | async }}&lt;/p&gt;
  `
})
export class CrisisAdminComponent implements OnInit {
  sessionId: Observable&lt;string&gt;;
  token: Observable&lt;string&gt;;

  constructor(private route: ActivatedRoute) {}

  ngOnInit() {
    // Capture the session ID if available
    this.sessionId = this.route
      .queryParams
      .map(params =&gt; params[&apos;session_id&apos;] || &apos;None&apos;);

    // Capture the fragment if available
    this.token = this.route
      .fragment
      .map(fragment =&gt; fragment || &apos;None&apos;);
  }
}
</code><p><em>Query Parameters</em> and <em>Fragments</em> are also available through the <code>ActivatedRoute</code> service available to route components.
Just like our <em>route parameters</em>, query parameters and fragments are provided as an <code>Observable</code>.
For our updated <em>Crisis Admin</em> component we&apos;ll feed the <code>Observable</code> directly into our template using the <code>AsyncPipe</code>, which
will handle <em>unsubscribing</em> from the <code>Observable</code> for us when the component is destroyed.</p><span>
</span><div class="l-sub-section"><img src="https://angular.io/resources/images/devguide/plunker-separate-window-button.png" alt="pop out the window" align="right"><p>When running in plunker, pop out the preview window by clicking the blue &apos;X&apos; button in the upper right corner.</p><span>
</span></div><p>Following the steps in this process, we can click on the <em>Crisis Admin</em> button, that takes us to the <em>Login</em>
page with our provided <code>query params</code> and <code>fragment</code>. After we click the login button, we notice that
we have been redirected to the <code>Crisis Admin</code> page with our <code>query params</code> and <code>fragment</code> still intact. We can use
these persistent bits of information for things that need to be provided with across pages interaction like
authentication tokens or session ids.</p><span>
</span><a id="asynchronous-routing"></a><h2 id="milestone-5-asynchronous-routing">Milestone #5: Asynchronous Routing</h2><span>
</span><p>As we have completed our milestones, our application has naturally gotten larger. As we continue to build
out feature areas our overall application size will get larger also. At some point we&apos;ll reach a tipping
point in where our application takes a significant enough time to load. This is not a viable long term solution.</p><span>
</span><p>So how do we combat this problem? We introduce asynchronous routing into our application and take advantage of loading
feature areas <em>lazily</em>. This buys us multiple things:</p><span>
</span><p>We can continue building out feature areas without increasing our initial bundle.
We can load feature areas only when requested by the user.
We can speed up load time for users that only visit certain areas of our application.</p><span>
</span><p>These are all things we want to have in our application, so let&apos;s apply this to our current setup. We&apos;ve already made
great strides by organizing our application into three modules: <code>AppModule</code>, <code>HeroesModule</code> and <code>CrisisCenterModule</code>.
Our <code>CrisisCenterModule</code> is the most feature-rich area of our application and also the largest, so we&apos;ll take advantage
of asynchronous routing and only load the <code>Crisis Center</code> feature area when requested.</p><span>
</span><h3 id="lazy-loading-route-configuration">Lazy-Loading route configuration</h3><span>
</span><p>We&apos;ll start by pulling our <code>redirect</code> and <code>crisis-center</code> routes out of our <code>CrisisCenterModule</code> and including them in our
<code>app.routing.ts</code> file. We want to load our <code>Crisis Center</code> asynchronously, so we&apos;ll use the <code>loadChildren</code> property in
our route config where previously we used the <code>children</code> property to include our child routes.</p><span>
</span><p>We&apos;ll also change our <code>crisis-center</code> <strong>path</strong> in our <code>crisis-center.routing.ts</code> to an empty path. The <code>Router</code> supports
<em>empty path</em> routes, which we can use for grouping routes together without adding anything additional paths to the URL. Our
users will still visit <code>/crisis-center</code> and our <code>CrisisCenterComponent</code> still serves as our <em>Routing Component</em> which contains
our child routes.</p><span>
</span><code-tabs><code language="ts" name="app.routing.ts (load children)" format="linenums">const crisisCenterRoutes: Routes = [
  {
    path: &apos;&apos;,
    redirectTo: &apos;/crisis-center&apos;,
    pathMatch: &apos;full&apos;
  },
  {
    path: &apos;crisis-center&apos;,
    loadChildren: &apos;app/crisis-center/crisis-center.module#CrisisCenterModule&apos;
  }
];

const appRoutes: Routes = [
  ...loginRoutes,
  ...crisisCenterRoutes
];
</code><code language="ts" name="crisis-center.routing.ts (empty path crisis center)" format="linenums">const crisisCenterRoutes: Routes = [
  {
    path: &apos;&apos;,
    component: CrisisCenterComponent,
    children: [
      {
        path: &apos;admin&apos;,
        component: CrisisAdminComponent,
        canActivate: [AuthGuard]
      },
      {
        path: &apos;:id&apos;,
        component: CrisisDetailComponent,
        canDeactivate: [CanDeactivateGuard],
        resolve: {
          crisis: CrisisDetailResolve
        }
      },
      {
        path: &apos;&apos;,
        component: CrisisListComponent
      }
    ]
  }
];

export const crisisCenterRouting: ModuleWithProviders = RouterModule.forChild(crisisCenterRoutes);
</code></code-tabs><p>The <code>loadChildren</code> property is used by the <code>Router</code> to map to our bundle we want to lazy-load, in this case being the <code>CrisisCenterModule</code>.</p><span>
</span><p>If we look closer at the <code>loadChildren</code> string, we can see that it maps directly to our <code>crisis-center.module</code> file where we previously built
out our <code>Crisis Center</code> feature area. After the path to the file we use a <code>#</code> to denote where our file path ends and to tell the <code>Router</code> the name
of our <code>CrisisCenter</code> NgModule. If we look in our <code>crisis-center.module</code> file, we can see it matches name of our exported NgModule class.</p><span>
</span><p>app/crisis-center/crisis-center.module.ts (export)</p><code language="ts" format="">export class CrisisCenterModule {}
</code><p>The <code>loadChildren</code> property is used by the <code>Router</code> to map to our bundle we want to lazy-load, in this case being the <code>CrisisCenterModule</code>.
The router will take our loadChildren string and dynamically load in our <code>CrisisCenterModule</code>, add its routes to our configuration <em>dynamically</em>
and then load the requested route. This will only happen when route is <strong>first</strong> requested and the module will be immediately be available
for subsequent requests.</p><span>
</span><div class="l-sub-section"><p>Angular provides a built-in module loader that supports <strong><code>SystemJS</code></strong> to load modules asynchronously. If we were
using another bundling tool, such as <strong>Webpack</strong>, we would use the Webpack mechanism for asynchronously loading modules.</p><span>
</span></div><p>We&apos;ve built our feature area, we&apos;ve updated our route configuration to take advantage of lazy-loading, now we have to do the final step
to break our <code>CrisisCenterModule</code> into a completely separate module. In our <code>app.module.ts</code>, we&apos;ll remove our <code>CrisisCenterModule</code> from the
<code>imports</code> array since we&apos;ll be loading it on-demand an we&apos;ll remove the imported <code>CrisisCenterModule</code>.</p><span>
</span><p>app/app.module.ts (final)</p><code language="ts" format="">import { NgModule }       from &apos;@angular/core&apos;;
import { BrowserModule }  from &apos;@angular/platform-browser&apos;;
import { FormsModule }    from &apos;@angular/forms&apos;;

import { AppComponent }       from &apos;./app.component&apos;;
import { routing,
         appRoutingProviders } from &apos;./app.routing&apos;;

import { HeroesModule } from &apos;./heroes/heroes.module&apos;;

import { LoginComponent } from &apos;./login.component&apos;;

import { DialogService }  from &apos;./dialog.service&apos;;

@NgModule({
  imports: [
    BrowserModule,
    FormsModule,
    routing,
    HeroesModule
  ],
  declarations: [
    AppComponent,
    LoginComponent
  ],
  providers: [
    appRoutingProviders,
    DialogService
  ],
  bootstrap: [ AppComponent ]
})
export class AppModule {
}
</code><p>If our initial redirect went to <code>/heroes</code> instead of going to <code>/crisis-center</code>, the <code>CrisisCenterModule</code> would not be loaded until the user
visited a <code>Crisis Center</code> route. We&apos;ll update our redirect in our <code>app.routing.ts</code> to make this change.</p><span>
</span><p>app/app.routing.ts (heroes redirect)</p><code language="ts" format="">{
  path: &apos;&apos;,
  redirectTo: &apos;/heroes&apos;,
  pathMatch: &apos;full&apos;
},
</code><a id="final-app"></a><h2 id="wrap-up">Wrap Up</h2><span>
</span><p>We&apos;ve covered a lot of ground in this chapter and the application is too big to reprint here.
Please visit the <live-example></live-example> and
where you can download the final source code.</p><span>
</span><h2 id="appendices">Appendices</h2><span>
</span><p>The balance of this chapter is a set of appendices that
elaborate some of the points we covered quickly above.</p><span>
</span><p>The appendix material isn&apos;t essential. Continued reading is for the curious.</p><span>
</span><span>
</span><p>We&apos;ve mentioned the <em>Link Parameters Array</em> several times. We&apos;ve used it several times.</p><span>
</span><p>A link parameters array holds the ingredients for router navigation:</p><span>
</span><ul>
<li>the <em>path</em> of the route to the destination component</li>
<li>required and optional route parameters that go into the route URL</li>
</ul><span>
</span><p>We can bind the <code>RouterLink</code> directive to such an array like this:</p><span>
</span><code language="ts" format="">&lt;a [routerLink]=&quot;[&apos;/heroes&apos;]&quot;&gt;Heroes&lt;/a&gt;
</code><p>We&apos;ve written a two element array when specifying a route parameter like this</p><span>
</span><code language="ts" format="">this.router.navigate([&apos;/hero&apos;, hero.id]);
</code><p>We can provide optional route parameters in an object like this:</p><span>
</span><code language="ts" format="">&lt;a [routerLink]=&quot;[&apos;/crisis-center&apos;, { foo: &apos;foo&apos; }]&quot;&gt;Crisis Center&lt;/a&gt;
</code><p>These three examples cover our needs for an app with one level routing.
The moment we add a child router, such as the <em>Crisis Center</em>, we create new link array possibilities.</p><span>
</span><p>Recall that we specified a default child route for <em>Crisis Center</em> so this simple <code>RouterLink</code> is fine.</p><span>
</span><code language="ts" format="">&lt;a [routerLink]=&quot;[&apos;/crisis-center&apos;]&quot;&gt;Crisis Center&lt;/a&gt;
</code><p>Let&apos;s parse it out.</p><span>
</span><ul>
<li>The first item in the array identifies the parent route (&apos;/crisis-center&apos;).</li>
<li>There are no parameters for this parent route so we&apos;re done with it.</li>
<li>There is no default for the child route so we need to pick one.</li>
<li>We decide to go to the <code>CrisisListComponent</code> whose route path is &apos;/&apos; but we don&apos;t need to explicitly add it</li>
<li>Voila! <code>[&apos;/crisis-center&apos;]</code>.</li>
</ul><span>
</span><p>Let&apos;s take it a step further.
This time we&apos;ll build a link parameters array that navigates from the root of the application
down to the &quot;Dragon Crisis&quot;.</p><span>
</span><ul>
<li>The first item in the array identifies the parent route (&apos;/crisis-center&apos;).</li>
<li>There are no parameters for this parent route so we&apos;re done with it.</li>
<li>The second item identifies the child route for details about a particular crisis (&apos;/:id&apos;).</li>
<li>The details child route requires an <code>id</code> route parameter</li>
<li>We add <code>id</code> of the <em>Dragon Crisis</em> as the second item in the array (<code>1</code>)</li>
</ul><span>
</span><p>It looks like this!</p><span>
</span><code language="ts" format="">&lt;a [routerLink]=&quot;[&apos;/crisis-center&apos;, 1]&quot;&gt;Dragon Crisis&lt;/a&gt;
</code><p>If we wanted to, we could redefine our <code>AppComponent</code> template with <em>Crisis Center</em> routes exclusively:</p><span>
</span><code language="ts" format="">template: `
  &lt;h1 class=&quot;title&quot;&gt;Component Router&lt;/h1&gt;
  &lt;nav&gt;
    &lt;a [routerLink]=&quot;[&apos;/crisis-center&apos;]&quot;&gt;Crisis Center&lt;/a&gt;
    &lt;a [routerLink]=&quot;[&apos;/crisis-center/1&apos;, { foo: &apos;foo&apos; }]&quot;&gt;Dragon Crisis&lt;/a&gt;
    &lt;a [routerLink]=&quot;[&apos;/crisis-center/2&apos;]&quot;&gt;Shark Crisis&lt;/a&gt;
  &lt;/nav&gt;
  &lt;router-outlet&gt;&lt;/router-outlet&gt;
`
</code><p>In sum, we can write applications with one, two or more levels of routing.
The link parameters array affords the flexibility to represent any routing depth and
any legal sequence of route paths, (required) router parameters and (optional) route parameter objects.</p><span>
</span><h2 id="appendix-why-use-an-ngoninit-method">Appendix: Why use an <em>ngOnInit</em> method</h2><span>
</span><p>We implemented an <code>ngOnInit</code> method in many of our Component classes.
We did so, for example, in the <a href="https://angular.io/docs/ts/latest/guide/router.html#hero-detail-ctor">HeroDetailComponent</a>.
We might have put the <code>ngOnInit</code> logic inside the constructor instead. We didn&apos;t for a reason. The reason is <em>testability</em>.</p><span>
</span><p>A constructor that has major side-effects can be difficult to test because it starts doing things as soon as
we create a test instance. In this case, it might have made a request to a remote server, something it shouldn&apos;t
do under test. It may even be impossible to reach the server in the test environment.</p><span>
</span><p>The better practice is to limit what the constructor can do. Mostly it should stash parameters in
local variables and perform simple instance configuration.</p><span>
</span><p>Yet we want an instance of this class to get the hero data from the <code>HeroService</code> soon after it is created.
How do we ensure that happens if not in the constructor?</p><span>
</span><p>Angular detects when a component has certain lifecycle methods like
<a href="https://angular.io/docs/ts/latest/api/core/index/OnInit-class.html">ngOnInit</a> and
<a href="https://angular.io/docs/ts/latest/api/core/index/OnDestroy-class.html">ngOnDestroy</a> and calls
them
at the appropriate moment.</p><span>
</span><p>Angular will call <code>ngOnInit</code> when we navigate to the <code>HeroDetailComponent</code>, we&apos;ll get the <code>id</code> from the <code>ActivatedRoute</code>
params and ask the server for the hero with that <code>id</code>.</p><span>
</span><p>We too can call that <code>ngOnInit</code> method in our tests if we wish ... after taking control of the injected
<code>HeroService</code> and (perhaps) mocking it.</p><span>
</span><a name="browser-url-styles"></a><span>
</span><a id="location-strategy"></a><h2 id="appendix-locationstrategy-and-browser-url-styles">Appendix: <em>LocationStrategy</em> and browser URL styles</h2><span>
</span><p>When the router navigates to a new component view, it updates the browser&apos;s location and history
with a URL for that view.
This is a strictly local URL. The browser shouldn&apos;t send this URL to the server
and should not reload the page.</p><span>
</span><p>Modern HTML 5 browsers support
<a href="https://developer.mozilla.org/en-US/docs/Web/API/History_API#Adding_and_modifying_history_entries">history.pushState</a>,
a technique that changes a browser&apos;s location and history without triggering a server page request.
The router can compose a &quot;natural&quot; URL that is indistinguishable from
one that would otherwise require a page load.</p><span>
</span><p>Here&apos;s the <em>Crisis Center</em> URL in this &quot;HTML 5 pushState&quot; style:</p><span>
</span><code format="." language="bash">localhost:3002/crisis-center/</code><p>Older browsers send page requests to the server when the location URL changes ...
unless the change occurs after a &quot;#&quot; (called the &quot;hash&quot;).
Routers can take advantage of this exception by composing in-application route
URLs with hashes.  Here&apos;s a &quot;hash URL&quot; that routes to the <em>Crisis Center</em></p><span>
</span><code format="." language="bash">localhost:3002/src/#/crisis-center/</code><p>The Angular Component Router supports both styles with two <code>LocationStrategy</code> providers:</p><span>
</span><ol>
<li><code>PathLocationStrategy</code> - the default &quot;HTML 5 pushState&quot; style.</li>
<li><code>HashLocationStrategy</code> - the &quot;hash URL&quot; style.</li>
</ol><span>
</span><p>The <code>RouterModule.forRoot</code> function sets the <code>LocationStrategy</code> to the <code>PathLocationStrategy</code>,
making it the default strategy.
We can switch to the <code>HashLocationStrategy</code> with an override during the bootstrapping process if we prefer it.</p><span>
</span><h3 id="which-strategy-is-best-">Which Strategy is Best?</h3><span>
</span><p>We must choose a strategy and we need to make the right call early in the project.
It won&apos;t be easy to change later once the application is in production
and there are lots of application URL references in the wild.</p><span>
</span><p>Almost all Angular 2 projects should use the default HTML 5 style.
It produces URLs that are easier for users to understand.
And it preserves the option to do <strong>server-side rendering</strong> later.</p><span>
</span><p>Rendering critical pages on the server is a technique that can greatly improve
perceived responsiveness when the app first loads.
An app that would otherwise take ten or more seconds to start
could be rendered on the server and delivered to the user&apos;s device
in less than a second.</p><span>
</span><p>This option is only available if application URLs look like normal web URLs
without hashes (#) in the middle.</p><span>
</span><p>Stick with the default unless you have a compelling reason to
resort to hash routes.</p><span>
</span><h3 id="html-5-urls-and-the-lt-base-href-">HTML 5 URLs and the  <em>&lt;base href&gt;</em></h3><span>
</span><p>While the router uses the &quot;<a href="https://developer.mozilla.org/en-US/docs/Web/API/History_API#Adding_and_modifying_history_entries">HTML 5 pushState</a>&quot;
style by default, we <em>must</em> configure that strategy with a <strong>base href</strong></p><span>
</span><p>The preferred way to configure the strategy is to add a
<a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base">&lt;base href&gt; element</a> tag
in the <code>&lt;head&gt;</code> of the <code>index.html</code>.</p><span>
</span><code language="html" format="">&lt;base href=&quot;/&quot;&gt;
</code><p>Without that tag, the browser may not be able to load resources
(images, css, scripts) when &quot;deep linking&quot; into the app.
Bad things could happen when someone pastes an application link into the
browser&apos;s address bar or clicks such a link in an email link.</p><span>
</span><p>Some developers may not be able to add the <code>&lt;base&gt;</code> element, perhaps because they don&apos;t have
access to <code>&lt;head&gt;</code> or the <code>index.html</code>.</p><span>
</span><p>Those developers may still use HTML 5 URLs by taking two remedial steps:</p><span>
</span><ol>
<li>Provide the router with an appropriate <code>APP_BASE_HREF</code> value.</li>
<li>Use <strong>absolute URLs</strong> for all web resources: css, images, scripts, and template html files.</li>
</ol><span>
</span><h3 id="-hashlocationstrategy-"><em>HashLocationStrategy</em></h3><span>
</span><p>We can go old-school with the <code>HashLocationStrategy</code> by
providing the <code>useHash: true</code> in an object as the second argument of the <code>RouterModule.forRoot</code>
in our root NgModule.</p><span>
</span><p>app/app.module.ts (hash URL strategy)</p><code language="ts" format="">import { NgModule }       from &apos;@angular/core&apos;;
import { BrowserModule }  from &apos;@angular/platform-browser&apos;;
import { FormsModule }    from &apos;@angular/forms&apos;;
import { Routes, RouterModule }   from &apos;@angular/router&apos;;

import { AppComponent }   from &apos;./app.component&apos;;

const routes: Routes = [

];

@NgModule({
  imports: [
    BrowserModule,
    FormsModule,
    RouterModule.forRoot(routes, { useHash: true })  // .../#/crisis-center/
  ],
  declarations: [
    AppComponent
  ],
  providers: [

  ],
  bootstrap: [ AppComponent ]
})
export class AppModule {
}
</code><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--></div></div>
        </article>
      
        <article>
          <h3>Security - ts</h3>
          <div><div class="showcase-content"><p>Web application security has many aspects. This chapter describes Angular&apos;s built in
protections against common web application vulnerabilities and attacks, such as Cross Site
Scripting Attacks. It does not cover application level security, such as authentication (<em>Who is
this user?</em>) or authorization (<em>What can this user do?</em>).</p><span>
</span><p>The <a href="https://www.owasp.org/index.php/Category:OWASP_Guide_Project">Open Web Application Security Project (OWASP)</a>
has further information on the attacks and mitigations described below.</p><span>
</span><span>
</span><ul>
<li><a href="https://angular.io/docs/ts/latest/guide/security.html#report-issues">Reporting Vulnerabilities</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/security.html#best-practices">Best Practices</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/security.html#xss">Preventing Cross-Site Scripting (XSS)</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/security.html#bypass-security-apis">Trusting Safe Values</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/security.html#http">HTTP-level Vulnerabilities</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/security.html#code-review">Auditing Angular Applications</a></li>
</ul><span>
</span><p>Try the <live-example></live-example> of the code shown in this chapter.</p><span>
</span><h2 id="report-issues">Reporting Vulnerabilities</h2><p>Email us at <a href="mailto:security@angular.io">security@angular.io</a> to report vulnerabilities in
Angular itself.</p><span>
</span><p>For further details on how Google handles security issues please refer to <a href="https://www.google.com/about/appsecurity/">Google&apos;s security
philosophy</a>.</p><span>
</span><h2 id="best-practices">Best Practices</h2><ul>
<li><p><strong>Keep current with the latest Angular library releases.</strong>
We regularly update our Angular libraries and these updates may fix security defects discovered in
previous version. Check the Angular <a href="https://github.com/angular/angular/blob/master/CHANGELOG.md">change
log</a> for security-related updates.</p>
</li>
<li><p><strong>Don&apos;t modify your copy of Angular.</strong>
Private, customized versions of Angular tend to fall behind the current version and may neglect
important security fixes and enhancements. Instead, share your Angular improvements with the
community and make a pull request.</p>
</li>
<li><p><strong>Avoid Angular APIs marked in the documentation as &#x201C;<a href="https://angular.io/docs/ts/latest/guide/security.html#bypass-security-apis"><em>Security Risk</em></a>&#x201D;.</strong></p>
</li>
</ul><span>
</span><h2 id="xss">Preventing Cross-Site Scripting (XSS)</h2><p><a href="https://en.wikipedia.org/wiki/Cross-site_scripting">Cross-Site Scripting (XSS)</a> enables attackers
to inject malicious code into web pages. Such code can then, for example, steal user&apos;s data (in
particular their login data), or perform actions impersonating the user. This is one of the most
common attacks on the web.</p><span>
</span><p>To block XSS attacks, we must prevent malicious code from entering the DOM. For example, if an
attacker can trick us into inserting a <code>&lt;script&gt;</code> tag in the DOM, they can run arbitrary code on
our website. The attack is not limited to <code>&lt;script&gt;</code> tags - many elements and properties in the
DOM allow code execution, for example <code>&lt;img onerror=&quot;...&quot;&gt;</code>, <code>&lt;a href=&quot;javascript:...&quot;&gt;</code>. If
attacker controlled data enters the DOM, we have to expect security vulnerabilities.</p><span>
</span><h3 id="angular-s-cross-site-scripting-security-model">Angular&#x2019;s Cross-site Scripting Security Model</h3><span>
</span><p>To systematically block XSS bugs, Angular treats all values as untrusted by default. When a value
is inserted into the DOM from a template, via property, attribute, style, or class binding, or via
interpolation, Angular will sanitize and escape untrusted values.</p><span>
</span><p><strong>Angular templates are the same as executable code</strong>: HTML, attributes, and binding expressions
(but not the values bound!) in templates are trusted to be safe. That means applications must
prevent potentially attacker controlled values from ever making it into the source code of a
template. Never generate template source code by concatenating user input and templates! Using
the <a href="https://angular.io/docs/ts/latest/guide/security.html#offline-template-compiler">offline template compiler</a> is an effective way to prevent these
vulnerabilities, also known as template injection.</p><span>
</span><h3 id="sanitization-and-security-contexts">Sanitization and security contexts</h3><span>
</span><p>Sanitization inspects an untrusted value and turns it into a value that is safe to insert into
the DOM. In many cases, values do not get changed by this at all. Sanitization depends on context:
a value that is harmless in CSS is potentially dangerous in a URL.</p><span>
</span><p>Angular defines four security contexts: HTML, style, URL, and resource URL.</p><span>
</span><ul>
<li>HTML is used when interpreting a value as HTML, e.g., when binding to <code>innerHtml</code></li>
<li>Style is used when binding CSS into the <code>style</code> property</li>
<li>URL is used for URL properties such as <code>&lt;a href&gt;</code></li>
<li>Resource URLs are URLs that will be loaded and executed as code, e.g., in <code>&lt;script src&gt;</code></li>
</ul><span>
</span><p>Angular sanitizes untrusted values for the first three items; sanitizing resource URLs is not
possible as they contain arbitrary code. In development mode, Angular prints a console warning
when it has to change a value during sanitization.</p><span>
</span><h3 id="sanitization-example">Sanitization example</h3><span>
</span><p>The template below binds the value of <code>htmlSnippet</code>, once by interpolating it into an element&apos;s
content, and once by binding it to the <code>innerHTML</code> property of an element.</p><span>
</span><p>app/inner-html-binding.component.html</p><code language="html" format="linenums">&lt;h3&gt;Binding innerHTML&lt;/h3&gt;
&lt;p&gt;Bound value:&lt;/p&gt;
&lt;p class=&quot;e2e-inner-html-interpolated&quot;&gt;{{htmlSnippet}}&lt;/p&gt;
&lt;p&gt;Result of binding to innerHTML:&lt;/p&gt;
&lt;p class=&quot;e2e-inner-html-bound&quot; [innerHTML]=&quot;htmlSnippet&quot;&gt;&lt;/p&gt;
</code><p>Interpolated content is always escaped - the HTML is not interpreted, and the browser displays
angle brackets in the elements text content.</p><span>
</span><p>For the HTML to be interpreted, we must bind to an HTML property, such as <code>innerHTML</code>. But binding
a potentially attacker controlled value into <code>innerHTML</code> would normally cause an XSS
vulnerability. For example, code contained in a <code>&lt;script&gt;</code> tag would be executed.</p><span>
</span><p>app/inner-html-binding.component.ts (inner-html-controller)</p><code language="ts" format="">export class InnerHtmlBindingComponent {
  // E.g. a user/attacker controlled value from a URL.
  htmlSnippet = &apos;Template &lt;script&gt;alert(&quot;0wned&quot;)&lt;/script&gt; &lt;b&gt;Syntax&lt;/b&gt;&apos;;
}
</code><p>Angular recognizes the value as unsafe, and automatically sanitizes it. It removes the <code>&lt;script&gt;</code>
tag but keeps safe content, such as the text content of the <code>&lt;script&gt;</code> tag, or the <code>&lt;b&gt;</code> element.</p><span>
</span><figure class="image-display"><img src="https://angular.io/resources/images/devguide/security/binding-inner-html.png" alt="A screenshot showing interpolated and bound HTML values"></figure><h3 id="avoid-direct-use-of-the-dom-apis">Avoid direct use of the DOM APIs</h3><span>
</span><p>The built-in browser DOM APIs do not automatically protect you from security vulnerabilities.
For example, <code>document</code>, the node available through <code>ElementRef</code>, and many third party APIs
contain unsafe methods. Avoid directly interacting with the DOM, and instead use Angular
templates where possible.</p><span>
</span><h3 id="content-security-policy">Content Security Policy</h3><span>
</span><p>A <a href="http://www.html5rocks.com/en/tutorials/security/content-security-policy/">Content Security Policy (CSP)</a> is a defense-in-depth
technique to prevent XSS. To enable CSP, configure your web server to return an appropriate
<code>Content-Security-Policy</code> HTTP header.</p><span>
</span><span>
</span><h3 id="use-the-offline-template-compiler">Use the Offline Template Compiler</h3><span>
</span><p>The offline template compiler prevents a whole class of vulnerabilities called template injection,
and also greatly improves application performance. Use the offline template compiler in production
deployments. Do not dynamically generate templates. Angular trusts template code, so generating
templates, in particular containing user data, circumvents Angular&apos;s built-in protections. See the
<a href="https://angular.io/docs/ts/latest/cookbook/dynamic-form.html">Dynamic Forms Cookbook</a> on how to dynamically construct forms in a
safe way.</p><span>
</span><h3 id="server-side-xss-protection">Server side XSS protection</h3><span>
</span><p>HTML constructed on the server is vulnerable to injection attacks. Injecting template code into an
Angular application is the same as injecting executable code into the
application; it gives the attacker full control over the application. To prevent this, make sure
to use a templating language that automatically escapes values to prevent XSS vulnerabilities on
the server. Do not generate Angular templates on the server side using a templating language, this
carries a high risk of introducing template injection vulnerabilities.</p><span>
</span><h2 id="bypass-security-apis">Trusting Safe Values</h2><p>Sometimes applications genuinely need to include executable code, display an <code>&lt;iframe&gt;</code> from some
URL, or construct potentially dangerous URLs. To prevent automatic sanitization in this situation,
you can tell Angular that you inspected a value, checked how it is generated, and made sure it is
always secure. But <strong>be careful</strong>! If you trust a value that can be malicious, you will likely
introduce a security vulnerability into your application. If in doubt, find a professional
security reviewer.</p><span>
</span><p>You can mark a value as trusted by injecting <code>DomSanitizer</code>, and calling one of the
following methods.</p><span>
</span><ul>
<li><code>bypassSecurityTrustHtml</code></li>
<li><code>bypassSecurityTrustScript</code></li>
<li><code>bypassSecurityTrustStyle</code></li>
<li><code>bypassSecurityTrustUrl</code></li>
<li><code>bypassSecurityTrustResourceUrl</code></li>
</ul><span>
</span><p>Remember, whether a value is safe depends on context, so you need to choose the right context for
your intended use of the value. Imagine the following template needs to bind a URL to a
<code>javascript:alert(...)</code> call.</p><span>
</span><p>app/bypass-security.component.html (dangerous-url)</p><code language="html" format="">&lt;h4&gt;A untrusted URL:&lt;/h4&gt;
&lt;p&gt;&lt;a class=&quot;e2e-dangerous-url&quot; [href]=&quot;dangerousUrl&quot;&gt;Click me&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;A trusted URL:&lt;/h4&gt;
&lt;p&gt;&lt;a class=&quot;e2e-trusted-url&quot; [href]=&quot;trustedUrl&quot;&gt;Click me&lt;/a&gt;&lt;/p&gt;
</code><p>Normally, Angular automatically sanitizes the URL, disables the dangerous code and,
in development mode, logs this action to the console. To prevent
this, we can mark the URL value as a trusted URL using the <code>bypassSecurityTrustUrl</code> call:</p><span>
</span><p>app/bypass-security.component.ts (trust-url)</p><code language="ts" format="">constructor(private sanitizer: DomSanitizer) {
  // javascript: URLs are dangerous if attacker controlled.
  // Angular sanitizes them in data binding, but we can
  // explicitly tell Angular to trust this value:
  this.dangerousUrl = &apos;javascript:alert(&quot;Hi there&quot;)&apos;;
  this.trustedUrl = sanitizer.bypassSecurityTrustUrl(this.dangerousUrl);
</code><figure class="image-display"><img src="https://angular.io/resources/images/devguide/security/bypass-security-component.png" alt="A screenshot showing an alert box created from a trusted URL"></figure><p>If we need to convert user input into a trusted value, it can be convenient to do so in a
controller method. The template below allows users to enter a YouTube video ID, and load the
corresponding video in an <code>&lt;iframe&gt;</code>. The <code>&lt;iframe src&gt;</code> attribute is a resource URL security
context, because an untrusted source can, e.g., smuggle in file downloads that unsuspecting users
would execute. So we call a method on the controller to construct a trusted video URL, which
Angular then allows binding into <code>&lt;iframe src&gt;</code>.</p><span>
</span><p>app/bypass-security.component.html (iframe-videoid)</p><code language="html" format="">&lt;h4&gt;Resource URL:&lt;/h4&gt;
&lt;p&gt;&lt;label&gt;Showing: &lt;input (input)=&quot;updateVideoUrl($event.target.value)&quot;&gt;&lt;/label&gt;&lt;/p&gt;
&lt;p&gt;Trusted:&lt;/p&gt;
&lt;iframe class=&quot;e2e-iframe-trusted-src&quot; width=&quot;640&quot; height=&quot;390&quot; [src]=&quot;videoUrl&quot;&gt;&lt;/iframe&gt;
&lt;p&gt;Untrusted:&lt;/p&gt;
&lt;iframe class=&quot;e2e-iframe-untrusted-src&quot; width=&quot;640&quot; height=&quot;390&quot; [src]=&quot;dangerousVideoUrl&quot;&gt;&lt;/iframe&gt;
</code><p>app/bypass-security.component.ts (trust-video-url)</p><code language="ts" format="">updateVideoUrl(id: string) {
  // Appending an ID to a YouTube URL is safe.
  // Always make sure to construct SafeValue objects as
  // close as possible to the input data, so
  // that it&apos;s easier to check if the value is safe.
  this.dangerousVideoUrl = &apos;https://www.youtube.com/embed/&apos; + id;
  this.videoUrl =
      this.sanitizer.bypassSecurityTrustResourceUrl(this.dangerousVideoUrl);
}
</code><h2 id="http">HTTP-level Vulnerabilities</h2><p>Angular has built in support to help prevent two common HTTP vulnerabilities, Cross-site Request
Forgery (XSRF) and Cross-site Script Inclusion (XSSI). Both of these must be primarily mitigated
on the server side, but Angular ships helpers to make integration on the client side easier.</p><span>
</span><h3 id="xsrf">Cross-site Request Forgery (XSRF)</h3><p>In a Cross-site Request Forgery (XSRF or CSRF), an attacker tricks the user into visiting a
<em>different</em> page, and has them, e.g., submit a form that sends a request to your application&apos;s
web server. If the user is logged into your application, the browser will send authentication
cookies, and the attacker could &#x2014; for example &#x2014; cause a bank transfer in the user&apos;s name with
the right request.</p><span>
</span><p>To prevent this, your application must ensure that user requests originate in your own
application, not on a different site. A common technique is that the server sends a randomly
generated authentication token in a cookie, often with the name <code>XSRF-TOKEN</code>. Cookies can only
be read by the website on which they are set, so only your own application can read this token. On
each API request, the server then validates the client by checking that the token is sent back,
usually in an HTTP header called <code>X-XSRF-TOKEN</code>.</p><span>
</span><p>The Angular <code>http</code> client has built-in support for this technique. The default
<code>CookieXSRFStrategy</code> looks for a cookie called <code>XSRF-TOKEN</code> and sets an HTTP request header named
<code>X-XSRF-TOKEN</code> with the value of that cookie on every request. The server must set the
<code>XSRF-TOKEN</code> cookie, and validate the response header for each state modifying request.</p><span>
</span><p>XSRF tokens should be unique per user and session, have a large random value generated by a
cryptographically secure random number generator, and expire.</p><span>
</span><p>Angular applications can customize cookie and header names by binding their own
<code>CookieXSRFStrategy</code> value, or implement an entirely custom <code>XSRFStrategy</code> by providing a custom
binding for that type, by adding either of the following to your providers list:</p><span>
</span><code language="typescript">{ provide: XSRFStrategy, useValue: new CookieXSRFStrategy(&apos;myCookieName&apos;, &apos;My-Header-Name&apos;)}
{ provide: XSRFStrategy, useClass: MyXSRFStrategy}
</code><p>Learn about Cross Site Request Forgery (XSRF) at the Open Web Application Security Project (OWASP)
<a href="https://www.owasp.org/index.php/Cross-Site_Request_Forgery_%28CSRF%29">here</a> and
<a href="https://www.owasp.org/index.php/CSRF_Prevention_Cheat_Sheet">here</a>. This <a href="https://seclab.stanford.edu/websec/csrf/csrf.pdf">Stanford University
paper</a> is also a rich source of detail.</p><span>
</span><h3 id="xssi">Cross-site Script Inclusion (XSSI)</h3><p>Cross-site Script Inclusion, also known as JSON vulnerability, can allow an attacker&apos;s website to
read data from a JSON API. The attack works on older browser by overriding native JavaScript
object constructors, and then including an API URL using a <code>&lt;script&gt;</code> tag.</p><span>
</span><p>This attack is only successful if the returned JSON is executable as JavaScript. Servers can
prevent it by prefixing all JSON responses to make them non-executable, by convention using the
well-known string <code>&quot;)]}&apos;,\n&quot;</code>.</p><span>
</span><p>Angular&apos;s <code>Http</code> library recognizes this convention and automatically strips the string
<code>&quot;)]}&apos;,\n&quot;</code> from all responses before further parsing.</p><span>
</span><p>Learn more in the XSSI section of this <a href="https://security.googleblog.com/2011/05/website-security-for-webmasters.html">Google web security blog
post</a></p><span>
</span><h2 id="code-review">Auditing Angular Applications</h2><p>Angular applications should follow the same security principles as regular web applications, and
should be audited as such. Angular specific APIs that should be audited in a security review,
such as the <a href="https://angular.io/docs/ts/latest/guide/security.html#bypass-security-apis"><em>bypassSecurityTrust</em></a> APIs, are marked in the documentation
as security sensitive.</p><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--></div></div>
        </article>
      
        <article>
          <h3>Structural Directives</h3>
          <div><div class="showcase-content"><p>One of the defining features of a single page application is its manipulation
of the DOM tree. Instead of serving a whole new page every time a user
navigates, whole sections of the DOM appear and disappear according
to the application state. In this chapter we&apos;ll to look at how Angular
manipulates the DOM and how we can do it ourselves in our own directives.</p><span>
</span><p>In this chapter we will</p><span>
</span><ul>
<li><a href="https://angular.io/docs/ts/latest/guide/structural-directives.html#definition">learn what structural directives are</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/structural-directives.html#ngIf">study <em>ngIf</em></a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/structural-directives.html#template">discover the &lt;template&gt; element</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/structural-directives.html#asterisk">understand the asterisk (*) in <em>*ngFor</em></a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/structural-directives.html#unless">write our own structural directive</a></li>
</ul><span>
</span><p>Try the <live-example></live-example>.</p><span>
</span><a id="definition"></a><h2 id="what-are-structural-directives-">What are structural directives?</h2><span>
</span><p>There are three kinds of Angular directives:</p><span>
</span><ol>
<li>Components</li>
<li>Attribute directives</li>
<li>Structural directives</li>
</ol><span>
</span><p>The <em>Component</em> is really a directive with a template.
It&apos;s the most common of the three directives and we write lots of them as we build our application.</p><span>
</span><p>The <a href="https://angular.io/docs/ts/latest/guide/attribute-directives.html"><em>Attribute</em> directive</a> changes the appearance or behavior of an element.
The built-in <a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#ngStyle">NgStyle</a> directive, for example,
can change several element styles at the same time.
We can use it to render text bold, italic, and lime green by binding to a
component property that requests such a sickening result.</p><span>
</span><p>A <em>Structural</em> directive changes the DOM layout by adding and removing DOM elements.
We&apos;ve seen three of the built-in structural directives in other chapters: <a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#ngIf">ngIf</a>,
<a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#ngSwitch">ngSwitch</a> and <a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#ngFor">ngFor</a>.</p><span>
</span><code language="html" format="">&lt;div *ngIf=&quot;hero&quot;&gt;{{hero}}&lt;/div&gt;
&lt;div *ngFor=&quot;let hero of heroes&quot;&gt;{{hero}}&lt;/div&gt;
&lt;div [ngSwitch]=&quot;status&quot;&gt;
  &lt;template [ngSwitchCase]=&quot;&apos;in-mission&apos;&quot;&gt;In Mission&lt;/template&gt;
  &lt;template [ngSwitchCase]=&quot;&apos;ready&apos;&quot;&gt;Ready&lt;/template&gt;
  &lt;template ngSwitchDefault&gt;Unknown&lt;/template&gt;
&lt;/div&gt;
</code><a id="ngIf"></a><h2 id="ngif-case-study">NgIf Case Study</h2><span>
</span><p>Let&#x2019;s focus on <code>ngIf</code>. It&apos;s a great example of a structural
directive: it takes a boolean and makes an entire chunk of DOM appear
or disappear.</p><span>
</span><code language="html" format="">&lt;p *ngIf=&quot;condition&quot;&gt;
  condition is true and ngIf is true.
&lt;/p&gt;
&lt;p *ngIf=&quot;!condition&quot;&gt;
  condition is false and ngIf is false.
&lt;/p&gt;
</code><p>The <code>ngIf</code> directive does not hide the element.
Using browser developer tools we can see that, when the condition is true, the top
paragraph is in the DOM and the bottom disused paragraph is completely
absent from the DOM! In its place are empty <code>&lt;script&gt;</code> tags.</p><span>
</span><figure class="image-display"><img src="https://angular.io/resources/images/devguide/structural-directives/element-not-in-dom.png" alt="element not in dom"></figure><h3 id="why-remove-rather-than-hide-">Why <em>remove</em> rather than <em>hide</em>?</h3><span>
</span><p>We could hide the unwanted paragraph by setting its css <code>display</code> style to <code>none</code>.
The element would remain in the DOM while invisible. Instead we removed it with <code>ngIf</code>.</p><span>
</span><p>The difference matters. When we hide an element,
the component&apos;s behavior continues.
It remains attached to its DOM element. It continues to listen to events.
Angular keeps checking for changes that could affect data bindings.
Whatever the component was doing it keeps doing.</p><span>
</span><p>Although invisible, the component &#x2014; and all of its descendent components &#x2014;
tie up resources that might be more useful elsewhere.
The performance and memory burden can be substantial and the user may not benefit at all.</p><span>
</span><p>On the positive side, showing the element again is very quick.
The component&apos;s previous state is preserved and ready to display.
The component doesn&apos;t re-initialize &#x2014; an operation that could be expensive.</p><span>
</span><p><code>ngIf</code> is different.
Setting <code>ngIf</code> to false <strong>does</strong> affect the component&apos;s resource consumption.
Angular removes the element from DOM, stops change detection for the associated component,
detaches it from DOM events (the attachments that it made) and destroys the component.
The component can be garbage-collected (we hope) and free up memory.</p><span>
</span><p>Components often have child components which themselves have children.
All of them are destroyed when <code>ngIf</code> destroys the common ancestor.
This cleanup effort is usually a good thing.</p><span>
</span><p>Of course it isn&apos;t <em>always</em> a good thing.
It might be a bad thing if we need that particular component again soon.</p><span>
</span><p>The component&apos;s state might be expensive to re-construct.
When <code>ngIf</code> becomes <code>true</code> again, Angular recreates the component and its subtree.
Angular runs every component&apos;s initialization logic again. That could be expensive ... as when
a component re-fetches data that had been in memory just moments ago.</p><span>
</span><div class="l-sub-section"><p><em>Design thought</em>: minimize initialization effort and consider caching state in a
companion service.</p><span>
</span></div><p>Although there are pros and cons to each approach,
in general it is best to use <code>ngIf</code> to remove unwanted components rather than
hide them.</p><span>
</span><p><strong>These same considerations apply to every structural directive, whether built-in or custom.</strong>
We should ask ourselves &#x2014; and the users of our directives &#x2014; to think carefully
about the consequences of adding and removing elements and of creating and destroying components.</p><span>
</span><p>Let&apos;s see these dynamics at work. For fun, we&apos;ll stack the deck <em>against</em>
our recommendation and consider a component called <code>heavy-loader</code> that
<strong><em>pretends</em></strong> to load a ton of data when initialized.</p><span>
</span><p>We&apos;ll display two instances of the component.  We toggle the visibility of the first one with CSS.
We toggle the second into and out of the DOM with <code>ngIf</code>.</p><span>
</span><code-tabs><code language="html" name="template (excerpt)" format="linenums">&lt;div&gt;&lt;!-- Visibility --&gt;
  &lt;button (click)=&quot;isVisible = !isVisible&quot;&gt;show | hide&lt;/button&gt;
  &lt;heavy-loader [style.display]=&quot;isVisible ? &apos;inline&apos; : &apos;none&apos;&quot; [logs]=&quot;logs&quot;&gt;&lt;/heavy-loader&gt;
&lt;/div&gt;

&lt;div&gt;&lt;!-- NgIf --&gt;
  &lt;button (click)=&quot;condition = !condition&quot;&gt;if | !if&lt;/button&gt;
  &lt;heavy-loader *ngIf=&quot;condition&quot; [logs]=&quot;logs&quot;&gt;&lt;/heavy-loader&gt;
&lt;/div&gt;

&lt;h4&gt;heavy-loader log:&lt;/h4&gt;
&lt;div *ngFor=&quot;let message of logs&quot;&gt;{{message}}&lt;/div&gt;
</code><code language="ts" name="heavy-loader.component.ts" format="linenums">import { Component, Input, OnDestroy, OnInit } from &apos;@angular/core&apos;;

let nextId = 1;

@Component({
  selector: &apos;heavy-loader&apos;,
  template: &apos;&lt;span&gt;heavy loader #{{id}} on duty!&lt;/span&gt;&apos;
})
export class HeavyLoaderComponent implements OnDestroy, OnInit {
  id = nextId++;
  @Input() logs: string[];

  ngOnInit() {
    // Mock todo: get 10,000 rows of data from the server
    this.log(`heavy-loader ${this.id} initialized,
      loading 10,000 rows of data from the server`);
  }

  ngOnDestroy() {
    // Mock todo: clean-up
    this.log(`heavy-loader ${this.id} destroyed, cleaning up`);
  }

  private log(msg: string) {
    this.logs.push(msg);
    this.tick();
  }

  // Triggers the next round of Angular change detection
  // after one turn of the browser event loop
  // ensuring display of msg added in onDestroy
  private tick() { setTimeout(() =&gt; { }, 0); }
}
</code></code-tabs><p>We also log when a component is created or destroyed
using the built-in <code>ngOnInit</code> and <code>ngOnDestroy</code> <a href="https://angular.io/docs/ts/latest/guide/lifecycle-hooks.html">lifecycle hooks</a>.
Here it is in action:</p><span>
</span><figure class="image-display"><img src="https://angular.io/resources/images/devguide/structural-directives/heavy-loader-toggle.gif" alt="heavy loader toggle"></figure><p>Both components are in the DOM at the start.
First we toggle the component&apos;s visibility repeatedly. The component never leaves the DOM.
When visible it&apos;s always the same instance and the log is quiet.</p><span>
</span><p>Then we toggle the second component with <code>ngIf</code>.
We create a new instance every time and the log shows that we&apos;re paying
a heavy price to create and destroy it.</p><span>
</span><p>If we really expected to &quot;wink&quot; the component like this, toggling visibility would be the better choice.
In most UIs, when we &quot;close&quot; a component we&apos;re unlikely see it again for a long time, if ever.
The <code>ngIf</code> would be preferred in that case.</p><span>
</span><a id="template"></a><h2 id="the-lt-template-tag">The <em>&lt;template&gt;</em> tag</h2><span>
</span><p>Structural directives, like <code>ngIf</code>, do their magic by using the
<a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/template">HTML 5 template tag</a>.</p><span>
</span><p>Outside of an Angular app, the <code>&lt;template&gt;</code> tag&apos;s default CSS <code>display</code> property is <code>none</code>.
It&apos;s contents are <strong><em>invisible</em></strong> within
a hidden <a href="https://developer.mozilla.org/en/docs/Web/API/DocumentFragment">document fragment</a>.</p><span>
</span><p>Inside of an app, Angular <strong><em>removes</em></strong> the<code>&lt;template&gt;</code> tags and their children.
The contents are gone &#x2014; but not forgotten as we&apos;ll see soon.</p><span>
</span><p>We can confirm these effects by wrapping the middle &quot;hip&quot; of the phrase &quot;Hip! Hip! Hooray!&quot; within a <code>&lt;template&gt;</code> tag.</p><span>
</span><code language="html" format="">&lt;p&gt;
  Hip!
&lt;/p&gt;
&lt;template&gt;
  &lt;p&gt;
    Hip!
  &lt;/p&gt;
&lt;/template&gt;
&lt;p&gt;
  Hooray!
&lt;/p&gt;
</code><p>The display is a &apos;Hip! Hooray!&apos;, short of perfect enthusiasm. The DOM effects are different when Angular is in control.</p><span>
</span><figure class="image-display"><img src="https://angular.io/resources/images/devguide/structural-directives/template-in-out-of-a2.png" alt="template outside angular"></figure><p>Evidently Angular replaces the <code>&lt;template&gt;</code> tag and its contents with empty <code>&lt;script&gt;</code> tags.
That&apos;s just its default behavior.
It can do something different as we saw when applying a variety of <code>ngSwitch</code> directives to <code>&lt;template&gt;</code> tags:</p><span>
</span><code language="html" format="">&lt;div [ngSwitch]=&quot;status&quot;&gt;
  &lt;template [ngSwitchCase]=&quot;&apos;in-mission&apos;&quot;&gt;In Mission&lt;/template&gt;
  &lt;template [ngSwitchCase]=&quot;&apos;ready&apos;&quot;&gt;Ready&lt;/template&gt;
  &lt;template ngSwitchDefault&gt;Unknown&lt;/template&gt;
&lt;/div&gt;
</code><p>When one of those <code>ngSwitch</code> conditions is true, Angular inserts the template&apos;s content into the DOM.</p><span>
</span><p>What does this have to do with <code>ngIf</code> and <code>ngFor</code>?  We didn&apos;t use a <code>&lt;template&gt;</code> tag with those directives.</p><span>
</span><a id="asterisk"></a><h2 id="the-asterisk-effect">The asterisk (*) effect</h2><span>
</span><p>Here are those directives again. See the difference?</p><span>
</span><code language="html" format="">&lt;div *ngIf=&quot;hero&quot;&gt;{{hero}}&lt;/div&gt;
&lt;div *ngFor=&quot;let hero of heroes&quot;&gt;{{hero}}&lt;/div&gt;
</code><p>We&apos;re prefixing these directive names with an asterisk (*).</p><span>
</span><p>The asterisk is &quot;syntactic sugar&quot;. It simplifies <code>ngIf</code> and <code>ngFor</code> for both the writer and the reader.
Under the hood, Angular replaces the asterisk version with a more verbose <code>&lt;template&gt;</code> form.</p><span>
</span><p>The next two <code>ngIf</code> examples are effectively the same and we may write in either style:</p><span>
</span><code language="html" format="">&lt;!-- Examples (A) and (B) are the same --&gt;
&lt;!-- (A) *ngIf paragraph --&gt;
&lt;p *ngIf=&quot;condition&quot;&gt;
  Our heroes are true!
&lt;/p&gt;

&lt;!-- (B) [ngIf] with template --&gt;
&lt;template [ngIf]=&quot;condition&quot;&gt;
  &lt;p&gt;
    Our heroes are true!
  &lt;/p&gt;
&lt;/template&gt;
</code><p>Most of us would rather write in style (A).</p><span>
</span><p>It&apos;s worth knowing that Angular expands style (A) into style (B).
It moves the paragraph and its contents inside a <code>&lt;template&gt;</code> tag.
It moves the directive up to the <code>&lt;template&gt;</code> tag where it becomes a property binding,
surrounded in square brackets. The boolean value of the host component&apos;s <code>condition</code> property
determines whether the templated content is displayed or not.</p><span>
</span><p>Angular transforms <code>*ngFor</code> in a similar manner:</p><span>
</span><code language="html" format="">&lt;!-- Examples (A) and (B) are the same --&gt;

&lt;!-- (A) *ngFor div --&gt;
&lt;div *ngFor=&quot;let hero of heroes&quot;&gt;{{ hero }}&lt;/div&gt;

&lt;!-- (B) ngFor with template --&gt;
&lt;template ngFor let-hero [ngForOf]=&quot;heroes&quot;&gt;
  &lt;div&gt;{{ hero }}&lt;/div&gt;
&lt;/template&gt;
</code><p>The basic pattern is the same:&#xA0; create a <code>&lt;template&gt;</code>, relocate the content,
and move the directive onto the <code>&lt;template&gt;</code>.</p><span>
</span><p>There are extra nuances stemming from
Angular&apos;s <a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#ngForMicrosyntax">ngFor micro-syntax</a> which expands
into an additional <code>ngForOf</code> property binding (the iterable) and
the <code>hero</code> template input variable (the current item in each iteration).</p><span>
</span><a id="unless"></a><h2 id="make-a-structural-directive">Make a structural directive</h2><span>
</span><p>Let&apos;s write our own structural directive, an <code>Unless</code> directive, the not-so-evil twin of <code>ngIf</code>.</p><span>
</span><p>Unlike <code>ngIf</code> which displays the template content when <code>true</code>,
our directive displays the content when the condition is <strong><em>false</em></strong>.</p><span>
</span><p>Creating a directive is similar to creating a component.</p><span>
</span><ul>
<li><p>import the <code>Directive</code> decorator.</p>
</li>
<li><p>add a CSS <strong>attribute selector</strong> (in brackets) that identifies our directive.</p>
</li>
<li><p>specify the name of the public <code>input</code> property for binding
(typically the name of the directive itself).</p>
</li>
<li><p>apply the decorator to our implementation class.</p>
</li>
</ul><span>
</span><p>Here is how we begin:</p><span>
</span><p>unless.directive.ts (excerpt)</p><code language="ts" format="">import { Directive, Input } from &apos;@angular/core&apos;;

@Directive({ selector: &apos;[myUnless]&apos; })
export class UnlessDirective {
}
</code><div class="l-sub-section"><h3 id="selector-brackets-nbsp-">Selector brackets [&#xA0;]</h3><span>
</span><p>The CSS syntax for selecting an attribute is a name in square brackets.
We surround our directive name in square brackets. See <em>Directive configuration</em> on the
<a href="https://angular.io/docs/ts/latest/guide/cheatsheet.html">cheatsheet</a>.</p><span>
</span><h3 id="selector-name-prefixes">Selector name prefixes</h3><span>
</span><p>We recommend picking a selector name with a prefix to ensure
that it cannot conflict with any standard HTML attribute, now or in the future.</p><span>
</span><p>We do <strong>not</strong> prefix our <code>unless</code> directive name with <strong><code>ng</code></strong>.
That prefix belongs to Angular and
we don&apos;t want to confuse our directives with their directives.</p><span>
</span><p>Our prefix is <code>my</code>.</p><span>
</span></div><p>We&apos;ll need access to the template <em>and</em> something that can render its contents.
We access the template with a <code>TemplateRef</code>.  The renderer is a <code>ViewContainerRef</code>.
We inject both into our constructor as private variables.</p><span>
</span><code language="ts" format="">constructor(
  private templateRef: TemplateRef&lt;any&gt;,
  private viewContainer: ViewContainerRef
  ) { }
</code><p>The consumer of our directive will bind a boolean value to our directive&apos;s <code>myUnless</code> input property.
The directive adds or removes the template based on that value.</p><span>
</span><p>Let&apos;s add the <code>myUnless</code> property now as a setter-only property.</p><span>
</span><code language="ts" format="">@Input() set myUnless(condition: boolean) {
  if (!condition) {
    this.viewContainer.createEmbeddedView(this.templateRef);
  } else {
    this.viewContainer.clear();
  }
}
</code><div class="l-sub-section"><p>The <code>@Input()</code> annotation marks this property as an input for the directive.</p><span>
</span></div><p>Nothing fancy here: if the condition is false,
we render the template, otherwise we clear the element content.</p><span>
</span><p>The end result should look like this:</p><span>
</span><p>unless.directive.ts</p><code language="ts" format="linenums">import { Directive, Input } from &apos;@angular/core&apos;;

import { TemplateRef, ViewContainerRef } from &apos;@angular/core&apos;;

@Directive({ selector: &apos;[myUnless]&apos; })
export class UnlessDirective {

  constructor(
    private templateRef: TemplateRef&lt;any&gt;,
    private viewContainer: ViewContainerRef
    ) { }

  @Input() set myUnless(condition: boolean) {
    if (!condition) {
      this.viewContainer.createEmbeddedView(this.templateRef);
    } else {
      this.viewContainer.clear();
    }
  }
}
</code><p>Now we add it to the <code>declarations</code> array of the AppModule and try it.
First we add some test HTML to the template:</p><span>
</span><code language="html" format="">&lt;p *myUnless=&quot;condition&quot;&gt;
  condition is false and myUnless is true.
&lt;/p&gt;

&lt;p *myUnless=&quot;!condition&quot;&gt;
  condition is true and myUnless is false.
&lt;/p&gt;
</code><p>We run it and it behaves as expected, doing the opposite of <code>ngIf</code>.
When <code>condition</code> is <code>true</code>, the top paragraph is removed (replaced by <code>&lt;script&gt;</code> tags) and the bottom paragraph appears.</p><span>
</span><figure class="image-display"><img src="https://angular.io/resources/images/devguide/structural-directives/myUnless-is-true.png" alt="myUnless is true"></figure><p>Our <code>myUnless</code> directive is dead simple. Surely we left something out.
Surely <code>ngIf</code> is more complex?</p><span>
</span><p><a href="https://github.com/angular/angular/blob/master/modules/%40angular/common/src/directives/ng_if.ts">Look at the source code</a>.
It&apos;s well documented and we shouldn&apos;t be shy
about consulting the source when we want to know how something works.</p><span>
</span><p><code>ngIf</code> isn&apos;t much different! There are a few
additional checks to improve performance (don&apos;t clear or recreate the
view unless necessary) but otherwise it&apos;s much the same.</p><span>
</span><h2 id="wrap-up">Wrap up</h2><span>
</span><p>Here is the pertinent source for this chapter.</p><span>
</span><code-tabs><code language="ts" name="unless.directive.ts" format="linenums">import { Directive, Input } from &apos;@angular/core&apos;;

import { TemplateRef, ViewContainerRef } from &apos;@angular/core&apos;;

@Directive({ selector: &apos;[myUnless]&apos; })
export class UnlessDirective {

  constructor(
    private templateRef: TemplateRef&lt;any&gt;,
    private viewContainer: ViewContainerRef
    ) { }

  @Input() set myUnless(condition: boolean) {
    if (!condition) {
      this.viewContainer.createEmbeddedView(this.templateRef);
    } else {
      this.viewContainer.clear();
    }
  }
}
</code><code language="ts" name="heavy-loader.component.ts" format="linenums">import { Component, Input, OnDestroy, OnInit } from &apos;@angular/core&apos;;

let nextId = 1;

@Component({
  selector: &apos;heavy-loader&apos;,
  template: &apos;&lt;span&gt;heavy loader #{{id}} on duty!&lt;/span&gt;&apos;
})
export class HeavyLoaderComponent implements OnDestroy, OnInit {
  id = nextId++;
  @Input() logs: string[];

  ngOnInit() {
    // Mock todo: get 10,000 rows of data from the server
    this.log(`heavy-loader ${this.id} initialized,
      loading 10,000 rows of data from the server`);
  }

  ngOnDestroy() {
    // Mock todo: clean-up
    this.log(`heavy-loader ${this.id} destroyed, cleaning up`);
  }

  private log(msg: string) {
    this.logs.push(msg);
    this.tick();
  }

  // Triggers the next round of Angular change detection
  // after one turn of the browser event loop
  // ensuring display of msg added in onDestroy
  private tick() { setTimeout(() =&gt; { }, 0); }
}
</code><code language="ts" name="structural-directives.component.ts" format="linenums">import { Component } from &apos;@angular/core&apos;;

@Component({
  selector: &apos;structural-directives&apos;,
  templateUrl: &apos;app/structural-directives.component.html&apos;,
  styles: [&apos;button { min-width: 100px; }&apos;]
})
export class StructuralDirectivesComponent {
  heroes = [&apos;Mr. Nice&apos;, &apos;Narco&apos;, &apos;Bombasto&apos;];
  hero = this.heroes[0];
  condition = true;
  isVisible = true;
  logs: string[] = [];
  status = &apos;ready&apos;;
}
</code><code language="html
  " name="structural-directives.component.html" format="linenums">&lt;h1&gt;Structural Directives&lt;/h1&gt;

&lt;div *ngIf=&quot;hero&quot;&gt;{{hero}}&lt;/div&gt;
&lt;div *ngFor=&quot;let hero of heroes&quot;&gt;{{hero}}&lt;/div&gt;
&lt;div [ngSwitch]=&quot;status&quot;&gt;
  &lt;template [ngSwitchCase]=&quot;&apos;in-mission&apos;&quot;&gt;In Mission&lt;/template&gt;
  &lt;template [ngSwitchCase]=&quot;&apos;ready&apos;&quot;&gt;Ready&lt;/template&gt;
  &lt;template ngSwitchDefault&gt;Unknown&lt;/template&gt;
&lt;/div&gt;

&lt;hr&gt;

&lt;button
  (click)=&quot;condition = !condition&quot;
  [style.background] = &quot;condition ? &apos;orangered&apos;: &apos;lightgreen&apos;&quot;
  &gt;
  Set &apos;condition&apos; to {{condition ? &apos;False&apos;: &apos;True&apos;}}
&lt;/button&gt;

&lt;p *ngIf=&quot;condition&quot;&gt;
  condition is true and ngIf is true.
&lt;/p&gt;
&lt;p *ngIf=&quot;!condition&quot;&gt;
  condition is false and ngIf is false.
&lt;/p&gt;
&lt;p *myUnless=&quot;condition&quot;&gt;
  condition is false and myUnless is true.
&lt;/p&gt;

&lt;p *myUnless=&quot;!condition&quot;&gt;
  condition is true and myUnless is false.
&lt;/p&gt;

&lt;hr&gt;

&lt;div&gt;&lt;!-- Visibility --&gt;
  &lt;button (click)=&quot;isVisible = !isVisible&quot;&gt;show | hide&lt;/button&gt;
  &lt;heavy-loader [style.display]=&quot;isVisible ? &apos;inline&apos; : &apos;none&apos;&quot; [logs]=&quot;logs&quot;&gt;&lt;/heavy-loader&gt;
&lt;/div&gt;

&lt;div&gt;&lt;!-- NgIf --&gt;
  &lt;button (click)=&quot;condition = !condition&quot;&gt;if | !if&lt;/button&gt;
  &lt;heavy-loader *ngIf=&quot;condition&quot; [logs]=&quot;logs&quot;&gt;&lt;/heavy-loader&gt;
&lt;/div&gt;

&lt;h4&gt;heavy-loader log:&lt;/h4&gt;
&lt;div *ngFor=&quot;let message of logs&quot;&gt;{{message}}&lt;/div&gt;

&lt;hr&gt;

&lt;p&gt;
  Hip!
&lt;/p&gt;
&lt;template&gt;
  &lt;p&gt;
    Hip!
  &lt;/p&gt;
&lt;/template&gt;
&lt;p&gt;
  Hooray!
&lt;/p&gt;

&lt;hr&gt;

&lt;!-- Examples (A) and (B) are the same --&gt;
&lt;!-- (A) *ngIf paragraph --&gt;
&lt;p *ngIf=&quot;condition&quot;&gt;
  Our heroes are true!
&lt;/p&gt;

&lt;!-- (B) [ngIf] with template --&gt;
&lt;template [ngIf]=&quot;condition&quot;&gt;
  &lt;p&gt;
    Our heroes are true!
  &lt;/p&gt;
&lt;/template&gt;

&lt;hr&gt;

&lt;!-- Examples (A) and (B) are the same --&gt;

&lt;!-- (A) *ngFor div --&gt;
&lt;div *ngFor=&quot;let hero of heroes&quot;&gt;{{ hero }}&lt;/div&gt;

&lt;!-- (B) ngFor with template --&gt;
&lt;template ngFor let-hero [ngForOf]=&quot;heroes&quot;&gt;
  &lt;div&gt;{{ hero }}&lt;/div&gt;
&lt;/template&gt;
</code></code-tabs><p>We learned that we can manipulate our HTML layout with
structural directives like <code>ngFor</code> and <code>ngIf</code> and we
wrote our own structural directive, <code>myUnless</code>, to do something similar.</p><span>
</span><p>Angular offers more sophisticated techniques for managing layout
such as <em>structural components</em> that can take external content
and incorporate that content within their own templates.
Tab and tab pane controls are good examples.</p><span>
</span><p>We&apos;ll learn about structural components in a future chapter.</p><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--></div></div>
        </article>
      
        <article>
          <h3>Testing - ts</h3>
          <div><div class="showcase-content"><div class="alert is-important"><p>We are still preparing the testing guide with all the new testing features
introduced in RC5 and will update it very soon.</p><span>
</span></div><p>We write <strong>unit tests</strong> to explore and confirm the <strong>behavior</strong> of parts of our application.</p><span>
</span><ol>
<li>They <strong>guard</strong> against breaking existing code (&#x201C;regressions&#x201D;) when we make changes.</li>
<li>They <strong>clarify</strong> what  the code does both when used as intended and when faced with deviant conditions.</li>
<li>They <strong>reveal</strong> mistakes in design and implementation. Tests force us to look at our code from many angles. When a part of our application seems hard to test, we may have discovered a design flaw, something we can cure now rather than later when it becomes expensive to fix.</li>
</ol><span>
</span><a id="top"></a><h1 id="table-of-contents">Table of Contents</h1><span>
</span><ol>
<li><p><a href="https://angular.io/docs/ts/latest/guide/testing.html#jasmine-101">Jasmine Testing 101</a></p>
<ul>
<li>setup to run Jasmine tests in the browser</li>
<li>basic Jasmine testing skills</li>
<li>write simple Jasmine tests in TypeScript</li>
<li>debug a test in the browser</li>
</ul>
</li>
<li><p><a href="https://angular.io/docs/ts/latest/guide/testing.html#aut">The Application Under Test</a></p>
</li>
<li><p><a href="https://angular.io/docs/ts/latest/guide/testing.html#first-app-tests">First app test</a></p>
<ul>
<li>test a simple application interface outside of Angular</li>
<li>where to put the test file</li>
<li>load a test file with systemJS</li>
</ul>
</li>
<li><p><a href="https://angular.io/docs/ts/latest/guide/testing.html#pipe-testing">Pipe driven development</a></p>
<ul>
<li>create a test before creating a class</li>
<li>load multiple test files in our test harness, using system.js</li>
<li>add the Angular 2 library to our test harness</li>
<li>watch the new test fail, and fix it</li>
</ul>
</li>
<li><p>Test an Asynchronous Service (forthcoming)</p>
<ul>
<li>test an asynchronous service class outside of Angular</li>
<li>write a test plan in code</li>
<li>fake a dependency</li>
<li>master the <code>catch(fail).then(done)</code> pattern</li>
<li>move setup to <code>beforeEach</code></li>
<li>test when a dependency fails</li>
<li>control async test timeout</li>
</ul>
</li>
<li><p>The Angular Test Environment (forthcoming)</p>
<ul>
<li>the Angular test environment and why we need help</li>
<li>add the Angular Test libraries to the  test harness</li>
<li>test the same async service using Angular Dependency Injection</li>
<li>reduce friction with test helpers</li>
<li>introducing spies</li>
</ul>
</li>
<li><p>Test a Component (forthcoming)</p>
<ul>
<li>test the component outside of Angular</li>
<li>mock the dependent asynchronous service</li>
<li>simulate interaction with the view (no DOM)</li>
<li>use a spy-promise to control asynchronous test flow</li>
</ul>
</li>
<li><p>Test a Component in the DOM (forthcoming</p>
<ul>
<li>test the component inside the Angular test environment</li>
<li>use the <code>TestComponentBuilder</code></li>
<li>more test helpers</li>
<li>interact with the DOM</li>
<li>bind to a mock dependent asynchronous service</li>
</ul>
</li>
<li><p>Run the tests with karma (forthcoming)</p>
</li>
</ol><span>
</span><p>It&#x2019;s a big agenda. Fortunately, you can learn a little bit at a time and put each lesson to use.</p><span>
</span><a href="https://angular.io/docs/ts/latest/guide/testing.html#top" class="to-top">Back to top</a><a id="jasmine-101"></a><h1 id="jasmine-testing-101">Jasmine Testing 101</h1><span>
</span><p>We&#x2019;ll write our tests with the <a href="http://jasmine.github.io/2.3/introduction.html">Jasmine test framework</a>.
We&#x2019;ll start by getting <em>some</em> tests to work - <em>any</em> tests at all.</p><span>
</span><p>We will learn</p><span>
</span><ul>
<li>basic Jasmine testing skills</li>
<li>to run our tests in the browser</li>
<li>to write simple Jasmine tests in TypeScript</li>
<li>to debug a test in the browser</li>
</ul><span>
</span><p><strong>Create a new project folder</strong> perhaps called <code>angular2-unit-testing</code>.</p><span>
</span><h2 id="install-npm-packages-locally">Install npm packages locally</h2><span>
</span><p>Next follow all of  the steps prescribed in  &#x201C;Install npm packages locally&#x201D; of the
<a href="https://angular.io/docs/ts/latest/quickstart.html">QuickStart</a>.</p><span>
</span><p>We&#x2019;ll also add the Jasmine package via <code>npm</code>:</p><span>
</span><pre class="prettyprint lang-bash"><code>npm install jasmine-core --save-dev --save-exact</code></pre><div class="alert is-important"><p>Be sure to install <code>jasmine-core</code> , not <code>jasmine</code>!</p><span>
</span></div><p><strong>Create a sub-folder <code>src</code> </strong> for our tests and then <strong>cd into it</strong>.</p><span>
</span><p>We are going to <strong>display and control our tests in the browser</strong>.</p><span>
</span><div class="l-sub-section"><p>The browser is nice during development of a few tests. It&#x2019;s not the best venue for working with a lot of tests and it won&#x2019;t do at all for build automation. We&#x2019;ll switch to the karma test-runner when the time comes. But the browser will do for now.</p><span>
</span></div><p>Create a new file called<code>unit-tests.html</code> and enter the following:</p><span>
</span><p>unit-tests.html</p><code language="html" format="linenums">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8&quot;&gt;
  &lt;title&gt;Ng App Unit Tests&lt;/title&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;../node_modules/jasmine-core/lib/jasmine-core/jasmine.css&quot;&gt;

  &lt;script src=&quot;../node_modules/jasmine-core/lib/jasmine-core/jasmine.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;../node_modules/jasmine-core/lib/jasmine-core/jasmine-html.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;../node_modules/jasmine-core/lib/jasmine-core/boot.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;

&lt;body&gt;
&lt;/body&gt;

&lt;/html&gt;
</code><p>In the head we have three Jasmine scripts and one Jasmine css file. That&#x2019;s the foundation for running any tests.</p><span>
</span><p>We&#x2019;ll write our first test with inline JavaScript inside the body tag:</p><span>
</span><code language="html" format="">&lt;body&gt;
  &lt;!-- Unit Testing Chapter #1: Proof of life.  --&gt;
  &lt;script&gt;
    it(&apos;true is true&apos;, function(){ expect(true).toEqual(true); });
  &lt;/script&gt;
&lt;/body&gt;
</code><p>Now open <code>unit-tests.html</code> in a browser and see the Jasmine HTML test output:</p><span>
</span><figure class="image-display"><img src="https://angular.io/resources/images/devguide/jasmine-testing-101/jasmine-1-spec-0-failures.png" alt="Jasmine HTML test output"></figure><p>It doesn&#x2019;t get much simpler than that!</p><span>
</span><h2 id="first-typescript-test">First TypeScript Test</h2><span>
</span><p>Perhaps too simple. We won&#x2019;t write our entire test suite inside one HTML file.
Let&#x2019;s <strong>extract</strong> that line of test code to a <strong>new file in <code>src</code> called <code>1st.spec.ts</code> </strong> .</p><span>
</span><div class="l-sub-section"><p>Among Jasmine developers, a test is known as a &#x201C;spec&#x201D; and test filenames include the word &#x201C;spec&#x201D;.  We&#x2019;ll stick with that convention.</p><span>
</span></div><p>The test we wrote is valid TypeScript because any JavaScript is valid TypeScript. But let&#x2019;s make it more modern with an arrow function:</p><span>
</span><p>1st.spec.ts</p><code language="ts" format="">it(&apos;true is true&apos;, () =&gt; expect(true).toEqual(true));
</code><p>Now modify <code>unit-tests.html</code> to load the script:</p><span>
</span><code language="html" format="">&lt;script src=&quot;1st.spec.js&quot;&gt;&lt;/script&gt;
</code><p>Hold on! We wrote a TypeScript file but we&#x2019;re loading a JavaScript file?</p><span>
</span><p>That&#x2019;s a reminder that we need to compile our TypeScript test files as we do our TypeScript application files.  Do that next.</p><span>
</span><h2 id="prepare-for-typescript">Prepare for TypeScript</h2><span>
</span><p>As we&#x2019;ve seen before, we first have to tell the compiler how to compile our TypeScript files with
a <strong> <code>tsconfig.json</code> </strong>.</p><span>
</span><p>We can copy one from the quickstart we wrote previously and paste it into our src sub-folder.
It should look something like this:</p><span>
</span><p>tsconfig.json</p><code language="json" format="linenums">{
  &quot;compilerOptions&quot;: {
    &quot;target&quot;: &quot;es5&quot;,
    &quot;module&quot;: &quot;system&quot;,
    &quot;moduleResolution&quot;: &quot;node&quot;,
    &quot;sourceMap&quot;: true,
    &quot;emitDecoratorMetadata&quot;: true,
    &quot;experimentalDecorators&quot;: true,
    &quot;removeComments&quot;: false,
    &quot;noImplicitAny&quot;: true,
    &quot;suppressImplicitAnyIndexErrors&quot;: true
  }
}
</code><h2 id="compile-and-run">Compile and Run</h2><span>
</span><p>Compile in the terminal window using the npm script command</p><span>
</span><pre class="prettyprint lang-bash"><code>npm run tsc</code></pre><div class="alert is-helpful"><p>Our editor and the compiler may complain that they don&#x2019;t know
what <code>it</code> and <code>expect</code> are because they lack the typing files that describe Jasmine.
We can ignore those annoying complaints for now as they are harmless.</p><span>
</span></div><p>If we reload the browser, we should see the same Jasmine test-runner output as before.</p><span>
</span><p>We&#x2019;ll be evolving these tests rapidly and it would be nice to have the browser refresh automatically as we make changes and recompile.</p><span>
</span><p>Let&#x2019;s launch with <strong>lite-server</strong> in a second terminal window:</p><span>
</span><pre class="prettyprint lang-bash"><code>npm start</code></pre><p>Now reload <code>unit-tests.html</code> in the browser</p><span>
</span><p>We should get the same Jasmine test-runner output as before.</p><span>
</span><h2 id="add-a-describe-and-another-test">Add a describe and another test</h2><span>
</span><p>We can&#x2019;t tell what file produced these test results. We only have one file at the moment but soon we&#x2019;ll write more.</p><span>
</span><p>We should wrap this test into something that identifies the file. In Jasmine that &#x201C;something&#x201D; is a <code>describe</code> function.  Every test file should have at least one <code>describe</code> that identifies the file holding the test(s).</p><span>
</span><p>Here&#x2019;s what our revised <code>1st.spec.ts</code> looks like when wrapped in a <code>describe</code>:</p><span>
</span><code language="ts" format="linenums"> describe(&apos;1st tests&apos;, () =&gt; {

  it(&apos;true is true&apos;, () =&gt; expect(true).toEqual(true));

});
</code><p>And here&#x2019;s how the test report displays it.</p><span>
</span><figure class="image-display"><img src="https://angular.io/resources/images/devguide/jasmine-testing-101/test-report-1-spec-0-failures.png" alt="1 spec, 0 failures"></figure><p>Let&#x2019;s add another Jasmine test to <code>1st.spec.ts</code></p><span>
</span><code language="ts" format="">it(&apos;null is not the same thing as undefined&apos;,
  () =&gt; expect(null).not.toEqual(undefined)
);
</code><p>You knew that right?  Let&#x2019;s prove it with this test. The browser should refresh after you paste that test, and show:</p><span>
</span><figure class="image-display"><img src="https://angular.io/resources/images/devguide/jasmine-testing-101/test-report-2-specs-0-failures.png" alt="refreshed 2 specs, 0 failures"></figure><p>What does a failing test look like? Remove the <code>.not</code>. The browser refreshes and shows:</p><span>
</span><figure class="image-display"><img src="https://angular.io/resources/images/devguide/jasmine-testing-101/test-report-2-specs-1-failure.png" alt="failing test 2 specs, 1 failure"></figure><p>Click the <code>Spec List</code> link just below &#x201C;2 specs, 1 failure&#x201D; to see the summary again:</p><span>
</span><figure class="image-display"><img src="https://angular.io/resources/images/devguide/jasmine-testing-101/spec-list-2-specs-1-failure.png" alt="2 specs, 1 failure"></figure><p>We can re-run just the failing test by double-clicking it.  Try it!</p><span>
</span><h2 id="debug-the-test">Debug the test</h2><span>
</span><p>Suppose we didn&#x2019;t know what was going on.  We can debug it in the browser.</p><span>
</span><ul>
<li>Open the browser&#x2019;s &#x201C;Developer Tools&#x201D; (F12 or Ctrl-Shift-I).</li>
<li>Pick the &#x201C;sources&#x201D; section</li>
<li>Open the <code>1st.spec.ts</code> test file (Ctrl-P, then start typing the name of the file).</li>
<li>Set a breakpoint on the second line of the failing test</li>
<li>Refresh the browser &#x2026; and it stops at our breakpoint.</li>
<li>Open the console window at the bottom  (press Esc)</li>
<li>Type <code>null === undefined</code> &#x2026; &#x2026; and we should see this:</li>
</ul><span>
</span><figure class="image-display"><img src="https://angular.io/resources/images/devguide/jasmine-testing-101/null-to-equal-undefined.png" alt="null === undefined"></figure><p>How about that!  They really aren&#x2019;t equal.</p><span>
</span><ul>
<li>remove the breakpoint (right-click in the &#x201C;Breakpoints&#x201D; section and chose &#x201C;Remove breakpoint&#x201D;)</li>
<li>Click the &#x201C;play&#x201D; icon to resume the test  (or F8)</li>
</ul><span>
</span><p>And the test finishes.  Close the browser tools (click the close box or press F12 or Ctrl-Shift-I)</p><span>
</span><p>Fix the test (restore the <code>.not</code>);  the browser should refresh automatically and all tests pass.</p><span>
</span><p>Congratulations &#x2026; you&#x2019;ve completed Jasmine testing 101.</p><span>
</span><p>Now that we&#x2019;re familiar with Jasmine on its own, we&#x2019;re ready to test an application.</p><span>
</span><!-- TODO
.l-main-section
:marked
  ## Learn more
  Learn more about basic Jasmine testing here
  [Resources TBD](./#)
  --><a href="https://angular.io/docs/ts/latest/guide/testing.html#top" class="to-top">Back to top</a><a id="aut"></a><h1 id="the-application-to-test">The Application to Test</h1><span>
</span><p>We&#x2019;ll need an Angular application to test, one as simple as possible while having most of the angular features we want to test.</p><span>
</span><p>What better app than our own <a href="https://angular.io/docs/ts/latest/tutorial/toh-pt5.html">The Tour of Heroes</a>? We&apos;re already quite familiar with it and it fits our criteria, so let&apos;s try to test what we&apos;ve done there.</p><span>
</span><p>We might end up modifying it a bit, because it doesn&apos;t have everything we want to test, but it&apos;s the perfect starting point.</p><span>
</span><p>Create a copy of the Tour of Heroes app so that we can fiddle without fear.</p><span>
</span><a href="https://angular.io/docs/ts/latest/guide/testing.html#top" class="to-top">Back to top</a><a id="first-app-tests"></a><h1 id="first-app-test">First app test</h1><span>
</span><p>In this chapter we&apos;ll setup the environment for testing our sample application and write a few easy Jasmine tests of the app&apos;s simplest parts.
We&apos;ll learn:</p><span>
</span><ul>
<li>to test one of our application files</li>
<li>why we prefer our test files to be next to their corresponding source files</li>
<li>to run tests with an <code>npm</code> command</li>
<li>load the test file with SystemJS</li>
</ul><span>
</span><div class="callout is-helpful"><header>Prior Knowledge</header><p>The Unit Testing chapters build upon each other. We recommend reading them in order.
We&apos;re also assuming that you&apos;re already comfortable with basic Angular 2 concepts and the tools
we introduced in the <a href="https://angular.io/docs/ts/latest/quickstart.html">QuickStart</a> and
the <a href="https://angular.io/docs/ts/latest/tutorial/">Tour of Heroes</a> tutorial
such as <code>npm</code>, <code>gulp</code>, and <code>lite-server</code>.</p><span>
</span></div><h2 id="create-the-test-runner-html">Create the test-runner HTML</h2><span>
</span><p>Locate the folder that contains the application <code>index.html</code> for your testing copy of Tour of Heroes.</p><span>
</span><p>Create a new, sibling HTML file, <strong> <code>unit-tests.html</code> </strong> and copy over the same basic material from the  <code>unit-tests.html</code> in the <a href="https://angular.io/docs/ts/latest/guide/jasmine-testing-101.html">Jasmine 101</a> chapter.</p><span>
</span><p>unit-tests.html</p><code language="html" format="linenums">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8&quot;&gt;
  &lt;title&gt;Ng App Unit Tests&lt;/title&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;../node_modules/jasmine-core/lib/jasmine-core/jasmine.css&quot;&gt;

  &lt;script src=&quot;../node_modules/jasmine-core/lib/jasmine-core/jasmine.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;../node_modules/jasmine-core/lib/jasmine-core/jasmine-html.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;../node_modules/jasmine-core/lib/jasmine-core/boot.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;

&lt;body&gt;
&lt;/body&gt;

&lt;/html&gt;
</code><p>We&apos;re picking up right where we left off. All we&apos;ve done is change the title.</p><span>
</span><h2 id="update-package-json-for-testing">Update <code>package.json</code> for testing</h2><span>
</span><p>We must install the Jasmine package as well:</p><span>
</span><pre class="prettyprint lang-bash"><code>npm install jasmine-core --save-dev --save-exact</code></pre><p>Be sure to install <code>jasmine-core</code> , not <code>jasmine</code>!</p><h2 id="configure-lite-server-for-serving-our-test-harness">Configure <code>lite-server</code> for serving our test harness</h2><span>
</span><p>First create a configuration file for serving up our test harness through <code>lite-server</code>.</p><span>
</span><p>liteserver-test-config.json</p><code language="json" format="linenums">{
    &quot;startPath&quot;: &quot;unit-tests.html&quot;
}
</code><p>Let&apos;s make one more change to the <code>package.json</code> script commands.</p><span>
</span><p><strong>Open the <code>package.json</code> </strong> and scroll to the <code>scripts</code> node and add the following two entries:</p><span>
</span><code format="">&quot;lite-server-test&quot;: &quot;lite-server --config=liteserver-test-config.json&quot;,
&quot;test&quot;: &quot;tsc &amp;&amp; concurrently \&quot;npm run tsc:w\&quot; \&quot;npm run lite-server-test\&quot; &quot;
</code><p>The <code>npm test</code> command will launch <code>lite-server</code> and open a browser to the <code>unit-tests.html</code> page we just wrote. It will also take care of recompiling your source code and reloading your browser after any change.</p><span>
</span><h2 id="first-app-tests">First app tests</h2><span>
</span><p>We can start testing <em>some</em> of our app right away. For example, we can test the <code>Hero</code> interface:</p><span>
</span><code language="ts" format="linenums">export class Hero {
  id: number;
  name: string;
}
</code><p>Let&apos;s add a couple of simple tests in a new file.</p><span>
</span><code language="ts" format="linenums">import { Hero } from &apos;./hero&apos;;

describe(&apos;Hero&apos;, () =&gt; {

  it(&apos;has name&apos;, () =&gt; {
    let hero: Hero = {id: 1, name: &apos;Super Cat&apos;};
    expect(hero.name).toEqual(&apos;Super Cat&apos;);
  });

  it(&apos;has id&apos;, () =&gt; {
    let hero: Hero = {id: 1, name: &apos;Super Cat&apos;};
    expect(hero.id).toEqual(1);
  });
});
</code><p>That&apos;s the basic Jasmine we learned back in &quot;Jasmine 101&quot;.</p><span>
</span><p>Notice that we surrounded our tests with <strong> <code>describe(&apos;Hero&apos;)</code> </strong>.</p><span>
</span><p><strong>By convention, our test always begin with a <code>describe</code> that identifies the application part under test.</strong></p><span>
</span><p>The description should be sufficient to identify the tested application part and its source file. Almost any convention will do as long as you and your team follow it consistently and are never confused.</p><span>
</span><p>But we haven&apos;t saved this test yet.</p><span>
</span><h2 id="where-do-tests-go-">Where do tests go?</h2><span>
</span><p>Some people like to keep their tests in a <code>tests</code> folder parallel to the application source folder.</p><span>
</span><p>We are not those people. We like our unit tests to be close to the source code that they test. We prefer this approach because</p><span>
</span><ul>
<li>The tests are easy to find</li>
<li>We see at a glance if an application part lacks tests.</li>
<li>Nearby tests can teach us about how the part works; they express the developers intention and reveal how the developer thinks the part should behave under a variety of circumstances.</li>
<li>When we move the source (inevitable), we remember to move the test.</li>
<li>When we rename the source file (inevitable), we remember to rename the test file.</li>
</ul><span>
</span><p>We can&apos;t think of a downside. The server doesn&apos;t care where they are.  They are easy to find and distinguish from application files when named conventionally.</p><span>
</span><div class="l-sub-section"><p>You may put your tests elsewhere if you wish. 
We&apos;re putting ours inside the app, next to the source files that they test.</p><span>
</span></div><h2 id="first-spec-file">First spec file</h2><span>
</span><p><strong>Create</strong> a new file, <strong> <code>hero.spec.ts</code> </strong> in <code>app</code> next to <code>hero.ts</code>.</p><span>
</span><p>Notice the &quot;.spec&quot; suffix in the test file&apos;s filename, appended to the name of the file holding the application part we&apos;re testing.</p><span>
</span><p> All of our unit test files follow this .spec naming pattern.</p><p>Save the tests we just made in <code>hero.spec.ts</code>:</p><span>
</span><code language="ts" format="linenums">import { Hero } from &apos;./hero&apos;;

describe(&apos;Hero&apos;, () =&gt; {

  it(&apos;has name&apos;, () =&gt; {
    let hero: Hero = {id: 1, name: &apos;Super Cat&apos;};
    expect(hero.name).toEqual(&apos;Super Cat&apos;);
  });

  it(&apos;has id&apos;, () =&gt; {
    let hero: Hero = {id: 1, name: &apos;Super Cat&apos;};
    expect(hero.id).toEqual(1);
  });
});
</code><h3 id="import-the-part-we-re-testing">Import the part we&apos;re testing</h3><span>
</span><p>We have an <code>import {Hero} from &apos;./hero&apos;</code> statement.</p><span>
</span><p>If we forgot this import, a TypeScript-aware editor would warn us, with a squiggly red underline, that it can&apos;t find the definition of the <code>Hero</code> interface.</p><span>
</span><h3 id="update-unit-tests-html">Update unit-tests.html</h3><span>
</span><p>Next we update the <code>unit-tests.html</code> with a reference to our new <code>hero.spec.ts</code> file. Delete the inline test code.  The revised pertinent HTML looks like this:</p><span>
</span><code language="html" format="">&lt;script src=&quot;app/hero.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;app/hero.spec.js&quot;&gt;&lt;/script&gt;
</code><h3 id="run-and-fail">Run and Fail</h3><span>
</span><p>Look over at the browser (lite-server will have reloaded it).  The browser displays</p><span>
</span><figure class="image-display"><img src="https://angular.io/resources/images/devguide/first-app-tests/Jasmine-not-running-tests.png" alt="Jasmine not running any tests"></figure><p>That&apos;s Jasmine saying &quot;<strong>things are <em>so</em> bad that <em>I&apos;m not running any tests</em>.</strong>&quot;</p><span>
</span><p>Open the browser&apos;s Developer Tools (F12, Ctrl-Shift-i). There&apos;s an error:</p><span>
</span><code format="" language="html">Uncaught ReferenceError: System is not defined
</code><h2 id="load-tests-with-systemjs">Load tests with SystemJS</h2><span>
</span><p>The immediate cause of the error is the <code>export</code> statement in <code>hero.ts</code>.
That error was there all along.
It wasn&apos;t a problem until we tried to <code>import</code> the <code>Hero</code> interface in our tests.</p><span>
</span><p>Our test environment lacks support for module loading.
Apparently we can&apos;t simply load our application and test scripts like we do with 3rd party JavaScript libraries.</p><span>
</span><p>We are committed to module loading in our application.
Our app will call <code>import</code>.  Our tests must do so too.</p><span>
</span><p>We add module loading support in four steps:</p><span>
</span><ol>
<li>add the <em>SystemJS</em> module management library</li>
<li>configure <em>SystemJS</em> to look for JavaScript files by default</li>
<li>import our test files</li>
<li>tell Jasmine to run the imported tests</li>
</ol><span>
</span><p>These steps are all clearly visible, in exactly that order, in the following lines that
replace the <code>&lt;body&gt;</code> contents in <code>unit-tests.html</code>:</p><span>
</span><code language="html" format="">&lt;body&gt;
  &lt;!-- #1. add the system.js library --&gt;
  &lt;script src=&quot;../node_modules/systemjs/dist/system.src.js&quot;&gt;&lt;/script&gt;

  &lt;script&gt;
    // #2. Configure systemjs to use the .js extension
    //     for imports from the app folder
    System.config({
      packages: {
        &apos;app&apos;: {defaultExtension: &apos;js&apos;}
      }
    });

    // #3. Import the spec file explicitly
    System.import(&apos;app/hero.spec&apos;)

      // #4. wait for all imports to load ...
      //     then re-execute `window.onload` which
      //     triggers the Jasmine test-runner start
      //     or explain what went wrong.
      .then(window.onload)
      .catch(console.error.bind(console));
  &lt;/script&gt;
&lt;/body&gt;
</code><p>Look in the browser window. Our tests pass once again.</p><span>
</span><figure class="image-display"><img src="https://angular.io/resources/images/devguide/first-app-tests/test-passed-once-again.png" alt="Tests passed once again"></figure><h2 id="observations">Observations</h2><span>
</span><h3 id="system-config">System.config</h3><span>
</span><p>System.js demands that we specify a default extension for the filenames that correspond to whatever it is asked to import.
Without that default, it would translate an import statement such as <code>import {Hero} from &apos;./hero&apos;</code> to a request for the file named <code>hero</code>.
Not <code>hero.js</code>. Just plain <code>hero</code>.  Our server error with &quot;404 - not found&quot; because it doesn&apos;t have a file of that name.</p><span>
</span><p>Once configured with a default extension of &apos;js&apos;,&#xA0;  SystemJS requests <code>hero.js</code> which <em>does</em> exist and is promptly returned by our server.</p><span>
</span><h3 id="asynchronous-system-import">Asynchronous System.import</h3><span>
</span><p>The call to <code>System.import</code> shouldn&apos;t surprise us but its asynchronous nature might.
If we ponder this for a moment, we realize that it must be asynchronous because
System.js may have to fetch the corresponding JavaScript file from the server.
Accordingly, <code>System.import</code> returns a promise and we must wait for that promise to resolve.
Only then can Jasmine start evaluating the imported tests.</p><span>
</span><h3 id="window-onload">window.onload</h3><span>
</span><p>Jasmine doesn&apos;t have a <code>start</code> method.  It wires its own start to the browser window&apos;s <code>load</code> event.
That makes sense if we&apos;re loading our tests with script tags.
The browser raises the <code>load</code> event when it finishes loading all scripts.</p><span>
</span><p>But we&apos;re not loading test scripts inline anymore.
We&apos;re using the SystemJS module loader and it won&apos;t be done until long after the browser raised the <code>load</code> event.
Meanwhile, Jasmine started and ran to completion &#x2026; with no tests to evaluate &#x2026; before the import completed.</p><span>
</span><p>So we must wait until the import completes and only then call the window <code>onLoad</code> handler.
Jasmine re-starts, this time with our imported test queued up.</p><span>
</span><h2 id="what-s-next-">What&apos;s Next?</h2><span>
</span><p>We are able to test a part of our application with simple Jasmine tests.
The part was a stand-alone interface that made no mention or use of Angular.</p><span>
</span><p>That&apos;s not rare but it&apos;s not typical either. 
Most of our application parts make some use of the Angular framework.
Let&apos;s test a <em>pipe</em> class that does rely on Angular.</p><span>
</span><a href="https://angular.io/docs/ts/latest/guide/testing.html#top" class="to-top">Back to top</a><a id="pipe-testing"></a><h1 id="pipe-driven-development">Pipe driven development</h1><span>
</span><p>We&#x2019;ll test an Angular pipe in this chapter.</p><span>
</span><p>An Angular pipe is a declarative way in HTML to transform some input into some displayable output.</p><span>
</span><p>We don&apos;t have a pipe though, since in Tour of Heroes we didn&apos;t create any pipes. It uses a pipe though, the <code>uppercase</code> pipe that comes with Angular 2.</p><span>
</span><p>We can make our own <code>my-uppercase</code> pipe that does exactly the same as the <code>uppercase</code> pipe and test that.</p><span>
</span><p>Since we&apos;re getting ready to write some code we want to test, let&apos;s take this opportunity to talk just a little bit about <a href="https://en.wikipedia.org/wiki/Test-driven_development">Test Driven Development</a>. There&apos;s a lot written about this topic so we don&apos;t want to have an exhaustive description here, but rather a practical application.</p><span>
</span><p>We already know <em>exactly</em> what we want the <code>uppercase</code> pipe to do. We could say our ...expectations... of it are very well defined.</p><span>
</span><p>We always use our expectations to guide development, but sometimes it&apos;s hard to see the forest for the trees when we&apos;re right in the middle of coding. This is especially evident in larger tasks.</p><span>
</span><p>So one thing we can do is put those expectations down as cold hard test code. We were going to test things manually anyway, so doing it <em>before</em> we have even one line of code isn&apos;t going to hurt. </p><span>
</span><p>Worst thing that can happen is have that test fail, but on the way to fixing it we&apos;ll end up creating our pipe. So in a sense, the failing test will <em>tell you what it wants</em> to pass.</p><span>
</span><p>We&apos;re just putting down expectations, nothing more. If we were to put them down on paper, they would look like this:</p><span>
</span><pre><code>  MyUppercasePipe
    transforms &quot;abc&quot; to &quot;ABC&quot;
    transforms &quot;abc def&quot; to &quot;ABC DEF&quot;
    leaves &quot;ABC DEF&quot; unchanged
</code></pre><p>All we need to know to put down our expectations as code is how a pipe class looks like from the outside. From the <a href="https://angular.io/docs/ts/latest/guide/pipes#custom-pipes">pipe developer guide</a> we know that a pipe implements a <code>transform</code> method. </p><span>
</span><p>Putting it down as Jasmine expectations, they would look something like this:</p><span>
</span><code language="ts" format="linenums">it(&apos;transforms &quot;abc&quot; to &quot;ABC&quot;&apos;, () =&gt; {
  expect(pipe.transform(&apos;abc&apos;)).toEqual(&apos;ABC&apos;);
});

it(&apos;transforms &quot;abc def&quot; to &quot;ABC DEF&quot;&apos;, () =&gt; {
  expect(pipe.transform(&apos;abc def&apos;)).toEqual(&apos;ABC DEF&apos;);
});

it(&apos;leaves &quot;ABC DEF&quot; unchanged&apos;, () =&gt; {
  expect(pipe.transform(&apos;ABC DEF&apos;)).toEqual(&apos;ABC DEF&apos;);
});
</code><p>In this chapter we will:</p><span>
</span><ul>
<li>create a test before creating a class</li>
<li>load multiple test files in our test harness, using system.js</li>
<li>add the Angular 2 library to our test harness</li>
<li>watch the new test fail, and fix it</li>
</ul><span>
</span><div class="callout is-helpful"><header>Prior Knowledge</header><p>The Unit Testing chapters build upon each other. We recommend reading them in order.
We&apos;re also assuming that you&apos;re already comfortable with basic Angular 2 concepts and the tools
we introduced in the <a href="https://angular.io/docs/ts/latest/quickstart.html">QuickStart</a> and
the <a href="https://angular.io/docs/ts/latest/tutorial/">Tour of Heroes</a> tutorial
such as <code>npm</code>, <code>gulp</code>, and <code>lite-server</code>.</p><span>
</span></div><h2 id="add-another-spec-file">Add another spec file</h2><span>
</span><p><strong>Create</strong> a <code>my-uppercase.pipe.spec.ts</code> in <code>app/</code>.</p><span>
</span><p><strong>Stop and restart the TypeScript compiler</strong> to ensure we compile the new file.</p><span>
</span><p><strong>Add</strong> the following lines of rather obvious Jasmine test code.</p><span>
</span><p>app/my-uppercase.pipe.spec.ts</p><code language="ts" format="linenums">import { MyUppercasePipe } from &apos;./my-uppercase.pipe&apos;;

describe(&apos;MyUppercasePipe&apos;, () =&gt; {
  let pipe: MyUppercasePipe;

  beforeEach(() =&gt; {
    pipe = new MyUppercasePipe();
  });

  it(&apos;transforms &quot;abc&quot; to &quot;ABC&quot;&apos;, () =&gt; {
    expect(pipe.transform(&apos;abc&apos;)).toEqual(&apos;ABC&apos;);
  });

  it(&apos;transforms &quot;abc def&quot; to &quot;ABC DEF&quot;&apos;, () =&gt; {
    expect(pipe.transform(&apos;abc def&apos;)).toEqual(&apos;ABC DEF&apos;);
  });

  it(&apos;leaves &quot;ABC DEF&quot; unchanged&apos;, () =&gt; {
    expect(pipe.transform(&apos;ABC DEF&apos;)).toEqual(&apos;ABC DEF&apos;);
  });
});
</code><p>Note that each test is short (one line in our case).
It has a clear label that accurately describes the test. And it makes exactly one expectation.</p><span>
</span><p>Anyone can read these tests and understand quickly what the test does and what the pipe does.
If one of the tests fails, we know which expected behavior is no longer true.
We&#x2019;ll have little trouble maintaining these tests and adding more like them as we encounter new conditions to explore.</p><span>
</span><p>That&#x2019;s the way we like our tests!</p><span>
</span><h2 id="add-this-spec-to-unit-tests-html-">Add this spec to <code>unit-tests.html</code></h2><span>
</span><p>Now let&#x2019;s wire our new spec file into the HTML test harness.</p><span>
</span><p>Open <code>unit-tests.html</code>. Find <code>System.import(&apos;app/hero.spec&apos;)</code>.</p><span>
</span><p>Hmm. We can&#x2019;t just add <code>System.import(&apos;app/my-uppercase.pipe.spec&apos;)</code>.</p><span>
</span><p>The first <code>System.import</code> returns a promise as does this second import.
We can&#x2019;t run any of the Jasmine tests until <strong>both imports are finished</strong>.</p><span>
</span><p>Fortunately, we can create a new <code>Promise</code> that wraps both import promises and waits
for both to finish loading.</p><span>
</span><code language="html" format="">&lt;script&gt;
  // #2. Import the spec files explicitly
  Promise.all([
    System.import(&apos;app/hero.spec&apos;),
    System.import(&apos;app/my-uppercase.pipe.spec&apos;)
  ])

    // #3. wait for all imports to load ...
    //     then re-execute `window.onload` which
    //     triggers the Jasmine test-runner start
    //     or explain what went wrong.
    .then(window.onload)
    .catch(console.error.bind(console));
&lt;/script&gt;
</code><p>We have a pattern for adding new tests.</p><span>
</span><p>In future, when we add a new spec, we add another <code>System.import(&apos;app/some.spec&apos;)</code> to
the array argument passed to <code>Promise.all</code>.</p><span>
</span><p>Try it. The browser should refresh and show the following in the console:</p><span>
</span><code format="" language="html" escape="html">GET http://localhost:8080/app/my-uppercase.pipe.js 404 (Not Found)
</code><p>Our test failed, as expected. We&apos;re importing something that doesn&apos;t exist and our test fails saying that. All is going according to plan.</p><span>
</span><h2 id="the-pipe-if-you-please">The pipe, if you please</h2><span>
</span><p>The test is asking for a pipe, and we shall deliver. </p><span>
</span><p><strong>Create</strong> a <code>my-uppercase.pipe.ts</code> in <code>app/</code>.</p><span>
</span><p><strong>Stop and restart the TypeScript compiler</strong> to ensure we compile the new file.</p><span>
</span><p><strong>Add</strong> a basic pipe that doesn&apos;t do anything. We know how to make strings uppercase, but we since we&apos;re letting the test take the lead let&apos;s wait for it to tell us what&apos;s next. Maybe it&apos;ll surprise us.</p><span>
</span><p>app/my-uppercase.pipe.ts</p><code language="ts" format="linenums">import { Pipe, PipeTransform } from &apos;@angular/core&apos;;

@Pipe({ name: &apos;my-uppercase&apos; })
export class MyUppercasePipe implements PipeTransform {
  transform(value: string) {
    return value;
  }
}
</code><p>Reload our test page and...</p><span>
</span><code format="" language="html" escape="html">GET http://localhost:8080/angular2/core 404 (Not Found)
</code><h2 id="the-angular-library-if-you-please">The Angular library, if you please</h2><span>
</span><p>Looking back at <code>unit-tests.html</code> we realize that we have not loaded the Angular library.
Yet we were able to load and test the application&#x2019;s <code>Hero</code> interface.</p><span>
</span><p><strong>We were lucky!</strong>  The <code>Hero</code> interface has no dependence on Angular.
If it had depended on Angular, we&#x2019;d still be staring at the Jasmine &#x201C;big-time fail&#x201D; screen:</p><span>
</span><figure class="image-display"><img src="https://angular.io/resources/images/devguide/testing-an-angular-pipe/big-time-fail-screen.png" alt="Jasmine&apos;s&apos; big time fail screen"></figure><p>We are writing an Angular application after all and
we were going to need Angular sooner or later. That time has come.</p><span>
</span><p><code>MyUppercasePipe</code> depends on Angular as is clear in the first few lines:</p><span>
</span><code language="ts" format="">import { Pipe, PipeTransform } from &apos;@angular/core&apos;;
</code><p><strong>Open</strong> <code>unit-tests.html</code></p><span>
</span><p><strong>Find</strong> the <code>&lt;!-- #1. add the system.js library --&gt;</code> comment.</p><span>
</span><p><strong>Replace</strong> the scripts tags beneath it with the all the needed angular scripts:</p><span>
</span><code language="html" format="">&lt;!-- #1. add the system.js and angular libraries --&gt;
  &lt;script src=&quot;node_modules/zone.js/dist/zone.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;node_modules/reflect-metadata/Reflect.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;node_modules/systemjs/dist/system.src.js&quot;&gt;&lt;/script&gt;

  &lt;script src=&quot;systemjs.config.js&quot;&gt;&lt;/script&gt;
</code><p>We should now be ready to see our 3 expectations fail when reloading our test page.</p><span>
</span><figure class="image-display"><img src="https://angular.io/resources/images/devguide/testing-an-angular-pipe/two-failures.png" alt="2 failed tests"></figure><h2 id="uppercase-if-you-please">Uppercase, if you please</h2><span>
</span><p>The first two tests that passed were our old <code>hero</code> interface tests, so it makes sense that those passed. Of our three new expectations, one still passed though.</p><span>
</span><pre><code>  MyUppercasePipe
    transforms &quot;abc&quot; to &quot;ABC&quot;
    transforms &quot;abc def&quot; to &quot;ABC DEF&quot;
    leaves &quot;ABC DEF&quot; unchanged
</code></pre><p>Ah but of course! Our simple pipe doesn&apos;t transform the input at all, and the third test expected
input to not be changed.</p><span>
</span><p>All we have to do now is actually transform text to uppercase in our pipe.</p><span>
</span><code language="ts" format="">transform(value: string) {
  return value.toUpperCase();
}
</code><p>Are we done now?</p><span>
</span><figure class="image-display"><img src="https://angular.io/resources/images/devguide/testing-an-angular-pipe/zero-failures.png" alt="0 failed tests"></figure><p>The glorious green is back with us again!</p><span>
</span><p>We tried a bit of test driven development and it seems to have guided us to success.</p><span>
</span><p>But it&apos;s not always feasible. For instance, sometimes we need to write tests for existing functionality, like what we&apos;re about to do with the rest of Tour of Heroes. </p><span>
</span><p>If we are writing new code though, writing tests might just be what we need to help us track our progress and keep the end result in sight at all times.</p><span>
</span><h2 id="what-s-next-">What&#x2019;s Next?</h2><span>
</span><p>Now we can test parts of our application that we <em>load</em> asynchronously with system.js.</p><span>
</span><p>What about testing parts that <em>are themselves asynchronous</em>?</p><span>
</span><p>Let&apos;s test a service with a public asynchronous method that fetches heroes from a remote server.</p><span>
</span><a href="https://angular.io/docs/ts/latest/guide/testing.html#top" class="to-top">Back to top</a><div class="alert is-important"><p>The testing chapter is still under development.
Please bear with us as we both update and complete it.</p><span>
</span></div><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--></div></div>
        </article>
      
        <article>
          <h3>TypeScript Configuration</h3>
          <div><div class="showcase-content"><p>TypeScript is a primary language for Angular application development. It is a dialect of JavaScript with design-time support for type-safety and tooling.</p><span>
</span><p>Browsers can&apos;t execute TypeScript directly. Typescript must be &quot;transpiled&quot; into JavaScript using the <em>tsc</em> compiler,
which requires some configuration.</p><span>
</span><p>This page covers some aspects of TypeScript configuration and the TypeScript environment
that are important to Angular developers, including details about the following files:</p><span>
</span><ul>
<li><a href="https://angular.io/docs/ts/latest/guide/typescript-configuration.html#tsconfig">tsconfig.json</a> - TypeScript compiler configuration.</li>
<li><a href="https://angular.io/docs/ts/latest/guide/typescript-configuration.html#typings">typings</a> - TypesScript declaration files.</li>
</ul><span>
</span><a id="tsconfig"></a><h2 id="-tsconfig-json-"><em>tsconfig.json</em></h2><span>
</span><p>Typically, you add a TypeScript configuration file (<code>tsconfig.json</code>) to your project to
guide the compiler as it generates JavaScript files.</p><span>
</span><p>We created the following <code>tsconfig.json</code> for <a href="https://angular.io/docs/ts/latest/quickstart.html">QuickStart</a>:</p><span>
</span><p>tsconfig.json</p><code language="json" format=".">{
  &quot;compilerOptions&quot;: {
    &quot;target&quot;: &quot;es5&quot;,
    &quot;module&quot;: &quot;commonjs&quot;,
    &quot;moduleResolution&quot;: &quot;node&quot;,
    &quot;sourceMap&quot;: true,
    &quot;emitDecoratorMetadata&quot;: true,
    &quot;experimentalDecorators&quot;: true,
    &quot;removeComments&quot;: false,
    &quot;noImplicitAny&quot;: false
  }
}
</code><p>This file contains options and flags that are essential for Angular 2 applications.</p><span>
</span><span>
</span><h3 id="-noimplicitany-and-suppressimplicitanyindexerrors-"><em>noImplicitAny</em> and <em>suppressImplicitAnyIndexErrors</em></h3><span>
</span><p>TypeScript developers disagree about whether the <code>noImplicitAny</code> flag should be <code>true</code> or <code>false</code>.
There is no correct answer and you can change the flag later.
But your choice now can make a difference in larger projects, so it merits discussion.</p><span>
</span><p>When the <code>noImplicitAny</code> flag is <code>false</code> (the default), and if
the compiler cannot infer the variable type based on how it&apos;s used, the compiler silently defaults the type to <code>any</code>. That&apos;s what is meant by <em>implicit <code>any</code></em>.</p><span>
</span><p>In the QuickStart exercise, the <code>noImplicitAny</code> flag is initialized to <code>false</code>
to make learning TypeScript development easier.</p><span>
</span><p>When the <code>noImplicitAny</code> flag is <code>true</code> and the TypeScript compiler cannot infer
the type, it still generates the JavaScript files, but it also <strong>reports an error</strong>.
Many seasoned developers prefer this stricter setting because type checking catches more
unintentional errors at compile time.</p><span>
</span><p>You can set a variable&apos;s type to <code>any</code> even when the <code>noImplicitAny</code> flag is <code>true</code>.</p><span>
</span><p>If you set the <code>noImplicitAny</code> flag to <code>true</code>, you may get <em>implicit index errors</em> as well.
Most developers feel that <em>this particular error</em> is more annoying than helpful.
You can suppress them with the following additional flag:</p><span>
</span><code format=".">&quot;suppressImplicitAnyIndexErrors&quot;:true

</code><a id="typings"></a><h2 id="typescript-typings">TypeScript Typings</h2><span>
</span><p>Many JavaScript libraries, such as jQuery, the Jasmine testing library, and Angular,
extend the JavaScript environment with features and syntax
that the TypeScript compiler doesn&apos;t recognize natively.
When the compiler doesn&apos;t recognize something, it throws an error. </p><span>
</span><p>Use <a href="http://www.typescriptlang.org/Handbook#writing-dts-files">TypeScript type definition files</a>&#x2014;<code>d.ts files</code>&#x2014;to tell the compiler about the libraries you load.</p><span>
</span><p>TypeScript-aware editors leverage these same definition files to display type information about library features.</p><span>
</span><p>Many libraries include definition files in their npm packages where both the TypeScript compiler and editors
can find them. Angular is one such library. 
The <code>node_modules/@angular/core/</code> folder of any Angular application contains several <code>d.ts</code> files that describe parts of Angular.</p><span>
</span><p><strong>You need do nothing to get <em>typings</em> files for library packages that include <code>d.ts</code> files&#x2014;as all Angular packages do.</strong></p><span>
</span><h3 id="installable-typings-files">Installable typings files</h3><span>
</span><p>Many libraries&#x2014;jQuery, Jasmine, and Lodash among them&#x2014;do <em>not</em> include <code>d.ts</code> files in their npm packages.
Fortunately, either their authors or community contributors have created separate <code>d.ts</code> files for these libraries and 
published them in well-known locations.
The <em>typings</em> tool can find and fetch these files for you.</p><span>
</span><p>After installing the <a href="https://github.com/typings/typings/blob/master/README.md">typings</a> tool 
with npm (it&apos;s listed among the <em>devDependencies</em> in the <code>package.json</code>), add an npm script (<code>postinstall</code>)
to run that tool automatically, after <em>npm</em> installation finishes.</p><span>
</span><p>package.json (postinstall)</p><code language="json" format=".">{
  &quot;scripts&quot;: {
    &quot;postinstall&quot;: &quot;typings install&quot;
  }
}</code><p>This <em>typings</em> tool command, <code>typings install</code>, installs the <code>d.ts</code> files into the <strong>typings</strong> folder.
You created a <code>typings.json</code> file in the <a href="https://angular.io/docs/ts/latest/quickstart.html">QuickStart</a>:</p><span>
</span><p>typings.json</p><code language="json" format=".">{
  &quot;globalDependencies&quot;: {
    &quot;core-js&quot;: &quot;registry:dt/core-js#0.0.0+20160725163759&quot;,
    &quot;jasmine&quot;: &quot;registry:dt/jasmine#2.2.0+20160621224255&quot;,
    &quot;node&quot;: &quot;registry:dt/node#6.0.0+20160831021119&quot;
  }
}
</code><p>QuickStart identified three <em>typings</em> (<code>d.ts</code>) files:</p><span>
</span><ul>
<li><p><a href="https://github.com/zloirock/core-js/blob/master/README.md">core-js</a>
brings ES2015/ES6 capabilities to ES5 browsers</p>
</li>
<li><p><a href="http://jasmine.github.io/">jasmine</a> typings for the Jasmine test framework</p>
</li>
<li><p><a href="https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/node/node.d.ts">node</a> for code that references objects in the <em>nodejs</em> environment; 
You can view an example in the <a href="https://angular.io/docs/ts/latest/guide/webpack.html">webpack</a> page.</p>
</li>
</ul><span>
</span><p>QuickStart doesn&apos;t require these typings but many of the samples do.</p><span>
</span><p>You can also run the <em>typings</em> tool yourself.
If the <code>postInstall</code> command fails to (re)install the typings files, run the following command to do so.</p><span>
</span><code format="">npm run typings install</code><p>Run this command to list the installed typings files:</p><span>
</span><code format="">npm run typings list</code><p>The following command installs or updates the typings file for the Jasmine test library from the <em>DefinitelyTyped</em> repository,
and updates the <code>typings.config</code> file so you receive it automatically the next time you install typings.</p><span>
</span><code format="">npm run typings -- install dt~jasmine --save --global</code><div class="l-sub-section"><p>The <a href="https://docs.npmjs.com/cli/run-script">&#x2013;&#x2013; option</a> tells npm to pass all arguments to the right of <code>--</code> to the <em>typings</em> command.</p><span>
</span><p>Read about the features of the <em>typings</em> tool at its <a href="https://github.com/typings/typings/blob/master/README.md">site on github</a>.</p><span>
</span></div><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--></div></div>
        </article>
      
        <article>
          <h3>Upgrading from 1.x</h3>
          <div><div class="showcase-content"><div class="alert is-important"><p>This guide is still in the process of being updated to RC5 and it&apos;s samples
may not work correctly.</p><span>
</span></div><p>Having an existing Angular 1 application doesn&apos;t mean that we can&apos;t
begin enjoying everything Angular 2 has to offer. That&apos;s because Angular 2
comes with built-in tools for migrating Angular 1 projects over to the
Angular 2 platform.</p><span>
</span><p>Some applications will be easier to upgrade than others, and there are
ways in which we can make it easier for ourselves. It is possible to
prepare and align Angular 1 applications with Angular 2 even before beginning
the upgrade process. These preparation steps are all about making the code
more decoupled, more maintainable, and up to speed with modern development
tools. That means the preparation work will not only make the eventual upgrade
easier, but will also generally improve our Angular 1 applications.</p><span>
</span><p>One of the keys to a successful upgrade is to do it incrementally,
by running the two frameworks side by side in the same application, and
porting Angular 1 components to Angular 2 one by one. This makes it possible
to upgrade even large and complex applications without disrupting other
business, because the work can be done collaboratively and spread over
a period of time. The <code>upgrade</code> module in Angular 2 has been designed to
make incremental upgrading seamless.</p><span>
</span><ol>
<li><a href="https://angular.io/docs/ts/latest/guide/upgrade.html#preparation">Preparation</a><ol>
<li><a href="https://angular.io/docs/ts/latest/guide/upgrade.html#following-the-angular-style-guide">Following The Angular Style Guide</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/upgrade.html#using-a-module-loader">Using a Module Loader</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/upgrade.html#migrating-to-typescript">Migrating to TypeScript</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/upgrade.html#using-component-directives">Using Component Directives</a></li>
</ol>
</li>
<li><a href="https://angular.io/docs/ts/latest/guide/upgrade.html#upgrading-with-the-upgrade-adapter">Upgrading with The Upgrade Adapter</a><ol>
<li><a href="https://angular.io/docs/ts/latest/guide/upgrade.html#how-the-upgrade-adapter-works">How The Upgrade Adapter Works</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/upgrade.html#bootstrapping-hybrid-angular-1-2-applications">Bootstrapping Hybrid Angular 1+2 Applications</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/upgrade.html#using-angular-2-components-from-angular-1-code">Using Angular 2 Components from Angular 1 Code</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/upgrade.html#using-angular-1-component-directives-from-angular-2-code">Using Angular 1 Component Directives from Angular 2 Code</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/upgrade.html#projecting-angular-1-content-into-angular-2-components">Projecting Angular 1 Content into Angular 2 Components</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/upgrade.html#transcluding-angular-2-content-into-angular-1-component-directives">Transcluding Angular 2 Content into Angular 1 Component Directives</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/upgrade.html#making-angular-1-dependencies-injectable-to-angular-2">Making Angular 1 Dependencies Injectable to Angular 2</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/upgrade.html#making-angular-2-dependencies-injectable-to-angular-1">Making Angular 2 Dependencies Injectable to Angular 1</a></li>
</ol>
</li>
<li><a href="https://angular.io/docs/ts/latest/guide/upgrade.html#phonecat-upgrade-tutorial">PhoneCat Upgrade Tutorial</a><ol>
<li><a href="https://angular.io/docs/ts/latest/guide/upgrade.html#switching-to-typescript">Switching to TypeScript</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/upgrade.html#installing-angular-2">Installing Angular 2</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/upgrade.html#bootstrapping-a-hybrid-1-2-phonecat">Bootstrapping A Hybrid 1+2 PhoneCat</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/upgrade.html#upgrading-the-phone-service">Upgrading the Phone service</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/upgrade.html#upgrading-components">Upgrading Components</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/upgrade.html#switching-to-the-angular-2-router-and-bootstrap">Switching To The Angular 2 Router And Bootstrap</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/upgrade.html#saying-goodbye-to-angular-1">Saying Goodbye to Angular 1</a></li>
</ol>
</li>
<li><a href="https://angular.io/docs/ts/latest/guide/upgrade.html#appendix-upgrading-phonecat-tests">Appendix: Upgrading PhoneCat Tests</a></li>
</ol><span>
</span><h1 id="preparation">Preparation</h1><span>
</span><p>There are many ways to structure Angular 1 applications. When we begin
to upgrade these applications to Angular 2, some will turn out to be
much more easy to work with than others. There are a few key techniques
and patterns that we can apply to future proof our apps even before we
begin the migration.</p><span>
</span><h2 id="following-the-angular-style-guide">Following The Angular Style Guide</h2><span>
</span><p>The <a href="https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#single-responsibility">Angular 1 Style Guide</a>
collects patterns and practices that have been proven to result in
cleaner and more maintainable Angular 1 applications. It contains a wealth
of information about how to write and organize Angular code - and equally
importantly - how <strong>not</strong> to write and organize Angular code.</p><span>
</span><p>Angular 2 is a reimagined version of the best parts of Angular 1. In that
sense, its goals are the same as the Angular Style Guide&apos;s: To preserve
the good parts of Angular 1, and to avoid the bad parts. There&apos;s a lot
more to Angular 2 than just that of course, but this does mean that
<em>following the style guide helps make your Angular 1 app more closely
aligned with Angular 2</em>.</p><span>
</span><p>There are a few rules in particular that will make it much easier to do
<em>an incremental upgrade</em> using the Angular 2 <code>upgrade</code> module:</p><span>
</span><ul>
<li>The <a href="https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#single-responsibility">Rule of 1</a>
states that there should be one component per file. This not only makes
components easy to navigate and find, but will also allow us to migrate
them between languages and frameworks one at a time. In this example application,
each controller, component, service, and filter is in its own source file.</li>
<li>The <a href="https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#folders-by-feature-structure">Folders-by-Feature Structure</a>
and <a href="https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#modularity">Modularity</a>
rules define similar principles on a higher level of abstraction: Different parts of the
application should reside in different directories and Angular modules.</li>
</ul><span>
</span><p>When an application is laid out feature per feature in this way, it can also be
migrated one feature at a time. For applications that don&apos;t already look like
this, applying the rules in the Angular style guide is a highly recommended
preparation step. And this is not just for the sake of the upgrade - it is just
solid advice in general!</p><span>
</span><h2 id="using-a-module-loader">Using a Module Loader</h2><span>
</span><p>When we break application code down into one component per file, we often end
up with a project structure with a large number of relatively small files. This is
a much neater way to organize things than a small number of large files, but it
doesn&apos;t work that well if you have to load all those files to the HTML page with
&lt;script&gt; tags. Especially when you also have to maintain those tags in the correct
order. That&apos;s why it&apos;s a good idea to start using a <em>module loader</em>.</p><span>
</span><p>Using a module loader such as <a href="https://github.com/systemjs/systemjs">SystemJS</a>,
<a href="http://webpack.github.io/">Webpack</a>, or <a href="http://browserify.org/">Browserify</a>
allows us to use the built-in module systems of the TypeScript or ES2015 languages in our apps.
We can use the <code>import</code> and <code>export</code> features that explicitly specify what code can
and will be shared between different parts of the application. For ES5 applications
we can use CommonJS style <code>require</code> and <code>module.exports</code> features. In both cases,
the module loader will then take care of loading all the code the application needs
in the correct order.</p><span>
</span><p>When we then take our applications into production, module loaders also make it easier
to package them all up into production bundles with batteries included.</p><span>
</span><h2 id="migrating-to-typescript">Migrating to TypeScript</h2><span>
</span><p>If part of our Angular 2 upgrade plan is to also take TypeScript into use, it makes
sense to bring in the TypeScript compiler even before the upgrade itself begins.
This means there&apos;s one less thing to learn and think about during the actual upgrade.
It also means we can start using TypeScript features in our Angular 1 code.</p><span>
</span><p>Since TypeScript is a superset of ECMAScript 2015, which in turn is a superset
of ECMAScript 5, &quot;switching&quot; to TypeScript doesn&apos;t necessarily require anything
more than installing the TypeScript compiler and switching renaming files from
<code>*.js</code> to <code>*.ts</code>. But just doing that is not hugely useful or exciting, of course.
Additional steps like the following can give us much more bang for the buck:</p><span>
</span><ul>
<li>For applications that use a module loader, TypeScript imports and exports
(which are really ECMAScript 2015 imports and exports) can be used to organize
code into modules.</li>
<li>Type annotations can be gradually added to existing functions and variables
to pin down their types and get benefits like build-time error checking,
great autocompletion support and inline documentation.</li>
<li>JavaScript features new to ES2015, like arrow functions, <code>let</code>s and <code>const</code>s,
default function parameters, and destructuring assignments can also be gradually
added to make the code more expressive.</li>
<li>Services and controllers can be turned into <em>classes</em>. That way they&apos;ll be a step
closer to becoming Angular 2 service and component classes, which will make our
life easier once we do the upgrade.</li>
</ul><span>
</span><h2 id="using-component-directives">Using Component Directives</h2><span>
</span><p>In Angular 2, components are the main primitive from which user interfaces
are built. We define the different parts of our UIs as components, and then
compose the UI by using components in our templates.</p><span>
</span><p>You can also do this in Angular 1, using <em>component directives</em>. These are
directives that define their own templates, controllers, and input/output bindings -
the same things that Angular 2 components define. Applications built with
component directives are much easier to migrate to Angular 2 than applications
built with lower-level features like <code>ng-controller</code>,  <code>ng-include</code>, and scope
inheritance.</p><span>
</span><p>To be Angular 2 compatible, an Angular 1 component directive should configure
these attributes:</p><span>
</span><ul>
<li><code>restrict: &apos;E&apos;</code>. Components are usually used as elements.</li>
<li><code>scope: {}</code> - an isolate scope. In Angular 2, components are always isolated
from their surroundings, and we should do this in Angular 1 too.</li>
<li><code>bindToController: {}</code>. Component inputs and outputs should be bound
to the controller instead of using the <code>$scope</code>.</li>
<li><code>controller</code> and <code>controllerAs</code>. Components have their own controllers.</li>
<li><code>template</code> or <code>templateUrl</code>. Components have their own templates.</li>
</ul><span>
</span><p>Component directives may also use the following attributes:</p><span>
</span><ul>
<li><code>transclude: true</code>, if the component needs to transclude content from elsewhere.</li>
<li><code>require</code>, if the component needs to communicate with some parent component&apos;s
controller.</li>
</ul><span>
</span><p>Component directives <strong>may not</strong> use the following attributes:</p><span>
</span><ul>
<li><code>compile</code>. This will not be supported in Angular 2.</li>
<li><code>replace: true</code>. Angular 2 never replaces a component element with the
component template. This attribute is also deprecated in Angular 1.</li>
<li><code>priority</code> and <code>terminal</code>. While Angular 1 components may use these,
they are not used in Angular 2 and it is better not to write code
that relies on them.</li>
</ul><span>
</span><p>An Angular 1 component directive that is fully aligned with the Angular 2
architecture may look something like this:</p><span>
</span><code language="ts" format="linenums">export function heroDetailDirective() {
  return {
    restrict: &apos;E&apos;,
    scope: {},
    bindToController: {
      hero: &apos;=&apos;,
      deleted: &apos;&amp;&apos;
    },
    template: `
      &lt;h2&gt;{{ctrl.hero.name}} details!&lt;/h2&gt;
      &lt;div&gt;&lt;label&gt;id: &lt;/label&gt;{{ctrl.hero.id}}&lt;/div&gt;
      &lt;button ng-click=&quot;ctrl.onDelete()&quot;&gt;Delete&lt;/button&gt;
    `,
    controller: function() {
      this.onDelete = () =&gt; {
        this.deleted({hero: this.hero});
      };
    },
    controllerAs: &apos;ctrl&apos;
  };
}
</code><p>Angular 1.5 introduces the <a href="https://docs.angularjs.org/api/ng/type/angular.Module">component API</a>
that makes it easier to define directives like these. It is a good idea to use
this API for component directives for several reasons:</p><span>
</span><ul>
<li>It requires less boilerplate code.</li>
<li>It enforces the use of component best practices like <code>controllerAs</code>.</li>
<li>It has good default values for directive attributes like <code>scope</code> and <code>restrict</code>.</li>
</ul><span>
</span><p>The component directive example from above looks like this when expressed
using the component API:</p><span>
</span><code language="ts" format="linenums">export const heroDetail = {
  bindings: {
    hero: &apos;&lt;&apos;,
    deleted: &apos;&amp;&apos;
  },
  template: `
    &lt;h2&gt;{{$ctrl.hero.name}} details!&lt;/h2&gt;
    &lt;div&gt;&lt;label&gt;id: &lt;/label&gt;{{$ctrl.hero.id}}&lt;/div&gt;
    &lt;button ng-click=&quot;$ctrl.onDelete()&quot;&gt;Delete&lt;/button&gt;
  `,
  controller: function() {
    this.onDelete = () =&gt; {
      this.deleted(this.hero);
    };
  }
};
</code><p>Controller lifecycle hook methods <code>$onInit()</code>, <code>$onDestroy()</code>, and <code>$onChanges()</code>
are another convenient feature that Angular 1.5 introduces. They all have nearly
exact <a href="https://angular.io/docs/ts/latest/guide/lifecycle-hooks.html">equivalents in Angular 2</a>, so organizing component lifecycle
logic around them will ease the eventual Angular 2 upgrade process.</p><span>
</span><h1 id="upgrading-with-the-upgrade-adapter">Upgrading with The Upgrade Adapter</h1><span>
</span><p>The <code>upgrade</code> module in Angular 2 is a very useful tool for upgrading
anything but the smallest of applications. With it we can mix and match
Angular 1 and 2 components in the same application and have them interoperate
seamlessly. That means we don&apos;t have to do the upgrade work all at once,
since there&apos;s a natural coexistence between the two frameworks during the
transition period.</p><span>
</span><h2 id="how-the-upgrade-adapter-works">How The Upgrade Adapter Works</h2><span>
</span><p>The primary tool provided by the upgrade module is called the <code>UpgradeAdapter</code>.
This is a service that can bootstrap and manage hybrid applications that support
both Angular 2 and Angular 1 code.</p><span>
</span><p>When we use <code>UpgradeAdapter</code>, what we&apos;re really doing is <em>running both versions
of Angular at the same time</em>. All Angular 2 code is running in the Angular 2
framework, and Angular 1 code in the Angular 1 framework. Both of these are the
actual, fully featured versions of the frameworks. There is no emulation going on,
so we can expect to have all the features and natural behavior of both frameworks.</p><span>
</span><p>What happens on top of this is that components and services managed by one
framework can interoperate with those from the other framework. This happens
in three main areas: Dependency injection, the DOM, and change detection.</p><span>
</span><h3 id="dependency-injection">Dependency Injection</h3><span>
</span><p>Dependency injection is front and center in both Angular 1 and
Angular 2, but there are some key differences between the two
frameworks in how it actually works.</p><span>
</span><table><tbody><tr><th>Angular 1</th><th>Angular 2</th></tr><tr><td><p>Dependency injection tokens are always strings</p>
</td><td><p>Tokens <a href="https://angular.io/docs/ts/latest/guide/dependency-injection.html">can have different types</a>.
They are often classes. They may also be strings.</p>
</td></tr><tr><td><p>There is exactly one injector. Even in multi-module applications,
everything is poured into one big namespace.</p>
</td><td><p>There is a <a href="https://angular.io/docs/ts/latest/guide/hierarchical-dependency-injection.html">tree hierarchy of injectors</a>,
with a root injector and an additional injector for each component.</p>
</td></tr></tbody></table><p>Even accounting for these differences we can still have dependency injection
interoperability. The <code>UpgradeAdapter</code> resolves the differences and makes
everything work seamlessly:</p><span>
</span><ul>
<li>We can make Angular 1 services available for injection to Angular 2 code
by <em>upgrading</em> them. The same singleton instance of each service is shared
between the frameworks. In Angular 2 these services will always be in the
<em>root injector</em> and available to all components. They will always have
<em>string tokens</em> - the same tokens that they have in Angular 1.</li>
<li>We can also make Angular 2 services available for injection to Angular 1 code
by <em>downgrading</em> them. Only services from the Angular 2 root injector can
be downgraded. Again, the same singleton instances are shared between the frameworks.
When we register a downgrade, we explicitly specify a <em>string token</em> that we want to
use in Angular 1.</li>
</ul><span>
</span><figure class="image-display"><img src="https://angular.io/resources/images/devguide/upgrade/injectors.png" alt="The two injectors in a hybrid application" width="700"></figure><h3 id="components-and-the-dom">Components and the DOM</h3><span>
</span><p>What we&apos;ll find in the DOM of a hybrid application are components and
directives from both Angular 1 and Angular 2. These components
communicate with each other by using the input and output bindings
of their respective frameworks, which the <code>UpgradeAdapter</code> bridges
together. They may also communicate through shared injected dependencies,
as described above.</p><span>
</span><p>There are two key things to understand about what happens in the DOM
of a hybrid application:</p><span>
</span><ol>
<li>Every element in the DOM is owned by exactly one of the two
frameworks. The other framework ignores it. If an element is
owned by Angular 1, Angular 2 treats it as if it didn&apos;t exist,
and vice versa.</li>
<li>The root of the application <em>is always an Angular 1 template</em>.</li>
</ol><span>
</span><p>So a hybrid application begins life as an Angular 1 application,
and it is Angular 1 that processes its root template. Angular 2 then steps
into the picture when an Angular 2 component is used somewhere in
the application templates. That component&apos;s view will then be managed
by Angular 2, and it may use any number of Angular 2 components and
directives.</p><span>
</span><p>Beyond that, we may interleave the two frameworks as much as we need to.
We always cross the boundary between the two frameworks by one of two
ways:</p><span>
</span><ol>
<li>By using a component from the other framework: An Angular 1 template
using an Angular 2 component, or an Angular 2 template using an
Angular 1 component.</li>
<li>By transcluding or projecting content from the other framework. The
<code>UpgradeAdapter</code> bridges the related concepts of  Angular 1 transclusion
and Angular 2 content projection together.</li>
</ol><span>
</span><figure class="image-display"><img src="https://angular.io/resources/images/devguide/upgrade/dom.png" alt="DOM element ownership in a hybrid application" width="500"></figure><p>Whenever we use a component that belongs to the other framework, a
switch between framework boundaries occurs. However, that switch only
happens to the <em>children</em> of the component element. Consider a situation
where we use an Angular 2 component from Angular 1 like this:</p><span>
</span><pre><code>&lt;ng2-component&gt;&lt;/ng2-component&gt;
</code></pre><p>The DOM element <code>&lt;ng2-component&gt;</code> will remain to be an Angular 1 managed
element, because it&apos;s defined in an Angular 1 template. That also
means you can apply additional Angular 1 directives to it, but <em>not</em>
Angular 2 directives. It is only in the template of the <code>Ng2Component</code>
component where Angular 2 steps in. This same rule also applies when you
use Angular 1 component directives from Angular 2.</p><span>
</span><h3 id="change-detection">Change Detection</h3><span>
</span><p>Change detection in Angular 1 is all about <code>scope.$apply()</code>. After every
event that occurs, <code>scope.$apply()</code> gets called. This is done either
automatically by the framework, or in some cases manually by our own
code. It is the point in time when change detection occurs and data
bindings get updated.</p><span>
</span><p>In Angular 2 things are different. While change detection still
occurs after every event, no one needs to call <code>scope.$apply()</code> for
that to happen. This is because all Angular 2 code runs inside something
called the <a href="https://angular.io/docs/ts/latest/api/core/index/NgZone-class.html">Angular zone</a>. Angular always
knows when the code finishes, so it also knows when it should kick off
change detection. The code itself doesn&apos;t have to call <code>scope.$apply()</code>
or anything like it.</p><span>
</span><p>In the case of hybrid applications, the <code>UpgradeAdapter</code> bridges the
Angular 1 and Angular 2 approaches. Here&apos;s what happens:</p><span>
</span><ul>
<li>Everything that happens in the application runs inside the Angular 2 zone.
This is true whether the event originated in Angular 1 or Angular 2 code.
The zone triggers Angular 2 change detection after every event.</li>
<li>The <code>UpgradeAdapter</code> will invoke the Angular 1 <code>$rootScope.$apply()</code> after
every turn of the Angular zone. This also triggers Angular 1 change
detection after every event.</li>
</ul><span>
</span><figure class="image-display"><img src="https://angular.io/resources/images/devguide/upgrade/change_detection.png" alt="Change detection in a hybrid application" width="600"></figure><p>What this means in practice is that we do not need to call <code>$apply()</code> in
our code, regardless of whether it is in Angular 1 on Angular 2. The
<code>UpgradeAdapter</code> does it for us. We <em>can</em> still call <code>$apply()</code> so there
is no need to remove such calls from existing code. Those calls just don&apos;t
have any effect in a hybrid application.</p><span>
</span><p>When we downgrade an Angular 2 component and then use it from Angular 1,
the component&apos;s inputs will be watched using Angular 1 change detection.
When those inputs change, the corresponding properties in the component
are set. We can also hook into the changes by implementing the
<a href="https://angular.io/docs/ts/latest/api/core/index/OnChanges-class.html">OnChanges</a> interface in the component,
just like we could if it hadn&apos;t been downgraded.</p><span>
</span><p>Correspondingly, when we upgrade an Angular 1 component and use it from Angular 2,
all the bindings defined for the component directive&apos;s <code>scope</code> (or <code>bindToController</code>)
will be hooked into Angular 2 change detection. They will be treated
as regular Angular 2 inputs and set onto the scope (or controller) when
they change.</p><span>
</span><h2 id="bootstrapping-hybrid-angular-1-2-applications">Bootstrapping Hybrid Angular 1+2 Applications</h2><span>
</span><p>The first step to upgrading an application using the <code>UpgradeAdapter</code> is
always to bootstrap it as a hybrid that supports both Angular 1 and
Angular 2.</p><span>
</span><p>Pure Angular 1 applications can be bootstrapped in two ways: By using an <code>ng-app</code>
directive somewhere on the HTML page, or by calling
<a href="https://docs.angularjs.org/api/ng/function/angular.bootstrap">angular.bootstrap</a>
from JavaScript. In Angular 2, only the second method is possible - there is
no <code>ng-app</code> in Angular 2. This is also the case for hybrid applications.
Therefore, it is a good preliminary step to switch Angular 1 applications to use the
JavaScript bootstrap method even before switching them to hybrid mode.</p><span>
</span><p>Say we have an <code>ng-app</code> driven bootstrap such as this one:</p><span>
</span><code language="html" format="linenums">&lt;!DOCTYPE HTML&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;script src=&quot;https://ajax.googleapis.com/ajax/libs/angularjs/1.5.3/angular.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;app/1-ng-app/app.module.js&quot;&gt;&lt;/script&gt;
  &lt;/head&gt;

  &lt;body <span class="otl">ng-app=&quot;heroApp&quot; ng-strict-di</span>&gt;
    &lt;div id=&quot;message&quot; ng-controller=&quot;MainCtrl as mainCtrl&quot;&gt;
      {{ mainCtrl.message }}
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code><p>We can remove the <code>ng-app</code> and <code>ng-strict-di</code> directives from the HTML
and instead switch to calling <code>angular.bootstrap</code> from JavaScript, which
will result in the same thing:</p><span>
</span><code language="ts" format="">angular.bootstrap(document.body, [&apos;heroApp&apos;], {strictDi: true});
</code><p>To then switch the application into hybrid mode, we must first
install Angular 2 to the project. Follow the instructions in
<a href="https://angular.io/docs/ts/latest/quickstart.html">the QuickStart</a> for some pointers on this.
When we have Angular 2 installed, we can import and instantiate
the <code>UpgradeAdapter</code>, and then call its <code>bootstrap</code> method. It
is designed to take the exact same arguments as
<a href="https://docs.angularjs.org/api/ng/function/angular.bootstrap">angular.bootstrap</a>
so that it is easy to make the switch:</p><span>
</span><code language="ts" format="linenums">import { UpgradeAdapter } from &apos;@angular/upgrade&apos;;

/* . . . */

const upgradeAdapter = new UpgradeAdapter();

upgradeAdapter.bootstrap(document.body, [&apos;heroApp&apos;], {strictDi: true});
</code><p>At this point we&apos;ll be running a hybrid Angular 1+2 application! All the
existing Angular 1 code will work as it always did, but we are now ready
to run Angular 2 code as well.</p><span>
</span><div class="alert is-helpful"><p>One notable difference between <code>angular.bootstrap</code> and
<code>upgradeAdapter.bootstrap</code> is that the latter works <em>asynchronously</em>.
This means that we cannot assume that the application has been instantiated
immediately after the bootstrap call returns.</p><span>
</span></div><p>As we begin to migrate components to Angular 2, we&apos;ll be using the
<code>UpgradeAdapter</code> for more than just bootstrapping. It&apos;ll be important
to use the <strong>same</strong> instance of the adapter across the whole application,
because it stores internal information about what&apos;s going on in the application.
It&apos;ll be useful to have a module for a shared <code>UpgradeAdapter</code> instance in
the project:</p><span>
</span><p>upgrade_adapter.ts</p><code language="ts" format="linenums">import { UpgradeAdapter } from &apos;@angular/upgrade&apos;;
export const upgradeAdapter = new UpgradeAdapter();
</code><p>This shared instance can then be pulled in to all the modules that need it:</p><span>
</span><code language="ts" format="linenums">import { upgradeAdapter } from &apos;./upgrade_adapter&apos;;

/* . . . */

upgradeAdapter.bootstrap(document.body, [&apos;heroApp&apos;], {strictDi: true});
</code><h2 id="using-angular-2-components-from-angular-1-code">Using Angular 2 Components from Angular 1 Code</h2><span>
</span><figure><img src="https://angular.io/resources/images/devguide/upgrade/a1-to-a2.png" alt="Using an Angular 2 component from Angular 1 code" align="left"></figure><p>Once we&apos;re running a hybrid app, we can start the gradual process of upgrading
code. One of the more common patterns for doing that is to use an Angular 2 component
in an Angular 1 context. This could be a completely new component or one that was
previously Angular 1 but has been rewritten for Angular 2.</p><span>
</span><p>Say we have a simple Angular 2 component that shows information about a hero:</p><span>
</span><p>hero-detail.component.ts</p><code language="ts" format="linenums">import { Component } from &apos;@angular/core&apos;;

@Component({
  selector: &apos;hero-detail&apos;,
  template: `
    &lt;h2&gt;Windstorm details!&lt;/h2&gt;
    &lt;div&gt;&lt;label&gt;id: &lt;/label&gt;1&lt;/div&gt;
  `
})
export class HeroDetailComponent {

}
</code><p>If we want to use this component from Angular 1, we need to <em>downgrade</em> it
using the upgrade adapter. What we get when we do that is an Angular 1
<em>directive</em>, which we can then register into our Angular 1 module:</p><span>
</span><code language="ts" format="linenums">import { HeroDetailComponent } from &apos;./hero-detail.component&apos;;

/* . . . */

angular.module(&apos;heroApp&apos;, [])
  .directive(&apos;heroDetail&apos;, upgradeAdapter.downgradeNg2Component(HeroDetailComponent));
</code><p>What we have here is an Angular 1 directive called <code>heroDetail</code>, which we can
use like any other directive in our Angular 1 templates.</p><span>
</span><code language="html" format="">&lt;hero-detail&gt;&lt;/hero-detail&gt;
</code><div class="alert is-helpful"><p>Note that since Angular 1 directives are matched based on their name,
<em>the selector metadata of the Angular 2 component is not used in Angular 1</em>.
It is matched as an element directive (<code>restrict: &apos;E&apos;</code>) called <code>heroDetail</code>.</p><span>
</span></div><p>Most components are not quite this simple, of course. Many of them
have <em>inputs and outputs</em> that connect them to the outside world. An
Angular 2 hero detail component with inputs and outputs might look
like this:</p><span>
</span><p>hero-detail.component.ts</p><code language="ts" format="linenums">import { Component, EventEmitter, Input, Output } from &apos;@angular/core&apos;;
import { Hero } from &apos;../hero&apos;;

@Component({
  selector: &apos;hero-detail&apos;,
  template: `
    &lt;h2&gt;{{hero.name}} details!&lt;/h2&gt;
    &lt;div&gt;&lt;label&gt;id: &lt;/label&gt;{{hero.id}}&lt;/div&gt;
    &lt;button (click)=&quot;onDelete()&quot;&gt;Delete&lt;/button&gt;
  `
})
export class HeroDetailComponent {
  @Input() hero: Hero;
  @Output() deleted = new EventEmitter&lt;Hero&gt;();
  onDelete() {
    this.deleted.emit(this.hero);
  }
}
</code><p>These inputs and outputs can be supplied from the Angular 1 template, and the
<code>UpgradeAdapter</code> takes care of bridging them over:</p><span>
</span><code language="html" format="linenums">&lt;div ng-controller=&quot;MainController as mainCtrl&quot;&gt;
  &lt;hero-detail [hero]=&quot;mainCtrl.hero&quot;
               (deleted)=&quot;mainCtrl.onDelete($event)&quot;&gt;
  &lt;/hero-detail&gt;
&lt;/div&gt;
</code><p>Note that even though we are in an Angular 1 template, <strong>we&apos;re using Angular 2
attribute syntax to bind the inputs and outputs</strong>. This is a requirement for downgraded
components. The expressions themselves are still regular Angular 1 expressions.</p><span>
</span><div class="callout is-important"><header>Use kebab-case for downgraded component attributes</header><p>There&apos;s one notable exception to the rule of using Angular 2 attribute syntax
for downgraded components. It has to do with input or output names that consist
of multiple words. In Angular 2 we would bind these attributes using camelCase:</p><span>
</span><code format="">[myHero]=&quot;hero&quot;</code><p>But when using them from Angular 1 templates, we need to use kebab-case:</p><span>
</span><code format="">[my-hero]=&quot;hero&quot;
</code></div><p>The <code>$event</code> variable can be used in outputs to gain access to the
object that was emitted. In this case it will be the <code>Hero</code> object, because
that is what was passed to <code>this.deleted.emit()</code>.</p><span>
</span><p>Since this is an Angular 1 template, we can still use other Angular 1
directives on the element, even though it has Angular 2 binding attributes on it.
For  example, we can easily make multiple copies of the component using <code>ng-repeat</code>:</p><span>
</span><code language="html" format="linenums">&lt;div ng-controller=&quot;MainController as mainCtrl&quot;&gt;
  &lt;hero-detail [hero]=&quot;hero&quot;
               (deleted)=&quot;mainCtrl.onDelete($event)&quot;
               ng-repeat=&quot;hero in mainCtrl.heroes&quot;&gt;
  &lt;/hero-detail&gt;
&lt;/div&gt;
</code><h2 id="using-angular-1-component-directives-from-angular-2-code">Using Angular 1 Component Directives from Angular 2 Code</h2><span>
</span><figure><img src="https://angular.io/resources/images/devguide/upgrade/a2-to-a1.png" alt="Using an Angular 1 component from Angular 2 code" align="left"></figure><p>So, we can write an Angular 2 component and then use it from Angular 1
code. This is very useful when we start our migration from lower-level
components and work our way up. But in some cases it is more convenient
to do things in the opposite order: To start with higher-level components
and work our way down. This too can be done using the <code>UpgradeAdapter</code>.
We can <em>upgrade</em> Angular 1 component directives and then use them from
Angular 2.</p><span>
</span><p>Not all kinds of Angular 1 directives can be upgraded. The directive
really has to be a <em>component directive</em>, with the characteristics
<a href="https://angular.io/docs/ts/latest/guide/upgrade.html#using-component-directives">described in the preparation guide above</a>.
Our safest bet for ensuring compatibility is using the
<a href="https://docs.angularjs.org/api/ng/type/angular.Module">component API</a>
introduced in Angular 1.5.</p><span>
</span><p>A simple example of an upgradable component is one that just has a template
and a controller:</p><span>
</span><p>hero-detail.component.ts</p><code language="ts" format="linenums">export const heroDetail = {
  template: `
    &lt;h2&gt;Windstorm details!&lt;/h2&gt;
    &lt;div&gt;&lt;label&gt;id: &lt;/label&gt;1&lt;/div&gt;
  `,
  controller: function() {
  }
};
</code><p>We can <em>upgrade</em> this component to Angular 2 using the <code>UpgradeAdapter</code>&apos;s
<code>upgradeNg1Component</code> method. It takes the name of an Angular 1 component
directive and returns an Angular 2 <strong>component class</strong>. When we then
want to use it from an Angular 2 component, we list it the in the <code>directives</code>
metadata of the component and then just use it in the Angular 2 template:</p><span>
</span><p>container.component.ts</p><code language="ts" format="linenums">import { Component } from &apos;@angular/core&apos;;
import { upgradeAdapter } from &apos;./upgrade_adapter&apos;;

const HeroDetail = upgradeAdapter.upgradeNg1Component(&apos;heroDetail&apos;);

@Component({
  selector: &apos;my-container&apos;,
  template: `
    &lt;h1&gt;Tour of Heroes&lt;/h1&gt;
    &lt;hero-detail&gt;&lt;/hero-detail&gt;
  `,
  directives: [HeroDetail]
})
export class ContainerComponent {

}
</code><div class="alert is-helpful"><p>Upgraded components always have an element selector, which is based
on the original name of the original Angular 1 component directive.</p><span>
</span></div><p>An upgraded component may also have inputs and outputs, as defined by
the scope/controller bindings of the original Angular 1 component
directive. When we use the component from an Angular 2 template,
we provide the inputs and outputs using <strong>Angular 2 template syntax</strong>,
with the following rules:</p><span>
</span><table><tbody><tr><th></th><th>Binding definition</th><th>Template syntax</th></tr><tr><th>Attribute binding</th><td><p><code>myAttribute: &apos;@myAttribute&apos;</code></p>
</td><td><p><code>&lt;my-component myAttribute=&quot;value&quot;&gt;</code></p>
</td></tr><tr><th>Expression binding</th><td><p><code>myOutput: &apos;&amp;myOutput&apos;</code></p>
</td><td><p><code>&lt;my-component (myOutput)=&quot;action()&quot;&gt;</code></p>
</td></tr><tr><th>One-way binding</th><td><p><code>myValue: &apos;&lt;myValue&apos;</code></p>
</td><td><p><code>&lt;my-component [myValue]=&quot;anExpression&quot;&gt;</code></p>
</td></tr><tr><th>Two-way binding</th><td><p><code>myValue: &apos;=myValue&apos;</code></p>
</td><td><p>As a two-way binding: <code>&lt;my-component [(myValue)]=&quot;anExpression&quot;&gt;</code>.
Since most Angular 1 two-way bindings actually only need a one-way binding
in practice, <code>&lt;my-component [myValue]=&quot;anExpression&quot;&gt;</code> is often enough.</p>
</td></tr></tbody></table><p>As an example, say we have a hero detail Angular 1 component directive
with one input and one output:</p><span>
</span><p>hero-detail.component.ts</p><code language="ts" format="linenums">export const heroDetail = {
  bindings: {
    hero: &apos;&lt;&apos;,
    deleted: &apos;&amp;&apos;
  },
  template: `
    &lt;h2&gt;{{$ctrl.hero.name}} details!&lt;/h2&gt;
    &lt;div&gt;&lt;label&gt;id: &lt;/label&gt;{{$ctrl.hero.id}}&lt;/div&gt;
    &lt;button ng-click=&quot;$ctrl.onDelete()&quot;&gt;Delete&lt;/button&gt;
  `,
  controller: function() {
    this.onDelete = () =&gt; {
      this.deleted(this.hero);
    };
  }
};
</code><p>We can upgrade this component to Angular 2, and then provide the input
and output using Angular 2 template syntax:</p><span>
</span><p>container.component.ts</p><code language="ts" format="linenums">import { Component } from &apos;@angular/core&apos;;
import { upgradeAdapter } from &apos;./upgrade_adapter&apos;;
import { Hero } from &apos;../hero&apos;;

const HeroDetail = upgradeAdapter.upgradeNg1Component(&apos;heroDetail&apos;);

@Component({
  selector: &apos;my-container&apos;,
  template: `
    &lt;h1&gt;Tour of Heroes&lt;/h1&gt;
    &lt;hero-detail [hero]=&quot;hero&quot;
                 (deleted)=&quot;heroDeleted($event)&quot;&gt;
    &lt;/hero-detail&gt;
  `,
  directives: [HeroDetail]
})
export class ContainerComponent {
  hero = new Hero(1, &apos;Windstorm&apos;);
  heroDeleted(hero: Hero) {
    hero.name = &apos;Ex-&apos; + hero.name;
  }
}
</code><h2 id="projecting-angular-1-content-into-angular-2-components">Projecting Angular 1 Content into Angular 2 Components</h2><span>
</span><figure><img src="https://angular.io/resources/images/devguide/upgrade/a1-to-a2-with-projection.png" alt="Projecting Angular 1 content into Angular 2" align="left"></figure><p>When we are using a downgraded Angular 2 component from an Angular 1
template, the need may arise to <em>transclude</em> some content into it. This
is also possible. While there is no such thing as transclusion in Angular 2,
there is a very similar concept called <em>content projection</em>. The <code>UpgradeAdapter</code>
is able to make these two features interoperate.</p><span>
</span><p>Angular 2 components that support content projection make use of an <code>&lt;ng-content&gt;</code>
tag within them. Here&apos;s an example of such a component:</p><span>
</span><p>hero-detail.component.ts</p><code language="ts" format="linenums">import { Component, Input } from &apos;@angular/core&apos;;
import { Hero } from &apos;../hero&apos;;

@Component({
  selector: &apos;hero-detail&apos;,
  template: `
    &lt;h2&gt;{{hero.name}}&lt;/h2&gt;
    &lt;div&gt;
      &lt;ng-content&gt;&lt;/ng-content&gt;
    &lt;/div&gt;
  `
})
export class HeroDetailComponent {
  @Input() hero: Hero;
}
</code><p>When using the component from Angular 1, we can supply contents for it. Just
like they would be transcluded in Angular 1, they get projected to the location
of the <code>&lt;ng-content&gt;</code> tag in Angular 2:</p><span>
</span><code language="html" format="linenums">&lt;div ng-controller=&quot;MainController as mainCtrl&quot;&gt;
  &lt;hero-detail [hero]=&quot;mainCtrl.hero&quot;&gt;
    &lt;!-- Everything here will get projected --&gt;
    &lt;p&gt;{{mainCtrl.hero.description}}&lt;/p&gt;
  &lt;/hero-detail&gt;
&lt;/div&gt;
</code><div class="alert is-helpful"><p>When Angular 1 content gets projected inside an Angular 2 component, it still
remains in &quot;Angular 1 land&quot; and is managed by the Angular 1 framework.</p><span>
</span></div><h2 id="transcluding-angular-2-content-into-angular-1-component-directives">Transcluding Angular 2 Content into Angular 1 Component Directives</h2><span>
</span><figure><img src="https://angular.io/resources/images/devguide/upgrade/a2-to-a1-with-transclusion.png" alt="Projecting Angular 2 content into Angular 1" align="left"></figure><p>Just like we can project Angular 1 content into Angular 2 components,
we can <em>transclude</em> Angular 2 content into Angular 1 components, whenever
we are using upgraded versions from them.</p><span>
</span><p>When an Angular 1 component directive supports transclusion, it may use
the <code>ng-transclude</code> directive in its template to mark the transclusion
point:</p><span>
</span><p>hero-detail.component.ts</p><code language="ts" format="linenums">export const heroDetailComponent = {
  bindings: {
    hero: &apos;=&apos;
  },
  template: `
    &lt;h2&gt;{{$ctrl.hero.name}}&lt;/h2&gt;
    &lt;div&gt;
      &lt;ng-transclude&gt;&lt;/ng-transclude&gt;
    &lt;/div&gt;
  `
};
</code><div class="alert is-helpful"><p>The directive also needs to have the <code>transclude: true</code> option enabled.
It is on by default for component directives defined with the
1.5 component API.</p><span>
</span></div><p>If we upgrade this component and use it from Angular 2, we can populate
the component tag with contents that will then get transcluded:</p><span>
</span><p>container.component.ts</p><code language="ts" format="linenums">import { Component } from &apos;@angular/core&apos;;
import { upgradeAdapter } from &apos;./upgrade_adapter&apos;;
import { Hero } from &apos;../hero&apos;;

const HeroDetail = upgradeAdapter.upgradeNg1Component(&apos;heroDetail&apos;);

@Component({
  selector: &apos;my-container&apos;,
  template: `
    &lt;hero-detail [hero]=&quot;hero&quot;&gt;
      &lt;!-- Everything here will get transcluded --&gt;
      &lt;p&gt;{{hero.description}}&lt;/p&gt;
    &lt;/hero-detail&gt;
  `,
  directives: [HeroDetail]
})
export class ContainerComponent {
  hero = new Hero(1, &apos;Windstorm&apos;, &apos;Specific powers of controlling winds&apos;);
}
</code><h2 id="making-angular-1-dependencies-injectable-to-angular-2">Making Angular 1 Dependencies Injectable to Angular 2</h2><span>
</span><p>When running a hybrid app, we may bump into situations where we need to have
some Angular 1 dependencies to be injected to Angular 2 code. This may be
because we have some business logic still in Angular 1 services, or because
we need some of Angular 1&apos;s built-in services like <code>$location</code> or <code>$timeout</code>.</p><span>
</span><p>In these situations, it is possible to <em>upgrade</em> an Angular 1 provider to
Angular 2. This makes it possible to then inject it somewhere in Angular 2
code. For example, we might have a service called <code>HeroesService</code> in Angular 1:</p><span>
</span><p>heroes.service.ts</p><code language="ts" format="linenums">import { Hero } from &apos;../hero&apos;;

export class HeroesService {
  get() {
    return [
      new Hero(1, &apos;Windstorm&apos;),
      new Hero(2, &apos;Spiderman&apos;)
    ];
  }
}
</code><p>We can upgrade the service using the <code>UpgradeAdapter</code>&apos;s <code>upgradeNg1Provider</code> method
by giving it the name of the service. This adds the service into Angular 2&apos;s root injector.</p><span>
</span><p>app.module.ts</p><code language="ts" format="linenums">angular.module(&apos;heroApp&apos;, [])
  .service(&apos;heroes&apos;, HeroesService)
  .directive(&apos;heroDetail&apos;,
    upgradeAdapter.downgradeNg2Component(HeroDetailComponent));

upgradeAdapter.upgradeNg1Provider(&apos;heroes&apos;);
</code><p>We can then inject it in Angular 2 using a string token that matches
its original name in Angular 1:</p><span>
</span><p>hero-detail.component.ts</p><code language="ts" format="linenums">import { Component, Inject } from &apos;@angular/core&apos;;
import { HeroesService } from &apos;./heroes.service&apos;;
import { Hero } from &apos;../hero&apos;;

@Component({
  selector: &apos;hero-detail&apos;,
  template: `
    &lt;h2&gt;{{hero.id}}: {{hero.name}}&lt;/h2&gt;
  `
})
export class HeroDetailComponent {
  hero: Hero;
  constructor(@Inject(&apos;heroes&apos;) heroes: HeroesService) {
    this.hero = heroes.get()[0];
  }
}
</code><div class="alert is-helpful"><p>In this example we upgraded a service class, which has the added benefit that
we can use a TypeScript type annotation when we inject it. While it doesn&apos;t
affect how the dependency is handled, it enables the benefits of static type
checking. This is not required though, and any Angular 1 service, factory, or
provider can be upgraded.</p><span>
</span></div><h2 id="making-angular-2-dependencies-injectable-to-angular-1">Making Angular 2 Dependencies Injectable to Angular 1</h2><span>
</span><p>In addition to upgrading Angular 1 dependencies, we can also <em>downgrade</em>
Angular 2 dependencies, so that we can use them from Angular 1. This can be
useful when we start migrating services to Angular 2 or creating new services
in Angular 2 while we still have components written in Angular 1.</p><span>
</span><p>For example, we might have an Angular 2 service called <code>Heroes</code>:</p><span>
</span><p>heroes.ts</p><code language="ts" format="linenums">import { Injectable } from &apos;@angular/core&apos;;
import { Hero } from &apos;../hero&apos;;

@Injectable()
export class Heroes {
  get() {
    return [
      new Hero(1, &apos;Windstorm&apos;),
      new Hero(2, &apos;Spiderman&apos;)
    ];
  }
}
</code><p>We can again use the <code>UpgradeAdapter</code> for this, but first we need to register <code>Heroes</code>
to the Angular 2 injector itself. In a pure Angular 2 application we would do this
when we bootstrap the app, as described in the <a href="https://angular.io/docs/ts/latest/guide/dependency-injection.html#!#providers">dependency injection guide</a>.
But since hybrid applications are bootstrapped using the <code>UpgradeAdapter</code>, we also
need to register our Angular 2 providers using <code>UpgradeAdapter</code>. It has a method
called <code>addProvider</code> for this purpose.</p><span>
</span><p>Once we&apos;ve registered the Angular 2 provider, we can turn <code>Heroes</code> into an <em>Angular 1
factory function</em> using <code>upgradeAdapter.downgradeNg2Provider()</code>. We can
then plug the factory into an Angular 1 module, at which point we also choose what the
name of the dependency will be in Angular 1:</p><span>
</span><p>app.module.ts</p><code language="ts" format="linenums">upgradeAdapter.addProvider(Heroes);

angular.module(&apos;heroApp&apos;, [])
  .factory(&apos;heroes&apos;, upgradeAdapter.downgradeNg2Provider(Heroes))
  .component(&apos;heroDetail&apos;, heroDetailComponent);
</code><p>After this, the service is injectable anywhere in our Angular 1 code:</p><span>
</span><p>hero-detail.component.ts</p><code language="ts" format="linenums">export const heroDetailComponent = {
  template: `
    &lt;h2&gt;{{$ctrl.hero.id}}: {{$ctrl.hero.name}}&lt;/h2&gt;
  `,
  controller: [&apos;heroes&apos;, function(heroes: Heroes) {
    this.hero = heroes.get()[0];
  }]
};
</code><h1 id="phonecat-upgrade-tutorial">PhoneCat Upgrade Tutorial</h1><span>
</span><p>In this section and we will look at a complete example of
preparing and upgrading an application using the <code>upgrade</code> module. The app
we&apos;re going to work on is <a href="https://github.com/angular/angular-phonecat">Angular PhoneCat</a>
from <a href="https://docs.angularjs.org/tutorial">the original Angular 1 tutorial</a>,
which is where many of us began our Angular adventures. Now we&apos;ll see how to
bring that application to the brave new world of Angular 2.</p><span>
</span><p>During the process we&apos;ll learn how to apply the steps outlined in the
<a href="https://angular.io/docs/ts/latest/guide/upgrade.html#preparation">preparation guide</a> in practice: We&apos;ll align the application
with Angular 2 and also take TypeScript into use.</p><span>
</span><p>To follow along with the tutorial, clone the
<a href="https://github.com/angular/angular-phonecat">angular-phonecat</a> repository
and apply the steps as we go.</p><span>
</span><p>In terms of project structure, this is where our work begins:</p><span>
</span><div class="filetree"><p>angular-phonecat</p><div class="children"><p>bower.json</p><p>karma.conf.js</p><p>package.json</p><p>app</p><div class="children"><p>core</p><div class="children"><p>checkmark</p><div class="children"><p>checkmark.filter.js</p><p>checkmark.filter.spec.js</p></div><p>phone</p><div class="children"><p>phone.module.js</p><p>phone.service.js</p><p>phone.service.spec.js</p></div><p>core.module.js</p></div><p>phone-detail</p><div class="children"><p>phone-detail.component.js</p><p>phone-detail.component.spec.js</p><p>phone-detail.module.js</p><p>phone-detail.template.html</p></div><p>phone-list</p><div class="children"><p>phone-list.component.js</p><p>phone-list.component.spec.js</p><p>phone-list.module.js</p><p>phone-list.template.html</p></div><p>img</p><p>phones</p><p>app.animations.js</p><p>app.config.js</p><p>app.css</p><p>app.module.js</p><p>index.html</p></div><p>e2e-tests</p><div class="children"><p>protractor-conf.js</p><p>scenarios.js</p></div></div></div><p>This is actually a pretty good starting point. The code uses the Angular 1.5
component API and the organization follows the
<a href="https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md">Angular 1 Style Guide</a>,
which is an important <a href="https://angular.io/docs/ts/latest/guide/upgrade.html#following-the-angular-style-guide">preparation step</a> before
a successful upgrade.</p><span>
</span><ul>
<li>Each component, service, and filter is in its own source file, as per the
<a href="https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#single-responsibility">Rule of 1</a>.</li>
<li>The <code>core</code>, <code>phone-detail</code>, and <code>phone-list</code> modules are each in their
own subdirectory. Those subdirectories contain the JavaScript code as well as
the HTML templates that go with each particular feature. This is in line with the
<a href="https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#style-y152">Folders-by-Feature Structure</a>
and <a href="https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#modularity">Modularity</a>
rules.</li>
<li>Unit tests are located side-by-side with application code where they are easily
found, as described in the rules for
<a href="https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#style-y197">Organizing Tests</a>.</li>
</ul><span>
</span><h2 id="switching-to-typescript">Switching to TypeScript</h2><span>
</span><p>Since we&apos;re going to be writing our Angular 2 code in TypeScript, it makes sense to
bring in the TypeScript compiler even before we begin upgrading.</p><span>
</span><p>We will also start to gradually phase out the Bower package manager in favor
of NPM. We&apos;ll install all new dependencies using NPM, and will eventually be
able to remove Bower from the project.</p><span>
</span><p>Let&apos;s begin by installing TypeScript to the project. While we&apos;re at it, let&apos;s also
install the <a href="https://github.com/typings/typings">Typings type definition manager</a>.
It will allow us to install type definitions for libraries that don&apos;t come with
prepackaged types.</p><span>
</span><code format="">npm i typescript typings --save-dev
</code><p>Let&apos;s also add run scripts for the <code>tsc</code> TypeScript compiler and the <code>typings</code>
tool to <code>package.json</code>:</p><span>
</span><p>package.json</p><code language="json" format="linenums">{
  &quot;scripts&quot;: {
    &quot;tsc&quot;: &quot;tsc&quot;,
    &quot;tsc:w&quot;: &quot;tsc -w&quot;,
    &quot;typings&quot;: &quot;typings&quot;
  }
}</code><p>We can now use Typings to install type definitions for the existing libraries that
we&apos;re using: Angular 1 and the Jasmine unit test framework.</p><span>
</span><code format="">npm run typings install dt~jquery dt~angular dt~angular-route \
  dt~angular-resource dt~angular-mocks dt~angular-animate \
  dt~jasmine -- --save --global
</code><p>This will add these typings into a <code>typings.json</code> configuration file as well as
download them into the <code>typings directory</code>.</p><span>
</span><p>We should also configure the TypeScript compiler so that it can understand our
project. We&apos;ll add a <code>tsconfig.json</code> file to the project directory, just like we do
in the <a href="https://angular.io/docs/ts/latest/quickstart.html">Quickstart</a>. It instructs the TypeScript compiler how
to interpret our source files.</p><span>
</span><p>tsconfig.json</p><code language="json" format="linenums">{
  &quot;compilerOptions&quot;: {
    &quot;target&quot;: &quot;es5&quot;,
    &quot;module&quot;: &quot;commonjs&quot;,
    &quot;moduleResolution&quot;: &quot;node&quot;,
    &quot;sourceMap&quot;: true,
    &quot;emitDecoratorMetadata&quot;: true,
    &quot;experimentalDecorators&quot;: true,
    &quot;removeComments&quot;: false,
    &quot;noImplicitAny&quot;: false,
    &quot;suppressImplicitAnyIndexErrors&quot;: true
  }
}
</code><p>We are telling the TypeScript compiler to turn our TypeScript files to ES5 code
bundled into CommonJS modules.</p><span>
</span><p>We can now launch the TypeScript compiler from the command line. It will watch
our <code>.ts</code> source files and compile them to JavaScript on the fly. Those compiled
<code>.js</code> files are then loaded into the browser by SystemJS. This is a process we&apos;ll
want to have continuously running in the background as we go along.</p><span>
</span><code format="">npm run tsc:w
</code><p>The next thing we&apos;ll do is convert our JavaScript files to TypeScript. Since
TypeScript is a superset of ECMAScript 2015, which in turn is a superset
of ECMAScript 5, we can simply switch the file extensions from <code>.js</code> to <code>.ts</code>
and everything will work just like it did before. As the TypeScript compiler
runs, it emits the corresponding <code>.js</code> file for every <code>.ts</code> file and the
compiled JavaScript is what actually gets executed. If you start
the project HTTP server with <code>npm start</code>, you should see the fully functional
application in your browser.</p><span>
</span><p>Now that we have TypeScript though, we can start benefiting from some of its
features. There&apos;s a lot of value the language can provide to Angular 1 applications.</p><span>
</span><p>For one thing, TypeScript is a superset of ES2015. Any app that has previously
been written in ES5 - like the PhoneCat example has - can with TypeScript
start incorporating all of the JavaScript features that are new to ES2015.
These include things like <code>let</code>s and <code>const</code>s, arrow functions, default function
parameters, and destructuring assignments.</p><span>
</span><p>Another thing we can do is start adding <em>type safety</em> to our code. This has
actually partially already happened because of the Angular 1 typings we installed.
TypeScript are checking that we are calling Angular 1 APIs correctly when we do
things like register components to Angular modules.</p><span>
</span><p>But we can also start adding <em>type annotations</em> for our own code to get even more
out of TypeScript&apos;s type system. For instance, we can annotate the checkmark
filter so that it explicitly expects booleans as arguments. This makes it clearer
what the filter is supposed to do.</p><span>
</span><p>app/core/checkmark/checkmark.filter.ts</p><code language="ts" format="linenums">
angular.
  module(&apos;core&apos;).
  filter(&apos;checkmark&apos;, function() {
    return function(input: boolean) {
      return input ? &apos;\u2713&apos; : &apos;\u2718&apos;;
    };
  });
</code><p>In the <code>Phone</code> service we can explicitly annotate the <code>$resource</code> service dependency
as an <code>angular.resource.IResourceService</code> - a type defined by the Angular 1 typings.</p><span>
</span><p>app/core/phone/phone.service.ts</p><code language="ts" format="linenums">angular.
  module(&apos;core.phone&apos;).
  factory(&apos;Phone&apos;, [&apos;$resource&apos;,
    function($resource: angular.resource.IResourceService) {
      return $resource(&apos;phones/:phoneId.json&apos;, {}, {
        query: {
          method: &apos;GET&apos;,
          params: {phoneId: &apos;phones&apos;},
          isArray: true
        }
      });
    }
  ]);
</code><p>We can apply the same trick to the application&apos;s route configuration file in <code>app.config.ts</code>,
where we are using the location and route services. By annotating them accordingly TypeScript
can verify we&apos;re calling their APIs with the correct kinds of arguments.</p><span>
</span><p>app/app.config.ts</p><code language="ts" format="linenums">angular.
  module(&apos;phonecatApp&apos;).
  config([&apos;$locationProvider&apos;, &apos;$routeProvider&apos;,
    function config($locationProvider: angular.ILocationProvider,
                    $routeProvider: angular.route.IRouteProvider) {
      $locationProvider.hashPrefix(&apos;!&apos;);

      $routeProvider.
        when(&apos;/phones&apos;, {
          template: &apos;&lt;phone-list&gt;&lt;/phone-list&gt;&apos;
        }).
        when(&apos;/phones/:phoneId&apos;, {
          template: &apos;&lt;phone-detail&gt;&lt;/phone-detail&gt;&apos;
        }).
        otherwise(&apos;/phones&apos;);
    }
  ]);
</code><div class="l-sub-section"><p>The <a href="https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/angularjs">Angular 1.x type definitions</a>
we installed with Typings are not officially maintained by the Angular team,
but are quite comprehensive. It is possible to make an Angular 1.x application
fully type-annotated with the help of these definitions.</p><span>
</span><p>If this is something we wanted to do, it would be a good idea to enable
the <code>noImplicitAny</code> configuration option in <code>tsconfig.json</code>. This would
cause the TypeScript compiler to display a warning when there&apos;s any code that
does not yet have type annotations. We could use it as a guide to inform
us about how close we are to having a fully annotated project.</p><span>
</span></div><p>Another TypeScript feature we can make use of is <em>classes</em>. In particular, we
can turn our component controllers into classes. That way they&apos;ll be a step
closer to becoming Angular 2 component classes, which will make our life
easier once we do the upgrade.</p><span>
</span><p>Angular 1 expects controllers to be constructor functions. That&apos;s exactly what
ES2015/TypeScript classes are under the hood, so that means we can just plug in a
class as a component controller and Angular 1 will happily use it.</p><span>
</span><p>Here&apos;s what our new class for the phone list component controller looks like:</p><span>
</span><p>app/phone-list/phone-list.component.ts</p><code language="ts" format="linenums">class PhoneListController {
  phones: any[];
  orderProp: string;
  query: string;

  static $inject = [&apos;Phone&apos;];
  constructor(Phone: any) {
    this.phones = Phone.query();
    this.orderProp = &apos;age&apos;;
  }

}

angular.
  module(&apos;phoneList&apos;).
  component(&apos;phoneList&apos;, {
    templateUrl: &apos;phone-list/phone-list.template.html&apos;,
    controller: PhoneListController
  });
</code><p>What was previously done in the controller function is now done in the class
constructor function. The dependency injection annotations are attached
to the class using a static property <code>$inject</code>. At runtime this becomes the
<code>PhoneListController.$inject</code> property.</p><span>
</span><p>The class additionally declares three members: The array of phones, the name of
the current sort key, and the search query. These are all things we have already
been attaching to the controller but that weren&apos;t explicitly declared anywhere.
The last one of these isn&apos;t actually used in the TypeScript code since it&apos;s only
referred to in the template, but for the sake of clarity we want to define all the
members our controller will have.</p><span>
</span><p>In the Phone detail controller we&apos;ll have two members: One for the phone
that the user is looking at and another for the URL of the currently displayed image:</p><span>
</span><p>app/phone-detail/phone-detail.component.ts</p><code language="ts" format="linenums">class PhoneDetailController {
  phone: any;
  mainImageUrl: string;

  static $inject = [&apos;$routeParams&apos;, &apos;Phone&apos;];
  constructor($routeParams: angular.route.IRouteParamsService, Phone: any) {
    let phoneId = $routeParams[&apos;phoneId&apos;];
    this.phone = Phone.get({phoneId}, (phone: any) =&gt; {
      this.setImage(phone.images[0]);
    });
  }

  setImage(imageUrl: string) {
    this.mainImageUrl = imageUrl;
  }
}

angular.
  module(&apos;phoneDetail&apos;).
  component(&apos;phoneDetail&apos;, {
    templateUrl: &apos;phone-detail/phone-detail.template.html&apos;,
    controller: PhoneDetailController
  });
</code><p>This makes our controller code look a lot more like Angular 2 already. We&apos;re
all set to actually introduce Angular 2 into the project.</p><span>
</span><p>If we had any Angular 1 services in the project, those would also be
a good candidate for converting to classes, since like controllers,
they&apos;re also constructor functions. But we only have the <code>Phone</code> factory
in this project, and that&apos;s a bit special since it&apos;s an <code>ngResource</code>
factory. So we won&apos;t be doing anything to it in the preparation stage.
We&apos;ll instead turn it directly into an Angular 2 service.</p><span>
</span><h2 id="installing-angular-2">Installing Angular 2</h2><span>
</span><p>Having completed our preparation work, let&apos;s get going with the Angular 2
upgrade of PhoneCat. We&apos;ll do this incrementally with the help of the
<a href="https://angular.io/docs/ts/latest/guide/upgrade.html#upgrading-with-the-upgrade-adapter">upgrade module</a> that comes with Angular 2.
By the time we&apos;re done, we&apos;ll be able to remove Angular 1 from the project
completely, but the key is to do this piece by piece without breaking the application.</p><span>
</span><p>The project also contains some animations, which we are not yet upgrading in this version of the guide. This will change in a later release.</p><p>Let&apos;s install Angular 2 into the project, along with the SystemJS module loader. Take a look into the
<a href="https://angular.io/docs/ts/latest/quickstart.html">Quickstart</a> guide and get the following configurations from there:</p><span>
</span><ul>
<li>Add Angular 2 and the other new dependencies to <code>package.json</code></li>
<li>Add the new typings into <code>typings.json</code></li>
<li>The SystemJS configuration file <code>systemjs.config.js</code> to the project root directory.</li>
</ul><span>
</span><p>Once these are done, run:</p><span>
</span><code format="">npm install
npm run typings install
</code><p>We can soon load Angular 2 dependencies into the application via <code>index.html</code>,
but first we need to do some directory path adjustments. This is because we&apos;re going
to need to load files from <code>node_modules</code> and the project root, whereas so far
in this project everything has been loaded from the <code>/app</code> directory.</p><span>
</span><p>Move the <code>app/index.html</code> file to the project root directory. Then change the
development server root path in <code>package.json</code> to also point to the project root
instead of <code>app</code>:</p><span>
</span><p>package.json</p><code language="json" format="linenums">{
  &quot;scripts&quot;: {
    &quot;start&quot;: &quot;http-server -a localhost -p 8000 -c-1 ./&quot;
  }
}</code><p>Now we&apos;re able to serve everything from the project root to the web browser. But we do <em>not</em>
want to have to change all the image and data paths used in the application code to match
our development setup. For that reason, we&apos;ll add a <code>&lt;base&gt;</code> tag to <code>index.html</code>, which will
cause relative URLs to be resolved back to the <code>/app</code> directory:</p><span>
</span><p>index.html</p><code language="html" format="">&lt;base href=&quot;/app/&quot;&gt;
</code><p>Now we can load Angular 2 via SystemJS. We&apos;ll add the Angular 2 polyfills and the
SystemJS config to the end of the <code>&lt;head&gt;</code> section, and then we&apos;ll use <code>System.import</code>
to load the actual application:</p><span>
</span><p>index.html</p><code language="html" format="linenums">&lt;script src=&quot;/node_modules/core-js/client/shim.min.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;/node_modules/zone.js/dist/zone.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;/node_modules/reflect-metadata/Reflect.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;/node_modules/systemjs/dist/system.src.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;/systemjs.config.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
  System.import(&apos;/app&apos;);
&lt;/script&gt;
</code><p>In the <code>systemjs.config.js</code> file we got from the Quickstart we also need to make a couple
of adjustments because of our project structure. We want to point the browser to the project
root when loading things through SystemJS, instead of using the  <code>&lt;base&gt;</code> URL:</p><span>
</span><p>systemjs.config.js</p><code language="js" format="linenums">var map = {
  &apos;app&apos;:                        &apos;/app&apos;, // &apos;dist&apos;,

  &apos;@angular&apos;:                   &apos;/node_modules/@angular&apos;,
  &apos;angular2-in-memory-web-api&apos;: &apos;/node_modules/angular2-in-memory-web-api&apos;,
  &apos;rxjs&apos;:                       &apos;/node_modules/rxjs&apos;
};

var packages = {
  &apos;/app&apos;:                       { main: &apos;main.js&apos;,  defaultExtension: &apos;js&apos; },
  &apos;rxjs&apos;:                       { defaultExtension: &apos;js&apos; },
  &apos;angular2-in-memory-web-api&apos;: { main: &apos;index.js&apos;, defaultExtension: &apos;js&apos; },
};
</code><h2 id="bootstrapping-a-hybrid-1-2-phonecat">Bootstrapping A Hybrid 1+2 PhoneCat</h2><span>
</span><p>What we&apos;ll do next is bootstrap the application as a <em>hybrid application</em>
that supports both Angular 1 and Angular 2 components. Once we&apos;ve done that
we can start converting the individual pieces to Angular 2.</p><span>
</span><p>To bootstrap a hybrid application, we first need to initialize an <code>UpgradeAdapter</code>,
which <a href="https://angular.io/docs/ts/latest/guide/upgrade.html#upgrading-with-the-upgrade-adapter">provides the glue</a> that joins the two
versions of the framework together. Let&apos;s import the <code>UpgradeAdapter</code> class into a
new file <code>app/main.ts</code>. This file has been configured as the application entrypoint
in <code>systemjs.config.js</code>, so it is already being loaded by the browser.</p><span>
</span><p>app/main.ts</p><code language="ts" format="">import { UpgradeAdapter } from &apos;@angular/upgrade&apos;;
</code><p>We can then make an adapter by instantiating the class:</p><span>
</span><code language="ts" format="">let upgradeAdapter = new UpgradeAdapter();
</code><p>Our application is currently bootstrapped using the Angular 1 <code>ng-app</code> directive
attached to the <code>&lt;html&gt;</code> element of the host page. This will no longer work with
Angular 2. We should switch to a JavaScript-driven bootstrap instead. So, remove the
<code>ng-app</code> attribute from <code>index.html</code>, and instead add this to <code>main.ts</code>:</p><span>
</span><code language="ts" format="">upgradeAdapter.bootstrap(document.documentElement, [&apos;phonecatApp&apos;]);
</code><p>The arguments used here are the root element of the application (which is
the same element we had <code>ng-app</code> on earlier), and the Angular 1.x modules
that we want to load. Since we&apos;re bootstrapping the app through
an <code>UpgradeAdapter</code>, we&apos;re actually now running the app as a hybrid Angular 1+2
app.</p><span>
</span><p>This means we are now running both Angular 1 and 2 at the same time. That&apos;s pretty
exciting! We&apos;re not running any actual Angular 2 components yet though,
so let&apos;s do that next.</p><span>
</span><h2 id="upgrading-the-phone-service">Upgrading the Phone service</h2><span>
</span><p>The first piece we&apos;ll port over to Angular 2 is the <code>Phone</code> service, which
resides in <code>app/core/phone/phone.service.ts</code> and makes it possible for components
to load phone information from the server. Right now it&apos;s implemented with
ngResource and we&apos;re using it for two things:</p><span>
</span><ul>
<li>For loading the list of all phones into the phone list component</li>
<li>For loading the details of a single phone into the phone detail component.</li>
</ul><span>
</span><p>We can replace this implementation with an Angular 2 service class, while
keeping our controllers in Angular 1 land. In the new version we&apos;ll just use
the <code>Http</code> service from Angular 2 instead of ngResource.</p><span>
</span><p>Before the <code>Http</code> service is available for injection, we need to register
it into our application&apos;s dependency injector. We should import the <code>HTTP_PROVIDERS</code>
constant in <code>main.ts</code>:</p><span>
</span><code language="ts" format="">import { HTTP_PROVIDERS } from &apos;@angular/http&apos;;
</code><p>In a regular Angular 2 application we would now pass <code>HTTP_PROVIDERS</code> into
the application bootstrap function. But we can&apos;t do that in a hybrid
application such as the one we&apos;re working on. That&apos;s because the <code>bootstrap</code>
method of  <code>UpgradeAdapter</code> expects Angular 1 modules as dependencies,
not Angular 2 providers.</p><span>
</span><p>What we must do instead is register <code>HTTP_PROVIDERS</code> into the <code>UpgradeAdapter</code>
separately. It has a method called <code>addProvider</code> for that purpose:</p><span>
</span><code language="ts" format="">upgradeAdapter.addProvider(HTTP_PROVIDERS);
</code><p>Now we&apos;re ready to upgrade the Phone service itself. We replace the ngResource-based
service in <code>phone.service.ts</code> with a TypeScript class decorated as <code>@Injectable</code>:</p><span>
</span><p>app/core/phone/phone.service.ts</p><code language="ts" format="linenums">@Injectable()
export class Phone {
/* . . . */
}
</code><p>The <code>@Injectable</code> decorator will attach some dependency injection metadata
to the class, letting Angular 2 know about its dependencies. As described
by our <a href="https://angular.io/docs/ts/latest/guide/dependency-injection.html">Dependency Injection Guide</a>,
this is a marker decorator we need to use for classes that have no other
Angular 2 decorators but still need to have their dependencies injected.</p><span>
</span><p>In its constructor the class expects to get the <code>Http</code> service. It will
be injected to it and it is stored as a private field. The service is then
used in the two instance methods, one of which loads the list of all phones,
and the other the details of a particular phone:</p><span>
</span><code language="ts" format="linenums">@Injectable()
export class Phone {
  constructor(private http: Http) { }
  query(): Observable&lt;PhoneData[]&gt; {
    return this.http.get(`phones/phones.json`)
      .map((res: Response) =&gt; res.json());
  }
  get(id: string): Observable&lt;PhoneData&gt; {
    return this.http.get(`phones/${id}.json`)
      .map((res: Response) =&gt; res.json());
  }
}
</code><p>The methods now return Observables of type <code>PhoneData</code> and <code>PhoneData[]</code>. This is
a type we don&apos;t have yet, so let&apos;s add a simple interface for it:</p><span>
</span><p>app/core/phone/phone.service.ts</p><code language="ts" format="linenums">export interface PhoneData {
  name: string;
  snippet: string;
  images: string[];
}
</code><p>Here&apos;s the full, final code for the service:</p><span>
</span><p>app/core/phone/phone.service.ts</p><code language="ts" format="linenums">import { Injectable } from &apos;@angular/core&apos;;
import { Http, Response } from &apos;@angular/http&apos;;
import { Observable } from &apos;rxjs/Rx&apos;;

import &apos;rxjs/add/operator/map&apos;;

export interface PhoneData {
  name: string;
  snippet: string;
  images: string[];
}

@Injectable()
export class Phone {
  constructor(private http: Http) { }
  query(): Observable&lt;PhoneData[]&gt; {
    return this.http.get(`phones/phones.json`)
      .map((res: Response) =&gt; res.json());
  }
  get(id: string): Observable&lt;PhoneData&gt; {
    return this.http.get(`phones/${id}.json`)
      .map((res: Response) =&gt; res.json());
  }
}
</code><p>Notice that we&apos;re importing the <code>map</code> operator of the RxJS <code>Observable</code> separately.
We need to do this for all RxJS operators that we want to use, since Angular 2
does not load all of them by default.</p><span>
</span><p>The new <code>Phone</code> service now has the same features that the original, ngResource based
service did. Now we just need to register the new service into the application, so that
our Angular 1 components will be able to use it.</p><span>
</span><p><code>UpgradeAdapter</code> has a <code>downgradeNg2Provider</code> method for the purpose of making
Angular 2 services available to Angular 1 code. We can use it to plug in our
<code>Phone</code> service:</p><span>
</span><p>app/main.ts</p><code language="ts" format="linenums">import { Phone } from &apos;./core/phone/phone.service&apos;;

/* . . . */

upgradeAdapter.addProvider(Phone);

/* . . . */

angular.module(&apos;core.phone&apos;)
  .factory(&apos;phone&apos;, upgradeAdapter.downgradeNg2Provider(Phone));
</code><p>Note that we actually needed to do two registrations here:</p><span>
</span><ol>
<li>Register <code>Phone</code> as an <strong>Angular 2 provider</strong> with the <code>addProvider</code>
method. That&apos;s the same method that we used earlier for <code>HTTP_PROVIDERS</code>.</li>
<li>Register an <strong>Angular 1 factory</strong> called <code>phone</code>, which will be a <em>downgraded</em>
version of the <code>Phone</code> Angular 2 service.</li>
</ol><span>
</span><p>Now that we are loading <code>phone.service.ts</code> through an import that is resolved
by SystemJS, we should <strong>remove the &lt;script&gt; tag</strong> for the service from <code>index.html</code>.
This is something we&apos;ll do to all our components as we upgrade them. Simultaneously
with the Angular 1 to 2 upgrade we&apos;re also migrating our code from scripts to modules.</p><span>
</span><p>At this point we can switch our two components to use the new service
instead of the old one. We <code>$inject</code> it as the downgraded <code>phone</code> factory,
but it&apos;s really an instance of the <code>Phone</code> class and we can annotate its type
accordingly:</p><span>
</span><p>app/phone-list/phone-list.component.ts</p><code language="ts" format="linenums">import { Phone, PhoneData } from &apos;../core/phone/phone.service&apos;;

class PhoneListController {
  phones: PhoneData[];
  orderProp: string;

  static $inject = [&apos;phone&apos;];
  constructor(phone: Phone) {
    phone.query().subscribe(phones =&gt; {
      this.phones = phones;
    });
    this.orderProp = &apos;age&apos;;
  }

}

angular.
  module(&apos;phoneList&apos;).
  component(&apos;phoneList&apos;, {
    templateUrl: &apos;app/phone-list/phone-list.template.html&apos;,
    controller: PhoneListController
  });
</code><p>app/phone-detail/phone-detail.component.ts</p><code language="ts" format="linenums">import { Phone, PhoneData } from &apos;../core/phone/phone.service&apos;;

class PhoneDetailController {
  phone: PhoneData;
  mainImageUrl: string;

  static $inject = [&apos;$routeParams&apos;, &apos;phone&apos;];
  constructor($routeParams: angular.route.IRouteParamsService, phone: Phone) {
    let phoneId = $routeParams[&apos;phoneId&apos;];
    phone.get(phoneId).subscribe(data =&gt; {
      this.phone = data;
      this.setImage(data.images[0]);
    });
  }

  setImage(imageUrl: string) {
    this.mainImageUrl = imageUrl;
  }
}

angular.
  module(&apos;phoneDetail&apos;).
  component(&apos;phoneDetail&apos;, {
    templateUrl: &apos;phone-detail/phone-detail.template.html&apos;,
    controller: PhoneDetailController
  });
</code><p>What we have here are two Angular 1 components using an Angular 2 service!
The components don&apos;t need to be aware of this, though the fact that the
service returns Observables and not Promises is a bit of a giveaway.
In any case, what we&apos;ve achieved is a migration of a service to Angular 2
without having to yet migrate the components that use it.</p><span>
</span><div class="alert is-helpful"><p>We could also use the <code>toPromise</code> method of <code>Observable</code> to turn those
Observables into Promises in the service. This can in many cases further
reduce the amount of changes needed in the component controllers.</p><span>
</span></div><h2 id="upgrading-components">Upgrading Components</h2><span>
</span><p>Next, let&apos;s upgrade our Angular 1 components to Angular 2 components. We&apos;ll
do it one at a time, while still keeping the application in hybrid mode.
As we make these conversions, we&apos;ll also be defining our first Angular 2 <em>pipes</em>.</p><span>
</span><p>Let&apos;s look at the phone list component first. Right now it contains a TypeScript
controller class and a component definition object. We can morph this into
an Angular 2 component by just renaming the controller class and turning the
Angular 1 component definition object into an Angular 2 <code>@Component</code> decorator.
We can then also remove the static <code>$inject</code> property from the class:</p><span>
</span><p>app/phone-list/phone-list.component.ts</p><code language="ts" format="linenums">import { Component } from &apos;@angular/core&apos;;
import { Phone, PhoneData } from &apos;../core/phone/phone.service&apos;;

@Component({
  selector: &apos;phone-list&apos;,
  templateUrl: &apos;phone-list/phone-list.template.html&apos;
})
export class PhoneListComponent {
  phones: PhoneData[];
  query: string;
  orderProp: string;

  constructor(phone: Phone) {
    phone.query().subscribe(phones =&gt; {
      this.phones = phones;
    });
    this.orderProp = &apos;age&apos;;
  }
}
</code><p>The <code>selector</code> attribute is a CSS selector that defines where on the page the component
should go. In Angular 1 we do matching based on component names, but in Angular 2 we
have these explicit selectors. This one will match elements with the name <code>phone-list</code>,
just like the Angular 1 version did.</p><span>
</span><p>We now also need to convert the template of this component into Angular 2 syntax.
In the search controls we need to use Angular 2 syntax for the two <code>ngModel</code>s.
We should also no longer use the <code>$ctrl</code> prefix in expressions:</p><span>
</span><p>app/phone-list/phone-list.template.html</p><code language="html" format="linenums">&lt;p&gt;
  Search:
  &lt;input [(ngModel)]=&quot;query&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;
  Sort by:
  &lt;select [(ngModel)]=&quot;orderProp&quot;&gt;
    &lt;option value=&quot;name&quot;&gt;Alphabetical&lt;/option&gt;
    &lt;option value=&quot;age&quot;&gt;Newest&lt;/option&gt;
  &lt;/select&gt;
&lt;/p&gt;
</code><p>In the list we need to replace the <code>ng-repeat</code> with an <code>*ngFor</code> and the
<code>let var of iterable</code> syntax, which is <a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#directives">described in our
Template Syntax guide</a>.
For the images, we can replace <code>ng-src</code> with a binding to the standard <code>src</code> property.</p><span>
</span><p>app/phone-list/phone-list.template.html</p><code language="html" format="linenums">&lt;ul class=&quot;phones&quot;&gt;
  &lt;li *ngFor=&quot;let phone of getPhones()&quot;
      class=&quot;thumbnail phone-list-item&quot;&gt;
    &lt;a href=&quot;/#!/phones/{{phone.id}}&quot; class=&quot;thumb&quot;&gt;
      &lt;img [src]=&quot;phone.imageUrl&quot; [alt]=&quot;phone.name&quot; /&gt;
    &lt;/a&gt;
    &lt;a href=&quot;/#!/phones/{{phone.id}}&quot; class=&quot;name&quot;&gt;{{phone.name}}&lt;/a&gt;
    &lt;p&gt;{{phone.snippet}}&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</code><p>Another thing that we&apos;ve done here is that we&apos;ve removed the use of <code>filter</code> and <code>orderBy</code> filters,
and replaced them with a call to the <code>getPhones()</code> controller method.
The built-in Angular filters <code>filter</code> and <code>orderBy</code> do not exist in Angular 2,
so we need to do the filtering and sorting ourselves. We could define our own Angular 2
pipes for this purpose, but in this case it is more convenient to just implement the filtering
and ordering logic in the component itself. We expect the <code>getPhones()</code> method to return a collection
where the current filtering and ordering has been applied.</p><span>
</span><p>app/phone-list/phone-list.component.ts</p><code language="ts" format="linenums">getPhones(): PhoneData[] {
  return this.sortPhones(this.filterPhones(this.phones));
}

private filterPhones(phones: PhoneData[]) {
  if (phones &amp;&amp; this.query) {
    return phones.filter(phone =&gt; {
      let name = phone.name.toLowerCase();
      let snippet = phone.snippet.toLowerCase();
      return name.indexOf(this.query) &gt;= 0 || snippet.indexOf(this.query) &gt;= 0;
    });
  }
  return phones;
}

private sortPhones(phones: PhoneData[]) {
    if (phones &amp;&amp; this.orderProp) {
        return phones
          .slice(0) // Make a copy
          .sort((a, b) =&gt; {
             if (a[this.orderProp] &lt; b[this.orderProp]) {
               return -1;
             } else if ([b[this.orderProp] &lt; a[this.orderProp]]) {
               return 1;
             } else {
               return 0;
             }
          });
    }
    return phones;
}
</code><p>In the entrypoint file <code>main.ts</code> we&apos;re going to plug this component into our application. Instead
of registering a component, we register a <code>phoneList</code> <em>directive</em>.
The directive is a downgraded version of our Angular 2 component, and the <code>UpgradeAdapter</code>
handles the bridging between the two:</p><span>
</span><p>app/main.ts</p><code language="ts" format="linenums">import { PhoneListComponent } from &apos;./phone-list/phone-list.component&apos;;

/* . . . */

angular.module(&apos;phoneList&apos;)
  .directive(
    &apos;phoneList&apos;,
    &lt;angular.IDirectiveFactory&gt;
      upgradeAdapter.downgradeNg2Component(PhoneListComponent)
  );
</code><p>The <code>&lt;angular.IDirectiveFactory&gt;</code> type annotation here is to let the TypeScript compiler
know that the return value of the downgrade method call will be something that can be
used as a directive factory.</p><span>
</span><p>At this point, also remove the &lt;script&gt; tag for the phone list component from <code>index.html</code>.</p><span>
</span><p>Now we can start looking at our other component, which is the one for
the phone details. Set the contents of <code>phone-detail.component.ts</code> as follows:</p><span>
</span><p>app/phone-detail/phone-detail.component.ts</p><code language="ts" format="linenums">import { Component, Inject } from &apos;@angular/core&apos;;
import { Phone, PhoneData } from &apos;../core/phone/phone.service&apos;;
@Component({
  selector: &apos;phone-detail&apos;,
  templateUrl: &apos;phone-detail/phone-detail.template.html&apos;,
})
export class PhoneDetailComponent {
  phone: PhoneData;
  mainImageUrl: string;

  constructor(@Inject(&apos;$routeParams&apos;)
                $routeParams: angular.route.IRouteParamsService,
              phone: Phone) {
    phone.get($routeParams[&apos;phoneId&apos;]).subscribe(phone =&gt; {
      this.phone = phone;
      this.setImage(phone.images[0]);
    });
  }

  setImage(imageUrl: string) {
    this.mainImageUrl = imageUrl;
  }
}
</code><p>This is pretty similar to what we did with the phone list. The one new change
here is the use of <code>@Inject</code> for the <code>$routeParams</code> dependency. It tells the
Angular 2 injector what this dependency should map to. We have a dependency called
<code>$routeParams</code> in the Angular 1 injector, where it is provided by the Angular 1 router.
That is what we were already using when <code>PhoneDetails</code> was still an Angular 1 controller.</p><span>
</span><p>The things is though, Angular 1 dependencies are not made automatically available to
Angular 2 components, so if we were to run this now, it would not work. We need to explicitly
tell the <code>UpgradeAdapter</code> to upgrade <code>$routeParams</code> so that it is available for injection in
Angular 2. We can do it in <code>main.ts</code>:</p><span>
</span><p>app/main.ts</p><code language="ts" format="">upgradeAdapter.upgradeNg1Provider(&apos;$routeParams&apos;);
</code><p>We now also need to convert the template of this component into Angular 2 syntax.
Here is the new template in its entirety:</p><span>
</span><p>app/phone-detail/phone-detail.template.html</p><code language="html" format="linenums">&lt;div *ngIf=&quot;phone&quot;&gt;
  &lt;div class=&quot;phone-images&quot;&gt;
    &lt;img [src]=&quot;img&quot; class=&quot;phone&quot;
        [ngClass]=&quot;{selected: img === mainImageUrl}&quot;
        *ngFor=&quot;let img of phone.images&quot; /&gt;
  &lt;/div&gt;

  &lt;h1&gt;{{phone.name}}&lt;/h1&gt;

  &lt;p&gt;{{phone.description}}&lt;/p&gt;

  &lt;ul class=&quot;phone-thumbs&quot;&gt;
    &lt;li *ngFor=&quot;let img of phone.images&quot;&gt;
      &lt;img [src]=&quot;img&quot; (click)=&quot;setImage(img)&quot; /&gt;
    &lt;/li&gt;
  &lt;/ul&gt;

  &lt;ul class=&quot;specs&quot;&gt;
    &lt;li&gt;
      &lt;span&gt;Availability and Networks&lt;/span&gt;
      &lt;dl&gt;
        &lt;dt&gt;Availability&lt;/dt&gt;
        &lt;dd *ngFor=&quot;let availability of phone.availability&quot;&gt;{{availability}}&lt;/dd&gt;
      &lt;/dl&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;span&gt;Battery&lt;/span&gt;
      &lt;dl&gt;
        &lt;dt&gt;Type&lt;/dt&gt;
        &lt;dd&gt;{{phone.battery?.type}}&lt;/dd&gt;
        &lt;dt&gt;Talk Time&lt;/dt&gt;
        &lt;dd&gt;{{phone.battery?.talkTime}}&lt;/dd&gt;
        &lt;dt&gt;Standby time (max)&lt;/dt&gt;
        &lt;dd&gt;{{phone.battery?.standbyTime}}&lt;/dd&gt;
      &lt;/dl&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;span&gt;Storage and Memory&lt;/span&gt;
      &lt;dl&gt;
        &lt;dt&gt;RAM&lt;/dt&gt;
        &lt;dd&gt;{{phone.storage?.ram}}&lt;/dd&gt;
        &lt;dt&gt;Internal Storage&lt;/dt&gt;
        &lt;dd&gt;{{phone.storage?.flash}}&lt;/dd&gt;
      &lt;/dl&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;span&gt;Connectivity&lt;/span&gt;
      &lt;dl&gt;
        &lt;dt&gt;Network Support&lt;/dt&gt;
        &lt;dd&gt;{{phone.connectivity?.cell}}&lt;/dd&gt;
        &lt;dt&gt;WiFi&lt;/dt&gt;
        &lt;dd&gt;{{phone.connectivity?.wifi}}&lt;/dd&gt;
        &lt;dt&gt;Bluetooth&lt;/dt&gt;
        &lt;dd&gt;{{phone.connectivity?.bluetooth}}&lt;/dd&gt;
        &lt;dt&gt;Infrared&lt;/dt&gt;
        &lt;dd&gt;{{phone.connectivity?.infrared | checkmark}}&lt;/dd&gt;
        &lt;dt&gt;GPS&lt;/dt&gt;
        &lt;dd&gt;{{phone.connectivity?.gps | checkmark}}&lt;/dd&gt;
      &lt;/dl&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;span&gt;Android&lt;/span&gt;
      &lt;dl&gt;
        &lt;dt&gt;OS Version&lt;/dt&gt;
        &lt;dd&gt;{{phone.android?.os}}&lt;/dd&gt;
        &lt;dt&gt;UI&lt;/dt&gt;
        &lt;dd&gt;{{phone.android?.ui}}&lt;/dd&gt;
      &lt;/dl&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;span&gt;Size and Weight&lt;/span&gt;
      &lt;dl&gt;
        &lt;dt&gt;Dimensions&lt;/dt&gt;
        &lt;dd *ngFor=&quot;let dim of phone.sizeAndWeight?.dimensions&quot;&gt;{{dim}}&lt;/dd&gt;
        &lt;dt&gt;Weight&lt;/dt&gt;
        &lt;dd&gt;{{phone.sizeAndWeight?.weight}}&lt;/dd&gt;
      &lt;/dl&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;span&gt;Display&lt;/span&gt;
      &lt;dl&gt;
        &lt;dt&gt;Screen size&lt;/dt&gt;
        &lt;dd&gt;{{phone.display?.screenSize}}&lt;/dd&gt;
        &lt;dt&gt;Screen resolution&lt;/dt&gt;
        &lt;dd&gt;{{phone.display?.screenResolution}}&lt;/dd&gt;
        &lt;dt&gt;Touch screen&lt;/dt&gt;
        &lt;dd&gt;{{phone.display?.touchScreen | checkmark}}&lt;/dd&gt;
      &lt;/dl&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;span&gt;Hardware&lt;/span&gt;
      &lt;dl&gt;
        &lt;dt&gt;CPU&lt;/dt&gt;
        &lt;dd&gt;{{phone.hardware?.cpu}}&lt;/dd&gt;
        &lt;dt&gt;USB&lt;/dt&gt;
        &lt;dd&gt;{{phone.hardware?.usb}}&lt;/dd&gt;
        &lt;dt&gt;Audio / headphone jack&lt;/dt&gt;
        &lt;dd&gt;{{phone.hardware?.audioJack}}&lt;/dd&gt;
        &lt;dt&gt;FM Radio&lt;/dt&gt;
        &lt;dd&gt;{{phone.hardware?.fmRadio | checkmark}}&lt;/dd&gt;
        &lt;dt&gt;Accelerometer&lt;/dt&gt;
        &lt;dd&gt;{{phone.hardware?.accelerometer | checkmark}}&lt;/dd&gt;
      &lt;/dl&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;span&gt;Camera&lt;/span&gt;
      &lt;dl&gt;
        &lt;dt&gt;Primary&lt;/dt&gt;
        &lt;dd&gt;{{phone.camera?.primary}}&lt;/dd&gt;
        &lt;dt&gt;Features&lt;/dt&gt;
        &lt;dd&gt;{{phone.camera?.features?.join(&apos;, &apos;)}}&lt;/dd&gt;
      &lt;/dl&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;span&gt;Additional Features&lt;/span&gt;
      &lt;dd&gt;{{phone.additionalFeatures}}&lt;/dd&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/div&gt;
</code><p>There are several notable changes here:</p><span>
</span><ul>
<li>We&apos;ve removed the <code>$ctrl.</code> prefix from all expressions.</li>
<li>Just like we did in the phone list, we&apos;ve replaced <code>ng-src</code> with property
bindings for the standard <code>src</code> property.</li>
<li>We&apos;re using the property binding syntax around <code>ng-class</code>. Though Angular 2
does have <a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#directives">a very similar <code>ngClass</code></a>
as Angular 1 does, its value is not magically evaluated as an expression.
In Angular 2 we always specify  in the template when an attribute&apos;s value is
a property expression, as opposed to a literal string.</li>
<li>We&apos;ve replaced <code>ng-repeat</code>s with <code>*ngFor</code>s.</li>
<li>We&apos;ve replaced <code>ng-click</code> with an event binding for the standard <code>click</code>.</li>
<li>We&apos;ve wrapped the whole template in an <code>ngIf</code> that causes it only to be
rendered when there is a phone present. We need this because when the component
first loads, we don&apos;t have <code>phone</code> yet and the expressions will refer to a
non-existing value. Unlike in Angular 1, Angular 2 expressions do not fail silently
when we try to refer to properties on undefined objects. We need to be explicit
about cases where this is expected.</li>
</ul><span>
</span><p>In <code>main.ts</code> we&apos;ll now register a <code>phoneDetail</code> directive instead of a
component. The directive is a downgraded version of the <code>PhoneDetail</code> Angular 2
component.</p><span>
</span><p>app/main.ts</p><code language="ts" format="linenums">import { PhoneDetailComponent } from &apos;./phone-detail/phone-detail.component&apos;;

/* . . . */

angular.module(&apos;phoneDetail&apos;)
  .directive(
    &apos;phoneDetail&apos;,
    &lt;angular.IDirectiveFactory&gt;
      upgradeAdapter.downgradeNg2Component(PhoneDetailComponent)
  );
</code><p>We should now also remove the phone detail component &lt;script&gt; tag from <code>index.html</code>.</p><span>
</span><p>There&apos;s one additional step we need to take, which is to upgrade the
<code>checkmark</code> filter that the template is using. We need an Angular 2
pipe instead of an Angular 1 filter.</p><span>
</span><p>While there is no upgrade method in the upgrade adapter for filters, we
can just turn the filter function into a class that fulfills
the contract for Angular 2 Pipes. The implementation is the same as before.
It just comes in a different kind of packaging. While changing it, also
rename the file to <code>checkmark.pipe.ts</code>:</p><span>
</span><p>app/core/checkmark/checkmark.pipe.ts</p><code language="ts" format="linenums">import { Pipe, PipeTransform } from &apos;@angular/core&apos;;

@Pipe({name: &apos;checkmark&apos;})
export class CheckmarkPipe implements PipeTransform {

  transform(input: boolean) {
    return input ? &apos;\u2713&apos; : &apos;\u2718&apos;;
  }

}
</code><p>In the component we should now import and declare our newly created pipe (as well as
remove the filter &lt;script&gt; tag from <code>index.html</code>):</p><span>
</span><p>app/phone-detail/phone-detail.component.ts</p><code language="ts" format="linenums">import { CheckmarkPipe } from &apos;../core/checkmark/checkmark.pipe&apos;;

@Component({
  selector: &apos;phone-detail&apos;,
  templateUrl: &apos;phone-detail/phone-detail.template.html&apos;,
  pipes: [ CheckmarkPipe ]
})
</code><h2 id="switching-to-the-angular-2-router-and-bootstrap">Switching To The Angular 2 Router And Bootstrap</h2><span>
</span><p>At this point we&apos;ve replaced all our Angular 1 application components with
their Angular 2 counterparts. The application is still bootstrapped as a hybrid,
but there isn&apos;t really any need for that anymore, and we can begin to
pull out the last remnants of Angular 1.</p><span>
</span><p>There are just two more things to do: We need to switch the router to
the Angular 2 one, and then bootstrap the app as a pure Angular 2 app.</p><span>
</span><p>Let&apos;s do the routing part first. Angular 2 comes with an <a href="https://angular.io/docs/ts/latest/guide/router.html">all-new router</a>
that we can use for this.</p><span>
</span><p>Angular 2 applications all have a <em>root component</em>, which, among other
things, is where we should plug in the router. We don&apos;t yet have such a root
component, because our app is still managed as an Angular 1 app.
Let&apos;s change this now and add an <code>AppComponent</code> class into a new file
<code>app.component.ts</code>:</p><span>
</span><p>app/app.component.ts</p><code language="ts" format="linenums">import { Component } from &apos;@angular/core&apos;;
import { RouteConfig, ROUTER_DIRECTIVES } from &apos;@angular/router-deprecated&apos;;
import { PhoneListComponent } from &apos;./phone-list/phone-list.component&apos;;
import { PhoneDetailComponent } from &apos;./phone-detail/phone-detail.component&apos;;

@RouteConfig([
  {path: &apos;/phones&apos;, name: &apos;Phones&apos;, component: PhoneListComponent},
  {path: &apos;/phones/:phoneId&apos;, name: &apos;Phone&apos;, component: PhoneDetailComponent},
  {path: &apos;/&apos;, redirectTo: [&apos;Phones&apos;]}
])
@Component({
  selector: &apos;phonecat-app&apos;,
  template: &apos;&lt;router-outlet&gt;&lt;/router-outlet&gt;&apos;,
  directives: [ROUTER_DIRECTIVES]
})
export class AppComponent {
}
</code><p>This is a component that plugs in to an <code>&lt;phonecat-app&gt;</code> element on the page,
and has a simple template that only includes the router outlet component
of the Angular router. This means that the component just renders the contents
of the current route and nothing else. The <code>@RouteConfig</code> decorator defines
the Angular 2 counterparts of our two routes. They refer directly to the
two components.</p><span>
</span><p>We should put this <code>&lt;phonecat-app&gt;</code> element in the HTML so that the root component
has something to attach to. It replaces the old Angular 1 <code>ng-view</code> directive:</p><span>
</span><p>index.html</p><code language="html" format="linenums">  &lt;body&gt;
    &lt;phonecat-app&gt;&lt;/phonecat-app&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code><p>In the <code>PhoneDetail</code> component we now need to change how the phone id parameter
is received. There will be no more <code>$routeParams</code> injection available, because
that comes from the Angular 1 router. Instead, what we have is a <code>RouteParams</code>
object provided by the Angular 2 router. We use it to obtain the <code>phoneId</code> from
the params:</p><span>
</span><p>app/phone-detail/phone-detail.component.ts</p><code language="ts" format="linenums">import { Component } from &apos;@angular/core&apos;;
import { RouteParams } from &apos;@angular/router-deprecated&apos;;
import { Phone, PhoneData } from &apos;../core/phone/phone.service&apos;;
import { CheckmarkPipe } from &apos;../core/checkmark/checkmark.pipe&apos;;

@Component({
  selector: &apos;phone-detail&apos;,
  templateUrl: &apos;phone-detail/phone-detail.template.html&apos;,
  pipes: [ CheckmarkPipe ]
})
export class PhoneDetailComponent {
  phone: PhoneData;
  mainImageUrl: string;

  constructor(routeParams: RouteParams, phone: Phone) {
    phone.get(routeParams.get(&apos;phoneId&apos;)).subscribe(phone =&gt; {
      this.phone = phone;
      this.setImage(phone.images[0]);
    });
  }

  setImage(imageUrl: string) {
    this.mainImageUrl = imageUrl;
  }
}
</code><p>With that, we&apos;re ready to switch the bootstrap method of the application from that
of the <code>UpgradeAdapter</code> to the main Angular 2 <code>bootstrap</code>. Let&apos;s import it together
with the router, the new app component, and everything else in <code>main.ts</code></p><span>
</span><code language="ts" format="linenums">import {
  LocationStrategy,
  HashLocationStrategy,
  APP_BASE_HREF
} from &apos;@angular/common&apos;;
import { bootstrap } from &apos;@angular/platform-browser-dynamic&apos;;
import { FormsModule } from &apos;@angular/forms&apos;;
import { HTTP_PROVIDERS } from &apos;@angular/http&apos;;
import { ROUTER_PROVIDERS } from &apos;@angular/router-deprecated&apos;;
import { Phone } from &apos;./core/phone/phone.service&apos;;
import { AppComponent } from &apos;./app.component&apos;;
</code><p>We&apos;ll now use the regular Angular 2 <code>bootstrap</code> function to bootstrap the app
instead of using <code>UpgradeAdapter</code>. The first argument to <code>bootstrap</code> is the
application&apos;s root component <code>AppComponent</code>, and the second
is an array of the Angular 2 providers that we want to make available for
injection. In that array we include all the things we have been registering
with  <code>upgradeAdapter.addProvider</code> until now, as well as the providers and
directives of the router:</p><span>
</span><code language="ts" format="linenums">bootstrap(AppComponent, {
  imports: [FormsModule],
  providers: [
    HTTP_PROVIDERS,
    ROUTER_PROVIDERS,
    { provide: APP_BASE_HREF, useValue: &apos;!&apos; },
    { provide: LocationStrategy, useClass: HashLocationStrategy },
    Phone
  ]
});
</code><p>We also configure a couple of things for the router here so that the application
URL paths match exactly those we had in the Angular 1 app: We want the
hash location strategy with the <code>!</code> prefix: <code>#!/phones</code>.</p><span>
</span><p>At this point we are running a pure Angular 2 application!</p><span>
</span><p>But there&apos;s actually one more cool thing we can do with the new router.
We no longer have to hardcode the links to phone details from the phone
list, because the Angular 2 router is able to generate them for us with
its <code>routerLink</code> directive. We just need to refer to the route names we
used in the <code>@RouteConfig</code>:</p><span>
</span><p>app/phone-list/phone-list.template.html</p><code language="html" format="linenums">&lt;ul class=&quot;phones&quot;&gt;
  &lt;li *ngFor=&quot;let phone of getPhones()&quot;
      class=&quot;thumbnail phone-list-item&quot;&gt;
    &lt;a [routerLink]=&quot;[&apos;/Phone&apos;, {phoneId: phone.id}]&quot; class=&quot;thumb&quot;&gt;
      &lt;img [src]=&quot;phone.imageUrl&quot; [alt]=&quot;phone.name&quot; /&gt;
    &lt;/a&gt;
    &lt;a [routerLink]=&quot;[&apos;/Phone&apos;, {phoneId: phone.id}]&quot; class=&quot;name&quot;&gt;{{phone.name}}&lt;/a&gt;
    &lt;p&gt;{{phone.snippet}}&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</code><p>For this to work the directive just needs to be declared in the component:</p><span>
</span><code language="ts" format="linenums">import { Component } from &apos;@angular/core&apos;;
import { RouterLink } from &apos;@angular/router-deprecated&apos;;
import { Phone, PhoneData } from &apos;../core/phone/phone.service&apos;;

@Component({
  selector: &apos;phone-list&apos;,
  templateUrl: &apos;phone-list/phone-list.template.html&apos;,
  directives: [ RouterLink ]
})
</code><h2 id="saying-goodbye-to-angular-1">Saying Goodbye to Angular 1</h2><span>
</span><p>It is time to take off the training wheels and let our application begin
its new life as a pure, shiny Angular 2 app. The remaining tasks all have to
do with removing code - which of course is every programmer&apos;s favorite task!</p><span>
</span><p>If you haven&apos;t already, remove all references to the <code>UpgradeAdapter</code> from <code>main.ts</code>.
Also remove the Angular 1 bootstrap code.</p><span>
</span><p>When you&apos;re done, this is what <code>main.ts</code> should look like:</p><span>
</span><p>app/main.ts</p><code language="ts" format="linenums">import {
  LocationStrategy,
  HashLocationStrategy,
  APP_BASE_HREF
} from &apos;@angular/common&apos;;
import { bootstrap } from &apos;@angular/platform-browser-dynamic&apos;;
import { FormsModule } from &apos;@angular/forms&apos;;
import { HTTP_PROVIDERS } from &apos;@angular/http&apos;;
import { ROUTER_PROVIDERS } from &apos;@angular/router-deprecated&apos;;
import { Phone } from &apos;./core/phone/phone.service&apos;;
import { AppComponent } from &apos;./app.component&apos;;

bootstrap(AppComponent, {
  imports: [FormsModule],
  providers: [
    HTTP_PROVIDERS,
    ROUTER_PROVIDERS,
    { provide: APP_BASE_HREF, useValue: &apos;!&apos; },
    { provide: LocationStrategy, useClass: HashLocationStrategy },
    Phone
  ]
});
</code><p>You may also completely remove the following files. They are Angular 1
module configuration files and not needed in Angular 2:</p><span>
</span><ul>
<li><code>app/app.module.ts</code></li>
<li><code>app/app.config.ts</code></li>
<li><code>app/core/core.module.ts</code></li>
<li><code>app/core/phone/phone.module.ts</code></li>
<li><code>app/phone-detail/phone-detail.module.ts</code></li>
<li><code>app/phone-list/phone-list.module.ts</code></li>
</ul><span>
</span><p>The external typings for Angular 1 may be uninstalled as well. The only ones
we still need are for Jasmine and Angular 2 polyfills.</p><span>
</span><code format="">npm run typings uninstall jquery -- --save --global
npm run typings uninstall angular -- --save --global
npm run typings uninstall angular-route -- --save --global
npm run typings uninstall angular-resource -- --save --global
npm run typings uninstall angular-mocks -- --save --global
npm run typings uninstall angular-animate -- --save --global
</code><p>Finally, from <code>index.html</code>, remove all references to
Angular 1 scripts, the Angular 2 upgrade module, and jQuery. When we&apos;re done,
this is what it should look like:</p><span>
</span><p>index.html</p><code language="html" format="linenums">&lt;!doctype html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;base href=&quot;/app/&quot;&gt;
    &lt;title&gt;Google Phone Gallery&lt;/title&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css&quot; /&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;app.css&quot; /&gt;

    &lt;script src=&quot;/node_modules/core-js/client/shim.min.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;/node_modules/zone.js/dist/zone.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;/node_modules/reflect-metadata/Reflect.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;/node_modules/systemjs/dist/system.src.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;/systemjs.config.js&quot;&gt;&lt;/script&gt;
    &lt;script&gt;
      System.import(&apos;/app&apos;);
    &lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;phonecat-app&gt;&lt;/phonecat-app&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code><p>That is the last we&apos;ll see of Angular 1! It has served us well but now
it&apos;s time to say goodbye.</p><span>
</span><h1 id="appendix-upgrading-phonecat-tests">Appendix: Upgrading PhoneCat Tests</h1><span>
</span><p>Tests can not only be retained through an upgrade process, but they can also be
used as a valuable safety measure when ensuring that the application does not
break during the upgrade. E2E tests are especially useful for this purpose.</p><span>
</span><h2 id="e2e-tests">E2E Tests</h2><span>
</span><p>The PhoneCat project has both E2E Protractor tests and some Karma unit tests in it.
Of these two, E2E tests can be dealt with much more easily: By definition,
E2E tests access our application from the <em>outside</em> by interacting with
the various UI elements the app puts on the screen. E2E tests aren&apos;t really that
concerned with the internal structure of the application components. That
also means that although we modify our project quite a bit during the upgrade, the E2E
test suite should keep passing with just minor modifications. This is because
we don&apos;t change how the application behaves from the user&apos;s point of view.</p><span>
</span><p>During TypeScript conversion, there is nothing we have to do to keep E2E tests
working. It is only when we start to upgrade components and their template to Angular 2
that we need to make some changes. This is because the E2E tests have matchers
that are specific to Angular 1. For PhoneCat we need to make the following changes
in order to make things work with Angular 2:</p><span>
</span><table><tbody><tr><th>Previous code</th><th>New code</th><th>Notes</th></tr><tr><td><p><code>by.repeater(&apos;phone in $ctrl.phones&apos;).column(&apos;phone.name&apos;)</code></p>
</td><td><p><code>by.css(&apos;.phones .name&apos;)</code></p>
</td><td><p>The repeater matcher relies on Angular 1 <code>ng-repeat</code></p>
</td></tr><tr><td><p><code>by.repeater(&apos;phone in $ctrl.phones&apos;)</code></p>
</td><td><p><code>by.css(&apos;.phones li&apos;)</code></p>
</td><td><p>The repeater matcher relies on Angular 1 <code>ng-repeat</code></p>
</td></tr><tr><td><p><code>by.model(&apos;$ctrl.query&apos;)</code></p>
</td><td><p><code>by.css(&apos;input&apos;)</code></p>
</td><td><p>The model matcher relies on Angular 1 <code>ng-model</code></p>
</td></tr><tr><td><p><code>by.model(&apos;$ctrl.orderProp&apos;)</code></p>
</td><td><p><code>by.css(&apos;select&apos;)</code></p>
</td><td><p>The model matcher relies on Angular 1 <code>ng-model</code></p>
</td></tr><tr><td><p><code>by.binding(&apos;$ctrl.phone.name&apos;)</code></p>
</td><td><p><code>by.css(&apos;h1&apos;)</code></p>
</td><td><p>The binding matcher relies on Angular 1 data binding</p>
</td></tr></tbody></table><p>When the bootstrap method is switched from that of <code>UpgradeAdapter</code> to
pure Angular 2, Angular 1 ceases to exist on the page completely.
At this point we need to tell Protractor that it should not be looking for
an Angular 1 app anymore, but instead it should find <em>Angular 2 apps</em> from
the page. The following change is then needed in <code>protractor-conf.js</code>:</p><span>
</span><code format="">useAllAngular2AppRoots: true,
</code><p>Also, there are a couple of Protractor API calls in the PhoneCat test code that
are using the Angular 1 <code>$location</code> service under the hood. As that
service is no longer there after the upgrade, we need to replace those calls with ones
that use WebDriver&apos;s generic URL APIs instead. The first of these is
the redirection spec:</p><span>
</span><p>e2e-tests/scenarios.ts</p><code language="ts" format="">BAD FILENAME: ../../../_fragments/upgrade-phonecat-3-final/e2e-spec-redirect.ts.md   Current path: docs,ts,latest,guide,upgrade PathToDocs: ../../../</code><p>And the second is the phone links spec:</p><span>
</span><p>e2e-tests/scenarios.ts</p><code language="ts" format="">BAD FILENAME: ../../../_fragments/upgrade-phonecat-3-final/e2e-spec-links.ts.md   Current path: docs,ts,latest,guide,upgrade PathToDocs: ../../../</code><h2 id="unit-tests">Unit Tests</h2><span>
</span><p>For unit tests, on the other hand, more conversion work is needed. Effectively
they need to be <em>upgraded</em> along with the production code.</p><span>
</span><p>During TypeScript conversion no changes are strictly necessary. But it may be
a good idea to convert the unit test code into TypeScript as well, as the same
benefits we from TypeScript in production code also applies to tests.</p><span>
</span><p>For instance, in the phone detail component spec we can use not only ES2015
features like arrow functions and block-scoped variables, but also type
definitions for some of the Angular 1 services we&apos;re consuming:</p><span>
</span><p>app/phone-detail/phone-detail.component.spec.ts</p><code language="ts" format="linenums">describe(&apos;phoneDetail&apos;, () =&gt; {

  // Load the module that contains the `phoneDetail` component before each test
  beforeEach(angular.mock.module(&apos;phoneDetail&apos;));

  // Test the controller
  describe(&apos;PhoneDetailController&apos;, () =&gt; {
    let $httpBackend: angular.IHttpBackendService;
    let ctrl: any;
    let xyzPhoneData = {
      name: &apos;phone xyz&apos;,
      images: [&apos;image/url1.png&apos;, &apos;image/url2.png&apos;]
    };

    beforeEach(inject(($componentController: any,
                       _$httpBackend_: angular.IHttpBackendService,
                       $routeParams: angular.route.IRouteParamsService) =&gt; {
      $httpBackend = _$httpBackend_;
      $httpBackend.expectGET(&apos;phones/xyz.json&apos;).respond(xyzPhoneData);

      $routeParams[&apos;phoneId&apos;] = &apos;xyz&apos;;

      ctrl = $componentController(&apos;phoneDetail&apos;);
    }));

    it(&apos;should fetch the phone details&apos;, () =&gt; {
      jasmine.addCustomEqualityTester(angular.equals);

      expect(ctrl.phone).toEqual({});

      $httpBackend.flush();
      expect(ctrl.phone).toEqual(xyzPhoneData);
    });

  });

});
</code><p>Once we start the upgrade process and bring in SystemJS, configuration changes
are needed for Karma. We need to let SystemJS load all the new Angular 2 code,
which can be done with the following kind of shim file:</p><span>
</span><p>karma-test-shim.js</p><code language="js" format="linenums">// /*global jasmine, __karma__, window*/
Error.stackTraceLimit = Infinity;
jasmine.DEFAULT_TIMEOUT_INTERVAL = 1000;

__karma__.loaded = function () {
};

function isJsFile(path) {
  return path.slice(-3) == &apos;.js&apos;;
}

function isSpecFile(path) {
  return /\.spec\.js$/.test(path);
}

function isBuiltFile(path) {
  var builtPath = &apos;/base/app/&apos;;
  return isJsFile(path) &amp;&amp; (path.substr(0, builtPath.length) == builtPath);
}

var allSpecFiles = Object.keys(window.__karma__.files)
  .filter(isSpecFile)
  .filter(isBuiltFile);

System.config({
  baseURL: &apos;/base&apos;,
  packageWithIndex: true // sadly, we can&apos;t use umd packages (yet?)
});

System.import(&apos;systemjs.config.js&apos;)
  .then(() =&gt; Promise.all([
      System.import(&apos;@angular/core/testing&apos;),
      System.import(&apos;@angular/platform-browser-dynamic/testing&apos;)
    ]))
  .then((providers) =&gt; {
    var coreTesting = providers[0];
    var browserTesting = providers[1];
    coreTesting.TestBed.initTestEnvironment(
      browserTesting.BrowserDynamicTestingModule,
      browserTesting.platformBrowserDynamicTesting());
  })
  .then(function () {
    // Finally, load all spec files.
    // This will run the tests directly.
    return Promise.all(
      allSpecFiles.map(function (moduleName) {
        return System.import(moduleName);
      }));
  })
  .then(__karma__.start, __karma__.error);
</code><p>The shim first loads the SystemJS configuration, then Angular 2&apos;s test support libraries,
and then the application&apos;s spec files themselves.</p><span>
</span><p>Karma configuration should then be changed so that it uses the application root dir
as the base directory, instead of <code>app</code>.</p><span>
</span><p>karma.conf.js</p><code language="js" format="">basePath: &apos;./&apos;,
</code><p>Once this is done, we can load SystemJS and other dependencies, and also switch the configuration
for loading application files so that they are <em>not</em> included to the page by Karma. We&apos;ll let
the shim and SystemJS load them.</p><span>
</span><p>karma.conf.js</p><code language="js" format="linenums">// System.js for module loading
&apos;node_modules/systemjs/dist/system.src.js&apos;,

// Polyfills
&apos;node_modules/core-js/client/shim.js&apos;,
&apos;node_modules/reflect-metadata/Reflect.js&apos;,

// zone.js
&apos;node_modules/zone.js/dist/zone.js&apos;,
&apos;node_modules/zone.js/dist/long-stack-trace-zone.js&apos;,
&apos;node_modules/zone.js/dist/proxy.js&apos;,
&apos;node_modules/zone.js/dist/sync-test.js&apos;,
&apos;node_modules/zone.js/dist/jasmine-patch.js&apos;,
&apos;node_modules/zone.js/dist/async-test.js&apos;,
&apos;node_modules/zone.js/dist/fake-async-test.js&apos;,

// RxJs.
{ pattern: &apos;node_modules/rxjs/**/*.js&apos;, included: false, watched: false },
{ pattern: &apos;node_modules/rxjs/**/*.js.map&apos;, included: false, watched: false },

// Angular 2 itself and the testing library
{pattern: &apos;node_modules/@angular/**/*.js&apos;, included: false, watched: false},
{pattern: &apos;node_modules/@angular/**/*.js.map&apos;, included: false, watched: false},

{pattern: &apos;systemjs.config.js&apos;, included: false, watched: false},
&apos;karma-test-shim.js&apos;,

{pattern: &apos;app/**/*.module.js&apos;, included: false, watched: true},
{pattern: &apos;app/*!(.module|.spec).js&apos;, included: false, watched: true},
{pattern: &apos;app/!(bower_components)/**/*!(.module|.spec).js&apos;, included: false, watched: true},
{pattern: &apos;app/**/*.spec.js&apos;, included: false, watched: true},

{pattern: &apos;**/*.html&apos;, included: false, watched: true},
</code><p>Since the HTML templates of Angular 2 components will be loaded as well, we need to help
Karma out a bit so that it can route them to the right paths:</p><span>
</span><p>karma.conf.js</p><code language="js" format="linenums">// proxied base paths for loading assets
proxies: {
  // required for component assets fetched by Angular&apos;s compiler
  &quot;/phone-detail&quot;: &apos;/base/app/phone-detail&apos;,
  &quot;/phone-list&quot;: &apos;/base/app/phone-list&apos;
},
</code><p>The unit test files themselves also need to be switched to Angular 2 when their production
counterparts are switched. The specs for the checkmark pipe are probably the most straightforward,
as the pipe has no dependencies:</p><span>
</span><p>app/core/checkmark/checkmark.pipe.spec.ts</p><code language="ts" format="">BAD FILENAME: ../../../_fragments/upgrade-phonecat-2-hybrid/ts/app/core/checkmark/checkmark.pipe.spec.ts.md   Current path: docs,ts,latest,guide,upgrade PathToDocs: ../../../</code><p>The unit test for the phone service is a bit more involved. We need to switch from the mocked-out
Angular 1 <code>$httpBackend</code> to a mocked-out Angular 2 Http backend.</p><span>
</span><p>app/core/phone/phone.service.spec.ts</p><code language="ts" format="">BAD FILENAME: ../../../_fragments/upgrade-phonecat-2-hybrid/ts/app/core/phone/phone.service.spec.ts.md   Current path: docs,ts,latest,guide,upgrade PathToDocs: ../../../</code><p>For the component specs we can mock out the <code>Phone</code> service itself, and have it provide
canned phone data. We use Angular&apos;s component unit testing APIs for both components.</p><span>
</span><p>app/phone-detail/phone-detail.component.spec.ts</p><code language="ts" format="">BAD FILENAME: ../../../_fragments/upgrade-phonecat-2-hybrid/ts/app/phone-detail/phone-detail.component.spec.ts.md   Current path: docs,ts,latest,guide,upgrade PathToDocs: ../../../</code><p>app/phone-list/phone-list.component.spec.ts</p><code language="ts" format="">BAD FILENAME: ../../../_fragments/upgrade-phonecat-2-hybrid/ts/app/phone-list/phone-list.component.spec.ts.md   Current path: docs,ts,latest,guide,upgrade PathToDocs: ../../../</code><p>Finally, we need to revisit both of the component tests when we switch to the Angular 2
router. For the details component we need to provide an Angular 2 <code>RouteParams</code> object
instead of using the Angular 1 <code>$routeParams</code>.</p><span>
</span><p>app/phone-detail/phone-detail.component.spec.ts</p><code language="ts" format="">BAD FILENAME: ../../../_fragments/upgrade-phonecat-3-final/ts/app/phone-detail/phone-detail.component.spec-routeparams.ts.md   Current path: docs,ts,latest,guide,upgrade PathToDocs: ../../../</code><p>And for the phone list component we need to set up a few things for the router itself so that
the route link directive will work.</p><span>
</span><p>app/phone-list/phone-list.component.spec.ts</p><code language="ts" format="">BAD FILENAME: ../../../_fragments/upgrade-phonecat-3-final/ts/app/phone-list/phone-list.component.spec-routestuff.ts.md   Current path: docs,ts,latest,guide,upgrade PathToDocs: ../../../</code><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--></div></div>
        </article>
      
        <article>
          <h3>Webpack: an introduction</h3>
          <div><div class="showcase-content"><p><a href="https://webpack.github.io/"><strong>Webpack</strong></a> is a popular module bundler,
a tool for bundling application source code in convenient <em>chunks</em> 
and for loading that code from a server into a browser.</p><span>
</span><p>It&apos;s an excellent alternative to the <em>SystemJS</em> approach we use throughout the documentation.
In this guide we get a taste of Webpack and how to use it with Angular 2 applications.</p><span>
</span><span>
</span><h2 id="table-of-contents">Table of contents</h2><span>
</span><p><a href="https://angular.io/docs/ts/latest/guide/webpack.html#what-is-webpack">What is Webpack?</a></p><span>
</span><ul>
<li><a href="https://angular.io/docs/ts/latest/guide/webpack.html#entries-outputs">Entries and outputs</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/webpack.html#loaders">Loaders</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/webpack.html#plugins">Plugins</a></li>
</ul><span>
</span><p><a href="https://angular.io/docs/ts/latest/guide/webpack.html#configure-webpack">Configuring Webpack</a></p><span>
</span><ul>
<li><a href="https://angular.io/docs/ts/latest/guide/webpack.html#common-configuration">Common configuration</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/webpack.html#development-configuration">Development configuration</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/webpack.html#production-configuration">Production configuration</a></li>
<li><a href="https://angular.io/docs/ts/latest/guide/webpack.html#test-configuration">Test configuration</a></li>
</ul><span>
</span><p><a href="https://angular.io/docs/ts/latest/guide/webpack.html#try">Trying it out</a></p><span>
</span><p><a href="https://angular.io/docs/ts/latest/guide/webpack.html#conclusions">Conclusions</a></p><span>
</span><a id="what-is-webpack"></a><h2 id="what-is-webpack-">What is Webpack?</h2><span>
</span><p>Webpack is a powerful module bundler. 
A <em>bundle</em> is a JavaScript file that incorporate <em>assets</em> that <em>belong</em> together and 
should be served to the client in a response to a single file request.
A bundle can include JavaScript, CSS styles, HTML, and almost any other kind of file.</p><span>
</span><p>Webpack roams over your application source code, 
looking for <code>import</code> statements, building a dependency graph, and emitting one (or more) <em>bundles</em>.
With plugin &quot;loaders&quot; Webpack can preprocess and minify different non-JavaScript files such as TypeScript, SASS, and LESS files. </p><span>
</span><p>We determine what Webpack does and how it does it with a JavaScript configuration file, <code>webpack.config.js</code>.</p><span>
</span><a id="entries-outputs"></a><h3 id="entries-and-outputs">Entries and outputs</h3><span>
</span><p>We feed Webpack with one or more <em>entry</em> files and let it find and incorporate the dependencies that radiate from those entries. 
In this example, we start from the application&apos;s root file, <code>src/app.ts</code>:</p><span>
</span><p>webpack.config.js (single entry)</p><code language="ts" format="">entry: {
  app: &apos;src/app.ts&apos;
}
</code><p>Webpack inspects that file and traverses its <code>import</code> dependencies recursively.</p><span>
</span><p>src/app.ts</p><code language="ts" format="">import { Component } from &apos;@angular/core&apos;;

@Component({
  ...
})
export class AppComponent {}
</code><p>Here it sees that we&apos;re importing <em>@angular/core</em> so it adds that to its dependency list for (potential) inclusion in the bundle.
It opens <em>@angular/core</em> and follows <em>its</em> network of <code>import</code> statements until it has build the complete dependency graph from <code>app.ts</code> down.</p><span>
</span><p>Then it <strong>outputs</strong> these files to the <code>app.js</code> <em>bundle file</em> designated in configuration:</p><span>
</span><p>webpack.config.js (single output)</p><code language="ts" format="">output: {
  filename: &apos;app.js&apos;
}
</code><p>This <code>app.js</code> output bundle is a single JavaScript file that contains our application source and its dependencies. 
We&apos;ll load it later with a &lt;script&gt; tag in our index.html. </p><span>
</span><h4 id="multiple-bundles">Multiple bundles</h4><span>
</span><p>We probably do not want one giant bundle of everything.
We&apos;ll likely prefer to separate our volatile application app code from comparatively stable vendor code modules.</p><span>
</span><p>We change the configuration so that we have two entry points, <code>app.ts</code> and <code>vendor.ts</code>:</p><span>
</span><p>webpack.config.js (two entries)</p><code language="ts" format="">entry: {
  app: &apos;src/app.ts&apos;,
  vendor: &apos;src/vendor.ts&apos;
},

output: {
  filename: &apos;[name].js&apos;
}
</code><p>Webpack constructs two separate dependency graphs
and emits <em>two</em> bundle files, one called <code>app.js</code> containing only our application code and 
another called <code>vendor.js</code> with all the vendor dependencies.</p><span>
</span><div class="l-sub-section"><p>The <code>[name]</code> in the output name is a Webpack <em>placeholder</em> that is replaced with the entry names.
<code>app</code> and <code>vendor</code> respectively.</p><span>
</span><p>We need a plugin to make this work; we&apos;ll <a href="https://angular.io/docs/ts/latest/guide/webpack.html#commons-chunk-plugin">cover that later</a> in the chapter.</p><span>
</span></div><p>We met <code>app.ts</code> earlier. We wrote <code>vendor.ts</code> such that it imports the vendor modules we need:</p><span>
</span><p>src/vendor.ts</p><code language="ts" format="">// Angular 2
import &apos;@angular/platform-browser&apos;;
import &apos;@angular/platform-browser-dynamic&apos;;
import &apos;@angular/core&apos;;
import &apos;@angular/common&apos;;
import &apos;@angular/http&apos;;
import &apos;@angular/router&apos;;

// RxJS
import &apos;rxjs&apos;;

// Other vendors for example jQuery, Lodash or Bootstrap
// You can import js, ts, css, sass, ...
</code><a id="loaders"></a><h3 id="loaders">Loaders</h3><span>
</span><p>Webpack can bundle any kind of file: JavaScript, TypeScript, CSS, SASS, LESS, images, html, fonts, whatever.
Webpack itself doesn&apos;t know what to do with a non-JavaScript file.
We teach it to process such files into JavaScript with <em>loaders</em>. 
Here we configure loaders for TypeScript and CSS:</p><span>
</span><p>webpack.config.js (two entries)</p><code language="ts" format="">loaders: [
  {
    test: /\.ts$/
    loaders: &apos;ts&apos;
  },
  {
    test: /\.css$/
    loaders: &apos;style!css&apos;
  }
]
</code><p>As Webpack encounters <code>import</code> statements like these ...</p><span>
</span><code language="ts" format="">import { AppComponent } from &apos;./app.component.ts&apos;;
import &apos;uiframework/dist/uiframework.css&apos;;
</code><p>... it applies the <code>test</code> RegEx patterns. When a pattern matches the filename, Webpack processes the file with the associated loader. </p><span>
</span><p>The first <code>import</code> file matches the <code>.ts</code> pattern so Webpack processes it with the <code>ts</code> (TypeScript) loader.
The imported file doesn&apos;t match the second pattern so its loader is ignored. </p><span>
</span><p>The second <code>import</code> matches the second <code>.css</code> pattern for which we have <em>two</em> loaders chained by the (!) character. 
Webpack applies chained loaders <em>right to left</em> so it applies 
the <code>css</code> loader first (to flatten CSS <code>@import</code> and <code>url(...)</code> statements) and
 then the <code>style</code> loader (to append the css inside <em>&lt;style&gt;</em> elements on the page).</p><span>
</span><a id="plugins"></a><h3 id="plugins">Plugins</h3><span>
</span><p>Webpack has a build pipeline with well-defined phases.
We tap into that pipeline with plugins such as the <code>uglify</code> minification plugin:</p><span>
</span><code language="ts" format="">plugins: [
  new webpack.optimize.UglifyJsPlugin()
]
</code><a id="configure-webpack"></a><h2 id="configure-webpack">Configure Webpack</h2><span>
</span><p>After that brief orientation, we are ready to build our own Webpack configuration for Angular 2 apps. </p><span>
</span><p>Begin by setting up the development environment.</p><span>
</span><p>Create a <strong>new project folder</strong></p><span>
</span><code format="">mkdir angular2-webpack
cd    angular2-webpack
</code><p>Add these files to the root directory:</p><span>
</span><code-tabs><code language="json" name="package.json" format="linenums">{
  &quot;name&quot;: &quot;angular2-webpack&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;A webpack starter for angular 2&quot;,
  &quot;scripts&quot;: {
    &quot;start&quot;: &quot;webpack-dev-server --inline --progress --port 8080&quot;,
    &quot;test&quot;: &quot;karma start&quot;,
    &quot;build&quot;: &quot;rimraf dist &amp;&amp; webpack --config config/webpack.prod.js --progress --profile --bail&quot;,
    &quot;postinstall&quot;: &quot;typings install&quot;
  },
  &quot;license&quot;: &quot;MIT&quot;,
  &quot;dependencies&quot;: {
    &quot;@angular/common&quot;: &quot;2.0.0-rc.6&quot;,
    &quot;@angular/compiler&quot;: &quot;2.0.0-rc.6&quot;,
    &quot;@angular/core&quot;: &quot;2.0.0-rc.6&quot;,
    &quot;@angular/forms&quot;: &quot;2.0.0-rc.6&quot;,
    &quot;@angular/http&quot;: &quot;2.0.0-rc.6&quot;,
    &quot;@angular/platform-browser&quot;: &quot;2.0.0-rc.6&quot;,
    &quot;@angular/platform-browser-dynamic&quot;: &quot;2.0.0-rc.6&quot;,
    &quot;@angular/router&quot;: &quot;3.0.0-rc.2&quot;,
    &quot;core-js&quot;: &quot;^2.4.1&quot;,
    &quot;rxjs&quot;: &quot;5.0.0-beta.11&quot;,
    &quot;zone.js&quot;: &quot;^0.6.17&quot;
  },
  &quot;devDependencies&quot;: {
    &quot;angular2-template-loader&quot;: &quot;^0.4.0&quot;,
    &quot;css-loader&quot;: &quot;^0.23.1&quot;,
    &quot;extract-text-webpack-plugin&quot;: &quot;^1.0.1&quot;,
    &quot;file-loader&quot;: &quot;^0.8.5&quot;,
    &quot;html-loader&quot;: &quot;^0.4.3&quot;,
    &quot;html-webpack-plugin&quot;: &quot;^2.15.0&quot;,
    &quot;jasmine-core&quot;: &quot;^2.4.1&quot;,
    &quot;karma&quot;: &quot;^0.13.22&quot;,
    &quot;karma-jasmine&quot;: &quot;^0.3.8&quot;,
    &quot;karma-phantomjs-launcher&quot;: &quot;^1.0.0&quot;,
    &quot;karma-sourcemap-loader&quot;: &quot;^0.3.7&quot;,
    &quot;karma-webpack&quot;: &quot;^1.7.0&quot;,
    &quot;null-loader&quot;: &quot;^0.1.1&quot;,
    &quot;phantomjs-prebuilt&quot;: &quot;^2.1.7&quot;,
    &quot;raw-loader&quot;: &quot;^0.5.1&quot;,
    &quot;rimraf&quot;: &quot;^2.5.2&quot;,
    &quot;style-loader&quot;: &quot;^0.13.1&quot;,
    &quot;ts-loader&quot;: &quot;^0.8.1&quot;,
    &quot;typescript&quot;: &quot;^1.8.10&quot;,
    &quot;typings&quot;: &quot;^1.0.4&quot;,
    &quot;webpack&quot;: &quot;^1.13.0&quot;,
    &quot;webpack-dev-server&quot;: &quot;^1.14.1&quot;,
    &quot;webpack-merge&quot;: &quot;^0.14.0&quot;
  }
}
</code><code language="json" name="typings.json" format="linenums">{
  &quot;globalDependencies&quot;: {
    &quot;core-js&quot;: &quot;registry:dt/core-js#0.0.0+20160725163759&quot;,
    &quot;jasmine&quot;: &quot;registry:dt/jasmine#2.2.0+20160621224255&quot;,
    &quot;node&quot;: &quot;registry:dt/node#6.0.0+20160831021119&quot;
  }
}
</code><code language="json" name="tsconfig.json" format="linenums">{
  &quot;compilerOptions&quot;: {
    &quot;target&quot;: &quot;es5&quot;,
    &quot;module&quot;: &quot;commonjs&quot;,
    &quot;moduleResolution&quot;: &quot;node&quot;,
    &quot;sourceMap&quot;: true,
    &quot;emitDecoratorMetadata&quot;: true,
    &quot;experimentalDecorators&quot;: true,
    &quot;removeComments&quot;: false,
    &quot;noImplicitAny&quot;: true,
    &quot;suppressImplicitAnyIndexErrors&quot;: true
  }
}
</code><code language="js" name="webpack.config.js" format="linenums">module.exports = require(&apos;./config/webpack.dev.js&apos;);
</code><code language="js" name="karma.conf.js" format="linenums">module.exports = require(&apos;./config/karma.conf.js&apos;);
</code><code language="js" name="config/helpers.js" format="linenums">var path = require(&apos;path&apos;);

var _root = path.resolve(__dirname, &apos;..&apos;);

function root(args) {
  args = Array.prototype.slice.call(arguments, 0);
  return path.join.apply(path, [_root].concat(args));
}

exports.root = root;
</code></code-tabs><div class="l-sub-section"><p>Many of these files and much of their content should be familiar from other Angular 2 documentation chapters.</p><span>
</span><p>Learn about the <code>package.json</code> in the <a href="https://angular.io/docs/ts/latest/guide/npm-packages.html">npm packages</a> chapter.
We require packages for Webpack use in addition to the ones listed in that chapter.</p><span>
</span><p>Learn about <code>tsconfig.json</code> and <code>typings.json</code> in the <a href="https://angular.io/docs/ts/latest/guide/typescript-configuration.html">Typescript configuration</a> chapter.</p><span>
</span></div><p>Open a terminal/console window and install the <em>npm</em> packages with <code>npm install</code>.</p><span>
</span><a id="common-configuration"></a><h3 id="common-configuration">Common Configuration</h3><span>
</span><p>We will define separate configurations for development, production, and test environments.
All three have some configuration in common.
We&apos;ll gather that common configuration in a separate file called <code>webpack.common.js</code>.</p><span>
</span><p>Let&apos;s see the entire file and then walk through it a section at a time:</p><span>
</span><p>config/webpack.common.js</p><code language="js" format="">var webpack = require(&apos;webpack&apos;);
var HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);
var ExtractTextPlugin = require(&apos;extract-text-webpack-plugin&apos;);
var helpers = require(&apos;./helpers&apos;);

module.exports = {
  entry: {
    &apos;polyfills&apos;: &apos;./src/polyfills.ts&apos;,
    &apos;vendor&apos;: &apos;./src/vendor.ts&apos;,
    &apos;app&apos;: &apos;./src/main.ts&apos;
  },

  resolve: {
    extensions: [&apos;&apos;, &apos;.js&apos;, &apos;.ts&apos;]
  },

  module: {
    loaders: [
      {
        test: /\.ts$/,
        loaders: [&apos;ts&apos;, &apos;angular2-template-loader&apos;]
      },
      {
        test: /\.html$/,
        loader: &apos;html&apos;
      },
      {
        test: /\.(png|jpe?g|gif|svg|woff|woff2|ttf|eot|ico)$/,
        loader: &apos;file?name=assets/[name].[hash].[ext]&apos;
      },
      {
        test: /\.css$/,
        exclude: helpers.root(&apos;src&apos;, &apos;app&apos;),
        loader: ExtractTextPlugin.extract(&apos;style&apos;, &apos;css?sourceMap&apos;)
      },
      {
        test: /\.css$/,
        include: helpers.root(&apos;src&apos;, &apos;app&apos;),
        loader: &apos;raw&apos;
      }
    ]
  },

  plugins: [
    new webpack.optimize.CommonsChunkPlugin({
      name: [&apos;app&apos;, &apos;vendor&apos;, &apos;polyfills&apos;]
    }),

    new HtmlWebpackPlugin({
      template: &apos;src/index.html&apos;
    })
  ]
};
</code><p>Webpack is a NodeJS-based tool so its configuration is a JavaScript <em>commonjs</em> module file 
that begins with <code>require</code> statements as such files do. </p><span>
</span><p>The configuration exports several objects, beginning with the <em>entries</em> described earlier:</p><span>
</span><p>config/webpack.common.js</p><code language="js" format="">entry: {
  &apos;polyfills&apos;: &apos;./src/polyfills.ts&apos;,
  &apos;vendor&apos;: &apos;./src/vendor.ts&apos;,
  &apos;app&apos;: &apos;./src/main.ts&apos;
},
</code><p>We are splitting our application into three bundles:</p><span>
</span><ul>
<li>polyfills - the standard polyfills we require to run Angular 2 applications in most modern browsers.</li>
<li>vendor - the vendor files we need: Angular 2, lodash, bootstrap.css...</li>
<li>app - our application code.</li>
</ul><span>
</span><div class="callout is-critical"><header>Loading polyfills</header><p>Load Zone.js early, immediately after the other ES6 and metadata shims.</p><span>
</span></div><p>Our app will <code>import</code> dozens if not hundreds of JavaScript and TypeScript files. 
We <em>might</em> write <code>import</code> statements with explicit extensions as in this example:</p><span>
</span><code language="ts" format="">import { AppComponent } from &apos;./app.component.ts&apos;;
</code><p>But most of our <code>import</code> statements won&apos;t mention the extension at all.
So we  tell Webpack to <em>resolve</em> module file requests by looking for matching files with</p><span>
</span><ul>
<li>an explicit extension (signified by the empty extension string, <code>&apos;&apos;</code>) or </li>
<li><code>.js</code> extension (for regular JavaScript files and pre-compiled TypeScript files) or </li>
<li><code>.ts</code> extension.</li>
</ul><span>
</span><p>config/webpack.common.js</p><code language="js" format="">resolve: {
  extensions: [&apos;&apos;, &apos;.js&apos;, &apos;.ts&apos;]
},
</code><div class="l-sub-section"><p>We could add  <code>.css</code> and <code>.html</code> later if we want Webpack to resolve extension-less files with <em>those</em> extension too.</p><span>
</span></div><p>Next we specify the loaders:</p><span>
</span><p>config/webpack.common.js</p><code language="js" format="">module: {
  loaders: [
    {
      test: /\.ts$/,
      loaders: [&apos;ts&apos;, &apos;angular2-template-loader&apos;]
    },
    {
      test: /\.html$/,
      loader: &apos;html&apos;
    },
    {
      test: /\.(png|jpe?g|gif|svg|woff|woff2|ttf|eot|ico)$/,
      loader: &apos;file?name=assets/[name].[hash].[ext]&apos;
    },
    {
      test: /\.css$/,
      exclude: helpers.root(&apos;src&apos;, &apos;app&apos;),
      loader: ExtractTextPlugin.extract(&apos;style&apos;, &apos;css?sourceMap&apos;)
    },
    {
      test: /\.css$/,
      include: helpers.root(&apos;src&apos;, &apos;app&apos;),
      loader: &apos;raw&apos;
    }
  ]
},
</code><ul>
<li>ts - a loader to transpile our Typescript code to ES5, guided by the <code>tsconfig.json</code> file</li>
<li>angular2-template-loader - loads angular components&apos; template and styles</li>
<li>html - for component templates</li>
<li>images/fonts - Images and fonts are bundled as well.</li>
<li>css - The pattern matches application-wide styles; the second handles component-scoped styles (the ones specified in a component&apos;s <code>styleUrls</code> metadata property)</li>
</ul><span>
</span><div class="l-sub-section"><p>The first pattern excludes <code>.css</code> files within the <code>/src/app</code> directories where our component-scoped styles sit.
It includes only <code>.css</code> files located at or above <code>/src</code>; these are the application-wide styles.
The <code>ExtractTextPlugin</code> (described below) applies the <code>style</code> and <code>css</code> loaders to these files.</p><span>
</span><p>The second pattern filters for component-scoped styles and loads them as strings via the <code>raw</code> loader &#x2014;
which is what Angular expects to do with styles specified in a <code>styleUrls</code> metadata property.</p><span>
</span></div><div class="l-sub-section"><p>Multiple loaders can be also chained using the array notation.</p><span>
</span></div><p>Finally we add two plugins:</p><span>
</span><p>config/webpack.common.js</p><code language="js" format="">plugins: [
  new webpack.optimize.CommonsChunkPlugin({
    name: [&apos;app&apos;, &apos;vendor&apos;, &apos;polyfills&apos;]
  }),

  new HtmlWebpackPlugin({
    template: &apos;src/index.html&apos;
  })
]
</code><a id="commons-chunk-plugin"></a><h4 id="-commonschunkplugin-"><em>CommonsChunkPlugin</em></h4><span>
</span><p>We want the <code>app.js</code> bundle to contain only app code and the <code>vendor.js</code> bundle to contain only the vendor code. </p><span>
</span><p>Our application code <code>imports</code> vendor code. Webpack is not smart enough to keep the vendor code out of the <code>app.js</code> bundle.
We rely on the <code>CommonsChunkPlugin</code> to do that job. </p><span>
</span><div class="l-sub-section"><p>It identifies the hierarchy among three <em>chunks</em>: <code>app</code> -&gt; <code>vendor</code> -&gt; <code>polyfills</code>. 
Where Webpack finds that <code>app</code> has shared dependencies with <code>vendor</code>, it removes them from <code>app</code>.
It would do the same if <code>vendor</code> and <code>polyfills</code> had shared dependencies (which they don&apos;t).</p><span>
</span></div><a id="html-webpack-plugin"></a><h4 id="-htmlwebpackplugin-"><em>HtmlWebpackPlugin</em></h4><span>
</span><p>Webpack generates a number of js and css files. 
We <em>could</em> insert them into our <code>index.html</code> <em>manually</em>. That would be tedious and error-prone.
Webpack can inject those scripts and links for us with the <code>HtmlWebpackPlugin</code>.</p><span>
</span><a id="environment-configuration"></a><h3 id="environment-specific-configuration">Environment-specific configuration</h3><span>
</span><p>The <code>webpack.common.js</code> configuration file does most of the heavy lifting. 
We create separate, environment-specific configuration files that build on <code>webpack.common</code>
by merging into it the peculiarities particular to their target environments.</p><span>
</span><p>These files tend to be short and simple.</p><span>
</span><a id="development-configuration"></a><h3 id="development-configuration">Development Configuration</h3><span>
</span><p>Here is the development configuration file, <code>webpack.dev.js</code></p><span>
</span><p>config/webpack.dev.js</p><code language="js" format="">var webpackMerge = require(&apos;webpack-merge&apos;);
var ExtractTextPlugin = require(&apos;extract-text-webpack-plugin&apos;);
var commonConfig = require(&apos;./webpack.common.js&apos;);
var helpers = require(&apos;./helpers&apos;);

module.exports = webpackMerge(commonConfig, {
  devtool: &apos;cheap-module-eval-source-map&apos;,

  output: {
    path: helpers.root(&apos;dist&apos;),
    publicPath: &apos;http://localhost:8080/&apos;,
    filename: &apos;[name].js&apos;,
    chunkFilename: &apos;[id].chunk.js&apos;
  },

  plugins: [
    new ExtractTextPlugin(&apos;[name].css&apos;)
  ],

  devServer: {
    historyApiFallback: true,
    stats: &apos;minimal&apos;
  }
});
</code><p>The development build relies on the Webpack development server which we configure near the bottom of the file.</p><span>
</span><p>Although we tell Webpack to put output bundles in the <code>dist</code> folder,
the dev server keeps all bundles in memory; it doesn&apos;t write them to disk.
So we won&apos;t find any files in the <code>dist</code> folder (at least not any generated from <code>this development build</code>).</p><span>
</span><p>The <code>HtmlWebpackPlugin</code> (added in <code>webpack.common.js</code>) use the <em>publicPath</em> and the <em>filename</em> settings to generate 
appropriate &lt;script&gt; and &lt;link&gt; tags into the <code>index.html</code>.</p><span>
</span><p>Our CSS are buried inside our Javascript bundles by default. The <code>ExtractTextPlugin</code> extracts them into
external <code>.css</code> files that the <code>HtmlWebpackPlugin</code> inscribes as &lt;link&gt; tags into the <code>index.html</code>.</p><span>
</span><p>Refer to the Webpack documentation for details on these and other configuration options in this file</p><span>
</span><p>Grab the app code at the end of this guide and try:</p><span>
</span><code format="">npm start
</code><a id="production-configuration"></a><h3 id="production-configuration">Production Configuration</h3><span>
</span><p>Configuration of a <em>production</em> build resembles <em>development</em> configuration ... with a few key changes.</p><span>
</span><p>config/webpack.prod.js</p><code language="js" format="">var webpack = require(&apos;webpack&apos;);
var webpackMerge = require(&apos;webpack-merge&apos;);
var ExtractTextPlugin = require(&apos;extract-text-webpack-plugin&apos;);
var commonConfig = require(&apos;./webpack.common.js&apos;);
var helpers = require(&apos;./helpers&apos;);

const ENV = process.env.NODE_ENV = process.env.ENV = &apos;production&apos;;

module.exports = webpackMerge(commonConfig, {
  devtool: &apos;source-map&apos;,

  output: {
    path: helpers.root(&apos;dist&apos;),
    publicPath: &apos;/&apos;,
    filename: &apos;[name].[hash].js&apos;,
    chunkFilename: &apos;[id].[hash].chunk.js&apos;
  },

  htmlLoader: {
    minimize: false // workaround for ng2
  },

  plugins: [
    new webpack.NoErrorsPlugin(),
    new webpack.optimize.DedupePlugin(),
    new webpack.optimize.UglifyJsPlugin(),
    new ExtractTextPlugin(&apos;[name].[hash].css&apos;),
    new webpack.DefinePlugin({
      &apos;process.env&apos;: {
        &apos;ENV&apos;: JSON.stringify(ENV)
      }
    })
  ]
});
</code><p>We don&apos;t use a development server. We&apos;re expected to deploy the application and its dependencies to a real production server.</p><span>
</span><p>This time the output bundle files are physically placed in the <code>dist</code> folder.</p><span>
</span><p>Webpack generates file names with cache-busting hash.
Thanks to the <code>HtmlWebpackPlugin</code> we don&apos;t have to update the <code>index.html</code> file when the hashes changes.</p><span>
</span><p>There are additional plugins:</p><span>
</span><ul>
<li><strong>NoErrorsPlugin</strong> - stops the build if there is any error.</li>
<li><strong>DedupePlugin</strong> - detects identical (and nearly identical) files and removes them from the output.</li>
<li><strong>UglifyJsPlugin</strong> - minifies the bundles.</li>
<li><strong>ExtractTextPlugin</strong> - extracts embedded css as external files, adding cache-busting hash to the filename.</li>
<li><strong>DefinePlugin</strong> - use to define environment variables that we can reference within our application.</li>
</ul><span>
</span><p>Thanks to the <em>DefinePlugin</em> and the <code>ENV</code> variable defined at top, we can enable Angular 2 production mode like this:</p><span>
</span><code language="ts" format="">if (process.env.ENV === &apos;production&apos;) {
  enableProdMode();
}
</code><p>Grab the app code at the end of this guide and try:</p><span>
</span><code format="">npm run build
</code><a id="test-configuration"></a><h3 id="test-configuration">Test Configuration</h3><span>
</span><p>We don&apos;t need much configuration to run unit tests. 
We don&apos;t need the loaders and plugins that we declared for our development and production builds.
We probably don&apos;t need to load and process the application-wide styles files for unit tests and doing so would slow us down;
we&apos;ll use the <code>null</code> loader for those CSS.</p><span>
</span><p>We could merge our test configuration into the <code>webpack.common</code> configuration and override the parts we don&apos;t want or need.
But it might be simpler to start over with a completely fresh configuration.</p><span>
</span><p>config/webpack.test.js</p><code language="js" format="">var helpers = require(&apos;./helpers&apos;);

module.exports = {
  devtool: &apos;inline-source-map&apos;,

  resolve: {
    extensions: [&apos;&apos;, &apos;.ts&apos;, &apos;.js&apos;]
  },

  module: {
    loaders: [
      {
        test: /\.ts$/,
        loaders: [&apos;ts&apos;, &apos;angular2-template-loader&apos;]
      },
      {
        test: /\.html$/,
        loader: &apos;html&apos;

      },
      {
        test: /\.(png|jpe?g|gif|svg|woff|woff2|ttf|eot|ico)$/,
        loader: &apos;null&apos;
      },
      {
        test: /\.css$/,
        exclude: helpers.root(&apos;src&apos;, &apos;app&apos;),
        loader: &apos;null&apos;
      },
      {
        test: /\.css$/,
        include: helpers.root(&apos;src&apos;, &apos;app&apos;),
        loader: &apos;raw&apos;
      }
    ]
  }
}
</code><p>Here&apos;s our karma configuration:</p><span>
</span><p>config/karma.conf.js</p><code language="js" format="">var webpackConfig = require(&apos;./webpack.test&apos;);

module.exports = function (config) {
  var _config = {
    basePath: &apos;&apos;,

    frameworks: [&apos;jasmine&apos;],

    files: [
      {pattern: &apos;./config/karma-test-shim.js&apos;, watched: false}
    ],

    preprocessors: {
      &apos;./config/karma-test-shim.js&apos;: [&apos;webpack&apos;, &apos;sourcemap&apos;]
    },

    webpack: webpackConfig,

    webpackMiddleware: {
      stats: &apos;errors-only&apos;
    },

    webpackServer: {
      noInfo: true
    },

    reporters: [&apos;progress&apos;],
    port: 9876,
    colors: true,
    logLevel: config.LOG_INFO,
    autoWatch: false,
    browsers: [&apos;PhantomJS&apos;],
    singleRun: true
  };

  config.set(_config);
};
</code><p>We&apos;re telling Karma to use webpack to run the tests. </p><span>
</span><p>We don&apos;t precompile our TypeScript; Webpack transpiles our Typescript files on the fly, in memory, and feeds the emitted JS directly to Karma.
There are no temporary files on disk.</p><span>
</span><p>The <code>karma-test-shim</code> tells Karma what files to pre-load and 
primes the Angular test framework with test versions of the providers that every app expects to be pre-loaded.</p><span>
</span><p>config/karma-test-shim.js</p><code language="js" format="">Error.stackTraceLimit = Infinity;

require(&apos;core-js/es6&apos;);
require(&apos;reflect-metadata&apos;);

require(&apos;zone.js/dist/zone&apos;);
require(&apos;zone.js/dist/long-stack-trace-zone&apos;);
require(&apos;zone.js/dist/proxy&apos;);
require(&apos;zone.js/dist/sync-test&apos;);
require(&apos;zone.js/dist/jasmine-patch&apos;);
require(&apos;zone.js/dist/async-test&apos;);
require(&apos;zone.js/dist/fake-async-test&apos;);

var appContext = require.context(&apos;../src&apos;, true, /\.spec\.ts/);

appContext.keys().forEach(appContext);

var testing = require(&apos;@angular/core/testing&apos;);
var browser = require(&apos;@angular/platform-browser-dynamic/testing&apos;);

testing.TestBed.initTestEnvironment(browser.BrowserDynamicTestingModule, browser.platformBrowserDynamicTesting());
</code><p>Notice that we do <em>not</em> load our application code explicitly.
We tell Webpack to find and load our test files (the files ending in <code>.spec.ts</code>).
Each spec file imports all &#x2014; and only &#x2014; the application source code that it tests.
Webpack loads just <em>those</em> specific application files and ignores the other files that we aren&apos;t testing.</p><span>
</span><p>Grab the app code at the end of this guide and try:</p><span>
</span><code format="">npm test
</code><a id="try"></a><h2 id="trying-it-out">Trying it out</h2><span>
</span><p>Here is the source code for a small application that we can bundle with the
Webpack techniques we learned in this chapter.</p><span>
</span><code-tabs><code language="html" name="src/index.html" format="linenums">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;base href=&quot;/&quot;&gt;
    &lt;title&gt;Angular With Webpack&lt;/title&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;my-app&gt;Loading...&lt;/my-app&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code><code language="ts" name="src/main.ts" format="linenums">import { platformBrowserDynamic } from &apos;@angular/platform-browser-dynamic&apos;;
import { enableProdMode } from &apos;@angular/core&apos;;

import { AppModule } from &apos;./app/app.module&apos;;

if (process.env.ENV === &apos;production&apos;) {
  enableProdMode();
}

platformBrowserDynamic().bootstrapModule(AppModule);
</code><code language="css" name="public/css/styles.css" format="linenums">body {
    background: #0147A7;
    color: #fff;
}
</code></code-tabs><code-tabs><code language="ts" name="src/app/app.component.ts" format="linenums">import { Component } from &apos;@angular/core&apos;;

import &apos;../../public/css/styles.css&apos;;

@Component({
  selector: &apos;my-app&apos;,
  templateUrl: &apos;./app.component.html&apos;,
  styleUrls: [&apos;./app.component.css&apos;]
})
export class AppComponent { }
</code><code language="html" name="src/app/app.component.html" format="linenums">&lt;main&gt;
  &lt;h1&gt;Hello from Angular 2 App with Webpack&lt;/h1&gt;

  &lt;img src=&quot;../../public/images/angular.png&quot;&gt;
&lt;/main&gt;
</code><code language="css" name="src/app/app.component.css" format="linenums">main {
  padding: 1em;
  font-family: Arial, Helvetica, sans-serif;
  text-align: center;
  margin-top: 50px;
  display: block;
}
</code><code language="ts" name="src/app/app.component.spec.ts" format="linenums">import { TestBed } from &apos;@angular/core/testing&apos;;

import { AppComponent } from &apos;./app.component&apos;;

describe(&apos;App&apos;, () =&gt; {
  beforeEach(() =&gt; {
    TestBed.configureTestingModule({ declarations: [AppComponent]});
  });

  it (&apos;should work&apos;, () =&gt; {
    let fixture = TestBed.createComponent(AppComponent);
    expect(fixture.componentInstance instanceof AppComponent).toBe(true, &apos;should create AppComponent&apos;);
  });
});
</code><code language="ts" name="src/app/app.module.ts" format="linenums">import { NgModule } from &apos;@angular/core&apos;;
import { BrowserModule }  from &apos;@angular/platform-browser&apos;;

import { AppComponent } from &apos;./app.component&apos;;

@NgModule({
  imports: [
    BrowserModule
  ],
  declarations: [
    AppComponent
  ],
  bootstrap: [ AppComponent ]
})
export class AppModule { }
</code></code-tabs><p>The <code>app.component.html</code> displays this downloadable Angular logo
<a href="https://raw.githubusercontent.com/angular/angular.io/master/public/resources/images/logos/angular2/angular.png" target="_blank">
<img src="https://raw.githubusercontent.com/angular/angular.io/master/public/resources/images/logos/angular2/angular.png" height="40px" title="download Angular logo"></a>.

</p><code-tabs><code language="ts" name="src/vendor.ts" format="linenums">// Angular 2
import &apos;@angular/platform-browser&apos;;
import &apos;@angular/platform-browser-dynamic&apos;;
import &apos;@angular/core&apos;;
import &apos;@angular/common&apos;;
import &apos;@angular/http&apos;;
import &apos;@angular/router&apos;;

// RxJS
import &apos;rxjs&apos;;

// Other vendors for example jQuery, Lodash or Bootstrap
// You can import js, ts, css, sass, ...
</code><code language="ts" name="src/polyfills.ts" format="linenums">import &apos;core-js/es6&apos;;
import &apos;core-js/es7/reflect&apos;;
require(&apos;zone.js/dist/zone&apos;);

if (process.env.ENV === &apos;production&apos;) {
  // Production

} else {
  // Development

  Error[&apos;stackTraceLimit&apos;] = Infinity;

  require(&apos;zone.js/dist/long-stack-trace-zone&apos;);
}
</code></code-tabs><a id="highlights"></a><h3 id="highlights-">Highlights:</h3><span>
</span><ul>
<li><p>There are no &lt;script&gt; or &lt;link&gt; tags in the <code>index.html</code>. 
The <code>HtmlWebpackPlugin</code> inserts them dynamically at runtime.</p>
</li>
<li><p>The <code>AppComponent</code> in <code>app.component.ts</code> imports the application-wide css with a simple <code>import</code> statement.</p>
</li>
<li><p>The <code>AppComponent</code> itself has its own html template and css file. WebPack loads them with calls to <code>require()</code>. 
Webpack stashes those component-scoped files in the <code>app.js</code> bundle too.
We don&apos;t see those calls in our source code; they&apos;re added behind the scenes by the <code>angular2-template-loader</code> plug-in. </p>
</li>
<li><p>The <code>vendor.ts</code> consists of vendor dependency <code>import</code> statements that drive the <code>vendor.js</code> bundle.
The application imports these modules too; they&apos;d be duplicated in the <code>app.js</code> bundle
if the <code>CommonsChunkPlugin</code> hadn&apos;t detected the overlap and removed them from <code>app.js</code>.</p>
</li>
</ul><span>
</span><a id="conclusions"></a><h2 id="conclusions">Conclusions</h2><span>
</span><p>We&apos;ve learned just enough Webpack to configurate development, test and production builds 
for a small Angular application.</p><span>
</span><p><em>We could always do more</em>. Search the web for expert advice and expand your Webpack knowledge.</p><span>
</span><p><a href="https://angular.io/docs/ts/latest/guide/webpack.html#top">Back to top</a></p><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--><!-- CHECK IF CURRENT PAGE IS SET, THEN SET NEXT PAGE--><!-- SET CURRENT PAGE FLAG WHEN YOU PASS IT--></div></div>
        </article>
      <h2></h2>
        <article>
          <h3>Cookbook - ts</h3>
          <div><div class="showcase-content"><!-- #docregion cookbook--><span>
</span><p>The <em>Cookbook</em> offers answers to common implementation questions.</p><span>
</span><p>Each cookbook chapter is a collection of recipes focused on a particular Angular 2 feature or application challenge
such as data binding, cross-component interaction, and communicating with a remote server via HTTP.</p><span>
</span><div class="l-sub-section"><p>The cookbook is just getting started. Many more recipes are on the way.</p><span>
</span></div><p>Each cookbook chapter links to a live sample with every recipe included.</p><span>
</span><p>Recipes are deliberately brief and code-centric. 
Each recipe links to a chapter of the Developer Guide or the API Guide
where you can learn more about the purpose, context, and design choices behind the code snippets.</p><span>
</span><span>
</span><p>The cookbook is a perpetual <em>work-in-progress</em>. 
We welcome feedback! Leave a comment by clicking the icon in upper right corner of the banner.</p><span>
</span><p>Post <em>documentation</em> issues and pull requests on the 
<a href="https://github.com/angular/angular.io">angular.io</a> github repository.</p><span>
</span><p>Post issues with <em>Angular 2 itself</em> to the <a href="https://github.com/angular/angular">angular</a> github repository.</p><span>
</span><!-- #enddocregion cookbook--></div></div>
        </article>
      
        <article>
          <h3>Angular 1 to 2 Quick Reference</h3>
          <div><div class="showcase-content"><a id="top"></a><p>There are many conceptual and syntactical differences between Angular&#xA0;1 and Angular&#xA0;2.
This chapter provides a quick reference guide to some of the common Angular&#xA0;1
syntax and its equivalent in Angular&#xA0;2.</p><span>
</span><p><strong>See the Angular 2 syntax in this <live-example name="cb-a1-a2-quick-reference"></live-example></strong>.</p><span>
</span><h2 id="contents">Contents</h2><span>
</span><p>This chapter covers</p><span>
</span><ul>
<li><p><a href="https://angular.io/docs/ts/latest/cookbook/a1-a2-quick-reference.html#template-basics">Template Basics</a> - binding and local variables</p>
</li>
<li><p><a href="https://angular.io/docs/ts/latest/cookbook/a1-a2-quick-reference.html#template-directives">Template Directives</a> - built-in directives <code>ngIf</code> and <code>ngClass</code></p>
</li>
<li><p><a href="https://angular.io/docs/ts/latest/cookbook/a1-a2-quick-reference.html#filters-pipes">Filters/Pipes</a> - built-in <em>filters</em>, known as <em>pipes</em> in Angular&#xA0;2</p>
</li>
<li><p><a href="https://angular.io/docs/ts/latest/cookbook/a1-a2-quick-reference.html#controllers-components">Modules/Controllers/Components</a> - <em>modules</em> are <em>modules</em> but different 
and <em>controllers</em> are <em>components</em> in Angular&#xA0;2.</p>
</li>
<li><p><a href="https://angular.io/docs/ts/latest/cookbook/a1-a2-quick-reference.html#style-sheets">Style Sheets</a> - more options for CSS in  Angular&#xA0;2.</p>
</li>
</ul><span>
</span><h2 id="template-basics">Template Basics</h2><span>
</span><p>Templates are the user-facing part of an Angular application and are written in HTML.
The following are some of the key Angular&#xA0;1 template features with the equivalent
template syntax in Angular&#xA0;2.</p><span>
</span><table width="100%"><colgroup><col width="50%"><col width="50%"></colgroup><tbody><tr><th>Angular&#xA0;1</th><th>Angular&#xA0;2</th></tr><tr><td><h3 id="bindings-interpolation">Bindings/Interpolation</h3>
<code>Your favorite hero is: {{vm.favoriteHero}}</code><p>In Angular&#xA0;1, an expression in curly braces denotes one-way binding.
This binds the value of the element to a property in the controller
associated with this template.</p>
<p>When using the <code>controller as</code> syntax,
the binding is prefixed with the controller alias (<code>vm</code> or <code>$ctrl</code>) because we
have to be specific about the source of the binding.</p>
</td><td><h3 id="bindings-interpolation">Bindings/Interpolation</h3>
<code language="html" format="">Your favorite hero is: {{favoriteHero}}
</code><p>In Angular&#xA0;2, a template expression in curly braces still denotes one-way binding.
This binds the value of the element to a property of the component.
The context of the binding is implied and is always the
associated component, so it needs no reference variable.</p>
<p>For more information see <a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#interpolation">Template Syntax</a>.</p>
</td></tr><tr><td><h3 id="filters">Filters</h3>
<code>&lt;td&gt;{{movie.title | uppercase}}&lt;/td&gt;</code><p>To filter output in our templates in Angular&#xA0;1, we use the pipe character (|) and one or more filters.</p>
<p>In this example, we filter the <code>title</code> property to uppercase.</p>
</td><td><h3 id="pipes">Pipes</h3>
<code language="html" format="">&lt;td&gt;{{movie.title | uppercase}}&lt;/td&gt;
</code><p>In Angular&#xA0;2, we use similar syntax with the pipe (|) character to filter output, but now we call them <strong>pipes</strong>.
Many (but not all) of the built-in filters from Angular&#xA0;1 are
built-in pipes in Angular&#xA0;2.</p>
<p>See the heading <a href="https://angular.io/docs/ts/latest/cookbook/a1-a2-quick-reference.html#Pipes">Filters / Pipes</a> below for more information.</p>
</td></tr><tr><td><h3 id="local-variables">Local variables</h3>
<code format="">&lt;tr ng-repeat=&quot;movie in vm.movies&quot;&gt;
  &lt;td&gt;{{movie.title}}&lt;/td&gt;
&lt;/tr&gt;</code><p>Here, <code>movie</code> is a user-defined local variable.</p>
</td><td><h3 id="input-variables">Input variables</h3>
<code language="html" format="">&lt;tr *ngFor=&quot;let movie of movies&quot;&gt;
  &lt;td&gt;{{movie.title}}&lt;/td&gt;
&lt;/tr&gt;
</code><p>In Angular&#xA0;2, we have true template input variables that are explicitly defined using the <code>let</code> keyword.</p>
<p>For more information see <a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#ngForMicrosyntax">ngFor micro-syntax</a>.</p>
</td></tr></tbody></table><p><a href="https://angular.io/docs/ts/latest/cookbook/a1-a2-quick-reference.html#top">Back to top</a></p><span>
</span><h2 id="template-directives">Template Directives</h2><span>
</span><p>Angular&#xA0;1 provides over seventy built-in directives for use in our templates.
Many of them are no longer needed in Angular&#xA0;2 because of its more capable and expressive binding system.
The following are some of the key Angular&#xA0;1 built-in directives and the equivalent feature in Angular&#xA0;2.</p><span>
</span><table width="100%"><colgroup><col width="50%"><col width="50%"></colgroup><tbody><tr><th>Angular&#xA0;1</th><th>Angular&#xA0;2</th></tr><tr><td><h3 id="ng-app">ng-app</h3>
<code>&lt;body ng-app=&quot;movieHunter&quot;&gt;</code><p>The application startup process is called <strong>bootstrapping</strong>.</p>
<p>Although we can bootstrap an Angular&#xA0;1 app in code,
many applications bootstrap declaratively with the <code>ng-app</code> directive,
giving it the name of the application&apos;s module (<code>movieHunter</code>).</p>
</td><td><h3 id="bootstrapping">Bootstrapping</h3>
<p>main.ts</p><code language="ts" format="">import { platformBrowserDynamic } from &apos;@angular/platform-browser-dynamic&apos;;
import { AppModule } from &apos;./app.module&apos;;

platformBrowserDynamic().bootstrapModule(AppModule);
</code><p>app.module.ts</p><code language="ts" format="">import { NgModule }      from &apos;@angular/core&apos;;
import { BrowserModule } from &apos;@angular/platform-browser&apos;;

import { AppComponent }  from &apos;./app.component&apos;;

@NgModule({
  imports: [ BrowserModule ],
  declarations: [ AppComponent ],
  bootstrap: [ AppComponent ]
})
export class AppModule { }
</code><p>Angular&#xA0;2 does not have a bootstrap directive.
We always launch the app in code by explicitly bootstrapping the application&apos;s root module (<code>AppModule</code>)
in <code>main.ts</code>
and the application&apos;s root component (<code>AppComponent</code>) in <code>app.module.ts</code>.</p>
<p>For more information see <a href="https://angular.io/docs/ts/latest/quickstart.html">Quick Start</a>.</p>
</td></tr><tr><td><h3 id="ng-class">ng-class</h3>
<code format="">&lt;div ng-class=&quot;{active: isActive}&quot;&gt;
&lt;div ng-class=&quot;{active: isActive,
                   shazam: isImportant}&quot;&gt;</code><p>In Angular&#xA0;1, the <code>ng-class</code> directive includes/excludes CSS classes
based on an expression. That expression is often a key-value control object with each
key of the object defined as a CSS class name, and each value defined as a template expression
that evaluates to a Boolean value.</p>
<p>In the first example, the <code>active</code> class is applied to the element if <code>isActive</code> is true.</p>
<p>We can specify multiple classes as shown in the second example.</p>
</td><td><h3 id="ngclass">ngClass</h3>
<code language="html" format="">&lt;div [ngClass]=&quot;{active: isActive}&quot;&gt;
&lt;div [ngClass]=&quot;{active: isActive,
                 shazam: isImportant}&quot;&gt;
&lt;div [class.active]=&quot;isActive&quot;&gt;
</code><p>In Angular&#xA0;2, the <code>ngClass</code> directive works similarly.
It includes/excludes CSS classes based on an expression.</p>
<p>In the first example, the <code>active</code> class is applied to the element if <code>isActive</code> is true.</p>
<p>We can specify multiple classes as shown in the second example.</p>
<p>Angular&#xA0;2 also has <strong>class binding</strong>, which is a good way to add or remove a single class
as shown in the third example.</p>
<p>For more information see <a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#other-bindings">Template Syntax</a>.</p>
</td></tr><tr><td><h3 id="ng-click">ng-click</h3>
<code format="">&lt;button ng-click=&quot;vm.toggleImage()&quot;&gt;
&lt;button ng-click=&quot;vm.toggleImage($event)&quot;&gt;</code><p>In Angular&#xA0;1, the <code>ng-click</code> directive allows us to specify custom behavior when an element is clicked.</p>
<p>In the first example, when the button is clicked, the <code>toggleImage()</code> method in the controller referenced by the <code>vm</code> <code>controller as</code> alias is executed.</p>
<p>The second example demonstrates passing in the <code>$event</code> object, which provides details about the event
to the controller.</p>
</td><td><h3 id="bind-to-the-click-event">bind to the <code>click</code> event</h3>
<code language="html" format="">&lt;button (click)=&quot;toggleImage()&quot;&gt;
&lt;button (click)=&quot;toggleImage($event)&quot;&gt;
</code><p>The Angular&#xA0;1 event-based directives do not exist in Angular&#xA0;2.
Rather, we define one-way binding from the template view to the component using <strong>event binding</strong>.</p>
<p>For event binding, we define the name of the target event within parenthesis and
specify a template statement in quotes to the right of the equals. Angular&#xA0;2 then
sets up an event handler for the target event. When the event is raised, the handler
executes the template statement.</p>
<p>In the first example, when the button is clicked, the <code>toggleImage()</code> method in the associated component is executed.</p>
<p>The second example demonstrates passing in the <code>$event</code> object, which provides details about the event
to the component.</p>
<p>For a list of DOM events, see: <a href="https://developer.mozilla.org/en-US/docs/Web/Events">https://developer.mozilla.org/en-US/docs/Web/Events</a>.</p>
<p>For more information see <a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#event-binding">Template Syntax</a>.</p>
</td></tr><tr><td><h3 id="ng-controller">ng-controller</h3>
<code format="">&lt;div ng-controller=&quot;MovieListCtrl as vm&quot;&gt;</code><p>In Angular&#xA0;1, the <code>ng-controller</code> directive attaches a controller to the view.
Using the <code>ng-controller</code> (or defining the controller as part of the routing) ties the
view to the controller code associated with that view.</p>
</td><td><h3 id="component-decorator">Component decorator</h3>
<code language="ts" format="">@Component({
  selector: &apos;movie-list&apos;,
  templateUrl: &apos;app/movie-list.component.html&apos;,
  styleUrls: [&apos;app/movie-list.component.css&apos;],
})
</code><p>In Angular&#xA0;2, the template no longer specifies its associated controller.
Rather, the component specifies its associated template as part of the component class decorator.</p>
<p>For more information see <a href="https://angular.io/docs/ts/latest/guide/architecture.html#component">Architecture Overview</a>.</p>
</td></tr><tr><td><h3 id="ng-hide">ng-hide</h3>
<p>In Angular&#xA0;1, the <code>ng-hide</code> directive shows or hides the associated HTML element based on
an expression. See <a href="https://angular.io/docs/ts/latest/cookbook/a1-a2-quick-reference.html#ng-show">ng-show</a> for more information.</p>
</td><td><h3 id="bind-to-the-hidden-property">bind to the <code>hidden</code> property</h3>
<p>In Angular&#xA0;2, we use property binding; there is no built-in <em>hide</em> directive.
See <a href="https://angular.io/docs/ts/latest/cookbook/a1-a2-quick-reference.html#ng-show">ng-show</a> for more information.</p>
</td></tr><tr><td><h3 id="ng-href">ng-href</h3>
<code format="">&lt;a ng-href=&quot;angularDocsUrl&quot;&gt;Angular Docs&lt;/a&gt;</code><p>The <code>ng-href</code> directive allows Angular&#xA0;1 to preprocess the <code>href</code> property so it
can replace the binding expression with the appropriate URL before the browser
fetches from that URL.</p>
<p>In Angular&#xA0;1, the <code>ng-href</code> is often used to activate a route as part of navigation.</p>
<code format="">&lt;a ng-href=&quot;#movies&quot;&gt;Movies&lt;/a&gt;</code><p>Routing is handled differently in Angular&#xA0;2.</p>
</td><td><h3 id="bind-to-the-href-property">bind to the <code>href</code> property</h3>
<code language="html" format="">&lt;a [href]=&quot;angularDocsUrl&quot;&gt;Angular Docs&lt;/a&gt;
</code><p>In Angular&#xA0;2, we use property binding; there is no built-in <em>href</em> directive.
We place the element&apos;s <code>href</code> property in square brackets and set it to a quoted template expression.</p>
<p>For more information on property binding see <a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#property-binding">Template Syntax</a>.</p>
<p>In Angular&#xA0;2, <code>href</code> is no longer used for routing. Routing uses <code>routerLink</code> as shown in the third example.</p>
<code language="html" format="">&lt;a [routerLink]=&quot;[&apos;/movies&apos;]&quot;&gt;Movies&lt;/a&gt;
</code><p>For more information on routing see <a href="https://angular.io/docs/ts/latest/guide/router.html#router-link">Routing &amp; Navigation</a>.</p>
</td></tr><tr><td><h3 id="ng-if">ng-if</h3>
<code format="">&lt;table ng-if=&quot;movies.length&quot;&gt;</code><p>In Angular&#xA0;1, the <code>ng-if</code> directive removes or recreates a portion of the DOM
based on an expression. If the expression is false, the element is removed from the DOM.</p>
<p>In this example, the <code>table</code> element is removed from the DOM unless the <code>movies</code> array has a length greater than zero.</p>
</td><td><h3 id="-ngif">*ngIf</h3>
<code language="html" format="">&lt;table *ngIf=&quot;movies.length&quot;&gt;
</code><p>The <code>*ngIf</code> directive in Angular&#xA0;2 works the same as the <code>ng-if</code> directive in Angular&#xA0;1,
it removes or recreates a portion of the DOM based on an expression.</p>
<p>In this example, the <code>table</code> element is removed from the DOM unless the <code>movies</code> array has a length.</p>
<p>The (*) before <code>ngIf</code> is required in this example.
For more information see <a href="https://angular.io/docs/ts/latest/guide/structural-directives.html">Structural Directives</a>.</p>
</td></tr><tr><td><h3 id="ng-model">ng-model</h3>
<code format="">&lt;input ng-model=&quot;vm.favoriteHero&quot;/&gt;</code><p>In Angular&#xA0;1, the <code>ng-model</code> directive binds a form control to a property in the controller associated with the template.
This provides <strong>two-way binding</strong> whereby any changes made to the value in the view is synchronized with the model and
any changes to the model are synchronized with the value in the view.</p>
</td><td><h3 id="ngmodel">ngModel</h3>
<code language="html" format="">&lt;input [(ngModel)]=&quot;favoriteHero&quot; /&gt;
</code><p>In Angular&#xA0;2, <strong>two-way binding</strong> is denoted with [()], descriptively referred to as a &quot;banana in a box&quot;.
This syntax is a short-cut for defining both property binding (from the component to the view)
and event binding (from the view to the component), thereby giving us two-way binding.</p>
<p>For more information on two-way binding with ngModel see <a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#ngModel">Template Syntax</a>.</p>
</td></tr><tr><td><h3 id="ng-repeat">ng-repeat</h3>
<code format="">&lt;tr ng-repeat=&quot;movie in vm.movies&quot;&gt;</code><p>In Angular&#xA0;1, the <code>ng-repeat</code> directive repeats the associated DOM element
for each item from the specified collection.</p>
<p>In this example, the table row (<code>tr</code>) element is repeated for each movie object in the collection of movies.</p>
</td><td><h3 id="-ngfor">*ngFor</h3>
<code language="html" format="">&lt;tr *ngFor=&quot;let movie of movies&quot;&gt;
</code><p>The <code>*ngFor</code> directive in Angular&#xA0;2 is similar to the <code>ng-repeat</code> directive in Angular&#xA0;1.
It repeats the associated DOM element for each item from the specified collection.
More accurately, it turns the defined element (<code>tr</code> in this example) and its contents into a template and
uses that template to instantiate a view for each item in the list.</p>
<p>Notice the other syntax differences:
The (*) before <code>ngFor</code> is required;
the <code>let</code> keyword identifies <code>movie</code> as an input variable;
the list preposition is <code>of</code>, not <code>in</code>.</p>
<p>For more information see <a href="https://angular.io/docs/ts/latest/guide/structural-directives.html">Structural Directives</a>.</p>
</td></tr><tr><td><h3 id="ng-show">ng-show</h3>
<code format="">&lt;h3 ng-show=&quot;vm.favoriteHero&quot;&gt;
  Your favorite hero is: {{vm.favoriteHero}}
&lt;/h3&gt;</code><p>In Angular&#xA0;1, the <code>ng-show</code> directive shows or hides the associated DOM element based on
an expression.</p>
<p>In this example, the <code>div</code> element is shown if the <code>favoriteHero</code> variable is truthy.</p>
</td><td><h3 id="bind-to-the-hidden-property">bind to the <code>hidden</code> property</h3>
<code language="html" format="">&lt;h3 [hidden]=&quot;!favoriteHero&quot;&gt;
  Your favorite hero is: {{favoriteHero}}
&lt;/h3&gt;
</code><p>In Angular&#xA0;2, we use property binding; there is no built-in <em>show</em> directive.
For hiding and showing elements, we bind to the HTML <code>hidden</code> property.</p>
<p>To conditionally display an element, place the element&apos;s <code>hidden</code> property in square brackets and
set it to a quoted template expression that evaluates to the <em>opposite</em> of <em>show</em>.</p>
<p>In this example, the <code>div</code> element is hidden if the <code>favoriteHero</code> variable is not truthy.</p>
<p>For more information on property binding see <a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#property-binding">Template Syntax</a>.</p>
</td></tr><tr><td><h3 id="ng-src">ng-src</h3>
<code format="">&lt;img ng-src=&quot;{{movie.imageurl}}&quot;&gt;</code><p>The <code>ng-src</code> directive allows Angular&#xA0;1 to preprocess the <code>src</code> property so it
can replace the binding expression with the appropriate URL before the browser
fetches from that URL.</p>
</td><td><h3 id="bind-to-the-src-property">bind to the <code>src</code> property</h3>
<code language="html" format="">&lt;img [src]=&quot;movie.imageurl&quot;&gt;
</code><p>In Angular&#xA0;2, we use property binding; there is no built-in <em>src</em> directive.
We place the <code>src</code> property in square brackets and set it to a quoted template expression.</p>
<p>For more information on property binding see <a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#property-binding">Template Syntax</a>.</p>
</td></tr><tr><td><h3 id="ng-style">ng-style</h3>
<code format="">&lt;div ng-style=&quot;{color: colorPreference}&quot;&gt;</code><p>In Angular&#xA0;1, the <code>ng-style</code> directive sets a CSS style on an HTML element
based on an expression. That expression is often a key-value control object with each
key of the object defined as a CSS style name, and each value defined as an expression
that evaluates to a value appropriate for the style.</p>
<p>In the example, the <code>color</code> style is set to the current value of the <code>colorPreference</code> variable.</p>
</td><td><h3 id="ngstyle">ngStyle</h3>
<code language="html" format="">&lt;div [ngStyle]=&quot;{color: colorPreference}&quot;&gt;
&lt;div [style.color]=&quot;colorPreference&quot;&gt;
</code><p>In Angular&#xA0;2, the <code>ngStyle</code> directive works similarly. It sets a CSS style on an HTML element based on an expression.</p>
<p>In the first example, the <code>color</code> style is set to the current value of the <code>colorPreference</code> variable.</p>
<p>Angular&#xA0;2 also has <strong>style binding</strong>, which is good way to set a single style. This is shown in the second example.</p>
<p>For more information on style binding see <a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#style-binding">Template Syntax</a>.</p>
<p>For more information on the ngStyle directive see <a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#ngStyle">Template Syntax</a>.</p>
</td></tr><tr><td><h3 id="ng-switch">ng-switch</h3>
<code format="">&lt;div ng-switch=&quot;vm.favoriteHero &amp;&amp;
                vm.checkMovieHero(vm.favoriteHero)&quot;&gt;
    &lt;div ng-switch-when=&quot;true&quot;&gt;
      Excellent choice!
    &lt;/div&gt;
    &lt;div ng-switch-when=&quot;false&quot;&gt;
      No movie, sorry!
    &lt;/div&gt;
    &lt;div ng-switch-default&gt;
      Please enter your favorite hero.
    &lt;/div&gt;
&lt;/div&gt;</code><p>In Angular&#xA0;1, the <code>ng-switch</code> directive swaps the contents of
an element by selecting one of the templates based on the current value of an expression.</p>
<p>In this example, if <code>favoriteHero</code> is not set, the template displays &quot;Please enter ...&quot;.
If the <code>favoriteHero</code> is set, it checks the movie hero by calling a controller method.
If that method returns <code>true</code>, the template displays &quot;Excellent choice!&quot;.
If that methods returns <code>false</code>, the template displays &quot;No movie, sorry!&quot;.</p>
</td><td><h3 id="ngswitch">ngSwitch</h3>
<code language="html" format="">&lt;span [ngSwitch]=&quot;favoriteHero &amp;&amp;
               checkMovieHero(favoriteHero)&quot;&gt;
  &lt;p *ngSwitchCase=&quot;true&quot;&gt;
    Excellent choice!
  &lt;/p&gt;
  &lt;p *ngSwitchCase=&quot;false&quot;&gt;
    No movie, sorry!
  &lt;/p&gt;
  &lt;p *ngSwitchDefault&gt;
    Please enter your favorite hero.
  &lt;/p&gt;
&lt;/span&gt;
</code><p>In Angular&#xA0;2, the <code>ngSwitch</code> directive works similarly.
It displays an element whose <code>*ngSwitchCase</code> matches the current <code>ngSwitch</code> expression value.</p>
<p>In this example, if <code>favoriteHero</code> is not set, the <code>ngSwitch</code> value is <code>null</code>
and we see the <code>*ngSwitchDefault</code> paragraph, &quot;Please enter ...&quot;.
If the <code>favoriteHero</code> is set, it checks the movie hero by calling a component method.
If that method returns <code>true</code>, we see &quot;Excellent choice!&quot;.
If that methods returns <code>false</code>, we see &quot;No movie, sorry!&quot;.</p>
<p>The (*) before <code>ngSwitchCase</code> and <code>ngSwitchDefault</code> is required in this example.</p>
<p>For more information on the ngSwitch directive see <a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#ngSwitch">Template Syntax</a>.</p>
</td></tr></tbody></table><p><a href="https://angular.io/docs/ts/latest/cookbook/a1-a2-quick-reference.html#top">Back to top</a></p><span>
</span><a id="filters-pipes"></a><h2 id="filters-pipes">Filters / Pipes</h2><span>
</span><p>Angular&#xA0;2 <strong>pipes</strong> provide formatting and transformation for data in our template, similar to Angular&#xA0;1 <strong>filters</strong>.
Many of the built-in filters in Angular&#xA0;1 have corresponding pipes in Angular&#xA0;2.
For more information on pipes see <a href="https://angular.io/docs/ts/latest/guide/pipes.html">Pipes</a>.</p><span>
</span><table width="100%"><colgroup><col width="50%"><col width="50%"></colgroup><tbody><tr><th>Angular&#xA0;1</th><th>Angular&#xA0;2</th></tr><tr><td><h3 id="currency">currency</h3>
<code>&lt;td&gt;{{movie.price | currency}}&lt;/td&gt;</code><p>Formats a number as a currency.</p>
</td><td><h3 id="currency">currency</h3>
<code language="html" format="">&lt;td&gt;{{movie.price | currency:&apos;USD&apos;:true}}&lt;/td&gt;
</code><p>The Angular&#xA0;2 <code>currency</code> pipe is similar although some of the parameters have changed.</p>
</td></tr><tr><td><h3 id="date">date</h3>
<code>&lt;td&gt;{{movie.releaseDate  | date}}&lt;/td&gt;</code><p>Formats a date to a string based on the requested format.</p>
</td><td><h3 id="date">date</h3>
<code language="html" format="">&lt;td&gt;{{movie.releaseDate | date}}&lt;/td&gt;
</code><p>The Angular&#xA0;2 <code>date</code> pipe is similar.</p>
</td></tr><tr><td><h3 id="filter">filter</h3>
<code>&lt;tr ng-repeat=&quot;movie in movieList | filter: {title:listFilter}&quot;&gt;</code><p>Selects a subset of items from the defined collection based on the filter criteria.</p>
</td><td><h3 id="none">none</h3>
<p>There is no comparable pipe in Angular&#xA0;2 for performance reasons.
Filtering should be coded in the component.
Consider building a custom pipe if the same filtering code
will be reused in several templates.</p>
</td></tr><tr><td><h3 id="json">json</h3>
<code>&lt;pre&gt;{{movie | json}}&lt;/pre&gt;</code><p>Converts a JavaScript object into a JSON string. This is useful for debugging.</p>
</td><td><h3 id="json">json</h3>
<code language="html" format="">&lt;pre&gt;{{movie | json}}&lt;/pre&gt;
</code><p>The Angular&#xA0;2 <code>json</code> pipe does the same thing.</p>
</td></tr><tr><td><h3 id="limitto">limitTo</h3>
<code>&lt;tr ng-repeat=&quot;movie in movieList | limitTo:2:0&quot;&gt;</code><p>Selects up to the first parameter (2) number of items from the collection
starting (optionally) at the beginning index (0).</p>
</td><td><h3 id="slice">slice</h3>
<code language="html" format="">&lt;tr *ngFor=&quot;let movie of movies | slice:0:2&quot;&gt;
</code><p>The <code>SlicePipe</code> does the same thing but the <em>order of the parameters is reversed</em> in keeping
with the JavaScript <code>Slice</code> method.
The first parameter is the starting index; the second is the limit.
As in Angular 1, performance may improve if we code this operation within the component instead.</p>
</td></tr><tr><td><h3 id="lowercase">lowercase</h3>
<code>&lt;div&gt;{{movie.title | lowercase}}&lt;/div&gt;</code><p>Converts the string to lowercase.</p>
</td><td><h3 id="lowercase">lowercase</h3>
<code language="html" format="">&lt;td&gt;{{movie.title | lowercase}}&lt;/td&gt;
</code><p>The Angular&#xA0;2 <code>lowercase</code> pipe does the same thing.</p>
</td></tr><tr><td><h3 id="number">number</h3>
<code>&lt;td&gt;{{movie.starRating  | number}}&lt;/td&gt;</code><p>Formats a number as text.</p>
</td><td><h3 id="number">number</h3>
<code language="html" format="">&lt;td&gt;{{movie.starRating | number}}&lt;/td&gt;
&lt;td&gt;{{movie.starRating | number:&apos;1.1-2&apos;}}&lt;/td&gt;
&lt;td&gt;{{movie.approvalRating | percent: &apos;1.0-2&apos;}}&lt;/td&gt;
</code><p>The Angular&#xA0;2 <code>number</code> pipe is similar.
It provides more functionality when defining
the decimal places as shown in the second example above.</p>
<p>Angular 2 also has a <code>percent</code> pipe which formats a number as a local percentage
as shown in the third example.</p>
</td></tr><tr><td><h3 id="orderby">orderBy</h3>
<code>&lt;tr ng-repeat=&quot;movie in movieList | orderBy : &apos;title&apos;&quot;&gt;</code><p>Orders the collection as specified by the expression.
In this example, the movieList is ordered by the movie title.</p>
</td><td><h3 id="none">none</h3>
<p>There is no comparable pipe in Angular&#xA0;2 for performance reasons.
Ordering/sorting the results should be coded in the component.
Consider building a custom pipe if the same ordering/sorting code
will be reused in several templates.</p>
</td></tr></tbody></table><p><a href="https://angular.io/docs/ts/latest/cookbook/a1-a2-quick-reference.html#top">Back to top</a></p><span>
</span><a id="controllers-components"></a><h2 id="modules-controllers-components">Modules / Controllers / Components</h2><span>
</span><p>In both Angular&#xA0;1 and Angular&#xA0;2, we use Angular modules to
help us organize our application into cohesive blocks of functionality.</p><span>
</span><p>In Angular&#xA0;1, we write the code that provides the model and the methods for the view in a <strong>controller</strong>.
In Angular&#xA0;2, we build a <strong>component</strong>.</p><span>
</span><p>Because much of our Angular&#xA0;1 code is in JavaScript, JavaScript code is shown in the Angular&#xA0;1 column.
The Angular&#xA0;2 code is shown using TypeScript.</p><span>
</span><table width="100%"><colgroup><col width="50%"><col width="50%"></colgroup><tbody><tr><th>Angular&#xA0;1</th><th>Angular&#xA0;2</th></tr><tr><td><h3 id="iife">IIFE</h3>
<code>(function () {
  ...
}());</code><p>In Angular&#xA0;1, we often defined an immediately invoked function expression (or IIFE) around our controller code.
This kept our controller code out of the global namespace.</p>
</td><td><h3 id="none">none</h3>
<p>We don&apos;t need to worry about this in Angular&#xA0;2 because we use ES 2015 modules
and modules handle the namespacing for us.</p>
<p>For more information on modules see <a href="https://angular.io/docs/ts/latest/guide/architecture.html#module">Architecture Overview</a>.</p>
</td></tr><tr><td><h3 id="angular-modules">Angular modules</h3>
<code>angular.module(&quot;movieHunter&quot;, [&quot;ngRoute&quot;]);</code><p>In Angular&#xA0;1, we define an Angular module, which keeps track of our
controllers, services, and other code. The second argument defines the list
of other modules that this module depends upon.</p>
</td><td><h3 id="angular-modules">Angular modules</h3>
<code language="ts" format="">import { NgModule }      from &apos;@angular/core&apos;;
import { BrowserModule } from &apos;@angular/platform-browser&apos;;

import { AppComponent }  from &apos;./app.component&apos;;

@NgModule({
  imports: [ BrowserModule ],
  declarations: [ AppComponent ],
  bootstrap: [ AppComponent ]
})
export class AppModule { }
</code><p>Angular&#xA0;2 modules, defined with the <code>NgModule</code> decorator, serve the same purpose:</p>
<ul>
<li><code>imports</code>: specifies the list of other modules that this module depends upon</li>
<li><code>declaration</code>: keeps track of our components, pipes, and directives.</li>
</ul>
<p>For more information on modules see <a href="https://angular.io/docs/ts/latest/guide/ngmodule.html">Angular Modules</a>.</p>
</td></tr><tr><td><h3 id="controller-registration">Controller registration</h3>
<code>angular
  .module(&quot;movieHunter&quot;)
  .controller(&quot;MovieListCtrl&quot;,
              [&quot;movieService&quot;,
               MovieListCtrl]);</code><p>In Angular&#xA0;1, we have code in each controller that looks up an appropriate Angular module
and registers the controller with that module.</p>
<p>The first argument is the controller name. The second argument defines the string names of
all dependencies injected into this controller, and a reference to the controller function.</p>
</td><td><h3 id="component-decorator">Component Decorator</h3>
<code language="ts" format="">@Component({
  selector: &apos;movie-list&apos;,
  templateUrl: &apos;app/movie-list.component.html&apos;,
  styleUrls: [&apos;app/movie-list.component.css&apos;],
})
</code><p>In Angular&#xA0;2, we add a decorator to the component class to provide any required metadata.
The Component decorator declares that the class is a component and provides metadata about
that component, such as its selector (or tag) and its template.</p>
<p>This is how we associate a template with code, which is defined in the component class.</p>
<p>For more information on components see <a href="https://angular.io/docs/ts/latest/guide/architecture.html#component">Architecture Overview</a>.</p>
</td></tr><tr><td><h3 id="controller-function">Controller function</h3>
<code>function MovieListCtrl(movieService) {
}</code><p>In Angular&#xA0;1, we write the code for the model and methods in a controller function.</p>
</td><td><h3 id="component-class">Component class</h3>
<code language="ts" format="">export class MovieListComponent {
}
</code><p>In Angular&#xA0;2, we create a component class.</p>
<p>NOTE: If you are using TypeScript with Angular&#xA0;1 then the only difference here is
that the component class must be exported using the <code>export</code> keyword.</p>
<p>For more information on components see <a href="https://angular.io/docs/ts/latest/guide/architecture.html#component">Architecture Overview</a>.</p>
</td></tr><tr><td><h3 id="dependency-injection">Dependency injection</h3>
<code>MovieListCtrl.$inject = [&apos;MovieService&apos;];
function MovieListCtrl(movieService) {
}</code><p>In Angular&#xA0;1, we pass in any dependencies as controller function arguments.
In this example, we inject a <code>MovieService</code>.</p>
<p>We also guard against minification problems by telling Angular explicitly
that it should inject an instance of the <code>MovieService</code> in the first parameter.</p>
</td><td><h3 id="dependency-injection">Dependency injection</h3>
<code language="ts" format="">constructor(movieService: MovieService) {
}
</code><p>In Angular&#xA0;2, we pass in dependencies as arguments to the component class constructor.
In this example, we inject a <code>MovieService</code>.
The first parameter&apos;s TypeScript type tells Angular what to inject even after minification.</p>
<p>For more information on dependency injection see <a href="https://angular.io/docs/ts/latest/guide/architecture.html#dependency-injection">Architecture Overview</a>.</p>
</td></tr></tbody></table><p><a href="https://angular.io/docs/ts/latest/cookbook/a1-a2-quick-reference.html#top">Back to top</a></p><span>
</span><a id="style-sheets"></a><h2 id="style-sheets">Style Sheets</h2><span>
</span><p>Style sheets give our application a nice look.
In Angular&#xA0;1, we specify the style sheets for our entire application.
As the application grows over time, the styles for the many parts of the application
are merged, which can cause unexpected results.
In Angular&#xA0;2, we can still define style sheets for our entire application. But now we can
also encapculate a style sheet within a specific component.</p><span>
</span><table width="100%"><colgroup><col width="50%"><col width="50%"></colgroup><tbody><tr><th>Angular&#xA0;1</th><th>Angular&#xA0;2</th></tr><tr><td>
<code>&lt;link href=&quot;styles.css&quot; rel=&quot;stylesheet&quot; /&gt;</code><p>In Angular&#xA0;1, we use a <code>link</code> tag in the head section of our <code>index.html</code> file
to define the styles for our application.</p>
</td><td>
<code language="html" format="">&lt;link rel=&quot;stylesheet&quot; href=&quot;styles.css&quot;&gt;
</code><p>In Angular&#xA0;2, we can continue to use the link tag to define the styles for our application in the <code>index.html</code> file.
But we can now also encapsulate styles for our components.</p>
<h3 id="styleurls">StyleUrls</h3>
<p>In Angular&#xA0;2, we can use the <code>styles</code> or <code>styleUrls</code> property of the <code>@Component</code> metadata to define
a style sheet for a particular component.</p>
<code language="ts" format="">styleUrls: [&apos;app/movie-list.component.css&apos;],
</code><p>This allows us to set appropriate styles for individual components that won&#x2019;t leak into
other parts of the application.</p>
</td></tr></tbody></table><p><a href="https://angular.io/docs/ts/latest/cookbook/a1-a2-quick-reference.html#top">Back to top</a></p></div></div>
        </article>
      
        <article>
          <h3>Angular Module FAQs</h3>
          <div><div class="showcase-content"><span>
</span><p><strong>Angular Modules</strong> help organize an application into cohesive blocks of functionality.</p><span>
</span><p>The <a href="https://angular.io/docs/ts/latest/guide/ngmodule.html">Angular Modules chapter</a> covers the concepts and takes you step by step
from the most elementary <code>@NgModule</code> to a multi-faceted sample with lazy loaded modules.</p><span>
</span><p><em>This</em> chapter answers the questions many developers ask about Angular Module design and implementation.</p><span>
</span><div class="alert is-important"><p>These FAQs assume that you have already read the <a href="https://angular.io/docs/ts/latest/guide/ngmodule.html">Angular Module</a> chapter.</p><span>
</span></div><p>Declarations</p><span>
</span><ul>
<li><a href="https://angular.io/docs/ts/latest/cookbook/ngmodule-faq.html#q-what-to-declare">What classes should I add to <em>declarations</em>?</a></li>
<li><a href="https://angular.io/docs/ts/latest/cookbook/ngmodule-faq.html#q-declarable">What is a <em>declarable</em>?</a></li>
<li><a href="https://angular.io/docs/ts/latest/cookbook/ngmodule-faq.html#q-what-not-to-declare">What classes should I <em>not</em> add to <em>declarations</em>?</a></li>
<li><a href="https://angular.io/docs/ts/latest/cookbook/ngmodule-faq.html#q-why-multiple-mentions">Why list the same component in multiple <em>NgModule</em> properties?</a></li>
<li><a href="https://angular.io/docs/ts/latest/cookbook/ngmodule-faq.html#q-why-cant-bind-to">What does &quot;<em>Can&apos;t bind to &apos;x&apos; since it isn&apos;t a known property of &apos;y&apos;</em>&quot; mean?</a></li>
</ul><span>
</span><p>Imports</p><span>
</span><ul>
<li><a href="https://angular.io/docs/ts/latest/cookbook/ngmodule-faq.html#q-what-to-import">What should I import?</a></li>
<li><a href="https://angular.io/docs/ts/latest/cookbook/ngmodule-faq.html#q-browser-vs-common-module">Should I import <em>BrowserModule</em> or <em>CommonModule</em>?</a></li>
<li><a href="https://angular.io/docs/ts/latest/cookbook/ngmodule-faq.html#q-reimport">What if I import the same module twice?</a></li>
</ul><span>
</span><p>Exports  </p><span>
</span><ul>
<li><a href="https://angular.io/docs/ts/latest/cookbook/ngmodule-faq.html#q-what-to-export">What should I export?</a></li>
<li><a href="https://angular.io/docs/ts/latest/cookbook/ngmodule-faq.html#q-what-not-to-export">What should I <em>not</em> export?</a></li>
<li><a href="https://angular.io/docs/ts/latest/cookbook/ngmodule-faq.html#q-re-export">Can I re-export imported classes and modules?</a></li>
<li><a href="https://angular.io/docs/ts/latest/cookbook/ngmodule-faq.html#q-for-root">What is the <em>forRoot</em> method?</a></li>
</ul><span>
</span><p>Service Providers  </p><span>
</span><ul>
<li><a href="https://angular.io/docs/ts/latest/cookbook/ngmodule-faq.html#q-module-provider-visibility">Why is a service provided in a feature module visible everywhere?</a></li>
<li><a href="https://angular.io/docs/ts/latest/cookbook/ngmodule-faq.html#q-lazy-loaded-module-provider-visibility">Why is a service provided in a <em>lazy loaded</em> module visible only to that module?</a> </li>
<li><a href="https://angular.io/docs/ts/latest/cookbook/ngmodule-faq.html#q-module-provider-duplicates">What if two modules provide the <em>same</em> service?</a></li>
<li><a href="https://angular.io/docs/ts/latest/cookbook/ngmodule-faq.html#q-component-scoped-providers">How do I restrict service scope to a module?</a></li>
<li><a href="https://angular.io/docs/ts/latest/cookbook/ngmodule-faq.html#q-root-component-or-module">Should I add providers to the root <em>AppModule</em> or the root <em>AppComponent</em>?</a></li>
<li><a href="https://angular.io/docs/ts/latest/cookbook/ngmodule-faq.html#q-why-bad">Why is it bad if <em>SharedModule</em> provides a service to a lazy loaded module?</a></li>
<li><a href="https://angular.io/docs/ts/latest/cookbook/ngmodule-faq.html#q-why-child-injector">Why does lazy loading create a child injector?</a>  </li>
<li><a href="https://angular.io/docs/ts/latest/cookbook/ngmodule-faq.html#q-is-it-loaded">How can I tell if a module or service was previously loaded?</a></li>
</ul><span>
</span><p>Entry Components</p><span>
</span><ul>
<li><a href="https://angular.io/docs/ts/latest/cookbook/ngmodule-faq.html#q-entry-component-defined">What is an <em>entry component</em>?</a></li>
<li><a href="https://angular.io/docs/ts/latest/cookbook/ngmodule-faq.html#q-bootstrap_vs_entry_component">What is the difference between a <em>bootstrap</em> component and an <em>entry component</em>?</a></li>
<li><a href="https://angular.io/docs/ts/latest/cookbook/ngmodule-faq.html#q-when-entry-components">When do I add components to <em>entryComponents</em>?</a></li>
<li><a href="https://angular.io/docs/ts/latest/cookbook/ngmodule-faq.html#q-why-entry-components">Why does Angular need <em>entryComponents</em>?</a></li>
</ul><span>
</span><p>General</p><span>
</span><ul>
<li><a href="https://angular.io/docs/ts/latest/cookbook/ngmodule-faq.html#q-module-recommendations">What kinds of modules should I have and how should I use them?</a></li>
<li><a href="https://angular.io/docs/ts/latest/cookbook/ngmodule-faq.html#q-ng-vs-js-modules">What&apos;s the difference between Angular and JavaScript Modules?</a></li>
<li><a href="https://angular.io/docs/ts/latest/cookbook/ngmodule-faq.html#q-template-reference">What is a &quot;template reference&quot;?</a></li>
<li><a href="https://angular.io/docs/ts/latest/cookbook/ngmodule-faq.html#q-template-reference">How does Angular find components, directives, and pipes in a template?</a>  </li>
<li><a href="https://angular.io/docs/ts/latest/cookbook/ngmodule-faq.html#q-angular-compiler">What is the Angular Compiler?</a></li>
<li><a href="https://angular.io/docs/ts/latest/cookbook/ngmodule-faq.html#q-ngmodule-api">Can you summarize the <em>NgModule</em> API?</a></li>
</ul><span>
</span><a id="q-what-to-declare"></a><h3 id="what-classes-should-i-add-to-_declarations_-">What classes should I add to <em>declarations</em>?</h3><span>
</span><p>Add <a href="https://angular.io/docs/ts/latest/cookbook/ngmodule-faq.html#q-declarable">declarable</a> classes &#x2014; components, directives, and pipes &#x2014; to a <code>declarations</code> list.</p><span>
</span><p>These classes must be declared in <em>exactly one</em> module of the application.
Declare them in <em>this</em> module if they <em>belong</em> to this module.</p><span>
</span><a id="q-declarable"></a><h3 id="what-is-a-_declarable_-">What is a <em>declarable</em>?</h3><span>
</span><p><em>Declarables</em> are the class types &#x2014; components, directives, and pipes &#x2014;
that you can add to a module&apos;s <code>declarations</code> list. 
They&apos;re the <em>only</em> classes that you can add to <code>declarations</code>.</p><span>
</span><a id="q-what-not-to-declare"></a><h3 id="what-classes-should-i-_not_-add-to-_declarations_-">What classes should I <em>not</em> add to <em>declarations</em>?</h3><span>
</span><p>Only <a href="https://angular.io/docs/ts/latest/cookbook/ngmodule-faq.html#q-declarable">declarable</a> classes can be added to a module&apos;s <code>declarations</code> list.</p><span>
</span><p>Do <em>not</em> declare </p><span>
</span><ul>
<li><p>a class that is already declared in another module, whether an app module, @angular module, or 3rd party module</p>
</li>
<li><p>an array of directives imported from another module. 
For example, do not declare FORMS_DIRECTIVES from <code>@angular/forms</code>.</p>
</li>
<li><p>module classes</p>
</li>
<li><p>service classes</p>
</li>
<li><p>non-Angular classes and objects such as 
strings, numbers, functions, entity models, configurations, business logic, and helper classes.</p>
</li>
</ul><span>
</span><a id="q-why-multiple-mentions"></a><h3 id="why-list-the-same-component-in-multiple-_ngmodule_-properties-">Why list the same component in multiple <em>NgModule</em> properties?</h3><span>
</span><p>We often see <code>AppComponent</code> listed in both <code>declarations</code> and <code>bootstrap</code>.
We might see <code>HeroComponent</code> listed in <code>declarations</code>, <code>exports</code>, and <code>entryComponents</code>.</p><span>
</span><p>That <em>feels</em> redundant but these properties have different functions 
and we can&apos;t infer that membership in one list implies membership in another list.</p><span>
</span><ul>
<li><code>AppComponent</code> could be declared in this module but not bootstrapped.</li>
<li><code>AppComponent</code> could be bootstrapped in this module but declared in a different feature module.</li>
<li><code>HeroComponent</code> could be imported from another app module (so we can&apos;t declare it) and re-exported by this module.</li>
<li><code>HeroComponent</code> could be exported for inclusion in an external component&apos;s template and also dynamically loaded in a pop-up dialog.</li>
</ul><span>
</span><a id="q-why-cant-bind-to"></a><h3 id="what-does-_can-t-bind-to-x-since-it-isn-t-a-known-property-of-y-_-mean-">What does &quot;<em>Can&apos;t bind to &apos;x&apos; since it isn&apos;t a known property of &apos;y&apos;</em>&quot; mean?</h3><span>
</span><p>This error usually means either that you neglected to declare the directive &quot;x&quot; 
or you haven&apos;t imported the module to which &quot;x&quot; belongs.</p><span>
</span><p>For example, if &quot;x&quot; is <code>ngModel</code>, you probably haven&apos;t imported the <code>FormsModule</code> from <code>@angular/forms</code>.</p><span>
</span><p>Perhaps you declared &quot;x&quot; in an application sub-module but forgot to export it? 
The &quot;x&quot; class won&apos;t be visible to other modules until you add it to the <code>exports</code> list.</p><span>
</span><a id="q-what-to-import"></a><h3 id="what-should-i-import-">What should I import?</h3><span>
</span><p>Import modules whose public (exported) <a href="https://angular.io/docs/ts/latest/cookbook/ngmodule-faq.html#q-declarable">declarable classes</a> 
you need to reference in this module&apos;s component templates.</p><span>
</span><p>This invariably means importing <code>CommonModule</code> from <code>@angular/common</code> for access to
the Angular directives such as <code>NgIf</code> and <code>NgFor</code>. 
You can import it directly or from another module that <a href="https://angular.io/docs/ts/latest/cookbook/ngmodule-faq.html#q-reexport">re-exports</a> it.</p><span>
</span><p>Import <code>FormsModule</code> from <code>@angular/forms</code> 
if your components have <code>[(ngModel)]</code> two-way binding expressions.</p><span>
</span><p>Import <em>shared</em> and <em>feature</em> modules when this module&apos;s components incorporate their
components, directives, and pipes.</p><span>
</span><p>Only <a href="https://angular.io/docs/ts/latest/cookbook/ngmodule-faq.html#q-browser-vs-common-module">import <em>BrowserModule</em></a> in the root <code>AppModule</code>.</p><span>
</span><a id="q-browser-vs-common-module"></a><h3 id="should-i-import-_browsermodule_-or-_commonmodule_-">Should I import <em>BrowserModule</em> or <em>CommonModule</em>?</h3><span>
</span><p>The <strong>root application module</strong> (<code>AppModule</code>) of almost every browser application
should import <code>BrowserModule</code> from <code>@angular/core</code>.</p><span>
</span><p><code>BrowserModule</code> provides services that are essential to launch and run a browser app.</p><span>
</span><p><code>BrowserModule</code> also re-exports <code>CommonModule</code> from <code>@angular/common</code>
which means that component in the <code>AppModule</code> module also have access to
the Angular directives every app needs such as <code>NgIf</code> and <code>NgFor</code>.</p><span>
</span><p><em>Do not import</em> <code>BrowserModule</code> in any other module.
<em>Feature modules</em> and <em>lazy loaded modules</em> should import <code>CommonModule</code> instead.
They need the common directives. They don&apos;t need to re-install the app-wide providers. </p><span>
</span><div class="l-sub-section"><p><code>BrowserModule</code> throws an error if you try to lazy load  a module that imports it.</p><span>
</span></div><p>Importing <code>CommonModule</code> also frees feature modules for use on <em>any</em> target platform, not just browsers,
a fact of some interest to authors of cross-platform libraries.</p><span>
</span><a id="q-reimport"></a><h3 id="what-if-i-import-the-same-module-twice-">What if I import the same module twice?</h3><span>
</span><p>That&apos;s not a problem. When three modules all import Module &apos;A&apos;, 
Angular evaluates Module &apos;A&apos; once, the first time it encounters it, and does not do so again. </p><span>
</span><p>That&apos;s true at whatever level <code>A</code> appears in a hierarchy of imported modules.
When Module &apos;B&apos; imports Module &apos;A&apos;, Module &apos;C&apos; imports &apos;B&apos;, and Module &apos;D&apos; imports <code>[C, B, A]</code>,
then &apos;D&apos; triggers the evaluation of &apos;C&apos; which triggers the evaluation of &apos;B&apos; which evaluates &apos;A&apos;.
When Angular gets to the &apos;B&apos; and &apos;A&apos; in &apos;D&apos;, they&apos;re already cached and ready to go.</p><span>
</span><p>Angular does not like modules with circular references so don&apos;t let Module &apos;A&apos; import Module &apos;B&apos; which imports Module &apos;A&apos;.</p><span>
</span><a id="q-what-to-export"></a><h3 id="what-should-i-export-">What should I export?</h3><span>
</span><p>Export <a href="https://angular.io/docs/ts/latest/cookbook/ngmodule-faq.html#q-declarable">declarable</a> classes that components in <em>other</em> modules
should be able to reference in their templates. These are your <em>public</em> classes.
If you don&apos;t export a class, it stays <em>private</em>, visible only to other component
declared in this module.</p><span>
</span><p>You <em>can</em> export any declarable class &#x2014; components, directives, and pipes &#x2014; 
whether it is declared in this module or in an imported module.</p><span>
</span><p>You <em>can</em> re-export entire imported modules which effectively re-exports all of their exported classes.
A module can even export a module that it doesn&apos;t import. </p><span>
</span><a id="q-what-not-to-export"></a><h3 id="what-should-i-not-export-">What should I <em>not</em> export?</h3><span>
</span><p>Do <em>not</em> export</p><span>
</span><ul>
<li><p>Private components, directives, and pipes that you need only within components declared in this module.
If you don&apos;t want another module to see it, don&apos;t export it.</p>
</li>
<li><p>Non-declarable objects such as services, functions, configurations, entity models, etc.</p>
</li>
<li><p>Components that are only loaded dynamically by the router or by bootstrapping.
Such <a href="https://angular.io/docs/ts/latest/cookbook/ngmodule-faq.html#q-entry-component-defined">entry components</a> can never be selected in another component&apos;s template.
There&apos;s no harm in exporting them but no benefit either. </p>
</li>
<li><p>Pure service modules that don&apos;t have public (exported) declarations. 
For example, there is no point in re-exporting <code>HttpModule</code> because it doesn&apos;t export anything.
It&apos;s only purpose is to add http service providers to the application as a whole.</p>
</li>
</ul><span>
</span><a id="q-reexport"></a><a id="q-re-export"></a><h3 id="can-i-re-export-classes-and-modules-">Can I re-export classes and modules?</h3><span>
</span><p>Absolutely!</p><span>
</span><p>Modules are a great way to selectively aggregate classes from other modules and
re-export them in a consolidated, convenience module.</p><span>
</span><p>A module can re-export entire modules which effectively re-exports all of their exported classes.
Angular&apos;s own <code>BrowserModule</code> exports a couple of modules like this:</p><span>
</span><code>exports: [CommonModule, ApplicationModule]
</code><p>A module can export a combination of its own declarations, selected imported classes, and imported modules.</p><span>
</span><div class="l-sub-section"><p>Don&apos;t bother re-exporting pure service modules.
Pure service modules don&apos;t export <a href="https://angular.io/docs/ts/latest/cookbook/ngmodule-faq.html#q-declarable">declarable</a> classes that another module could use.
For example, there is no point in re-exporting <code>HttpModule</code> because it doesn&apos;t export anything.
It&apos;s only purpose is to add http service providers to the application as a whole.</p><span>
</span></div><a id="q-for-root"></a><h3 id="what-is-the-_forroot_-method-">What is the <em>forRoot</em> method?</h3><span>
</span><p>The <code>forRoot</code> static method is a convention that makes it easy for developers to configure the module&apos;s provider(s).</p><span>
</span><p>The <code>RouterModule.forRoot</code> method is a good example. 
Apps pass a <code>Routes</code> object to <code>RouterModule.forRoot</code> in order to configure the app-wide <code>Router</code> service with routes. 
<code>RouterModule.forRoot</code> returns a <a href="https://angular.io/docs/ts/latest/api/core/index/ModuleWithProviders-interface.html">ModuleWithProviders</a>. 
We add that result to the <code>imports</code> list of the root <code>AppModule</code>.</p><span>
</span><div class="alert is-important"><p>Only call and import a <code>.forRoot</code> result in the root application module, <code>AppModule</code>.
Importing it in any other module, particularly in a lazy loaded module,
is contrary to the intent and is likely to produce a runtime error.</p><span>
</span></div><p><code>RouterModule</code> also offers a <code>forChild</code> static method for configuring the routes of lazy loaded modules.</p><span>
</span><p><strong><em>forRoot</em></strong> and <strong><em>forChild</em></strong> are conventional names for methods that
configure services in root and feature modules respectively.</p><span>
</span><p>Angular doesn&apos;t recognize these names but Angular developers do.
Follow this convention when you write similar modules with configurable service providers.</p><span>
</span><a id="q-module-provider-visibility"></a><h3 id="why-is-a-service-provided-in-a-feature-module-visible-everywhere-">Why is a service provided in a feature module visible everywhere?</h3><span>
</span><p>Providers listed in the <code>@NgModule.providers</code> of a bootstrapped module have <strong>application scope</strong>.
Adding a service provider to <code>@NgModule.providers</code> effectively publishes the service to the entire application.</p><span>
</span><p>When we import a module,
Angular adds the module&apos;s service providers (the contents of its <code>providers</code> list)
to the application <em>root injector</em>.</p><span>
</span><p>This makes the provider visible to every class in the application that knows the provider&apos;s lookup token.</p><span>
</span><p>This is by design. 
Extensibility through module imports is a primary goal of the Angular module system.
Merging module providers into the application injector
makes it easy for a module library to enrich the entire application with new services.
By adding the <code>HttpModule</code> once, every application component can make http requests. </p><span>
</span><p>However, this can feel like an unwelcome surprise if you are expecting the module&apos;s services 
to be visible only to the components declared by that feature module.
If the <code>HeroModule</code> provides the <code>HeroService</code> and the root <code>AppModule</code> imports <code>HeroModule</code>, 
any class that knows the <code>HeroService</code> <em>type</em> can inject that service, 
not just the classes declared in the <code>HeroModule</code>.</p><span>
</span><a id="q-lazy-loaded-module-provider-visibility"></a><h3 id="why-is-a-service-provided-in-a-lazy-loaded-module-visible-only-to-that-module-">Why is a service provided in a lazy loaded module visible only to that module?</h3><span>
</span><p>Unlike providers of the modules loaded at launch, 
providers of lazy loaded modules are <em>module-scoped</em>.</p><span>
</span><p>When the Angular router lazy-loads a module, it creates a new execution context.
That <a href="https://angular.io/docs/ts/latest/cookbook/ngmodule-faq.html#q-why-child-injector" title="Why Angular creates a child injector">context has its own injector</a> which is a direct child of the application injector.</p><span>
</span><p>The router adds the lazy module&apos;s providers and the providers of its imported modules to this child injector.</p><span>
</span><p>These providers are insulated from changes to application providers with the same lookup token.
When the router creates a component within the lazy loaded context,
Angular prefers service instances created from these providers to the service instances of the application root injector.</p><span>
</span><a id="q-module-provider-duplicates"></a><h3 id="what-if-two-modules-provide-the-_same_-service-">What if two modules provide the <em>same</em> service?</h3><span>
</span><p>When two imported modules, loaded at the same time, list a provider with the same token, 
the second module&apos;s provider &quot;wins&quot;. That&apos;s because both providers are added to the same injector.</p><span>
</span><p>When Angular looks to inject a service for that token, 
it creates and delivers the instance created by the second provider.</p><span>
</span><p><em>Every</em> class that injects this service gets the instance created by the second provider.
Even classes declared within the first module get the instance created by the second provider.
<em>This can be an unwelcome surprise</em>.</p><span>
</span><p>If Module A provides a service for token &apos;X&apos; and imports a module B
that also provides a service for token &apos;X&apos;, then Module A&apos;s service definition &quot;wins&quot;.</p><span>
</span><p>The service provided by the root <code>AppModule</code> takes precedence over services provided by imported modules.
The <code>AppModule</code> always wins.</p><span>
</span><a id="q-component-scoped-providers"></a><h3 id="how-do-i-restrict-service-scope-to-a-module-">How do I restrict service scope to a module?</h3><span>
</span><p>When a module is loaded at application launch,
its <code>@NgModule.providers</code> have <strong><em>application-wide scope</em></strong>.
They are available for injection throughout the application.</p><span>
</span><p>Imported providers are easily replaced by providers from another imported module.
Such replacement may be by design. It could be unintentional and have adverse consequences.</p><span>
</span><div class="alert is-important"><p>As a general rule, import modules with providers <em>exactly once</em>, preferably in the application&apos;s <em>root module</em>.
That&apos;s also usually the best place to configure, wrap, and override them.</p><span>
</span></div><p>Suppose a module requires a customized <code>HttpBackend</code> that adds a special header for all Http requests.
If another module elsewhere in the application also customizes <code>HttpBackend</code>
or merely imports the <code>HttpModule</code>, it could override this module&apos;s <code>HttpBackend</code> provider, 
losing the special header. The server will reject http requests from this module.</p><span>
</span><div class="alert is-important"><p>Avoid this problem by importing the <code>HttpModule</code> only in the <code>AppModule</code>, the application <em>root module</em>.</p><span>
</span></div><p>If you must guard against this kind of &quot;provider corruption&quot;, <em>don&apos;t rely on a launch-time module&apos;s <code>providers</code>.</em></p><span>
</span><p>Load the module lazily if you can. 
Angular gives a <a href="https://angular.io/docs/ts/latest/cookbook/ngmodule-faq.html#q-lazy-loaded-module-provider-visibility">lazy-loaded module</a> its own child injector.
The module&apos;s providers are visible only within the component tree created with this injector.</p><span>
</span><p>If you must load the module eagerly, when the application starts,
<strong><em>provide the service in a component instead.</em></strong></p><span>
</span><p>Continuing with the same example, suppose the components of a module truly require a private, custom <code>HttpBackend</code>.</p><span>
</span><p>Create a &quot;top component&quot; that acts as the root for all of the module&apos;s components. 
Add the custom <code>HttpBackend</code> provider to the top component&apos;s <code>providers</code> list rather than the module&apos;s <code>providers</code>.
Recall that Angular creates a child injector for each component instance and populates the injector
with the component&apos;s own providers.</p><span>
</span><p>When a child of this component <em>asks</em> for the <code>HttpBackend</code> service,
Angular provides the local <code>HttpBackend</code> service, 
not the version provided in the application root injector.
Child components will make proper http requests no matter what other modules do to <code>HttpBackend</code>.</p><span>
</span><p>Be sure to create module components as children of this module&apos;s top component.</p><span>
</span><p>You can embed the child components in the top component&apos;s template.
Alternatively, make the top component a routing host by giving it a <code>&lt;router-outlet&gt;</code>.
Define child routes and let the router load module components into that outlet.</p><span>
</span><a id="q-root-component-or-module"></a><h3 id="should-i-add-providers-to-the-root-_appmodule_-or-the-root-_appcomponent_-">Should I add providers to the root <em>AppModule</em> or the root <em>AppComponent</em>?</h3><span>
</span><p>Most apps launch with an initial set of service providers. 
Should we register those providers on the root <code>AppModule</code> (<code>@NgModule.providers</code>) or
the root <code>AppComponent</code> (<code>@Component.providers</code>)?</p><span>
</span><p><strong><em>List such providers in the root</em> <code>AppModule</code> <em>unless you have a compelling reason to do otherwise</em></strong>.</p><span>
</span><p>Angular registers all startup module providers with the application root injector.
The services created from root injector providers are available to the entire application. 
They are <em>application-scoped</em>.</p><span>
</span><p>Certain services (e.g., the <code>Router</code>) only work when registered in the application root injector.</p><span>
</span><p>By contrast, Angular registers <code>AppComponent</code> providers with the <code>AppComponent</code>&apos;s own injector.
<code>AppComponent</code>services are available to that component and its component tree. 
They are <em>component-scoped</em>.</p><span>
</span><p>The <code>AppComponent</code>&apos;s injector is a <em>child</em> of the root injector, one down in the injector hierarchy.
That is <em>almost</em> the entire application for apps that don&apos;t use the router.
But &quot;almost&quot; isn&apos;t good enough for routed applications.</p><span>
</span><p><code>AppComponent</code> services don&apos;t exist at the root level where routing operates. 
Lazy loaded modules can&apos;t reach them.
In this sample applications, if we had registered <code>UserService</code> in the <code>AppComponent</code>, 
the <code>HeroComponent</code> couldn&apos;t inject it.
The application  would fail the moment a user navigated to &quot;Heroes&quot;.</p><span>
</span><p>We <em>can</em> register a service in <code>AppComponent</code> providers if the app doesn&apos;t use routing.
We <em>should</em> register a service in <code>AppComponent</code> providers if the service must be hidden
from components outside the <code>AppComponent</code> tree. </p><span>
</span><p>These are special cases.
When in doubt, register with the <code>AppModule</code>.</p><span>
</span><a id="q-why-bad"></a><h3 id="why-is-it-bad-if-_sharedmodule_-provides-a-service-to-a-lazy-loaded-module-">Why is it bad if <em>SharedModule</em> provides a service to a lazy loaded module?</h3><span>
</span><p>This question arose in the <a href="https://angular.io/docs/ts/latest/guide/ngmodule.html#no-shared-module-providers">Angular Module</a> chapter 
when we discussed the importance of keeping providers out of the <code>SharedModule</code>.</p><span>
</span><p>Suppose we had listed the <code>UserService</code> in the module&apos;s <code>providers</code> (which we did not).
Suppose every module imports this <code>SharedModule</code> (which they all do).</p><span>
</span><p>When the app starts, Angular eagerly loads the <code>AppModule</code> and the <code>ContactModule</code>.</p><span>
</span><p>Both instances of the imported <code>SharedModule</code> would provide the <code>UserService</code>. 
Angular registers one of them in the root app injector (see <a href="https://angular.io/docs/ts/latest/cookbook/ngmodule-faq.html#q-reimport">above</a>).
Then some component injects <code>UserService</code>, Angular finds it in the app root injector,
and delivers the app-wide singleton <code>UserService</code>. No problem. </p><span>
</span><p>Now consider the <code>HeroModule</code> <em>which is lazy loaded!</em></p><span>
</span><p>When the router lazy loads the <code>HeroModule</code>, it creates a child injector and registers the <code>UserService</code>
provider with that child injector. The child injector is <em>not</em> the root injector.</p><span>
</span><p>When Angular creates a lazy <code>HeroComponent</code>, it must inject a <code>UserService</code>.
This time it finds a <code>UserService</code> provider in the lazy module&apos;s <em>child injector</em>
and creates a <em>new</em> instance of the <code>UserService</code>.
This is an entirely different <code>UserService</code> instance
than the app-wide singleton version that Angular injected in one of the eagerly loaded components.</p><span>
</span><p>That&apos;s almost certainly a mistake.</p><span>
</span><div class="l-sub-section"><p>Prove it for yourself.
Run the <live-example>live example</live-example>.
Modify the <code>SharedModule</code> so that it provides the <code>UserService</code> rather than the <code>CoreModule</code>.
Then toggle between the &quot;Contact&quot; and &quot;Heroes&quot; links a few times.
The username goes bonkers as the Angular creates a new <code>UserService</code> instance each time.</p><span>
</span></div><a id="q-why-child-injector"></a><h3 id="why-does-lazy-loading-create-a-child-injector-">Why does lazy loading create a child injector?</h3><span>
</span><p>Angular adds <code>@NgModule.providers</code> to the application root injector ... unless the module is lazy loaded.
Then it creates a <em>child injector</em> and adds the module&apos;s providers to the child injector.</p><span>
</span><p>This means that a module behaves differently depending on whether it is loaded during application start
or lazy loaded later. Neglecting that difference can lead to <a href="https://angular.io/docs/ts/latest/cookbook/ngmodule-faq.html#q-why-bad">adverse consequences</a>.</p><span>
</span><p>Why doesn&apos;t Angular add lazy loaded providers to the app root injector as it does for eagerly loaded modules? 
Why the inconsistency?</p><span>
</span><p>The answer is grounded in a fundamental characteristic of the Angular dependency injection system.
An injector can add providers <em>until it is first used</em>. 
Once an injector starts creating and delivering services, its provider list is frozen. No new providers allowed.</p><span>
</span><p>When an applications starts, Angular first configures the root injector with the providers of all eagerly loaded modules
<em>before</em> creating its first component and injecting any of the provided services. 
Once the application begins, the app root injector is closed to new providers.</p><span>
</span><p>Time passes. Application logic triggers lazy loading of a module.
Angular must add the lazy loaded module&apos;s providers to an injector <em>somewhere</em>. 
It can&apos;t added them to the app root injector because that injector is closed to new providers. 
So Angular creates a new child injector for the lazy loaded module context.</p><span>
</span><a id="q-is-it-loaded"></a><h3 id="how-can-i-tell-if-a-module-or-service-was-previously-loaded-">How can I tell if a module or service was previously loaded?</h3><span>
</span><p>Some modules and its services should only be loaded once by the root <code>AppModule</code>.
Importing the module a second time by lazy loading a module could <a href="https://angular.io/docs/ts/latest/cookbook/ngmodule-faq.html#q-why-bad">produce errant behavior</a> 
that may be difficult to detect and diagnose.</p><span>
</span><p>We can guard against that danger by writing a constructor that attempts to inject the module or service
from the root app injector. If the injection succeeds, the class has been loaded a second time.
We can throw an error or take other remedial action.</p><span>
</span><p>Certain Angular modules (such as <code>BrowserModule</code>) implements such a guard 
as does this Angular Module chapter sample&apos;s <code>CoreModule</code> constructor.</p><span>
</span><p>app/core/core.module.ts (Constructor)</p><code language="ts" format="">constructor (@Optional() @SkipSelf() parentModule: CoreModule) {
  if (parentModule) {
    throw new Error(
      &apos;CoreModule is already loaded. Import it in the AppModule only&apos;);
  }
}
</code><a id="q-entry-component-defined"></a><h3 id="what-is-an-_entry-component_-">What is an <em>entry component</em>?</h3><span>
</span><p>Any component that Angular loads <em>imperatively</em> by type is an <em>entry component</em>,</p><span>
</span><p>A component loaded <em>declaratively</em> via its selector is <em>not</em> an entry component.</p><span>
</span><p>Most application components are loaded declaratively. 
Angular uses the component&apos;s selector to locate the element in the template. 
It then creates the HTML representation of the component and inserts it into the DOM at the selected element.
These are not entry components.</p><span>
</span><p>A few components are only loaded dynamically and are <em>never</em> referenced in a component template. </p><span>
</span><p>The bootstrapped root <code>AppComponent</code> is an <em>entry component</em>.
True, its selector matches an element tag in <code>index.html</code>.
But <code>index.html</code> is not a component template and the <code>AppComponent</code> 
selector doesn&apos;t match an element in any component template.</p><span>
</span><p>Angular loads <code>AppComponent</code> dynamically either because we listed it <em>by type</em> in <code>@NgModule.bootstrap</code> 
or because we boostrapped it imperatively with the module&apos;s <code>ngDoBootstrap</code> method.</p><span>
</span><p>Components in route definitions are also <em>entry components</em>.
A route definition refers to a component by its <em>type</em>. 
The router ignores a routed component&apos;s selector (if it even has one) and 
loads the component dynamically into a <code>RouterOutlet</code>. </p><span>
</span><p>The compiler can&apos;t discover these <em>entry components</em> by looking for them in other component templates. 
We must tell it about them ... by adding them to the <code>entryComponents</code> list.</p><span>
</span><p>Angular automatically adds two kinds of components to the module&apos;s <code>entryComponents</code>:</p><span>
</span><ol>
<li>the component in the <code>@NgModule.bootstrap</code> list</li>
<li>components referenced in router configuration</li>
</ol><span>
</span><p>We don&apos;t have to mention these components explicitly although it does not harm to do so.</p><span>
</span><a id="q-bootstrap_vs_entry_component"></a><h3 id="what-s-the-difference-between-a-_bootstrap_-component-and-an-_entry-component_-">What&apos;s the difference between a <em>bootstrap</em> component and an <em>entry component</em>?</h3><span>
</span><p>A bootstrapped component <em>is</em> an <a href="https://angular.io/docs/ts/latest/cookbook/ngmodule-faq.html#q-entry-component-defined">entry component</a>.
It&apos;s an entry component that Angular loads into the DOM during the bootstrap (application launch) process.
Other entry components are loaded dynamically by other means such as with the router.</p><span>
</span><p>The <code>@NgModule.bootstrap</code> property tells the compiler <em>both</em> that this is an entry component <em>and</em>
that it should generate code to bootstrap the application with this component.</p><span>
</span><p>There is no need to list a component in both the <code>bootstrap</code> and <code>entryComponent</code> lists 
although it is harmless to do so.</p><span>
</span><a id="q-when-entry-components"></a><h3 id="when-do-i-add-components-to-_entrycomponents_-">When do I add components to <em>entryComponents</em>?</h3><span>
</span><p>Most application developers won&apos;t need to add components to the <code>entryComponents</code>.</p><span>
</span><p>Angular adds certain components to <em>entry components</em> automatically.
Components listed in <code>@NgModule.bootstrap</code> are added automatically.
Components referenced in router configuration are added automatically.
These two mechanisms account for almost all entry components.</p><span>
</span><p>If your app happens to bootstrap or dynamically load a component <em>by type</em> in some other manner, 
you&apos;ll have to add it to <code>entryComponents</code> explicitly.</p><span>
</span><p>Although it&apos;s harmless to add components to this list,
it&apos;s best to add only the components that are truly <em>entry components</em>.
Don&apos;t include components that <a href="https://angular.io/docs/ts/latest/cookbook/ngmodule-faq.html#q-template-reference">are referenced</a> 
in the templates of other components.</p><span>
</span><a id="q-why-entry-components"></a><h3 id="why-does-angular-need-_entrycomponents_-">Why does Angular need <em>entryComponents</em>?</h3><span>
</span><p><em>Entry components</em> are also declared.
Why doesn&apos;t the Angular compiler generate code for every component in <code>@NgModule.declarations</code>?
Then we wouldn&apos;t need entry components.</p><span>
</span><p>The reason is <em>tree shaking</em>. For production apps we want to load the smallest, fastest code possible.
The code should contain only the classes that we actually need.
It should exclude a component that&apos;s never used, whether or not that component is declared.</p><span>
</span><p>In fact, many libraries declare and export components we&apos;ll never use.
The <em>tree shaker</em> will drop these components from the final code package
if we don&apos;t reference them. </p><span>
</span><p>If the <a href="https://angular.io/docs/ts/latest/cookbook/ngmodule-faq.html#q-angular-compiler">Angular compiler</a> generated code for every declared component, 
it would defeat the purpose of the tree shaker.</p><span>
</span><p>Instead, the compiler adopts a recursive strategy that generates code only for the components we use.</p><span>
</span><p>It starts with the entry components, 
then it generates code for the declared components it <a href="https://angular.io/docs/ts/latest/cookbook/ngmodule-faq.html#q-template-reference">finds</a> in an entry component&apos;s template,
then for the declared components it discovers in the templates of previously compiled components,
and so on. At the end of the process, it has generated code for every  entry component
and every component reachable from an entry component.</p><span>
</span><p>If a component isn&apos;t an <em>entry component</em> or wasn&apos;t found in a template, 
the compiler omits it. </p><span>
</span><a id="q-module-recommendations"></a><h4 id="what-kinds-of-modules-should-i-have-and-how-should-i-use-them-">What kinds of modules should I have and how should I use them?</h4><span>
</span><p>Every app is different and developers have varying levels of experience and comfort with the available choices.
Some suggestions and guidelines appear to have wide appeal.</p><span>
</span><div class="alert is-important"><p>The following is preliminary guidance based on early experience using Angular modules in a few applications.
Read with appropriate caution and reflection.</p><span>
</span></div><h4 id="_sharedmodule_"><em>SharedModule</em></h4><span>
</span><p>Create a <code>SharedModule</code> with the components, directives, and pipes that you use
everywhere in your app. This module should consist entirely of <code>declarations</code>
most of them exported. </p><span>
</span><p>It may re-export other <a href="https://angular.io/docs/ts/latest/cookbook/ngmodule-faq.html#widget-feature-module">widget modules</a> such as <code>CommonModule</code>,
<code>FormsModule</code> and modules with the UI controls that you use most widely.</p><span>
</span><p>It should <strong><em>not</em></strong> have <code>providers</code> for reasons <a href="https://angular.io/docs/ts/latest/cookbook/ngmodule-faq.html#q-why-bad">explained earlier</a>.
Nor should any of its imported or re-exported modules have <code>providers</code>.
Know what you&apos;re doing and why if you deviate from this guideline.</p><span>
</span><p>Import the <code>SharedModule</code> in your <em>feature</em> modules, 
both those loaded when the app starts and those you lazy load later.</p><span>
</span><h4 id="_coremodule_"><em>CoreModule</em></h4><span>
</span><p>Create a <code>CoreModule</code> with <code>providers</code> for the singleton services you load when the application starts.</p><span>
</span><p>Import <code>CoreModule</code> in the root <code>AppModule</code> only.
Never import <code>CoreModule</code> in any module other than the root <code>AppModule</code>.</p><span>
</span><p>Consider making <code>CoreModule</code> a <a href="https://angular.io/docs/ts/latest/cookbook/ngmodule-faq.html#service-feature-module">pure services module</a> with no <code>declarations</code>.</p><span>
</span><div class="l-sub-section"><p>This chapter sample departs from that advice by declaring and exporting two components that are
only used within the root <code>AppComponent</code> declared by <code>AppModule</code>. 
Someone following this guideline strictly would have declared these components in the <code>AppModule</code> instead.</p><span>
</span></div><h4 id="feature-modules">Feature Modules</h4><span>
</span><p>Create <em>Feature Modules</em> around specific application business domains, user workflows, and utility collections.</p><span>
</span><p>Feature modules tend to fall into one of these four groups:</p><span>
</span><ul>
<li><a href="https://angular.io/docs/ts/latest/cookbook/ngmodule-faq.html#domain-feature-module">Domain Feature Modules</a></li>
<li><a href="https://angular.io/docs/ts/latest/cookbook/ngmodule-faq.html#routed-feature-module">Routed Feature Modules</a></li>
<li><a href="https://angular.io/docs/ts/latest/cookbook/ngmodule-faq.html#service-feature-module">Service Feature Modules</a></li>
<li><a href="https://angular.io/docs/ts/latest/cookbook/ngmodule-faq.html#widget-feature-module">Widget Feature Modules</a></li>
</ul><span>
</span><div class="l-sub-section"><p>Real world modules are often hybrids that knowingly deviate from the following guidelines.
They are guidelines, not laws.
Follow them until you have a good reason to do otherwise.</p><span>
</span></div><table><tbody><tr><th>Feature Module</th><th>Guidelines</th></tr><tr><td><a id="domain-feature-module"></a>Domain</td><td><p>Domain Feature Modules deliver a user experience <strong>dedicated to a particular application domain</strong>
like editing a customer or placing an order.</p>
<p>They typically have a top component that acts as the feature root.
Private, supporting sub-components descend from it.</p>
<p>Domain feature module consist mostly of <em>declarations</em>.
Only the top component is exported.</p>
<p>Domain feature modules rarely have <em>providers</em>.
When they do, the lifetime of the provided services
should be the same as the lifetime of the module.</p>
<p>Do not provide application-wide singleton services in a domain feature module.</p>
<p>Domain feature modules are typically imported <em>exactly once</em> by a larger feature module.</p>
<p>They might be imported by the root <code>AppModule</code> of a small application that lacks routing.</p>
<div class="l-sub-section"><p>For an example, see <a href="https://angular.io/docs/ts/latest/guide/ngmodule.html#contact-module-v1"><em>ContactModule</em></a> 
in the Angular Module chapter, before we introduced routing.</p><span>
</span></div></td></tr><tr><td><a id="routed-feature-module"></a>Routed</td><td><p><em>Routed Feature Modules</em> are <em>Domain Feature modules</em> 
whose top components are the <strong>targets of router navigation routes</strong>.</p>
<p>All lazy loaded modules are routed feature modules by nature.</p>
<p>This chapter&apos;s <code>ContactModule</code>, <code>HeroModule</code> and <code>CrisisModule</code> are routed feature modules.</p>
<p>Routed Feature Modules <em>should not export anything</em>. 
They don&apos;t have to because none of their components ever appear in the template of an external component.</p>
<p>Routed Feature Modules are <em>never imported</em>.</p>
<p>Routed Feature Modules rarely have <em>providers</em> for reasons <a href="https://angular.io/docs/ts/latest/cookbook/ngmodule-faq.html#q-why-bad">explained earlier</a>.
When they do, the lifetime of the provided services
should be the same as the lifetime of the module.</p>
<p>Do not provide application-wide singleton services in a routed feature module
or in a module that the routed module imports.</p>
</td></tr><tr><td><a id="service-feature-module"></a>Service</td><td><p><em>Service Modules</em> <strong>provide utility services</strong> such as data access and messaging.</p>
<p>Ideally they consist entirely of <em>providers</em> and have no <em>declarations</em>.
The <code>CoreModule</code> and Angular&apos;s <code>HttpModule</code> are good examples.</p>
<p>Service Modules should <em>only</em> be imported by the root <code>AppModule</code>.</p>
<p>Do <strong>not</strong> import them in other feature modules.
Know what you&apos;re doing and why if you deviate from this guideline.</p>
</td></tr><tr><td><a id="widget-feature-module"></a>Widget</td><td><p>A <em>Widget Module</em> makes <strong>components, directives, and pipes</strong> available to external modules.</p>
<p><code>CommonModule</code> and <code>SharedModule</code> are widget modules.
Many third party UI component libraries are widget modules.</p>
<p>A Widget Module should consist entirely of <em>declarations</em>, most of them exported. </p>
<p>A Widget Module should rarely have <em>providers</em>. 
Know what you&apos;re doing and why if you deviate from this guideline.</p>
<p>Import Widget Modules in any module whose component templates need the widgets.</p>
</td></tr></tbody></table><p>The following table summarizes the key characteristics of each <em>Feature Module</em> group.</p><span>
</span><div class="l-sub-section"><p>Real world modules are often hybrids that knowingly deviate from these guidelines.</p><span>
</span></div><table><tbody><tr><th>Feature Module</th><th>Declarations </th><th>Providers </th><th>Exports</th><th>Imported By</th><th>Examples</th></tr><tr><td>Domain</td><td>Yes</td><td>Rare</td><td>Top Component</td><td>Feature, <code>AppModule</code></td><td><code>ContactModule</code> (before routing)</td></tr><tr><td>Routed</td><td>Yes</td><td>Rare</td><td>No</td><td>Nobody</td><td><code>ContactModule</code>, <code>HeroModule</code>, <code>CrisisModule</code></td></tr><tr><td>Service</td><td>No</td><td>Yes</td><td>No</td><td><code>AppModule</code></td><td><code>HttpModule</code>, <code>CoreModule</code></td></tr><tr><td>Widget</td><td>Yes</td><td>Rare</td><td>Yes</td><td>Feature</td><td><code>CommonModule</code>, <code>SharedModule</code></td></tr></tbody></table><a id="q-ng-vs-js-modules"></a><h3 id="what-s-the-difference-between-angular-and-javascript-modules-">What&apos;s the difference between Angular and JavaScript Modules?</h3><span>
</span><p>Angular and JavaScript are two different yet complementary module systems.</p><span>
</span><p>In modern JavaScript, <a href="http://exploringjs.com/es6/ch_modules.html">every file is a <em>module</em></a>.
Within each file we write an <code>export</code> statement to make parts of the module public:</p><span>
</span><code format=".">export class AppComponent { ... }
</code><p>Then we <code>import</code> a part in another module:</p><span>
</span><code format=".">import { AppComponent }  from &apos;./app.component&apos;;
</code><p>This kind of modularity is a feature of the <em>JavaScript language</em>.</p><span>
</span><p>An <em>Angular Module</em> is a feature of <em>Angular</em> itself.</p><span>
</span><p>Angular&apos;s <code>NgModule</code> also has <code>imports</code> and <code>exports</code> and they serve a similar purpose. </p><span>
</span><p>We <em>import</em> other Angular modules so we can use their exported classes in component templates.
We <em>export</em> this Angular module&apos;s classes so they can be imported and used by components of <em>other</em> modules.</p><span>
</span><p>The Angular module classes differ from JavaScript module class in three key respects:</p><span>
</span><ol>
<li><p>An Angular module bounds <a href="https://angular.io/docs/ts/latest/cookbook/ngmodule-faq.html#q-declarables"><em>declarable classes</em></a> only. 
Declarables are the only classes that matter to the <a href="https://angular.io/docs/ts/latest/cookbook/ngmodule-faq.html#q-angular-compiler">Angular compiler</a>.</p>
</li>
<li><p>Instead of defining all member classes in one giant file (as in a JavaScript module),
we list the module&apos;s classes in the <code>@NgModule.declarations</code> list.</p>
</li>
<li><p>An Angular module can only export the <a href="https://angular.io/docs/ts/latest/cookbook/ngmodule-faq.html#q-declarables"><em>declarable classes</em></a> 
it owns or imports from other modules.
It doesn&apos;t declare or export any other kind of class.</p>
</li>
</ol><span>
</span><p>The Angular Module is also special in another way.
Unlike JavaScript modules, an Angular module can extend the <em>entire</em> application with services
by adding providers to the <code>@NgModule.providers</code> list.</p><span>
</span><div class="alert is-important"><p>The provided services do not belong to the module nor are they scoped to the declared classes.
They are available <em>everywhere</em>.</p><span>
</span></div><p>Here&apos;s an <em>Angular Module</em> class with imports, exports, and declarations.</p><span>
</span><code language="ts" format="">@NgModule({
  imports:      [ CommonModule, FormsModule ],
  declarations: [ ContactComponent, HighlightDirective, AwesomePipe ],
  exports:      [ ContactComponent ],
  providers:    [ ContactService ]
})
export class ContactModule { }
</code><p>Of course we use <em>JavaScript</em> modules to write <em>Angular</em> modules as seen in the complete <code>contact.module.ts</code> file:</p><span>
</span><p>app/contact/contact.module.ts</p><code language="ts" format="">import { NgModule }           from &apos;@angular/core&apos;;
import { CommonModule }       from &apos;@angular/common&apos;;
import { FormsModule }        from &apos;@angular/forms&apos;;

import { AwesomePipe }        from &apos;./awesome.pipe&apos;;

import
       { ContactComponent }   from &apos;./contact.component&apos;;
import { ContactService }     from &apos;./contact.service&apos;;
import { HighlightDirective } from &apos;./highlight.directive&apos;;

@NgModule({
  imports:      [ CommonModule, FormsModule ],
  declarations: [ ContactComponent, HighlightDirective, AwesomePipe ],
  exports:      [ ContactComponent ],
  providers:    [ ContactService ]
})
export class ContactModule { }
</code><a id="q-template-reference"></a><h4>How does Angular find components, directives, and pipes in a template?<br>What is a <i><b>template reference</b></i>?</h4><p>The <a href="https://angular.io/docs/ts/latest/cookbook/ngmodule-faq.html#q-angular-compiler">Angular compiler</a> looks inside component templates 
for other components, directives, and pipes. When it finds one, that&apos;s a &quot;template reference&quot;.</p><span>
</span><p>The Angular compiler finds a component or directive in a template when it can match the <strong>selector</strong> of that 
component or directive to some HTML in that template. </p><span>
</span><p>The compiler finds a pipe if the pipe&apos;s <strong>name</strong> appears within the pipe syntax of the template HTML.</p><span>
</span><p>Angular only matches selectors and pipe names for classes that are declared by this module
or exported by a module that this module imports.</p><span>
</span><a id="q-angular-compiler"> </a><h3 id="what-is-the-angular-compiler-">What is the Angular Compiler?</h3><span>
</span><p>The <em>Angular Compiler</em> converts the application code we write into highly performant JavaScript code.
The <code>@NgModule</code> metadata play an important role in guiding the compilation process.</p><span>
</span><p>The code we write is not immediately executable.
Consider <strong>components</strong>.
Components have templates that contain custom elements, attribute directives, Angular binding declarations, 
and some peculiar syntax that clearly isn&apos;t native HTML.</p><span>
</span><p>The <em>Angular Compiler</em> reads the template markup, 
combines it with the corresponding component class code, and emits <em>component factories</em>.</p><span>
</span><p>A component factory creates a pure, 100% JavaScript representation
of the component that incorporates everything described in its <code>@Component</code> metadata: 
the HTML, the binding instructions, the attached styles ... everything.</p><span>
</span><p>Because <strong>directives</strong> and <strong>pipes</strong> appear in component templates, 
the <em>Angular Compiler</em> incorporates them into compiled component code too.</p><span>
</span><p><code>@NgModule</code> metadata tells the <em>Angular Compiler</em> what components to compile for this module and 
how to link this module with other modules.</p><span>
</span><a id="q-ngmodule-api"> </a><span>
</span><p>The following chart summarizes the <code>NgModule</code> metadata properties.</p><span>
</span><!--export interface NgModuleMetadataType {
  providers?: any[];
  declarations?: Array<Type|any[]>;
  imports?: Array<Type|ModuleWithProviders|any[]>;
  exports?: Array<Type|any[]>;
  entryComponents?: Array<Type|any[]>;
  bootstrap?: Array<Type|any[]>;
  schemas?: Array<SchemaMetadata|any[]>;
}
--><table><tbody><tr><th>Property</th><th>Description</th></tr><tr><td><code>declarations</code></td><td><p>A list of <a href="https://angular.io/docs/ts/latest/cookbook/ngmodule-faq.html#q-declarables">declarable</a> classes, 
the <strong>component</strong>, <strong>directive</strong> and <strong>pipe</strong> classes that <em>belong to this module</em>.</p>
<p>These declared classes are visible within the module but invisible to
components in a different module unless (a) they are <em>exported</em> from this module and 
(b) that other module <em>imports</em> this one.</p>
<p>Components, directives and pipes must belong to <em>exactly</em> one module.
The compiler emits an error if we try to declare the same class in more than one module.</p>
<p><strong>Do not re-declare a class imported from another module.</strong></p>
</td></tr><tr><td><code>providers</code></td><td><p>A list of dependency injection providers.</p>
<p>Angular registers these providers with the root injector of the module&apos;s execution context.
That&apos;s the application&apos;s root injector for all modules loaded when the application starts.</p>
<p>Angular can inject one of these provider services into any component in the application.
If this module provides the <code>HeroService</code>, or any module loaded at launch provides the <code>HeroService</code>,
Angular can inject the same <code>HeroService</code> intance into any app component.</p>
<p>A lazy loaded module has its own sub-root injector which typically 
is a direct child of the application root injector.</p>
<p>Lazy loaded services are scoped to the lazy module&apos;s injector.
If a lazy loaded module also provides the <code>HeroService</code>, 
any component created within that module&apos;s context (e.g., by router navigation)
gets the local instance of the service, not the instance in the root application injector.</p>
<p>Components in external modules continue to receive the instance created for the application root. </p>
</td></tr><tr><td><code>imports</code></td><td><p>A list of supporting modules.</p>
<p>Specifically, the list of modules whose exported components, directives or pipes 
are referenced by the component templates declared in this module.</p>
<p>A component template can <a href="https://angular.io/docs/ts/latest/cookbook/ngmodule-faq.html#q-template-reference">reference</a> another component, directive or pipe
on two conditions: either the referenced class is declared in this module
or the class was imported from another module. </p>
<p>A component can use the <code>NgIf</code> and <code>NgFor</code> directives only because its parent module 
imported the Angular <code>CommonModule</code> (perhaps indirectly by importing <code>BrowserModule</code>).</p>
<p>We can import many standard directives with the <code>CommonModule</code>.
But some familiar directives belong to other modules.
A component template can bind with <code>[(ngModel)]</code> only after importing the Angular <code>FormsModule</code>.</p>
</td></tr><tr><td><code>exports</code></td><td><p>A list of declarations &#x2014; <strong>component</strong>, <strong>directive</strong>, and <strong>pipe</strong> classes &#x2014; that 
an importing module can use.</p>
<p>Exported declarations are the module&apos;s <em>public API</em>. 
A component in another module can <a href="https://angular.io/docs/ts/latest/cookbook/ngmodule-faq.html#q-template-reference">reference</a> <em>this</em> module&apos;s <code>HeroComponent</code> 
if (a) it imports this module and (b) this module exports <code>HeroComponent</code>.</p>
<p>Declarations are private by default.
If this module does <em>not</em> export <code>HeroComponent</code>, no other module can see it.</p>
<p>Importing a module does <em>not</em> automatically re-export the imported module&apos;s exports.
Module &apos;B&apos; can&apos;t use <code>ngIf</code> just because it imported module <code>A</code> which imported <code>CommonModule</code>.
Module &apos;B&apos; must import <code>CommonModule</code> itself.</p>
<p>A module can list another module among its <code>exports</code> in which case
all of that module&apos;s public components, directives, and pipes are exported.</p>
<p><a href="https://angular.io/docs/ts/latest/cookbook/ngmodule-faq.html#q-re-export">Re-export</a> makes module transitivity explicit.
If Module &apos;A&apos; re-exports <code>CommonModule</code> and Module &apos;B&apos; imports Module &apos;A&apos;,
Module &apos;B&apos; components can use <code>ngIf</code> even though &apos;B&apos; itself didn&apos;t import <code>CommonModule</code>.</p>
</td></tr><tr><td><code>bootstrap</code></td><td><p>A list of components that can be bootstrapped.</p>
<p>Usually there is only one component in this list, the <em>root component</em> of the application.</p>
<p>Angular can launch with multiple bootstrap components, 
each with its own location in the host web page.</p>
<p>A bootstrap component is automatically an <code>entryComponent</code> </p>
</td></tr><tr><td><code>entryComponents</code></td><td><p>A list of components that are <em>not</em> <a href="https://angular.io/docs/ts/latest/cookbook/ngmodule-faq.html#q-template-reference">referenced</a> in a reachable component template.</p>
<p>Most developers will never set this property. Here&apos;s why.</p>
<p>The <a href="https://angular.io/docs/ts/latest/cookbook/ngmodule-faq.html#q-angular-compiler"><em>Angular Compiler</em></a> must know about every component actually used in the application.
The compiler can discover most components by walking the tree of references 
from one component template to another.</p>
<p>But there&apos;s always at least one component that is not referenced in any template:
the root component, <code>AppComponent</code>, that we bootstrap to launch the app.
That&apos;s why it&apos;s called an <em>entry component</em>.</p>
<p>Routed components are also <em>entry components</em> because they aren&apos;t referenced in a template either.
The router creates them and drops them into the DOM near a <code>&lt;router-outlet&gt;</code>.</p>
<p>While the bootstrapped and routed components are <em>entry components</em>, 
we usally don&apos;t have to add them to a module&apos;s <code>entryComponents</code> list.</p>
<p>Angular automatically adds components in the module&apos;s <code>bootstrap</code> list to the <code>entryComponents</code> list.
The <code>RouterModule</code> adds routed components to that list.</p>
<p>That leaves only two sources of undiscoverable components.</p>
<ol>
<li>Components bootstrapped using one of the imperative techniques.</li>
<li>Components dynamically loaded into the DOM by some means other than the router.</li>
</ol>
<p>Both are advanced techniques that few developers will ever employ. 
If you are one of those few, you&apos;ll have to add these components to the 
<code>entryComponents</code> list yourself, either programmatically or by hand.</p>
</td></tr></tbody></table></div></div>
        </article>
      
        <article>
          <h3>Component Interaction</h3>
          <div><div class="showcase-content"><a id="top"></a><p>This cookbook contains recipes for common component communication scenarios
in which two or more components share information.</p><span>
</span><!--.l-sub-section
  :marked
    For an in-depth look at each fundamental concepts in component communication, we can find detailed description and
    samples in the [Component Communication]() document.
--><a id="toc"></a><h2 id="table-of-contents">Table of contents</h2><span>
</span><p><a href="https://angular.io/docs/ts/latest/cookbook/component-communication.html#parent-to-child">Pass data from parent to child with input binding</a></p><span>
</span><p><a href="https://angular.io/docs/ts/latest/cookbook/component-communication.html#parent-to-child-setter">Intercept input property changes with a setter</a></p><span>
</span><p><a href="https://angular.io/docs/ts/latest/cookbook/component-communication.html#parent-to-child-on-changes">Intercept input property changes with <em>ngOnChanges</em></a></p><span>
</span><p><a href="https://angular.io/docs/ts/latest/cookbook/component-communication.html#child-to-parent">Parent listens for child event</a></p><span>
</span><p><a href="https://angular.io/docs/ts/latest/cookbook/component-communication.html#parent-to-child-local-var">Parent interacts with child via a <em>local variable</em></a></p><span>
</span><p><a href="https://angular.io/docs/ts/latest/cookbook/component-communication.html#parent-to-view-child">Parent calls a <em>ViewChild</em></a></p><span>
</span><p><a href="https://angular.io/docs/ts/latest/cookbook/component-communication.html#bidirectional-service">Parent and children communicate via a service</a></p><span>
</span><p><strong>See the <live-example name="cb-component-communication"></live-example></strong>.</p><span>
</span><a id="parent-to-child"></a><h2 id="pass-data-from-parent-to-child-with-input-binding">Pass data from parent to child with input binding</h2><span>
</span><p><code>HeroChildComponent</code> has two <strong><em>input properties</em></strong>, 
typically adorned with <a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#inputs-outputs">@Input decorations</a>.</p><span>
</span><code language="ts" format="linenums">import { Component, Input } from &apos;@angular/core&apos;;

import { Hero } from &apos;./hero&apos;;

@Component({
  selector: &apos;hero-child&apos;,
  template: `
    &lt;h3&gt;{{hero.name}} says:&lt;/h3&gt;
    &lt;p&gt;I, {{hero.name}}, am at your service, {{masterName}}.&lt;/p&gt;
  `
})
export class HeroChildComponent {
  @Input() hero: Hero;
  @Input(&apos;master&apos;) masterName: string;
}
</code><p>The second <code>@Input</code> aliases the child component property name <code>masterName</code> as <code>&apos;master&apos;</code>.</p><span>
</span><p>The <code>HeroParentComponent</code> nests the child <code>HeroChildComponent</code> inside an <code>*ngFor</code> repeater, 
binding its <code>master</code> string property to the child&apos;s <code>master</code> alias
and each iteration&apos;s <code>hero</code> instance to the child&apos;s <code>hero</code> property.</p><span>
</span><code language="ts" format="linenums">import { Component } from &apos;@angular/core&apos;;

import { HEROES } from &apos;./hero&apos;;

@Component({
  selector: &apos;hero-parent&apos;,
  template: `
    &lt;h2&gt;{{master}} controls {{heroes.length}} heroes&lt;/h2&gt;
    &lt;hero-child *ngFor=&quot;let hero of heroes&quot;
      [hero]=&quot;hero&quot;
      [master]=&quot;master&quot;&gt;
    &lt;/hero-child&gt;
  `
})
export class HeroParentComponent {
  heroes = HEROES;
  master: string = &apos;Master&apos;;
}
</code><p>The running application displays three heroes:</p><span>
</span><figure class="image-display"><img src="https://angular.io/resources/images/cookbooks/component-communication/parent-to-child.png" alt="Parent-to-child"></figure><h3 id="test-it">Test it</h3><span>
</span><p>E2E test that all children were instantiated and displayed as expected:</p><span>
</span><code language="ts" format="linenums">// ...
let _heroNames = [&apos;Mr. IQ&apos;, &apos;Magneta&apos;, &apos;Bombasto&apos;];
let _masterName = &apos;Master&apos;;

it(&apos;should pass properties to children properly&apos;, function () {
  let parent = element.all(by.tagName(&apos;hero-parent&apos;)).get(0);
  let heroes = parent.all(by.tagName(&apos;hero-child&apos;));

  for (let i = 0; i &lt; _heroNames.length; i++) {
    let childTitle = heroes.get(i).element(by.tagName(&apos;h3&apos;)).getText();
    let childDetail = heroes.get(i).element(by.tagName(&apos;p&apos;)).getText();
    expect(childTitle).toEqual(_heroNames[i] + &apos; says:&apos;);
    expect(childDetail).toContain(_masterName);
  }
});
// ...
</code><p><a href="https://angular.io/docs/ts/latest/cookbook/component-communication.html#top">Back to top</a></p><span>
</span><a id="parent-to-child-setter"></a><h2 id="intercept-input-property-changes-with-a-setter">Intercept input property changes with a setter</h2><span>
</span><p>Use an input property setter to intercept and act upon a value from the parent.</p><span>
</span><p>The setter of the <code>name</code> input property in the child <code>NameChildComponent</code> 
trims the whitespace from a name and replaces an empty value with default text. </p><span>
</span><code language="ts" format="linenums">import { Component, Input } from &apos;@angular/core&apos;;

@Component({
  selector: &apos;name-child&apos;,
  template: `
    &lt;h3&gt;&quot;{{name}}&quot;&lt;/h3&gt;
  `
})
export class NameChildComponent {
  _name: string = &apos;&lt;no name set&gt;&apos;;

  @Input()
  set name(name: string) {
    this._name = (name &amp;&amp; name.trim()) || &apos;&lt;no name set&gt;&apos;;
  }

  get name() { return this._name; }
}
</code><p>Here&apos;s the <code>NameParentComponent</code> demonstrating name variations including a name with all spaces:</p><span>
</span><code language="ts" format="linenums">import { Component } from &apos;@angular/core&apos;;

@Component({
  selector: &apos;name-parent&apos;,
  template: `
    &lt;h2&gt;Master controls {{names.length}} names&lt;/h2&gt;
    &lt;name-child *ngFor=&quot;let name of names&quot;
      [name]=&quot;name&quot;&gt;
    &lt;/name-child&gt;
  `
})
export class NameParentComponent {
  // Displays &apos;Mr. IQ&apos;, &apos;&lt;no name set&gt;&apos;, &apos;Bombasto&apos;
  names = [&apos;Mr. IQ&apos;, &apos;   &apos;, &apos;  Bombasto  &apos;];
}
</code><figure class="image-display"><img src="https://angular.io/resources/images/cookbooks/component-communication/setter.png" alt="Parent-to-child-setter"></figure><h3 id="test-it">Test it</h3><span>
</span><p>E2E tests of input property setter with empty and non-empty names:</p><span>
</span><code language="ts" format="linenums">// ...
it(&apos;should display trimmed, non-empty names&apos;, function () {
  let _nonEmptyNameIndex = 0;
  let _nonEmptyName = &apos;&quot;Mr. IQ&quot;&apos;;
  let parent = element.all(by.tagName(&apos;name-parent&apos;)).get(0);
  let hero = parent.all(by.tagName(&apos;name-child&apos;)).get(_nonEmptyNameIndex);

  let displayName = hero.element(by.tagName(&apos;h3&apos;)).getText();
  expect(displayName).toEqual(_nonEmptyName);
});

it(&apos;should replace empty name with default name&apos;, function () {
  let _emptyNameIndex = 1;
  let _defaultName = &apos;&quot;&lt;no name set&gt;&quot;&apos;;
  let parent = element.all(by.tagName(&apos;name-parent&apos;)).get(0);
  let hero = parent.all(by.tagName(&apos;name-child&apos;)).get(_emptyNameIndex);

  let displayName = hero.element(by.tagName(&apos;h3&apos;)).getText();
  expect(displayName).toEqual(_defaultName);
});
// ...
</code><p><a href="https://angular.io/docs/ts/latest/cookbook/component-communication.html#top">Back to top</a></p><span>
</span><a id="parent-to-child-on-changes"></a><h2 id="intercept-input-property-changes-with-ngonchanges-">Intercept input property changes with <em>ngOnChanges</em></h2><span>
</span><p>Detect and act upon changes to input property values with the <code>ngOnChanges</code> method of the <code>OnChanges</code> lifecycle hook interface.</p><span>
</span><div class="l-sub-section"><p>May prefer this approach to the property setter when watching multiple, interacting input properties.</p><span>
</span><p>Learn about <code>ngOnChanges</code> in the <a href="https://angular.io/docs/ts/latest/guide/lifecycle-hooks.html">LifeCycle Hooks</a> chapter.</p><span>
</span></div><p>This <code>VersionChildComponent</code> detects changes to the <code>major</code> and <code>minor</code> input properties and composes a log message reporting these changes:</p><span>
</span><code language="ts" format="linenums">import { Component, Input, OnChanges, SimpleChange } from &apos;@angular/core&apos;;

@Component({
  selector: &apos;version-child&apos;,
  template: `
    &lt;h3&gt;Version {{major}}.{{minor}}&lt;/h3&gt;
    &lt;h4&gt;Change log:&lt;/h4&gt;
    &lt;ul&gt;
      &lt;li *ngFor=&quot;let change of changeLog&quot;&gt;{{change}}&lt;/li&gt;
    &lt;/ul&gt;
  `
})
export class VersionChildComponent implements OnChanges {
  @Input() major: number;
  @Input() minor: number;
  changeLog: string[] = [];

  ngOnChanges(changes: {[propKey: string]: SimpleChange}) {
    let log: string[] = [];
    for (let propName in changes) {
      let changedProp = changes[propName];
      let from = JSON.stringify(changedProp.previousValue);
      let to =   JSON.stringify(changedProp.currentValue);
      log.push( `${propName} changed from ${from} to ${to}`);
    }
    this.changeLog.push(log.join(&apos;, &apos;));
  }
}
</code><p>The <code>VersionParentComponent</code> supplies the <code>minor</code> and <code>major</code> values and binds buttons to methods that change them.</p><span>
</span><code language="ts" format="linenums">import { Component } from &apos;@angular/core&apos;;

@Component({
  selector: &apos;version-parent&apos;,
  template: `
    &lt;h2&gt;Source code version&lt;/h2&gt;
    &lt;button (click)=&quot;newMinor()&quot;&gt;New minor version&lt;/button&gt;
    &lt;button (click)=&quot;newMajor()&quot;&gt;New major version&lt;/button&gt;
    &lt;version-child [major]=&quot;major&quot; [minor]=&quot;minor&quot;&gt;&lt;/version-child&gt;
  `
})
export class VersionParentComponent {
  major: number = 1;
  minor: number = 23;

  newMinor() {
    this.minor++;
  }

  newMajor() {
    this.major++;
    this.minor = 0;
  }
}
</code><p>Here&apos;s the output of a button-pushing sequence:</p><span>
</span><figure class="image-display"><img src="https://angular.io/resources/images/cookbooks/component-communication/parent-to-child-on-changes.gif" alt="Parent-to-child-onchanges"></figure><h3 id="test-it">Test it</h3><span>
</span><p>Test that <strong><em>both</em></strong> input properties are set initially and that button clicks trigger 
the expected <code>ngOnChanges</code> calls and values:</p><span>
</span><code language="ts" format="linenums">// ...
// Test must all execute in this exact order
it(&apos;should set expected initial values&apos;, function () {
  let actual = getActual();

  let initialLabel = &apos;Version 1.23&apos;;
  let initialLog = &apos;major changed from {} to 1, minor changed from {} to 23&apos;;

  expect(actual.label).toBe(initialLabel);
  expect(actual.count).toBe(1);
  expect(actual.logs.get(0).getText()).toBe(initialLog);
});

it(&apos;should set expected values after clicking \&apos;Minor\&apos; twice&apos;, function () {
  let repoTag = element(by.tagName(&apos;version-parent&apos;));
  let newMinorButton = repoTag.all(by.tagName(&apos;button&apos;)).get(0);

  newMinorButton.click().then(function() {
    newMinorButton.click().then(function() {
      let actual = getActual();

      let labelAfter2Minor = &apos;Version 1.25&apos;;
      let logAfter2Minor = &apos;minor changed from 24 to 25&apos;;

      expect(actual.label).toBe(labelAfter2Minor);
      expect(actual.count).toBe(3);
      expect(actual.logs.get(2).getText()).toBe(logAfter2Minor);
    });
  });
});

it(&apos;should set expected values after clicking \&apos;Major\&apos; once&apos;, function () {
  let repoTag = element(by.tagName(&apos;version-parent&apos;));
  let newMajorButton = repoTag.all(by.tagName(&apos;button&apos;)).get(1);

  newMajorButton.click().then(function() {
    let actual = getActual();

    let labelAfterMajor = &apos;Version 2.0&apos;;
    let logAfterMajor = &apos;major changed from 1 to 2, minor changed from 25 to 0&apos;;

    expect(actual.label).toBe(labelAfterMajor);
    expect(actual.count).toBe(4);
    expect(actual.logs.get(3).getText()).toBe(logAfterMajor);
  });
});

function getActual() {
  let versionTag = element(by.tagName(&apos;version-child&apos;));
  let label = versionTag.element(by.tagName(&apos;h3&apos;)).getText();
  let ul = versionTag.element((by.tagName(&apos;ul&apos;)));
  let logs = ul.all(by.tagName(&apos;li&apos;));

  return {
    label: label,
    logs: logs,
    count: logs.count()
  };
}
// ...
</code><p><a href="https://angular.io/docs/ts/latest/cookbook/component-communication.html#top">Back to top</a></p><span>
</span><a id="child-to-parent"></a><h2 id="parent-listens-for-child-event">Parent listens for child event</h2><span>
</span><p>The child component exposes an <code>EventEmitter</code> property with which it <code>emits</code>events when something happens. 
The parent binds to that event property and reacts to those events.</p><span>
</span><p>The child&apos;s <code>EventEmitter</code> property is an <strong><em>output property</em></strong>, 
  typically adorned with an <a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#inputs-outputs">@Output decoration</a>
  as seen in this <code>VoterComponent</code>:</p><span>
</span><code language="ts" format="linenums">import { Component, EventEmitter, Input, Output } from &apos;@angular/core&apos;;

@Component({
  selector: &apos;my-voter&apos;,
  template: `
    &lt;h4&gt;{{name}}&lt;/h4&gt;
    &lt;button (click)=&quot;vote(true)&quot;  [disabled]=&quot;voted&quot;&gt;Agree&lt;/button&gt;
    &lt;button (click)=&quot;vote(false)&quot; [disabled]=&quot;voted&quot;&gt;Disagree&lt;/button&gt;
  `
})
export class VoterComponent {
  @Input()  name: string;
  @Output() onVoted = new EventEmitter&lt;boolean&gt;();
  voted = false;

  vote(agreed: boolean) {
    this.onVoted.emit(agreed);
    this.voted = true;
  }
}
</code><p>Clicking a button triggers emission of a <code>true</code> or <code>false</code> (the boolean <em>payload</em>).</p><span>
</span><p>The parent <code>VoteTakerComponent</code> binds an event handler (<code>onVoted</code>) that responds to the child event
payload (<code>$event</code>) and updates a counter.</p><span>
</span><code language="ts" format="linenums">import { Component }      from &apos;@angular/core&apos;;

@Component({
  selector: &apos;vote-taker&apos;,
  template: `
    &lt;h2&gt;Should mankind colonize the Universe?&lt;/h2&gt;
    &lt;h3&gt;Agree: {{agreed}}, Disagree: {{disagreed}}&lt;/h3&gt;
    &lt;my-voter *ngFor=&quot;let voter of voters&quot;
      [name]=&quot;voter&quot;
      (onVoted)=&quot;onVoted($event)&quot;&gt;
    &lt;/my-voter&gt;
  `
})
export class VoteTakerComponent {
  agreed = 0;
  disagreed = 0;
  voters = [&apos;Mr. IQ&apos;, &apos;Ms. Universe&apos;, &apos;Bombasto&apos;];

  onVoted(agreed: boolean) {
    agreed ? this.agreed++ : this.disagreed++;
  }
}
</code><p>The framework passes the event argument &#x2014; represented by <code>$event</code> &#x2014; to the handler method, 
and the method processes it:</p><span>
</span><figure class="image-display"><img src="https://angular.io/resources/images/cookbooks/component-communication/child-to-parent.gif" alt="Child-to-parent"></figure><h3 id="test-it">Test it</h3><span>
</span><p>Test that clicking the <em>Agree</em> and <em>Disagree</em> buttons update the appropriate counters:</p><span>
</span><code language="ts" format="linenums">// ...
it(&apos;should not emit the event initially&apos;, function () {
  let voteLabel = element(by.tagName(&apos;vote-taker&apos;))
    .element(by.tagName(&apos;h3&apos;)).getText();
  expect(voteLabel).toBe(&apos;Agree: 0, Disagree: 0&apos;);
});

it(&apos;should process Agree vote&apos;, function () {
  let agreeButton1 = element.all(by.tagName(&apos;my-voter&apos;)).get(0)
    .all(by.tagName(&apos;button&apos;)).get(0);
  agreeButton1.click().then(function() {
    let voteLabel = element(by.tagName(&apos;vote-taker&apos;))
      .element(by.tagName(&apos;h3&apos;)).getText();
    expect(voteLabel).toBe(&apos;Agree: 1, Disagree: 0&apos;);
  });
});

it(&apos;should process Disagree vote&apos;, function () {
  let agreeButton1 = element.all(by.tagName(&apos;my-voter&apos;)).get(1)
    .all(by.tagName(&apos;button&apos;)).get(1);
  agreeButton1.click().then(function() {
    let voteLabel = element(by.tagName(&apos;vote-taker&apos;))
      .element(by.tagName(&apos;h3&apos;)).getText();
    expect(voteLabel).toBe(&apos;Agree: 1, Disagree: 1&apos;);
  });
});
// ...
</code><p><a href="https://angular.io/docs/ts/latest/cookbook/component-communication.html#top">Back to top</a></p><span>
</span><parent-to-child-local-var></parent-to-child-local-var><a id="parent-to-child-local-var"></a><h2 id="parent-interacts-with-child-via-local-variable-">Parent interacts with child via <em>local variable</em></h2><span>
</span><p>A parent component cannot use data binding to read child properties
or invoke child methods. We can do both 
by creating a template reference variable for the child element
and then reference that variable <em>within the parent template</em>
as seen in the following example.</p><span>
</span><p>
We have a child <code>CountdownTimerComponent</code> that repeatedly counts down to zero and launches a rocket.
It has <code>start</code> and <code>stop</code> methods that control the clock and it displays a
countdown status message in its own template.</p><span>
</span><code language="ts" format="linenums">import { Component, OnDestroy, OnInit } from &apos;@angular/core&apos;;

@Component({
  selector: &apos;countdown-timer&apos;,
  template: &apos;&lt;p&gt;{{message}}&lt;/p&gt;&apos;
})
export class CountdownTimerComponent implements OnInit, OnDestroy {

  intervalId = 0;
  message = &apos;&apos;;
  seconds = 11;

  clearTimer() { clearInterval(this.intervalId); }

  ngOnInit()    { this.start(); }
  ngOnDestroy() { this.clearTimer(); }

  start() { this.countDown(); }
  stop()  {
    this.clearTimer();
    this.message = `Holding at T-${this.seconds} seconds`;
  }

  private countDown() {
    this.clearTimer();
    this.intervalId = window.setInterval(() =&gt; {
      this.seconds -= 1;
      if (this.seconds === 0) {
        this.message = &apos;Blast off!&apos;;
      } else {
        if (this.seconds &lt; 0) { this.seconds = 10; } // reset
        this.message = `T-${this.seconds} seconds and counting`;
      }
    }, 1000);
  }
}
</code><p>Let&apos;s see the <code>CountdownLocalVarParentComponent</code> that hosts the timer component.</p><span>
</span><code language="ts" format="linenums">import { Component }                from &apos;@angular/core&apos;;
import { CountdownTimerComponent }  from &apos;./countdown-timer.component&apos;;

@Component({
  selector: &apos;countdown-parent-lv&apos;,
  template: `
  &lt;h3&gt;Countdown to Liftoff (via local variable)&lt;/h3&gt;
  &lt;button (click)=&quot;timer.start()&quot;&gt;Start&lt;/button&gt;
  &lt;button (click)=&quot;timer.stop()&quot;&gt;Stop&lt;/button&gt;
  &lt;div class=&quot;seconds&quot;&gt;{{timer.seconds}}&lt;/div&gt;
  &lt;countdown-timer #timer&gt;&lt;/countdown-timer&gt;
  `,
  styleUrls: [&apos;demo.css&apos;]
})
export class CountdownLocalVarParentComponent { }
</code><p>The parent component cannot data bind to the child&apos;s 
<code>start</code> and <code>stop</code> methods nor to its <code>seconds</code> property.</p><span>
</span><p>We can place a local variable (<code>#timer</code>) on the tag (<code>&lt;countdown-timer&gt;</code>) representing the child component.
That gives us a reference to the child component itself and the ability to access
<em>any of its properties or methods</em> from within the parent template.</p><span>
</span><p>In this example, we wire parent buttons to the child&apos;s <code>start</code> and <code>stop</code> and
use interpolation to display the child&apos;s <code>seconds</code> property.</p><span>
</span><p>Here we see the parent and child working together.</p><span>
</span><figure class="image-display"><img src="https://angular.io/resources/images/cookbooks/component-communication/countdown-timer-anim.gif" alt="countdown timer"></figure><a id="countdown-tests"></a><h3 id="test-it">Test it</h3><span>
</span><p>Test that the seconds displayed in the parent template
match the seconds displayed in the child&apos;s status message.
Test also that clicking the <em>Stop</em> button pauses the countdown timer:</p><span>
</span><code language="ts" format="linenums">// ...
it(&apos;timer and parent seconds should match&apos;, function () {
  let parent = element(by.tagName(parentTag));
  let message = parent.element(by.tagName(&apos;countdown-timer&apos;)).getText();
  browser.sleep(10); // give `seconds` a chance to catchup with `message`
  let seconds = parent.element(by.className(&apos;seconds&apos;)).getText();
  expect(message).toContain(seconds);
});

it(&apos;should stop the countdown&apos;, function () {
  let parent = element(by.tagName(parentTag));
  let stopButton = parent.all(by.tagName(&apos;button&apos;)).get(1);

  stopButton.click().then(function() {
    let message = parent.element(by.tagName(&apos;countdown-timer&apos;)).getText();
    expect(message).toContain(&apos;Holding&apos;);
  });
});
// ...
</code><p><a href="https://angular.io/docs/ts/latest/cookbook/component-communication.html#top">Back to top</a></p><span>
</span><a id="parent-to-view-child"></a><h2 id="parent-calls-a-viewchild-">Parent calls a <em>ViewChild</em></h2><span>
</span><p>The <em>local variable</em> approach is simple and easy. But it is limited because 
the parent-child wiring must be done entirely within the parent template.
The parent component <em>itself</em> has no access to the child.</p><span>
</span><p>We can&apos;t use the <em>local variable</em> technique if an instance of the parent component <em>class</em>
must read or write child component values or must call child component methods.</p><span>
</span><p>When the parent component <em>class</em> requires that kind of access, 
we <strong><em>inject</em></strong> the child component into the parent as a <em>ViewChild</em>.</p><span>
</span><p>We&apos;ll illustrate this technique with the same <a href="https://angular.io/docs/ts/latest/cookbook/component-communication.html#countdown-timer-example">Countdown Timer</a> example. 
We won&apos;t change its appearance or behavior. 
The child <a href="https://angular.io/docs/ts/latest/cookbook/component-communication.html#countdown-timer-example">CountdownTimerComponent</a> is the same as well.</p><span>
</span><div class="l-sub-section"><p>We are switching from the <em>local variable</em> to the <em>ViewChild</em> technique
solely for the purpose of demonstration.</p><span>
</span></div><p>Here is the parent, <code>CountdownViewChildParentComponent</code>:</p><span>
</span><code language="ts" format="linenums">import { AfterViewInit, ViewChild } from &apos;@angular/core&apos;;
import { Component }                from &apos;@angular/core&apos;;
import { CountdownTimerComponent }  from &apos;./countdown-timer.component&apos;;

@Component({
  selector: &apos;countdown-parent-vc&apos;,
  template: `
  &lt;h3&gt;Countdown to Liftoff (via ViewChild)&lt;/h3&gt;
  &lt;button (click)=&quot;start()&quot;&gt;Start&lt;/button&gt;
  &lt;button (click)=&quot;stop()&quot;&gt;Stop&lt;/button&gt;
  &lt;div class=&quot;seconds&quot;&gt;{{ seconds() }}&lt;/div&gt;
  &lt;countdown-timer&gt;&lt;/countdown-timer&gt;
  `,
  styleUrls: [&apos;demo.css&apos;]
})
export class CountdownViewChildParentComponent implements AfterViewInit {

  @ViewChild(CountdownTimerComponent)
  private timerComponent: CountdownTimerComponent;

  seconds() { return 0; }

  ngAfterViewInit() {
    // Redefine `seconds()` to get from the `CountdownTimerComponent.seconds` ...
    // but wait a tick first to avoid one-time devMode
    // unidirectional-data-flow-violation error
    setTimeout(() =&gt; this.seconds = () =&gt; this.timerComponent.seconds, 0);
  }

  start() { this.timerComponent.start(); }
  stop() { this.timerComponent.stop(); }
}
</code><p>It takes a bit more work to get the child view into the parent component classs.</p><span>
</span><p>We import references to the <code>ViewChild</code> decorator and the <code>AfterViewInit</code> lifecycle hook.</p><span>
</span><p>We inject the child <code>CountdownTimerComponent</code> into the private <code>timerComponent</code> property
via the <code>@ViewChild</code> property decoration.</p><span>
</span><p>The <code>#timer</code> local variable is gone from the component metadata. 
Instead we bind the buttons to the parent component&apos;s own <code>start</code> and <code>stop</code> methods and
present the ticking seconds in an interpolation around the parent component&apos;s <code>seconds</code> method.</p><span>
</span><p>These methods access the injected timer component directly.</p><span>
</span><p>The <code>ngAfterViewInit</code> lifecycle hook is an important wrinkle.
The timer component isn&apos;t available until <em>after</em> Angular displays the parent view.
So we display <code>0</code> seconds initially.</p><span>
</span><p>Then Angular calls the <code>ngAfterViewInit</code> lifecycle hook at which time it is <em>too late</em>
to update the parent view&apos;s display of the countdown seconds.
Angular&apos;s unidirectional data flow rule prevents us from updating the parent view&apos;s
in the same cycle. We have to <em>wait one turn</em> before we can display the seconds.</p><span>
</span><p>We use <code>setTimeout</code> to wait one tick and then revise the <code>seconds</code> method so 
that it takes future values from the timer component.</p><span>
</span><h3 id="test-it">Test it</h3><span>
</span><p>Use <a href="https://angular.io/docs/ts/latest/cookbook/component-communication.html#countdown-tests">the same countdown timer tests</a> as before.</p><span>
</span><p><a href="https://angular.io/docs/ts/latest/cookbook/component-communication.html#top">Back to top</a></p><span>
</span><a id="bidirectional-service"></a><h2 id="parent-and-children-communicate-via-a-service">Parent and children communicate via a service</h2><span>
</span><p>A parent component and its children share a service whose interface enables bi-directional communication
<em>within the family</em>.</p><span>
</span><p>The scope of the service instance is the parent component and its children. 
Components outside this component subtree have no access to the service or their communications.</p><span>
</span><p>This <code>MissionService</code> connects the <code>MissionControlComponent</code> to multiple <code>AstronautComponent</code> children.</p><span>
</span><code language="ts" format="linenums">import { Injectable } from &apos;@angular/core&apos;;
import { Subject }    from &apos;rxjs/Subject&apos;;

@Injectable()
export class MissionService {

  // Observable string sources
  private missionAnnouncedSource = new Subject&lt;string&gt;();
  private missionConfirmedSource = new Subject&lt;string&gt;();

  // Observable string streams
  missionAnnounced$ = this.missionAnnouncedSource.asObservable();
  missionConfirmed$ = this.missionConfirmedSource.asObservable();

  // Service message commands
  announceMission(mission: string) {
    this.missionAnnouncedSource.next(mission);
  }

  confirmMission(astronaut: string) {
    this.missionConfirmedSource.next(astronaut);
  }
}
</code><p>The <code>MissionControlComponent</code> both provides the instance of the service that it shares with its children
(through the <code>providers</code> metadata array) and injects that instance into itself through its constructor:</p><span>
</span><code language="ts" format="linenums">import { Component }          from &apos;@angular/core&apos;;

import { MissionService }     from &apos;./mission.service&apos;;

@Component({
  selector: &apos;mission-control&apos;,
  template: `
    &lt;h2&gt;Mission Control&lt;/h2&gt;
    &lt;button (click)=&quot;announce()&quot;&gt;Announce mission&lt;/button&gt;
    &lt;my-astronaut *ngFor=&quot;let astronaut of astronauts&quot;
      [astronaut]=&quot;astronaut&quot;&gt;
    &lt;/my-astronaut&gt;
    &lt;h3&gt;History&lt;/h3&gt;
    &lt;ul&gt;
      &lt;li *ngFor=&quot;let event of history&quot;&gt;{{event}}&lt;/li&gt;
    &lt;/ul&gt;
  `,
  providers: [MissionService]
})
export class MissionControlComponent {
  astronauts = [&apos;Lovell&apos;, &apos;Swigert&apos;, &apos;Haise&apos;];
  history: string[] = [];
  missions = [&apos;Fly to the moon!&apos;,
              &apos;Fly to mars!&apos;,
              &apos;Fly to Vegas!&apos;];
  nextMission = 0;

  constructor(private missionService: MissionService) {
    missionService.missionConfirmed$.subscribe(
      astronaut =&gt; {
        this.history.push(`${astronaut} confirmed the mission`);
      });
  }

  announce() {
    let mission = this.missions[this.nextMission++];
    this.missionService.announceMission(mission);
    this.history.push(`Mission &quot;${mission}&quot; announced`);
    if (this.nextMission &gt;= this.missions.length) { this.nextMission = 0; }
  }
}
</code><p>The <code>AstronautComponent</code> also injects the service in its constructor.
Each <code>AstronautComponent</code> is a child of the <code>MissionControlComponent</code> and therefore receives its parent&apos;s service instance:</p><span>
</span><code language="ts" format="linenums">import { Component, Input, OnDestroy } from &apos;@angular/core&apos;;

import { MissionService } from &apos;./mission.service&apos;;
import { Subscription }   from &apos;rxjs/Subscription&apos;;

@Component({
  selector: &apos;my-astronaut&apos;,
  template: `
    &lt;p&gt;
      {{astronaut}}: &lt;strong&gt;{{mission}}&lt;/strong&gt;
      &lt;button
        (click)=&quot;confirm()&quot;
        [disabled]=&quot;!announced || confirmed&quot;&gt;
        Confirm
      &lt;/button&gt;
    &lt;/p&gt;
  `
})
export class AstronautComponent implements OnDestroy {
  @Input() astronaut: string;
  mission = &apos;&lt;no mission announced&gt;&apos;;
  confirmed = false;
  announced = false;
  subscription: Subscription;

  constructor(private missionService: MissionService) {
    this.subscription = missionService.missionAnnounced$.subscribe(
      mission =&gt; {
        this.mission = mission;
        this.announced = true;
        this.confirmed = false;
    });
  }

  confirm() {
    this.confirmed = true;
    this.missionService.confirmMission(this.astronaut);
  }

  ngOnDestroy() {
    // prevent memory leak when component destroyed
    this.subscription.unsubscribe();
  }
}
</code><div class="l-sub-section"><p>Notice that we capture the <code>subscription</code> and unsubscribe when the <code>AstronautComponent</code> is destroyed.
This is a memory-leak guard step. There is no actual risk in this app because the
lifetime of a <code>AstronautComponent</code> is the same as the lifetime of the app itself.
That <em>would not</em> always be true in a more complex application.</p><span>
</span><p>We do not add this guard to the <code>MissionControlComponent</code> because, as the parent,
it controls the lifetime of the <code>MissionService</code>.</p><span>
</span></div><p>The <em>History</em> log demonstrates that messages travel in both directions between
the parent <code>MissionControlComponent</code> and the <code>AstronautComponent</code> children,
facilitated by the service:</p><span>
</span><figure class="image-display"><img src="https://angular.io/resources/images/cookbooks/component-communication/bidirectional-service.gif" alt="bidirectional-service"></figure><h3 id="test-it">Test it</h3><span>
</span><p>Tests click buttons of both the parent <code>MissionControlComponent</code> and the <code>AstronautComponent</code> children
and verify that the <em>History</em> meets expectations:</p><span>
</span><code language="ts" format="linenums">// ...
it(&apos;should announce a mission&apos;, function () {
  let missionControl = element(by.tagName(&apos;mission-control&apos;));
  let announceButton = missionControl.all(by.tagName(&apos;button&apos;)).get(0);
  announceButton.click().then(function () {
    let history = missionControl.all(by.tagName(&apos;li&apos;));
    expect(history.count()).toBe(1);
    expect(history.get(0).getText()).toMatch(/Mission.* announced/);
  });
});

it(&apos;should confirm the mission by Lovell&apos;, function () {
  testConfirmMission(1, 2, &apos;Lovell&apos;);
});

it(&apos;should confirm the mission by Haise&apos;, function () {
  testConfirmMission(3, 3, &apos;Haise&apos;);
});

it(&apos;should confirm the mission by Swigert&apos;, function () {
  testConfirmMission(2, 4, &apos;Swigert&apos;);
});

function testConfirmMission(buttonIndex: number, expectedLogCount: number, astronaut: string) {
  let _confirmedLog = &apos; confirmed the mission&apos;;
  let missionControl = element(by.tagName(&apos;mission-control&apos;));
  let confirmButton = missionControl.all(by.tagName(&apos;button&apos;)).get(buttonIndex);
  confirmButton.click().then(function () {
    let history = missionControl.all(by.tagName(&apos;li&apos;));
    expect(history.count()).toBe(expectedLogCount);
    expect(history.get(expectedLogCount - 1).getText()).toBe(astronaut + _confirmedLog);
  });
}
// ...
</code><p><a href="https://angular.io/docs/ts/latest/cookbook/component-communication.html#top">Back to top</a></p></div></div>
        </article>
      
        <article>
          <h3>Component-relative Paths</h3>
          <div><div class="showcase-content"><h2 id="write-component-relative-urls-to-component-templates-and-style-files">Write <em>Component-Relative</em> URLs to component templates and style files</h2><span>
</span><p>Our components often refer to external template and style files.
We identify those files with a URL in the <code>templateUrl</code> and <code>styleUrls</code> properties of the <code>@Component</code> metadata
as seen here:</p><span>
</span><code language="ts" format="">@Component({
  selector: &apos;absolute-path&apos;,
  templateUrl: &apos;app/some.component.html&apos;,
  styleUrls:  [&apos;app/some.component.css&apos;]
})
</code><p>By default, we <em>must</em> specify the full path back to the application root.
We call this an <strong><em>absolute path</em></strong> because it is <em>absolute</em> with respect to the application root.</p><span>
</span><p>There are two problems with an <em>absolute path</em>:</p><span>
</span><ol>
<li><p>We have to remember the full path back to the application root.</p>
</li>
<li><p>We have to update the URL when we move the component around in the application files structure.</p>
</li>
</ol><span>
</span><p>It would be much easier to write and maintain our application components if we could specify template and style locations
<em>relative</em> to their component class file.</p><span>
</span><p><em>We can!</em></p><span>
</span><div class="alert is-important"><p>We can if we build our application as <code>commonjs</code> modules and load those modules
with a suitable package loader such as <code>systemjs</code> or <code>webpack</code>.
Learn why <a href="https://angular.io/docs/ts/latest/cookbook/component-relative-paths.html#why-default">below</a>.</p><span>
</span><p>The Angular 2 CLI uses these technologies and defaults to the
<em>component-relative path</em> approach described here.
CLI users can skip this chapter or read on to understand
how it works.</p><span>
</span></div><h2 id="_component-relative_-paths"><em>Component-Relative</em> Paths</h2><span>
</span><p>Our goal is to specify template and style URLs <em>relative</em> to their component class files, 
hence the term <strong><em>component-relative path</em></strong>.</p><span>
</span><p>The key to success is following a convention that puts related component files in well-known locations.</p><span>
</span><p>We recommend keeping component template and component-specific style files as <em>siblings</em> of their
companion component class files. 
Here we see the three files for <code>SomeComponent</code> sitting next to each other in the <code>app</code> folder. </p><span>
</span><div class="filetree"><div class="file"><span>app</span><div class="children"><p>some.component.css</p><p>some.component.html</p><p>some.component.ts</p></div><p>...</p></div></div><p>We&apos;ll have more files and folders &#x2014; and greater folder depth &#x2014; as our application grows.
We&apos;ll be fine as long as the component files travel together as the inseparable siblings they are.</p><span>
</span><h3 id="set-the-moduleid-">Set the <em>moduleId</em></h3><span>
</span><p>Having adopted this file structure convention, we can specify locations of the template and style files
relative to the component class file simply by setting the <code>moduleId</code> property of the <code>@Component</code> metadata like this</p><span>
</span><code language="ts" format="">moduleId: module.id,
</code><p>We strip the <code>app/</code> base path from the <code>templateUrl</code> and <code>styleUrls</code>. The result looks like this:</p><span>
</span><code language="ts" format="">@Component({
  moduleId: module.id,
  selector: &apos;relative-path&apos;,
  templateUrl: &apos;some.component.html&apos;,
  styleUrls:  [&apos;some.component.css&apos;]
})
</code><div class="alert is-helpful"><p>Webpack users may prefer <a href="https://angular.io/docs/ts/latest/cookbook/component-relative-paths.html#webpack">an alternative approach</a>.</p><span>
</span></div><h2 id="source">Source</h2><span>
</span><p><strong>We can see the <live-example name="cb-component-relative-paths"></live-example></strong>
and download the source code from there
or simply read the pertinent source here.</p><span>
</span><code-tabs><code language="ts" name="app/some.component.ts" format="linenums">import { Component } from &apos;@angular/core&apos;;

///////// Using Absolute Paths ///////

@Component({
  selector: &apos;absolute-path&apos;,
  templateUrl: &apos;app/some.component.html&apos;,
  styleUrls:  [&apos;app/some.component.css&apos;]
})
export class SomeAbsoluteComponent {
  class = &apos;absolute&apos;;
  type = &apos;Absolute template &amp; style URLs&apos;;
  path = &apos;app/path.component.html&apos;;
}

///////// Using Relative Paths ///////

@Component({
  moduleId: module.id,
  selector: &apos;relative-path&apos;,
  templateUrl: &apos;some.component.html&apos;,
  styleUrls:  [&apos;some.component.css&apos;]
})

export class SomeRelativeComponent {
  class = &apos;relative&apos;;
  type = &apos;Component-relative template &amp; style URLs&apos;;
  path = &apos;path.component.html&apos;;

}
</code><code language="html" name="app/some.component.html" format="linenums">&lt;div class={{class}}&gt;
  {{type}}&lt;br&gt;{{path}}
&lt;/div&gt;
</code><code language="css" name="app/some.component.css" format="linenums">div.absolute {
  background: beige;
  border: 1px solid darkred;
  color: red;
  margin: 8px;
  max-width: 20em;
  padding: 4px;
  text-align: center;
}

div.relative {
  background: powderblue;
  border: 1px solid darkblue;
  color: Blue;
  font-style: italic;
  margin: 8px;
  max-width: 20em;
  padding: 4px;
  text-align: center;
}
</code><code language="ts" name="app/app.component.ts" format="linenums">import { Component } from &apos;@angular/core&apos;;

@Component({
selector: &apos;my-app&apos;,
template:
  `&lt;h1&gt;Absolute &amp; &lt;i&gt;Component-Relative&lt;/i&gt; Paths&lt;/h1&gt;
  &lt;absolute-path&gt;&lt;/absolute-path&gt;
  &lt;relative-path&gt;&lt;/relative-path&gt;
  `
})
export class AppComponent {}
</code></code-tabs><a id="why-default"></a><h2 id="appendix-why-component-relative-is-not-the-default">Appendix: why <em>component-relative</em> is not the default</h2><span>
</span><p>A <em>component-relative</em> path is obviously superior to an <em>absolute</em> path.
Why did Angular default to the <em>absolute</em> path?
Why do <em>we</em> have to set the <code>moduleId</code>? Why can&apos;t Angular set it?</p><span>
</span><p>First, let&apos;s look at what happens if we use a relative path and omit the <code>moduleId</code>.</p><span>
</span><p><code>EXCEPTION: Failed to load some.component.html</code></p><span>
</span><p>Angular can&apos;t find the file so it throws an error.</p><span>
</span><p>Why can&apos;t Angular calculate the template and style URLs from the component file&apos;s location? </p><span>
</span><p>Because the location of the component can&apos;t be determined without the developer&apos;s help.
Angular apps can be loaded in many ways: from individual files, from SystemJS packages, or
from CommonJS packages, to name a few. 
We might generate modules in any of several formats. 
We might not be writing modular code at all!</p><span>
</span><p>With this diversity of packaging and module load strategies, 
it&apos;s not possible for Angular to know with certainty where these files reside at runtime.</p><span>
</span><p>The only location Angular can be sure of is the URL of the <code>index.html</code> home page, the application root.
So by default it resolves template and style paths relative to the URL of <code>index.html</code>.
That&apos;s why we previously wrote our file URLs with an <code>app/</code> base path prefix.</p><span>
</span><p>But <em>if</em> we follow the recommended guidelines and we write modules in <code>commonjs</code> format
and we use a module loader that <em>plays nice</em>,
<em>then</em> we &#x2014; the developers of the application &#x2014;
know that the semi-global <code>module.id</code> variable is available and contains
the absolute URL of the component class module file.</p><span>
</span><p>That knowledge enables us to tell Angular where the <em>component</em> file is
by setting the <code>moduleId</code>:</p><span>
</span><code language="ts" format="">moduleId: module.id,
</code><a id="webpack"></a><h2 id="webpack-load-templates-and-styles">Webpack: load templates and styles</h2><span>
</span><p>Webpack developers have an alternative to <code>moduleId</code>.</p><span>
</span><p>They can load templates and styles at runtime by adding <code>./</code> at the beginning of the <code>template</code> and <code>styles</code> / <code>styleUrls</code>
properties that reference *component-relative URLS.</p><span>
</span><code language="ts" format="">import { Component } from &apos;@angular/core&apos;;

import &apos;../../public/css/styles.css&apos;;

@Component({
  selector: &apos;my-app&apos;,
  templateUrl: &apos;./app.component.html&apos;,
  styleUrls: [&apos;./app.component.css&apos;]
})
export class AppComponent { }
</code><div class="l-sub-section"><p>Webpack will do a <code>require</code> behind the scenes to load the templates and styles. Read more <a href="https://angular.io/docs/ts/latest/guide/webpack.html#highlights">here</a>.</p><span>
</span></div><p>See the <a href="https://angular.io/docs/ts/latest/guide/webpack.html">Introduction to Webpack</a>.</p></div></div>
        </article>
      
        <article>
          <h3>Dependency Injection</h3>
          <div><div class="showcase-content"><p>Dependency Injection is a powerful pattern for managing code dependencies. 
In this cookbook we will explore many of the features of Dependency Injection (DI) in Angular.</p><span>
</span><a id="toc"></a><h2 id="table-of-contents">Table of contents</h2><span>
</span><p><a href="https://angular.io/docs/ts/latest/cookbook/dependency-injection.html#app-wide-dependencies">Application-wide dependencies</a></p><span>
</span><p><a href="https://angular.io/docs/ts/latest/cookbook/dependency-injection.html#external-module-configuration">External module configuration</a></p><span>
</span><p><a href="https://angular.io/docs/ts/latest/cookbook/dependency-injection.html#nested-dependencies"><em>@Injectable</em> and nested service dependencies</a></p><span>
</span><p><a href="https://angular.io/docs/ts/latest/cookbook/dependency-injection.html#service-scope">Limit service scope to a component subtree</a></p><span>
</span><p><a href="https://angular.io/docs/ts/latest/cookbook/dependency-injection.html#multiple-service-instances">Multiple service instances (sandboxing)</a></p><span>
</span><p><a href="https://angular.io/docs/ts/latest/cookbook/dependency-injection.html#qualify-dependency-lookup">Qualify dependency lookup with <em>@Optional</em> and <em>@Host</em></a></p><span>
</span><p><a href="https://angular.io/docs/ts/latest/cookbook/dependency-injection.html#component-element">Inject the component&apos;s DOM element</a></p><span>
</span><p><a href="https://angular.io/docs/ts/latest/cookbook/dependency-injection.html#providers">Define dependencies with providers</a></p><span>
</span><ul>
<li><a href="https://angular.io/docs/ts/latest/cookbook/dependency-injection.html#provide">The <em>provide</em> object literal</a></li>
<li><a href="https://angular.io/docs/ts/latest/cookbook/dependency-injection.html#usevalue">useValue - the <em>value provider</em></a></li>
<li><a href="https://angular.io/docs/ts/latest/cookbook/dependency-injection.html#useclass">useClass - the <em>class provider</em></a></li>
<li><a href="https://angular.io/docs/ts/latest/cookbook/dependency-injection.html#useexisting">useExisting - the <em>alias provider</em></a></li>
<li><a href="https://angular.io/docs/ts/latest/cookbook/dependency-injection.html#usefactory">useFactory - the <em>factory provider</em></a></li>
</ul><span>
</span><p><a href="https://angular.io/docs/ts/latest/cookbook/dependency-injection.html#tokens">Provider token alternatives</a></p><span>
</span><ul>
<li><a href="https://angular.io/docs/ts/latest/cookbook/dependency-injection.html#class-interface">class-interface</a></li>
<li><a href="https://angular.io/docs/ts/latest/cookbook/dependency-injection.html#opaque-token">OpaqueToken</a></li>
</ul><span>
</span><p><a href="https://angular.io/docs/ts/latest/cookbook/dependency-injection.html#di-inheritance">Inject into a derived class</a></p><span>
</span><p><a href="https://angular.io/docs/ts/latest/cookbook/dependency-injection.html#find-parent">Find a parent component by injection</a></p><span>
</span><ul>
<li><a href="https://angular.io/docs/ts/latest/cookbook/dependency-injection.html#known-parent">Find parent with a known component type</a></li>
<li><a href="https://angular.io/docs/ts/latest/cookbook/dependency-injection.html#base-parent">Cannot find a parent by its base class</a></li>
<li><a href="https://angular.io/docs/ts/latest/cookbook/dependency-injection.html#class-interface-parent">Find a parent by its class-interface</a></li>
<li><a href="https://angular.io/docs/ts/latest/cookbook/dependency-injection.html#parent-tree">Find a parent in a tree of parents (<em>@SkipSelf</em>)</a></li>
<li><a href="https://angular.io/docs/ts/latest/cookbook/dependency-injection.html#provideparent">A <em>provideParent</em> helper function</a></li>
</ul><span>
</span><p><a href="https://angular.io/docs/ts/latest/cookbook/dependency-injection.html#forwardref">Break circularities with a forward class reference (<em>forwardRef</em>)</a></p><span>
</span><p><strong>See the <live-example name="cb-dependency-injection"></live-example></strong>
of the code supporting this cookbook.        </p><span>
</span><a id="app-wide-dependencies"></a><h2 id="application-wide-dependencies">Application-wide dependencies</h2><span>
</span><p>Register providers for dependencies used throughout the application in the root application component, <code>AppComponent</code>.</p><span>
</span><p>In the following example, we import and register several services 
(the <code>LoggerService</code>, <code>UserContext</code>, and the <code>UserService</code>)
in the <code>@Component</code> metadata <code>providers</code> array.</p><span>
</span><p>app/app.component.ts (excerpt)</p><code language="ts" format="">import { LoggerService }      from &apos;./logger.service&apos;;
import { UserContextService } from &apos;./user-context.service&apos;;
import { UserService }        from &apos;./user.service&apos;;

@Component({
  selector: &apos;my-app&apos;,
  templateUrl: &apos;app/app.component.html&apos;,
  providers: [LoggerService, UserContextService, UserService]
})
export class AppComponent {
/* . . . */
}
</code><p>All of these services are implemented as classes. 
Service classes can act as their own providers which is why listing them in the <code>providers</code> array
is all the registration we need.</p><span>
</span><div class="l-sub-section"><p>A <em>provider</em> is something that can create or deliver a service.
Angular creates a service instance from a class provider by &quot;new-ing&quot; it.
Learn more about providers <a href="https://angular.io/docs/ts/latest/cookbook/dependency-injection.html#providers">below</a>.</p><span>
</span></div><p>Now that we&apos;ve registered these services, 
Angular can inject them into the constructor of <em>any</em> component or service, <em>anywhere</em> in the application.</p><span>
</span><p>app/hero-bios.component.ts (component constructor injection)</p><code language="ts" format="">constructor(logger: LoggerService) {
  logger.logInfo(&apos;Creating HeroBiosComponent&apos;);
}
</code><p>app/user-context.service.ts (service constructor injection)</p><code language="ts" format="">constructor(private userService: UserService, private loggerService: LoggerService) {
}
</code><a id="external-module-configuration"></a><h2 id="external-module-configuration">External module configuration</h2><span>
</span><p>We often register providers in the <code>NgModule</code> rather than in the root application component.</p><span>
</span><p>We do this when (a) we expect the service to be injectable everywhere
or (b) we must configure another application global service <em>before it starts</em>.</p><span>
</span><p>We see an example of the second case here, where we configure the Component Router with a non-default
<a href="https://angular.io/docs/ts/latest/guide/router.html#location-strategy">location strategy</a> by listing its provider 
in the <code>providers</code> list of the <code>AppModule</code>.</p><span>
</span><p>app/app.module.ts (providers)</p><code language="ts" format="">providers: [
  { provide: LocationStrategy, useClass: HashLocationStrategy }
]
</code><a id="injectable"></a><a id="nested-dependencies"></a><h2 id="-injectable-and-nested-service-dependencies"><em>@Injectable</em> and nested service dependencies</h2><span>
</span><p>The consumer of an injected service does not know how to create that service.
It shouldn&apos;t care.
It&apos;s the dependency injection&apos;s job to create and cache that service.</p><span>
</span><p>Sometimes a service depends on other services ... which may depend on yet other services.
Resolving these nested dependencies in the correct order is also the framework&apos;s job.
At each step, the consumer of dependencies simply declares what it requires in its constructor and the framework takes over.</p><span>
</span><p>For example, we inject both the <code>LoggerService</code> and the <code>UserContext</code> in the <code>AppComponent</code>. </p><span>
</span><p>app/app.component.ts</p><code language="ts" format="">constructor(logger: LoggerService, public userContext: UserContextService) {
  userContext.loadUser(this.userId);
  logger.logInfo(&apos;AppComponent initialized&apos;);
}
</code><p>The <code>UserContext</code> in turn has dependencies on both the <code>LoggerService</code> (again) and 
a <code>UserService</code> that gathers information about a particular user.</p><span>
</span><p>user-context.service.ts (injection)</p><code language="ts" format="">@Injectable()
export class UserContextService {
  constructor(private userService: UserService, private loggerService: LoggerService) {
  }
}
</code><p>When Angular creates an<code>AppComponent</code>, the dependency injection framework creates an instance of the <code>LoggerService</code> and 
starts to create the <code>UserContextService</code>.
The <code>UserContextService</code> needs the <code>LoggerService</code>, which the framework already has, and the <code>UserService</code>, which it has yet to create. 
The <code>UserService</code> has no dependencies so the dependency injection framework can just <code>new</code> one into existence.</p><span>
</span><p>The beauty of dependency injection is that the author of <code>AppComponent</code> didn&apos;t care about any of this. 
The author simply declared what was needed in the constructor (<code>LoggerService</code> and <code>UserContextService</code>) and the framework did the rest.</p><span>
</span><p>Once all the dependencies are in place, the <code>AppComponent</code> displays the user information:</p><span>
</span><figure class="image-display"><img src="https://angular.io/resources/images/cookbooks/dependency-injection/logged-in-user.png" alt="Logged In User"></figure><h3 id="-injectable-"><em>@Injectable()</em></h3><span>
</span><p>Notice the <code>@Injectable()</code>decorator on the <code>UserContextService</code> class. </p><span>
</span><p>user-context.service.ts (@Injectable)</p><code language="ts" format="">@Injectable()
export class UserContextService {
}
</code><p>That decorator makes it possible for Angular to identify the types of its two dependencies, <code>LoggerService</code> and <code>UserService</code>.</p><span>
</span><p>Technically, the <code>@Injectable()</code>decorator is only <em>required</em> for a service class that has <em>its own dependencies</em>.
The <code>LoggerService</code> doesn&apos;t depend on anything. The logger would work if we omitted <code>@Injectable()</code>
and the generated code would be slightly smaller. </p><span>
</span><p>But the service would break the moment we gave it a dependency and we&apos;d have to go back and
and add <code>@Injectable()</code> to fix it. We add <code>@Injectable()</code> from the start for the sake of consistency and to avoid future pain.</p><span>
</span><div class="alert is-helpful"><p>Although we recommend applying <code>@Injectable</code> to all service classes, do not feel bound by it.
Some developers prefer to add it only where needed and that&apos;s a reasonable policy too.</p><span>
</span></div><div class="l-sub-section"><p>The <code>AppComponent</code> class had two dependencies as well but no <code>@Injectable()</code>.
It didn&apos;t need <code>@Injectable()</code> because that component class has the <code>@Component</code> decorator.
In Angular with TypeScript, a <em>single</em> decorator &#x2014; <em>any</em> decorator &#x2014; is sufficient to identify dependency types.</p><span>
</span></div><a id="service-scope"></a><h2 id="limit-service-scope-to-a-component-subtree">Limit service scope to a component subtree</h2><span>
</span><p>All injected service dependencies are singletons meaning that, 
for a given dependency injector (&quot;injector&quot;), there is only one instance of service. </p><span>
</span><p>But an Angular application has multiple dependency injectors, arranged in a tree hierarchy that parallels the component tree.
So a particular service can be <em>provided</em> (and created) at any component level and multiple times
if provided in multiple components.</p><span>
</span><p>By default, a service dependency provided in one component is visible to all of its child components and 
Angular injects the same service instance into all child components that ask for that service.</p><span>
</span><p>Accordingly, dependencies provided in the root <code>AppComponent</code> can be injected into <em>any</em> component <em>anywhere</em> in the application.</p><span>
</span><p>That isn&apos;t always desirable. 
Sometimes we want to restrict service availability to a particular region of the application.</p><span>
</span><p>We can limit the scope of an injected service to a <em>branch</em> of the application hierarchy
by providing that service <em>at the sub-root component for that branch</em>.
Here we provide the <code>HeroService</code> to the <code>HeroesBaseComponent</code> by listing it in the <code>providers</code> array:</p><span>
</span><p>app/sorted-heroes.component.ts (HeroesBaseComponent excerpt)</p><code language="ts" format="linenums">@Component({
  selector: &apos;unsorted-heroes&apos;,
  template: `&lt;div *ngFor=&quot;let hero of heroes&quot;&gt;{{hero.name}}&lt;/div&gt;`,
  providers: [HeroService]
})
export class HeroesBaseComponent implements OnInit {
  constructor(private heroService: HeroService) { }
}
</code><p>When Angular creates the <code>HeroesBaseComponent</code>, it also creates a new instance of <code>HeroService</code> 
that is visible only to the component and its children (if any).</p><span>
</span><p>We could also provide the <code>HeroService</code> to a <em>different</em> component elsewhere in the application. 
That would result in a <em>different</em> instance of the service, living in a <em>different</em> injector.</p><span>
</span><div class="l-sub-section"><p>We examples of such scoped <code>HeroService</code> singletons appear throughout the accompanying sample code, 
including the <code>HeroBiosComponent</code>, <code>HeroOfTheMonthComponent</code>, and <code>HeroesBaseComponent</code>. 
Each of these components has its own <code>HeroService</code> instance managing its own independent collection of heroes.</p><span>
</span></div><div class="alert is-helpful"><h3 id="take-a-break-">Take a break!</h3><span>
</span><p>This much Dependency Injection knowledge may be all that many Angular developers
ever need to build their applications. It doesn&apos;t always have to be more complicated.</p><span>
</span></div><a id="multiple-service-instances"></a><h2 id="multiple-service-instances-sandboxing-">Multiple service instances (sandboxing)</h2><span>
</span><p>Sometimes we want multiple instances of a service at <em>the same level of the component hierarchy</em>.</p><span>
</span><p>A good example is a service that holds state for its companion component instance. 
We need a separate instance of the service for each component.
Each service has its own work-state, isolated from the service-and-state of a different component.
We call this <em>sandboxing</em> because each service and component instance has its own sandbox to play in.</p><span>
</span><p><a id="hero-bios-component"></a>
Imagine a <code>HeroBiosComponent</code> that presents three instances of the <code>HeroBioComponent</code>. </p><span>
</span><p>ap/hero-bios.component.ts</p><code language="ts" format="linenums">@Component({
  selector: &apos;hero-bios&apos;,
  template: `
    &lt;hero-bio [heroId]=&quot;1&quot;&gt;&lt;/hero-bio&gt;
    &lt;hero-bio [heroId]=&quot;2&quot;&gt;&lt;/hero-bio&gt;
    &lt;hero-bio [heroId]=&quot;3&quot;&gt;&lt;/hero-bio&gt;`,
  providers: [HeroService]
})
export class HeroBiosComponent {
}
</code><p>Each <code>HeroBioComponent</code> can edit a single hero&apos;s biography. 
A <code>HeroBioComponent</code> relies on a <code>HeroCacheService</code> to fetch, cache, and perform other persistence operations on that hero.</p><span>
</span><p>app/hero-cache.service.ts</p><code language="ts" format="linenums">@Injectable()
export class HeroCacheService {
  hero: Hero;
  constructor(private heroService: HeroService) {}

  fetchCachedHero(id: number) {
    if (!this.hero) {
      this.hero = this.heroService.getHeroById(id);
    }
    return this.hero;
  }
}
</code><p>Clearly the three instances of the <code>HeroBioComponent</code> can&apos;t share the same <code>HeroCacheService</code>. 
They&apos;d be competing with each other to determine which hero to cache.</p><span>
</span><p>Each <code>HeroBioComponent</code> gets its <em>own</em> <code>HeroCacheService</code> instance 
by listing the <code>HeroCacheService</code> in its metadata <code>providers</code> array.</p><span>
</span><p>app/hero-bio.component.ts</p><code language="ts" format="linenums">@Component({
  selector: &apos;hero-bio&apos;,
  template: `
    &lt;h4&gt;{{hero.name}}&lt;/h4&gt;
    &lt;ng-content&gt;&lt;/ng-content&gt;
    &lt;textarea cols=&quot;25&quot; [(ngModel)]=&quot;hero.description&quot;&gt;&lt;/textarea&gt;`,
  providers: [HeroCacheService]
})

export class HeroBioComponent implements OnInit  {
  @Input() heroId: number;

  constructor(private heroCache: HeroCacheService) { }

  ngOnInit() { this.heroCache.fetchCachedHero(this.heroId); }

  get hero() { return this.heroCache.hero; }
}
</code><p>The parent <code>HeroBiosComponent</code> binds a value to the <code>heroId</code>.
The <code>ngOnInit</code> pass that <code>id</code> to the service which fetches and caches the hero. 
The getter for the <code>hero</code> property pulls the cached hero from the service.
And the template displays this data-bound property.</p><span>
</span><p>Find this example in <live-example name="cb-dependency-injection">live code</live-example>
and confirm that the three <code>HeroBioComponent</code> instances have their own cached hero data. </p><span>
</span><figure class="image-display"><img src="https://angular.io/resources/images/cookbooks/dependency-injection/hero-bios.png" alt="Bios"></figure><a id="optional"></a><a id="qualify-dependency-lookup"></a><h2 id="qualify-dependency-lookup-with-optional-and-host-">Qualify dependency lookup with <em>@Optional</em> and <em>@Host</em></h2><span>
</span><p>We learned that dependencies can be registered at any level in the component hierarchy. </p><span>
</span><p>When a component requests a dependency, Angular starts with that component&apos;s injector and walks up the injector tree 
until it finds the first suitable provider.  Angular throws an error if it can&apos;t find the dependency during that walk. </p><span>
</span><p>We <em>want</em> this behavior most of the time. 
But sometimes we need to limit the search and/or accommodate a missing dependency.
We can modify Angular&apos;s search behavior with the <code>@Host</code> and <code>@Optional</code> qualifying decorators,
used individually or together.</p><span>
</span><p>The <code>@Optional</code> decorator tells Angular to continue when it can&apos;t find the dependency. 
Angular sets the injection parameter to <code>null</code> instead.</p><span>
</span><p>The <code>@Host</code> decorator stops the upward search at the <em>host component</em>. </p><span>
</span><p>The host component is typically the component requesting the dependency. 
But when this component is projected into a <em>parent</em> component, that parent component becomes the host.
We look at this second, more interesting case in our next example.</p><span>
</span><h3 id="demonstration">Demonstration</h3><span>
</span><p>The <code>HeroBiosAndContactsComponent</code> is a revision of the <code>HeroBiosComponent</code> that we looked at <a href="https://angular.io/docs/ts/latest/cookbook/dependency-injection.html#hero-bios-component">above</a>.</p><span>
</span><p>app/hero-bios.component.ts (HeroBiosAndContactsComponent)</p><code language="ts" format="linenums">@Component({
  selector: &apos;hero-bios-and-contacts&apos;,
  template: `
    &lt;hero-bio [heroId]=&quot;1&quot;&gt; &lt;hero-contact&gt;&lt;/hero-contact&gt; &lt;/hero-bio&gt;
    &lt;hero-bio [heroId]=&quot;2&quot;&gt; &lt;hero-contact&gt;&lt;/hero-contact&gt; &lt;/hero-bio&gt;
    &lt;hero-bio [heroId]=&quot;3&quot;&gt; &lt;hero-contact&gt;&lt;/hero-contact&gt; &lt;/hero-bio&gt;`,
  providers: [HeroService]
})
export class HeroBiosAndContactsComponent {
  constructor(logger: LoggerService) {
    logger.logInfo(&apos;Creating HeroBiosAndContactsComponent&apos;);
  }
}
</code><p>Focus on the template:</p><span>
</span><code language="ts" format="">template: `
  &lt;hero-bio [heroId]=&quot;1&quot;&gt; &lt;hero-contact&gt;&lt;/hero-contact&gt; &lt;/hero-bio&gt;
  &lt;hero-bio [heroId]=&quot;2&quot;&gt; &lt;hero-contact&gt;&lt;/hero-contact&gt; &lt;/hero-bio&gt;
  &lt;hero-bio [heroId]=&quot;3&quot;&gt; &lt;hero-contact&gt;&lt;/hero-contact&gt; &lt;/hero-bio&gt;`,
</code><p>We&apos;ve inserted a <code>&lt;hero-contact&gt;</code> element between the <code>&lt;hero-bio&gt;</code> tags.
Angular <em>projects</em> (<em>transcludes</em>) the corresponding <code>HeroContactComponent</code> into the <code>HeroBioComponent</code> view, 
placing it in the <code>&lt;ng-content&gt;</code> slot of the <code>HeroBioComponent</code> template:</p><span>
</span><p>app/hero-bio.component.ts (template)</p><code language="ts" format="">template: `
  &lt;h4&gt;{{hero.name}}&lt;/h4&gt;
  &lt;ng-content&gt;&lt;/ng-content&gt;
  &lt;textarea cols=&quot;25&quot; [(ngModel)]=&quot;hero.description&quot;&gt;&lt;/textarea&gt;`,
</code><p>It looks like this, with the hero&apos;s telephone number from <code>HeroContactComponent</code> projected above the hero description:</p><span>
</span><figure class="image-display"><img src="https://angular.io/resources/images/cookbooks/dependency-injection/hero-bio-and-content.png" alt="bio and contact"></figure><p>Here&apos;s the <code>HeroContactComponent</code> which demonstrates the qualifying decorators that we&apos;re talking about in this section:</p><span>
</span><p>app/hero-contact.component.ts</p><code language="ts" format="linenums">@Component({
  selector: &apos;hero-contact&apos;,
  template: `
  &lt;div&gt;Phone #: {{phoneNumber}}
  &lt;span *ngIf=&quot;hasLogger&quot;&gt;!!!&lt;/span&gt;&lt;/div&gt;`
})
export class HeroContactComponent {

  hasLogger = false;

  constructor(
      @Host() // limit to the host component&apos;s instance of the HeroCacheService
      private heroCache: HeroCacheService,

      @Host()     // limit search for logger; hides the application-wide logger
      @Optional() // ok if the logger doesn&apos;t exist
      private loggerService: LoggerService
  ) {
    if (loggerService) {
      this.hasLogger = true;
      loggerService.logInfo(&apos;HeroContactComponent can log!&apos;);
    }
  }

  get phoneNumber() { return this.heroCache.hero.phone; }

}
</code><p>Focus on the constructor parameters</p><span>
</span><p>app/hero-contact.component.ts</p><code language="ts" format="">@Host() // limit to the host component&apos;s instance of the HeroCacheService
private heroCache: HeroCacheService,

@Host()     // limit search for logger; hides the application-wide logger
@Optional() // ok if the logger doesn&apos;t exist
private loggerService: LoggerService
</code><p>The <code>@Host()</code> function decorating the  <code>heroCache</code> property ensures that 
we get a reference to the cache service from the parent <code>HeroBioComponent</code>.
Angular throws if the parent lacks that service, even if a component higher in the component tree happens to have that service.</p><span>
</span><p>A second <code>@Host()</code> function decorates the <code>loggerService</code> property.
We know the only <code>LoggerService</code> instance in the app is provided at the <code>AppComponent</code> level.
The host <code>HeroBioComponent</code> doesn&apos;t have its own <code>LoggerService</code> provider.</p><span>
</span><p>Angular would throw an error if we hadn&apos;t also decorated the property with the <code>@Optional()</code> function.
Thanks to <code>@Optional()</code>, Angular sets the <code>loggerService</code> to null and the rest of the component adapts.</p><span>
</span><div class="l-sub-section"><p>We&apos;ll come back to the <code>elementRef</code> property shortly.</p><span>
</span></div><p>Here&apos;s the <code>HeroBiosAndContactsComponent</code> in action.</p><span>
</span><figure class="image-display"><img src="https://angular.io/resources/images/cookbooks/dependency-injection/hero-bios-and-contacts.png" alt="Bios with contact into"></figure><p>If we comment out the <code>@Host()</code> decorator, Angular now walks up the injector ancestor tree 
until it finds the logger at the <code>AppComponent</code> level. The logger logic kicks in and the hero display updates
with the gratuitous &quot;!!!&quot;, indicating that the logger was found.</p><span>
</span><figure class="image-display"><img src="https://angular.io/resources/images/cookbooks/dependency-injection/hero-bio-contact-no-host.png" alt="Without @Host"></figure><p>On the other hand, if we restore the <code>@Host()</code> decorator and comment out <code>@Optional</code>, 
the application fails for lack of the required logger at the host component level.
<br><code>EXCEPTION: No provider for LoggerService! (HeroContactComponent -&gt; LoggerService)</code></p><span>
</span><a id="component-element"></a><h2 id="inject-the-component-s-element">Inject the component&apos;s element</h2><span>
</span><p>On occasion we might need to access a component&apos;s corresponding DOM element. 
Although we strive to avoid it, many visual effects and 3rd party tools (such as jQuery)
require DOM access. </p><span>
</span><p>To illustrate, we&apos;ve written a simplified version of the <code>HighlightDirective</code> from 
the <a href="https://angular.io/docs/ts/latest/guide/attribute-directives.html">Attribute Directives</a> chapter.</p><span>
</span><p>app/highlight.directive.ts</p><code language="ts" format="linenums">import { Directive, ElementRef, HostListener, Input } from &apos;@angular/core&apos;;

@Directive({
  selector: &apos;[myHighlight]&apos;
})
export class HighlightDirective {

  @Input(&apos;myHighlight&apos;) highlightColor: string;

  private el: HTMLElement;

  constructor(el: ElementRef) {
    this.el = el.nativeElement;
  }

  @HostListener(&apos;mouseenter&apos;) onMouseEnter() {
    this.highlight(this.highlightColor || &apos;cyan&apos;);
  }

  @HostListener(&apos;mouseleave&apos;) onMouseLeave() {
    this.highlight(null);
  }

  private highlight(color: string) {
    this.el.style.backgroundColor = color;
  }
}
</code><p>The directive sets the background to a highlight color when the user mouses over the
DOM element to which it is applied.</p><span>
</span><p>Angular set the constructor&apos;s <code>el</code> parameter to the injected <code>ElementRef</code> which is 
a wrapper around that DOM element. 
Its <code>nativeElement</code> property exposes the DOM element for the directive to manipulate.</p><span>
</span><p>The sample code applies the directive&apos;s <code>myHighlight</code> attribute to two <code>&lt;div&gt;</code> tags, 
first without a value (yielding the default color) and then with an assigned color value.</p><span>
</span><p>app/app.component.html (highlight)</p><code language="html" format="">&lt;div id=&quot;highlight&quot;  class=&quot;di-component&quot;  myHighlight&gt;
  &lt;h3&gt;Hero Bios and Contacts&lt;/h3&gt;
  &lt;div myHighlight=&quot;yellow&quot;&gt;
    &lt;hero-bios-and-contacts&gt;&lt;/hero-bios-and-contacts&gt;
  &lt;/div&gt;
&lt;/div&gt;
</code><p>The following image shows the effect of mousing over the <code>&lt;hero-bios-and-contacts&gt;</code> tag.</p><span>
</span><figure class="image-display"><img src="https://angular.io/resources/images/cookbooks/dependency-injection/highlight.png" alt="Highlighted bios"></figure><span>
</span><a id="providers"></a><h2 id="define-dependencies-with-providers">Define dependencies with providers</h2><span>
</span><p>In this section we learn to write providers that deliver dependent services.</p><span>
</span><h3 id="background">Background</h3><span>
</span><p>We get a service from a dependency injector by giving it a <strong><em>token</em></strong>. </p><span>
</span><p>We usually let Angular handle this transaction for us by specifying a constructor parameter and its type.
The parameter type serves as the injector lookup <em>token</em>. 
Angular passes this token to the injector and assigns the result to the parameter.
Here&apos;s a typical example:</p><span>
</span><p>app/hero-bios.component.ts (component constructor injection)</p><code language="ts" format="">constructor(logger: LoggerService) {
  logger.logInfo(&apos;Creating HeroBiosComponent&apos;);
}
</code><p>Angular asks the injector for the service associated with the <code>LoggerService</code> and
and assigns the returned value to the <code>logger</code> parameter.</p><span>
</span><p>Where did the injector get that value?
It may already have that value in its internal container. 
If it doesn&apos;t, it may be able to make one with the help of a <strong><em>provider</em></strong>.
A <em>provider</em> is a recipe for delivering a service associated with a <em>token</em>.</p><span>
</span><div class="l-sub-section"><p>If the injector doesn&apos;t have a provider for the requested <em>token</em>, it delegates the request 
to its parent injector, where the process repeats until there are no more injectors. 
If the search is futile, the injector throws an error ... unless the request was <a href="https://angular.io/docs/ts/latest/cookbook/dependency-injection.html#optional">optional</a>.</p><span>
</span><p>Let&apos;s return our attention to providers themselves.</p><span>
</span></div><p>A new injector has no providers.
Angular initializes the injectors it creates with some providers it cares about.
We have to register our <em>own</em> application providers manually, 
usually in the <code>providers</code> array of the <code>Component</code> or <code>Directive</code> metadata:</p><span>
</span><p>app/app.component.ts (providers)</p><code language="ts" format="">providers: [LoggerService, UserContextService, UserService]
</code><h3 id="defining-providers">Defining providers</h3><span>
</span><p>The simple class provider is the most typical by far.
We mention the class in the <code>providers</code> array and we&apos;re done.</p><span>
</span><p>app/hero-bios.component.ts (class provider)</p><code language="ts" format="">providers: [HeroService]
</code><p>It&apos;s that simple because the most common injected service is an instance of a class.
But not every dependency can be satisfied by creating a new instance of a class.
We need other ways to deliver dependency values and that means we need other ways to specify a provider.</p><span>
</span><p>The <code>HeroOfTheMonthComponent</code> example demonstrates many of the alternatives and why we need them. </p><span>
</span><figure class="image-display"><img src="https://angular.io/resources/images/cookbooks/dependency-injection/hero-of-month.png" alt="Hero of the month" width="300px"></figure><p>It&apos;s visually simple: a few properties and the output of a logger. The code behind it gives us plenty to talk about.</p><span>
</span><p>hero-of-the-month.component.ts</p><code language="ts" format="linenums">import { Component, Inject } from &apos;@angular/core&apos;;

import { DateLoggerService,
         MinimalLogger }     from &apos;./date-logger.service&apos;;
import { Hero }              from &apos;./hero&apos;;
import { HeroService }       from &apos;./hero.service&apos;;
import { LoggerService }     from &apos;./logger.service&apos;;
import { RUNNERS_UP,
         runnersUpFactory }  from &apos;./runners-up&apos;;

@Component({
  selector: &apos;hero-of-the-month&apos;,
  template: template,
  providers: [
    { provide: Hero,          useValue:    someHero },
    { provide: TITLE,         useValue:   &apos;Hero of the Month&apos; },
    { provide: HeroService,   useClass:    HeroService },
    { provide: LoggerService, useClass:    DateLoggerService },
    { provide: MinimalLogger, useExisting: LoggerService },
    { provide: RUNNERS_UP,    useFactory:  runnersUpFactory(2), deps: [Hero, HeroService] }
  ]
})
export class HeroOfTheMonthComponent {
  logs: string[] = [];

  constructor(
      logger: MinimalLogger,
      public heroOfTheMonth: Hero,
      @Inject(RUNNERS_UP) public runnersUp: string,
      @Inject(TITLE) public title: string)
  {
    this.logs = logger.logs;
    logger.logInfo(&apos;starting up&apos;);
  }
}
</code><a id="provide"></a><h4 id="the-provide-object-literal">The <em>provide</em> object literal</h4><span>
</span><p>The <code>provide</code> object literal takes a <em>token</em> and a <em>definition object</em>.
The <em>token</em> is usually a class but <a href="https://angular.io/docs/ts/latest/cookbook/dependency-injection.html#tokens">it doesn&apos;t have to be</a>.</p><span>
</span><p>The <em>definition</em> object has one main property, (e.g. <code>useValue</code>) that indicates how the provider 
should create or return the provided value.</p><span>
</span><a id="usevalue"></a><h4 id="usevalue-the-value-provider-">useValue - the <em>value provider</em></h4><span>
</span><p>Set the <code>useValue</code> property to a <strong><em>fixed value</em></strong> that the provider can return as the dependency object.</p><span>
</span><p>Use this technique to provide <em>runtime configuration constants</em> such as web-site base addresses and feature flags.
We often use a <em>value provider</em> in a unit test to replace a production service with a fake or mock.</p><span>
</span><p>The <code>HeroOfTheMonthComponent</code> example has two <em>value providers</em>.
The first provides an instance of the <code>Hero</code> class; 
the second specifies a literal string resource:</p><span>
</span><code language="ts" format="">    { provide: Hero,          useValue:    someHero },
    { provide: TITLE,         useValue:   &apos;Hero of the Month&apos; },
</code><p>The <code>Hero</code> provider token is a class which makes sense because the value is a <code>Hero</code>
and the consumer of the injected hero would want the type information.</p><span>
</span><p>The <code>TITLE</code> provider token is <em>not a class</em>.
It&apos;s a special kind of provider lookup key called an <a href="https://angular.io/docs/ts/latest/cookbook/dependency-injection.html#opaquetoken">OpaqueToken</a>.
We often use an <code>OpaqueToken</code> when the dependency is a simple value like a string, a number, or a function.</p><span>
</span><p>The value of a <em>value provider</em> must be defined <em>now</em>. We can&apos;t create the value later. 
Obviously the title string literal is immediately available. 
The <code>someHero</code> variable in this example was set earlier in the file:</p><span>
</span><code language="ts" format="">const someHero = new Hero(42, &apos;Magma&apos;, &apos;Had a great month!&apos;, &apos;555-555-5555&apos;);
</code><p>The other providers create their values <em>lazily</em> when they&apos;re needed for injection.</p><span>
</span><a id="useclass"></a><h4 id="useclass-the-class-provider-">useClass - the <em>class provider</em></h4><span>
</span><p>The <code>useClass</code> provider creates and returns new instance of the specified class.</p><span>
</span><p>Use this technique to <strong><em>substitute an alternative implementation</em></strong> for a common or default class.
The alternative could implement a different strategy, extend the default class,
or fake the behavior of the real class in a test case.</p><span>
</span><p>We see two examples in the <code>HeroOfTheMonthComponent</code>:</p><span>
</span><code language="ts" format="">{ provide: HeroService,   useClass:    HeroService },
{ provide: LoggerService, useClass:    DateLoggerService },
</code><p>The first provider is the <em>de-sugared</em>, expanded form of the most typical case in which the
class to be created (<code>HeroService</code>) is also the provider&apos;s injection token. 
We wrote it in this long form to de-mystify the preferred short form.</p><span>
</span><p>The second provider substitutes the <code>DateLoggerService</code> for the <code>LoggerService</code>.
The <code>LoggerService</code> is already registered at the <code>AppComponent</code> level.
When <em>this component</em> requests the <code>LoggerService</code>, it receives the <code>DateLoggerService</code> instead.</p><span>
</span><div class="l-sub-section"><p>This component and its tree of child components receive the <code>DateLoggerService</code> instance.
Components outside the tree continue to receive the original <code>LoggerService</code> instance.</p><span>
</span></div><p>The <code>DateLoggerService</code> inherits from <code>LoggerService</code>; it appends the current date/time to each message:  </p><span>
</span><p>app/date-logger.service.ts</p><code language="ts" format="">@Injectable()
export class DateLoggerService extends LoggerService implements MinimalLogger
{
  logInfo(msg: any)  { super.logInfo(stamp(msg)); }
  logDebug(msg: any) { super.logInfo(stamp(msg)); }
  logError(msg: any) { super.logError(stamp(msg)); }
}

function stamp(msg: any) { return msg + &apos; at &apos; + new Date(); }
</code><a id="useexisting"></a><h4 id="useexisting-the-alias-provider-">useExisting - the <em>alias provider</em></h4><span>
</span><p>The <code>useExisting</code> provider maps one token to another. 
In effect, the first token is an <strong><em>alias</em></strong> for the service associated with second token,
creating <strong><em>two ways to access the same service object</em></strong>.</p><span>
</span><code language="ts" format="">{ provide: MinimalLogger, useExisting: LoggerService },
</code><p>Narrowing an API through an aliasing interface is <em>one</em> important use case for this technique.
We&apos;re aliasing for that very purpose here.
Imagine that the <code>LoggerService</code> had a large API (it&apos;s actually only three methods and a property).
We want to shrink that API surface to just the two members exposed by the <code>MinimalLogger</code> <a href="https://angular.io/docs/ts/latest/cookbook/dependency-injection.html#class-interface"><em>class-interface</em></a>:</p><span>
</span><p>app/date-logger.service.ts (MinimalLogger)</p><code language="ts" format="">// class used as a restricting interface (hides other public members)
export abstract class MinimalLogger {
  logInfo: (msg: string) =&gt; void;
  logs: string[];
}
</code><p>The constructor&apos;s <code>logger</code> parameter is typed as <code>MinimalLogger</code> so only its two members are visible in TypeScript:</p><span>
</span><figure class="image-display"><img src="https://angular.io/resources/images/cookbooks/dependency-injection/minimal-logger-intellisense.png" alt="MinimalLogger restricted API"></figure><p>Angular actually sets the <code>logger</code> parameter to the injector&apos;s full version of the <code>LoggerService</code> 
which happens to be the <code>DateLoggerService</code> thanks to the override provider registered previously via <code>useClass</code>.
The following image, which displays the logging date, confirms the point:</p><span>
</span><figure class="image-display"><img src="https://angular.io/resources/images/cookbooks/dependency-injection/date-logger-entry.png" alt="DateLoggerService entry" width="300px"></figure><a id="usefactory"></a><h4 id="usefactory-the-factory-provider-">useFactory - the <em>factory provider</em></h4><span>
</span><p>The <code>useFactory</code> provider creates a dependency object by calling a factory function
as seen in this example.</p><span>
</span><code language="ts" format="">{ provide: RUNNERS_UP,    useFactory:  runnersUpFactory(2), deps: [Hero, HeroService] }
</code><p>Use this technique to <strong><em>create a dependency object</em></strong> 
with a factory function whose inputs are some <strong><em>combination of injected services and local state</em></strong>.</p><span>
</span><p>The <em>dependency object</em> doesn&apos;t have to be a class instance. It could be anything.
In this example, the <em>dependency object</em> is a string of the names of the runners-up
to the &quot;Hero of the Month&quot; contest.</p><span>
</span><p>The local state is the number <code>2</code>, the number of runners-up this component should show.
We execute <code>runnersUpFactory</code> immediately with <code>2</code>. </p><span>
</span><p>The <code>runnersUpFactory</code> itself isn&apos;t the provider factory function.
The true provider factory function is the function that <code>runnersUpFactory</code> returns.</p><span>
</span><p>runners-up.ts (excerpt)</p><code language="ts" format="">export function runnersUpFactory(take: number) {
  return (winner: Hero, heroService: HeroService): string =&gt; {
    /* ... */
  };
};
</code><p>That returned function takes a winning <code>Hero</code> and a <code>HeroService</code> as arguments.</p><span>
</span><p>Angular supplies these arguments from injected values identified by 
the two <em>tokens</em> in the <code>deps</code> array. 
The two <code>deps</code> values are <em>tokens</em> that the injector uses
to provide these factory function dependencies.</p><span>
</span><p>After some undisclosed work, the function returns the string of names 
and Angular injects it into the <code>runnersUp</code> parameter of the <code>HeroOfTheMonthComponent</code>.</p><span>
</span><div class="l-sub-section"><p>The function retrieves candidate heroes from the <code>HeroService</code>, 
takes <code>2</code> of them to be the runners-up, and returns their concatenated names.
Look at the <live-example name="cb-dependency-injection"></live-example>
for the full source code.</p><span>
</span></div><a id="tokens"></a><h2 id="provider-token-alternatives-the-class-interface-and-opaquetoken-">Provider token alternatives: the <em>class-interface</em> and <em>OpaqueToken</em></h2><span>
</span><p>Angular dependency injection is easiest when the provider <em>token</em> is a class
that is also the type of the returned dependency object (what we usually call the <em>service</em>).</p><span>
</span><p>But the token doesn&apos;t have to be a class and even when it is a class,
it doesn&apos;t have to be the same type as the returned object.
That&apos;s the subject of our next section. </p><span>
</span><span>
</span><h3 id="class-interface">class-interface</h3><span>
</span><p>In the previous <em>Hero of the Month</em> example, we used the <code>MinimalLogger</code> class
as the token for a provider of a <code>LoggerService</code>.</p><span>
</span><code language="ts" format="">{ provide: MinimalLogger, useExisting: LoggerService },
</code><p>The <code>MinimalLogger</code> is an abstract class. </p><span>
</span><code language="ts" format="">// class used as a restricting interface (hides other public members)
export abstract class MinimalLogger {
  logInfo: (msg: string) =&gt; void;
  logs: string[];
}
</code><p>We usually inherit from an abstract class.
But <code>LoggerService</code> doesn&apos;t inherit from <code>MinimalLogger</code>. <em>No class</em> inherits from it.
Instead, we use it like an interface.</p><span>
</span><p>Look again at the declaration for <code>DateLoggerService</code></p><span>
</span><code language="ts" format="">export class DateLoggerService extends LoggerService implements MinimalLogger
</code><p><code>DateLoggerService</code> inherits (extends) from <code>LoggerService</code>, not <code>MinimalLogger</code>.
The <code>DateLoggerService</code> <em>implements</em> <code>MinimalLogger</code> as if <code>MinimalLogger</code> were an <em>interface</em>.</p><span>
</span><p>We call a class used in this way a <strong><em>class-interface</em></strong>.
The key benefit of a <em>class-interface</em> is that we can get the strong-typing of an interface
and we can <strong><em>use it as a provider token</em></strong> in the same manner as a normal class.</p><span>
</span><p>A <strong><em>class-interface</em></strong> should define <em>only</em> the members that its consumers are allowed to call.
Such a narrowing interface helps decouple the concrete class from its consumers.
The <code>MinimalLogger</code> defines just two of the <code>LoggerClass</code> members.</p><span>
</span><div class="l-sub-section"><h4 id="why-minimallogger-is-a-class-and-not-an-interface">Why <em>MinimalLogger</em> is a class and not an interface</h4><span>
</span><p>We can&apos;t use an interface as a provider token because 
interfaces are not JavaScript objects. 
They exist only in the TypeScript design space. 
They disappear after the code is transpiled to JavaScript.</p><span>
</span><p>A provider token must be a real JavaScript object of some kind: 
a function, an object, a string ... a class.</p><span>
</span><p>Using a class as an interface gives us the characteristics of an interface in a JavaScript object.</p><span>
</span><p>The minimize memory cost, the class should have <em>no implementation</em>. 
The <code>MinimalLogger</code> transpiles to this unoptimized, pre-minified JavaScript:</p><span>
</span><code language="ts" format="">var MinimalLogger = (function () {
  function MinimalLogger() {}
  return MinimalLogger;
}());
exports(&quot;MinimalLogger&quot;, MinimalLogger);
</code><p>It never grows larger no matter how many members we add <em>as long as they are typed but not implemented</em>.</p><span>
</span></div><a id="opaque-token"></a><h3 id="opaquetoken">OpaqueToken</h3><span>
</span><p>Dependency objects can be simple values like dates, numbers and strings or 
shapeless objects like arrays and functions.</p><span>
</span><p>Such objects don&apos;t have application interfaces and therefore aren&apos;t well represented by a class.
They&apos;re better represented by a token that is both unique and symbolic, 
a JavaScript object that has a friendly name but won&apos;t conflict with 
another token that happens to have the same name.</p><span>
</span><p>The <code>OpaqueToken</code> has these characteristics.
We encountered them twice in the <em>Hero of the Month</em> example, 
in the <em>title</em> value provider and in the <em>runnersUp</em> factory provider.</p><span>
</span><code language="ts" format="">{ provide: TITLE,         useValue:   &apos;Hero of the Month&apos; },
{ provide: RUNNERS_UP,    useFactory:  runnersUpFactory(2), deps: [Hero, HeroService] }
</code><p>We created the <code>TITLE</code> token like this:</p><span>
</span><code language="ts" format="">import { OpaqueToken } from &apos;@angular/core&apos;;

export const TITLE = new OpaqueToken(&apos;title&apos;);
</code><a id="di-inheritance"></a><h2 id="inject-into-a-derived-class">Inject into a derived class</h2><span>
</span><p>We must take care when writing a component that inherits from another component.
If the base component has injected dependencies, 
we must re-provide and re-inject them in the derived class
and then pass them down to the base class through the constructor.</p><span>
</span><p>In this contrived example, <code>SortedHeroesComponent</code> inherits from <code>HeroesBaseComponent</code> 
to display a <em>sorted</em> list of heroes.</p><span>
</span><figure class="image-display"><img src="https://angular.io/resources/images/cookbooks/dependency-injection/sorted-heroes.png" alt="Sorted Heroes"></figure><p>The <code>HeroesBaseComponent</code> could stand on its own.
It demands its own instance of the <code>HeroService</code> to get heroes
and displays them in the order they arrive from the database.</p><span>
</span><p>app/sorted-heroes.component.ts (HeroesBaseComponent)</p><code language="ts" format="linenums">@Component({
  selector: &apos;unsorted-heroes&apos;,
  template: `&lt;div *ngFor=&quot;let hero of heroes&quot;&gt;{{hero.name}}&lt;/div&gt;`,
  providers: [HeroService]
})
export class HeroesBaseComponent implements OnInit {
  constructor(private heroService: HeroService) { }

  heroes: Array&lt;Hero&gt;;

  ngOnInit() {
    this.heroes = this.heroService.getAllHeroes();
    this.afterGetHeroes();
  }

  // Post-process heroes in derived class override.
  protected afterGetHeroes() {}

}
</code><div class="l-sub-section"><p>We strongly prefer simple constructors. They should do little more than initialize variables.
This rule makes the component safe to construct under test without fear that it will do something dramatic like talk to the server.
That&apos;s why we call the <code>HeroService</code> from within the <code>ngOnInit</code> rather than the constructor.</p><span>
</span><p>We explain the mysterious <code>afterGetHeroes</code> below.</p><span>
</span></div><p>Users want to see the heroes in alphabetical order.
Rather than modify the original component, we sub-class it and create a
<code>SortedHeroesComponent</code> that sorts the heroes before presenting them.
The <code>SortedHeroesComponent</code> lets the base class fetch the heroes.
(we said it was contrived).</p><span>
</span><p>Unfortunately, Angular cannot inject the <code>HeroService</code> directly into the base class.
We must provide the <code>HeroService</code> again for <em>this</em> component, 
then pass it down to the base class inside the constructor.</p><span>
</span><p>app/sorted-heroes.component.ts (SortedHeroesComponent)</p><code language="ts" format="linenums">@Component({
  selector: &apos;sorted-heroes&apos;,
  template: `&lt;div *ngFor=&quot;let hero of heroes&quot;&gt;{{hero.name}}&lt;/div&gt;`,
  providers: [HeroService]
})
export class SortedHeroesComponent extends HeroesBaseComponent {
  constructor(heroService: HeroService) {
    super(heroService);
  }

  protected afterGetHeroes() {
    this.heroes = this.heroes.sort((h1, h2) =&gt; {
      return h1.name &lt; h2.name ? -1 :
            (h1.name &gt; h2.name ? 1 : 0);
    });
  }
}
</code><p>Now take note of the <code>afterGetHeroes</code> method. 
Our first instinct was to create an <code>ngOnInit</code> method in <code>SortedHeroesComponent</code> and do the sorting there.
But Angular calls the <em>derived</em> class&apos;s <code>ngOnInit</code> <em>before</em> calling the base class&apos;s <code>ngOnInit</code> 
so we&apos;d be sorting the heroes array <em>before they arrived</em>. That produces a nasty error.</p><span>
</span><p>Overriding the base class&apos;s <code>afterGetHeroes</code> method solves the problem</p><span>
</span><p>These complications argue for <em>avoiding component inheritance</em>. </p><span>
</span><a id="find-parent"></a><h2 id="find-a-parent-component-by-injection">Find a parent component by injection</h2><span>
</span><p>Application components often need to share information.
We prefer the more loosely coupled techniques such as data binding and service sharing.
But sometimes it makes sense for one component to have a direct reference to another component
perhaps to access values or call methods on that component.</p><span>
</span><p>Obtaining a component reference is a bit tricky in Angular.
Although an Angular application is a tree of components,
there is no public API for inspecting and traversing that tree. </p><span>
</span><p>There is an API for acquiring a child reference
(checkout <code>Query</code>, <code>QueryList</code>, <code>ViewChildren</code>, and <code>ContentChildren</code>).</p><span>
</span><p>There is no public API for acquiring a parent reference.
But because every component instance is added to an injector&apos;s container,
we can use Angular dependency injection to reach a parent component.</p><span>
</span><p>This section describes some techniques for doing that.</p><span>
</span><span>
</span><h3 id="find-a-parent-component-of-known-type">Find a parent component of known type</h3><span>
</span><p>We use standard class injection to acquire a parent component whose type we know.</p><span>
</span><p>In the following example, the parent <code>AlexComponent</code> has several children including a <code>CathyComponent</code>:</p><span>
</span><a id="alex"></a><p>parent-finder.component.ts (AlexComponent v.1)</p><code language="ts" format="">@Component({
  selector: &apos;alex&apos;,
  template: `
    &lt;div class=&quot;a&quot;&gt;
      &lt;h3&gt;{{name}}&lt;/h3&gt;
      &lt;cathy&gt;&lt;/cathy&gt;
      &lt;craig&gt;&lt;/craig&gt;
      &lt;carol&gt;&lt;/carol&gt;
    &lt;/div&gt;`,
})
export class AlexComponent extends Base
{
  name= &apos;Alex&apos;;
}
</code><p><em>Cathy</em> reports whether or not she has access to <em>Alex</em>
after injecting an <code>AlexComponent</code> into her constructor:</p><span>
</span><p>parent-finder.component.ts (CathyComponent)</p><code language="ts" format="">@Component({
  selector: &apos;cathy&apos;,
  template: `
  &lt;div class=&quot;c&quot;&gt;
    &lt;h3&gt;Cathy&lt;/h3&gt;
    {{alex ? &apos;Found&apos; : &apos;Did not find&apos;}} Alex via the component class.&lt;br&gt;
  &lt;/div&gt;`
})
export class CathyComponent {
  constructor( @Optional() public alex: AlexComponent ) { }
}
</code><p>We added the <a href="https://angular.io/docs/ts/latest/cookbook/dependency-injection.html#optional">@Optional</a> qualifier for safety but
the <live-example name="cb-dependency-injection"></live-example>
confirms that the <code>alex</code> parameter is set.</p><span>
</span><span>
</span><h3 id="cannot-find-a-parent-by-its-base-class">Cannot find a parent by its base class</h3><span>
</span><p>What if we do <em>not</em> know the concrete parent component class?</p><span>
</span><p>A re-usable component might be a child of multiple components.
Imagine a component for rendering breaking news about a financial instrument.
For sound (cough) business reasons, this news component makes frequent calls 
directly into its parent instrument as changing market data stream by.</p><span>
</span><p>The app probably defines more than a dozen financial instrument components.
If we&apos;re lucky, they all implement the same base class
whose API our <code>NewsComponent</code> understands.</p><span>
</span><div class="l-sub-section"><p>Looking for components that implement an interface would be better.
That&apos;s not possible because TypeScript interfaces disappear from the transpiled JavaScript
which doesn&apos;t support interfaces. There&apos;s no artifact we could look for.</p><span>
</span></div><p>We&apos;re not claiming this is good design. 
We are asking <em>can a component inject its parent via the parent&apos;s base class</em>?</p><span>
</span><p>The sample&apos;s <code>CraigComponent</code> explores this question. <a href="https://angular.io/docs/ts/latest/cookbook/dependency-injection.html#alex">Looking back</a> 
we see that the <code>Alex</code> component <em>extends</em> (<em>inherits</em>) from a class named <code>Base</code>.</p><span>
</span><p>parent-finder.component.ts (Alex class signature)</p><code language="ts" format="">export class AlexComponent extends Base
</code><p>The <code>CraigComponent</code> tries to inject <code>Base</code> into its <code>alex</code> constructor parameter and reports if it succeeded.</p><span>
</span><p>parent-finder.component.ts (CraigComponent)</p><code language="ts" format="">@Component({
  selector: &apos;craig&apos;,
  template: `
  &lt;div class=&quot;c&quot;&gt;
    &lt;h3&gt;Craig&lt;/h3&gt;
    {{alex ? &apos;Found&apos; : &apos;Did not find&apos;}} Alex via the base class.
  &lt;/div&gt;`
})
export class CraigComponent {
  constructor( @Optional() public alex: Base ) { }
}
</code><p>Unfortunately, this does not work. 
The <live-example name="cb-dependency-injection"></live-example>
confirms that the <code>alex</code> parameter is null.
<em>We cannot inject a parent by its base class.</em></p><span>
</span><span>
</span><h3 id="find-a-parent-by-its-class-interface">Find a parent by its class-interface</h3><span>
</span><p>We can find a parent component with a <a href="https://angular.io/docs/ts/latest/cookbook/dependency-injection.html#class-interface">class-interface</a>.</p><span>
</span><p>The parent must cooperate by providing an <em>alias</em> to itself in the name of a <em>class-interface</em> token. </p><span>
</span><p>Recall that Angular always adds a component instance to its own injector; 
that&apos;s why we could inject <em>Alex</em> into <em>Carol</em> <a href="https://angular.io/docs/ts/latest/cookbook/dependency-injection.html#known-parent">earlier</a>.</p><span>
</span><p>We write an <a href="https://angular.io/docs/ts/latest/cookbook/dependency-injection.html#useexisting"><em>alias provider</em></a> &#x2014; a <code>provide</code> object literal with a <code>useExisting</code> definition &#x2014;
that creates an <em>alternative</em> way to inject the same component instance
and add that provider to the <code>providers</code> array of the <code>@Component</code> metadata for the <code>AlexComponent</code>:</p><span>
</span><a id="alex-providers"></a><p>parent-finder.component.ts (AlexComponent providers)</p><code language="ts" format="">providers: [{ provide: Parent, useExisting: forwardRef(() =&gt; AlexComponent) }],
</code><p><a href="https://angular.io/docs/ts/latest/cookbook/dependency-injection.html#parent-token">Parent</a> is the provider&apos;s <em>class-interface</em> token. 
The <a href="https://angular.io/docs/ts/latest/cookbook/dependency-injection.html#forwardref"><em>forwardRef</em></a> breaks the circular reference we just created by having the <code>AlexComponent</code> refer to itself.</p><span>
</span><p><em>Carol</em>, the third of <em>Alex</em>&apos;s child components, injects the parent into its <code>parent</code> parameter, the same way we&apos;ve done it before:</p><span>
</span><p>parent-finder.component.ts (CarolComponent class)</p><code language="ts" format="">export class CarolComponent {
  name= &apos;Carol&apos;;
  constructor( @Optional() public parent: Parent ) { }
}
</code><p>Here&apos;s <em>Alex</em> and family in action:</p><span>
</span><figure class="image-display"><img src="https://angular.io/resources/images/cookbooks/dependency-injection/alex.png" alt="Alex in action"></figure><a id="parent-tree"></a><h3 id="find-the-parent-in-a-tree-of-parents">Find the parent in a tree of parents</h3><span>
</span><p>Imagine one branch of a component hierarchy: <em>Alice</em> -&gt; <em>Barry</em> -&gt; <em>Carol</em>. 
Both <em>Alice</em> and <em>Barry</em> implement the <code>Parent</code> <em>class-interface</em>.</p><span>
</span><p><em>Barry</em> is the problem. He needs to reach his parent, <em>Alice</em>, and also be a parent to <em>Carol</em>.
That means he must both <em>inject</em> the <code>Parent</code> <em>class-interface</em> to get <em>Alice</em> and
<em>provide</em> a <code>Parent</code> to satisfy <em>Carol</em>.</p><span>
</span><p>Here&apos;s <em>Barry</em>:</p><span>
</span><p>parent-finder.component.ts (BarryComponent)</p><code language="ts" format="">const templateB = `
  &lt;div class=&quot;b&quot;&gt;
    &lt;div&gt;
      &lt;h3&gt;{{name}}&lt;/h3&gt;
      &lt;p&gt;My parent is {{parent?.name}}&lt;/p&gt;
    &lt;/div&gt;
    &lt;carol&gt;&lt;/carol&gt;
    &lt;chris&gt;&lt;/chris&gt;
  &lt;/div&gt;`;

@Component({
  selector:   &apos;barry&apos;,
  template:   templateB,
  providers:  [{ provide: Parent, useExisting: forwardRef(() =&gt; BarryComponent) }]
})
export class BarryComponent implements Parent {
  name = &apos;Barry&apos;;
  constructor( @SkipSelf() @Optional() public parent: Parent ) { }
}
</code><p><em>Barry</em>&apos;s <code>providers</code> array looks just like <a href="https://angular.io/docs/ts/latest/cookbook/dependency-injection.html#alex-providers"><em>Alex</em>&apos;s</a>.
If we&apos;re going to keep writing <a href="https://angular.io/docs/ts/latest/cookbook/dependency-injection.html#useexisting"><em>alias providers</em></a> like this we should create a <a href="https://angular.io/docs/ts/latest/cookbook/dependency-injection.html#provideparent">helper function</a>.</p><span>
</span><p>For now, focus on <em>Barry</em>&apos;s constructor:</p><span>
</span><code-tabs><code language="ts" name="Barry&apos;s constructor" format=".">constructor( @SkipSelf() @Optional() public parent: Parent ) { }
</code><code language="ts" name="Carol&apos;s constructor" format=".">constructor( @Optional() public parent: Parent ) { }
</code></code-tabs><p>It&apos;s identical to <em>Carol</em>&apos;s constructor except for the additional <code>@SkipSelf</code> decorator.</p><span>
</span><p><code>@SkipSelf</code> is essential for two reasons:</p><span>
</span><ol>
<li><p>It tell the injector to start its search for a <code>Parent</code> dependency in a component <em>above</em> itself,
which <em>is</em> what parent means.</p>
</li>
<li><p>Angular throws a cyclic dependency error if we omit the <code>@SkipSelf</code> decorator.</p>
<p><code>Cannot instantiate cyclic dependency! (BethComponent -&gt; Parent -&gt; BethComponent)</code></p>
</li>
</ol><span>
</span><p>Here&apos;s <em>Alice</em>, <em>Barry</em> and family in action:</p><span>
</span><figure class="image-display"><img src="https://angular.io/resources/images/cookbooks/dependency-injection/alice.png" alt="Alice in action"></figure><a id="parent-token"></a><h3 id="the-parent-class-interface">The <em>Parent</em> class-interface</h3><span>
</span><p>We <a href="https://angular.io/docs/ts/latest/cookbook/dependency-injection.html#class-interface">learned earlier</a> that a <em>class-interface</em> is an abstract class used as an interface rather than as a base class.</p><span>
</span><p>Our example defines a <code>Parent</code> <em>class-interface</em> .</p><span>
</span><p>parent-finder.component.ts (Parent class-interface)</p><code language="ts" format="">export abstract class Parent { name: string; }
</code><p>The <code>Parent</code> <em>class-interface</em> defines a <code>name</code> property with a type declaration but <em>no implementation</em>., 
The <code>name</code> property is the only member of a parent component that a child component can call.
Such a narrowing interface helps decouple the child component class from its parent components.</p><span>
</span><p>A component that could serve as a parent <em>should</em> implement the <em>class-interface</em> as the <code>AliceComponent</code> does:</p><span>
</span><p>parent-finder.component.ts (AliceComponent class signature)</p><code language="ts" format="">export class AliceComponent implements Parent
</code><p>Doing so adds clarity to the code.  But it&apos;s not technically necessary. 
Although the <code>AlexComponent</code> has a <code>name</code> property (as required by its <code>Base</code> class) 
its class signature doesn&apos;t mention <code>Parent</code>:</p><span>
</span><p>parent-finder.component.ts (AlexComponent class signature)</p><code language="ts" format="">export class AlexComponent extends Base
</code><div class="l-sub-section"><p>The <code>AlexComponent</code> <em>should</em> implement <code>Parent</code> as a matter of proper style. 
It doesn&apos;t in this example <em>only</em> to demonstrate that the code will compile and run without the interface </p><span>
</span></div><a id="provideparent"></a><h3 id="a-provideparent-helper-function">A <em>provideParent</em> helper function</h3><span>
</span><p>Writing variations of the same parent <em>alias provider</em> gets old quickly, 
especially this awful mouthful with a <a href="https://angular.io/docs/ts/latest/cookbook/dependency-injection.html#forwardref"><em>forwardRef</em></a>:</p><span>
</span><code language="ts" format="">providers: [{ provide: Parent, useExisting: forwardRef(() =&gt; AlexComponent) }],
</code><p>We can extract that logic into a helper function like this:</p><span>
</span><code language="ts" format="">// Helper method to provide the current component instance in the name of a `parentType`.
const provideParent =
  (component: any) =&gt; {
    return { provide: Parent, useExisting: forwardRef(() =&gt; component) };
  };
</code><p>Now we can add a simpler, more meaningful parent provider to our components:</p><span>
</span><code language="ts" format="">providers:  [ provideParent(AliceComponent) ]
</code><p>We can do better. The current version of the helper function can only alias the <code>Parent</code> <em>class-interface</em>.
Our application might have a variety of parent types, each with its own <em>class-interface</em> token.</p><span>
</span><p>Here&apos;s a revised version that defaults to <code>parent</code> but also accepts an optional second parameter for a different parent <em>class-interface</em>.</p><span>
</span><code language="ts" format="">// Helper method to provide the current component instance in the name of a `parentType`.
// The `parentType` defaults to `Parent` when omitting the second parameter.
const provideParent =
  (component: any, parentType?: any) =&gt; {
    return { provide: parentType || Parent, useExisting: forwardRef(() =&gt; component) };
  };
</code><p>And here&apos;s how we could use it with a different parent type:</p><span>
</span><code language="ts" format="">providers:  [ provideParent(BethComponent, DifferentParent) ]
</code><a id="forwardref"></a><h2 id="break-circularities-with-a-forward-class-reference-forwardref-">Break circularities with a forward class reference (<em>forwardRef</em>)</h2><span>
</span><p>The order of class declaration matters in TypeScript.
We can&apos;t refer directly to a class until it&apos;s been defined.</p><span>
</span><p>This isn&apos;t usually a problem, especially if we adhere to the recommended <em>one class per file</em> rule.
But sometimes circular references are unavoidable. 
We&apos;re in a bind when class &apos;A refers to class &apos;B&apos; and &apos;B&apos; refers to &apos;A&apos;.
One of them has to be defined first. </p><span>
</span><p>The Angular <code>forwardRef</code> function creates an <em>indirect</em> reference that Angular can resolve later.</p><span>
</span><p>The <em>Parent Finder</em> sample is full of circular class references that are impossible to break.</p><span>
</span><p>We face this dilemma when a class makes <em>a reference to itself</em>
as does the <code>AlexComponent</code> in its <code>providers</code> array. 
The <code>providers</code> array is a property of the <code>@Component</code> decorator function which must
appear <em>above</em> the class definition.</p><span>
</span><p>We break the circularity with <code>forwardRef</code>:</p><span>
</span><p>parent-finder.component.ts (AlexComponent providers)</p><code language="ts" format="">providers: [{ provide: Parent, useExisting: forwardRef(() =&gt; AlexComponent) }],
</code></div></div>
        </article>
      
        <article>
          <h3>Dynamic Forms</h3>
          <div><div class="showcase-content"><p>We can&apos;t always justify the cost and time to build handcrafted forms, 
especially if we&apos;ll need a great number of them, they&apos;re similar to each other, and they change frequently 
to meet rapidly changing business and regulatory requirements.</p><span>
</span><p>It may be more economical to create the forms dynamically, based on metadata that describe the business object model.</p><span>
</span><p>In this cookbook we show how to use <code>formGroup</code> to dynamically render a simple form with different control types and validation.
It&apos;s a primitive start. 
It might evolve to support a much richer variety of questions, more graceful rendering, and superior user experience.
All such greatness has humble beginnings.</p><span>
</span><p>In our example we use a dynamic form to build an online application experience for heroes seeking employment.
The agency is constantly tinkering with the application process.
We can create the forms on the fly <em>without changing our application code</em>. </p><span>
</span><a id="toc"></a><h2 id="table-of-contents">Table of contents</h2><span>
</span><p>   <a href="https://angular.io/docs/ts/latest/cookbook/dynamic-form.html#bootstrap">Bootstrap</a></p><span>
</span><p>   <a href="https://angular.io/docs/ts/latest/cookbook/dynamic-form.html#object-model">Question Model</a></p><span>
</span><p>   <a href="https://angular.io/docs/ts/latest/cookbook/dynamic-form.html#form-component">Form Component</a></p><span>
</span><p>   <a href="https://angular.io/docs/ts/latest/cookbook/dynamic-form.html#questionnaire-metadata">Questionnaire Metadata</a></p><span>
</span><p>   <a href="https://angular.io/docs/ts/latest/cookbook/dynamic-form.html#dynamic-template">Dynamic Template</a></p><span>
</span><p><strong>See the <live-example name="cb-dynamic-form"></live-example></strong>.</p><span>
</span><a id="bootstrap"></a><h2 id="bootstrap">Bootstrap</h2><span>
</span><p>We start by creating an <code>NgModule</code> called <code>AppModule</code>.</p><span>
</span><p>In our example we will be using Reactive Forms. </p><span>
</span><p>Reactive Forms belongs to a different <code>NgModule</code> called <code>ReactiveFormsModule</code>, so in order to access any Reactive Forms directives, we have to import <code>ReactiveFormsModule</code> from <code>AppModule</code>.    </p><span>
</span><p>We bootstrap our <code>AppModule</code> in main.ts.</p><span>
</span><code-tabs><code language="ts" name="app.module.ts" format="linenums">import { BrowserModule }                from &apos;@angular/platform-browser&apos;;
import { ReactiveFormsModule }          from &apos;@angular/forms&apos;;
import { NgModule }                     from &apos;@angular/core&apos;;

import { AppComponent }                 from &apos;./app.component&apos;;
import { DynamicFormComponent }         from &apos;./dynamic-form.component&apos;;
import { DynamicFormQuestionComponent } from &apos;./dynamic-form-question.component&apos;;

@NgModule({
  imports: [ BrowserModule, ReactiveFormsModule ],
  declarations: [ AppComponent, DynamicFormComponent, DynamicFormQuestionComponent ],
  bootstrap: [ AppComponent ]
})
export class AppModule {
  constructor() {
  }
}
</code><code language="ts" name="main.ts" format="linenums">import { platformBrowserDynamic } from &apos;@angular/platform-browser-dynamic&apos;;
import { AppModule } from &apos;./app.module&apos;;

platformBrowserDynamic().bootstrapModule(AppModule);
</code></code-tabs><a id="object-model"></a><h2 id="question-model">Question Model</h2><span>
</span><p>The next step is to define an object model that can describe all scenarios needed by the form functionality.
The hero application process involves a form with a lot of questions. 
The &quot;question&quot; is the most fundamental object in the model.</p><span>
</span><p>We have created <code>QuestionBase</code> as the most fundamental question class.</p><span>
</span><p>app/question-base.ts</p><code language="ts" format="linenums">export class QuestionBase&lt;T&gt;{
  value: T;
  key: string;
  label: string;
  required: boolean;
  order: number;
  controlType: string;

  constructor(options: {
      value?: T,
      key?: string,
      label?: string,
      required?: boolean,
      order?: number,
      controlType?: string
    } = {}) {
    this.value = options.value;
    this.key = options.key || &apos;&apos;;
    this.label = options.label || &apos;&apos;;
    this.required = !!options.required;
    this.order = options.order === undefined ? 1 : options.order;
    this.controlType = options.controlType || &apos;&apos;;
  }
}
</code><p>From this base we derived two new classes in <code>TextboxQuestion</code> and <code>DropdownQuestion</code> that represent Textbox and Dropdown questions. 
The idea is that the form will be bound to specific question types and render the appropriate controls dynamically. </p><span>
</span><p><code>TextboxQuestion</code> supports multiple html5 types like text, email, url etc via the <code>type</code> property.</p><span>
</span><p>app/question-textbox.ts</p><code language="ts" format="">import { QuestionBase } from &apos;./question-base&apos;;

export class TextboxQuestion extends QuestionBase&lt;string&gt; {
  controlType = &apos;textbox&apos;;
  type: string;

  constructor(options: {} = {}) {
    super(options);
    this.type = options[&apos;type&apos;] || &apos;&apos;;
  }
}
</code><p><code>DropdownQuestion</code> presents a list of choices in a select box.</p><span>
</span><p>app/question-dropdown.ts</p><code language="ts" format="">import { QuestionBase } from &apos;./question-base&apos;;

export class DropdownQuestion extends QuestionBase&lt;string&gt; {
  controlType = &apos;dropdown&apos;;
  options: {key: string, value: string}[] = [];

  constructor(options: {} = {}) {
    super(options);
    this.options = options[&apos;options&apos;] || [];
  }
}
</code><p>Next we have defined <code>QuestionControlService</code>, a simple service for transforming our questions to a <code>FormGroup</code>. 
In a nutshell, the form group consumes the metadata from the question model and allows us to specify default values and validation rules.</p><span>
</span><p>app/question-control.service.ts</p><code language="ts" format="">import { Injectable }   from &apos;@angular/core&apos;;
import { FormControl, FormGroup, Validators } from &apos;@angular/forms&apos;;

import { QuestionBase } from &apos;./question-base&apos;;

@Injectable()
export class QuestionControlService {
  constructor() { }

  toFormGroup(questions: QuestionBase&lt;any&gt;[] ) {
    let group: any = {};

    questions.forEach(question =&gt; {
      group[question.key] = question.required ? new FormControl(question.value || &apos;&apos;, Validators.required)
                                              : new FormControl(question.value || &apos;&apos;);
    });
    return new FormGroup(group);
  }
}
</code><a id="form-component"></a><h2 id="question-form-components">Question form components</h2><span>
</span><p>Now that we have defined the complete model we are ready to create components to represent the dynamic form.</p><span>
</span><p><code>DynamicFormComponent</code> is the entry point and the main container for the form. </p><span>
</span><code-tabs><code language="html" name="dynamic-form.component.html" format="linenums">&lt;div&gt;
  &lt;form (ngSubmit)=&quot;onSubmit()&quot; [formGroup]=&quot;form&quot;&gt;

    &lt;div *ngFor=&quot;let question of questions&quot; class=&quot;form-row&quot;&gt;
      &lt;df-question [question]=&quot;question&quot; [form]=&quot;form&quot;&gt;&lt;/df-question&gt;
    &lt;/div&gt;

    &lt;div class=&quot;form-row&quot;&gt;
      &lt;button type=&quot;submit&quot; [disabled]=&quot;!form.valid&quot;&gt;Save&lt;/button&gt;
    &lt;/div&gt;
  &lt;/form&gt;

  &lt;div *ngIf=&quot;payLoad&quot; class=&quot;form-row&quot;&gt;
    &lt;strong&gt;Saved the following values&lt;/strong&gt;&lt;br&gt;{{payLoad}}
  &lt;/div&gt;
&lt;/div&gt;
</code><code language="ts" name="dynamic-form.component.ts" format="linenums">import { Component, Input, OnInit }  from &apos;@angular/core&apos;;
import { FormGroup }                 from &apos;@angular/forms&apos;;

import { QuestionBase }              from &apos;./question-base&apos;;
import { QuestionControlService }    from &apos;./question-control.service&apos;;

@Component({
  selector: &apos;dynamic-form&apos;,
  templateUrl: &apos;app/dynamic-form.component.html&apos;,
  providers: [ QuestionControlService ]
})
export class DynamicFormComponent implements OnInit {

  @Input() questions: QuestionBase&lt;any&gt;[] = [];
  form: FormGroup;
  payLoad = &apos;&apos;;

  constructor(private qcs: QuestionControlService) {  }

  ngOnInit() {
    this.form = this.qcs.toFormGroup(this.questions);
  }

  onSubmit() {
    this.payLoad = JSON.stringify(this.form.value);
  }
}
</code></code-tabs><p>It presents a list of questions, each question bound to a <code>&lt;df-question&gt;</code> component element.
The <code>&lt;df-question&gt;</code> tag matches the <code>DynamicFormQuestionComponent</code>,
the component responsible for rendering the details of each <em>individual</em> question based on values in the data-bound question object.  </p><span>
</span><code-tabs><code language="html" name="dynamic-form-question.component.html" format="linenums">&lt;div [formGroup]=&quot;form&quot;&gt;
  &lt;label [attr.for]=&quot;question.key&quot;&gt;{{question.label}}&lt;/label&gt;

  &lt;div [ngSwitch]=&quot;question.controlType&quot;&gt;

    &lt;input *ngSwitchCase=&quot;&apos;textbox&apos;&quot; [formControlName]=&quot;question.key&quot;
            [id]=&quot;question.key&quot; [type]=&quot;question.type&quot;&gt;

    &lt;select [id]=&quot;question.key&quot; *ngSwitchCase=&quot;&apos;dropdown&apos;&quot; [formControlName]=&quot;question.key&quot;&gt;
      &lt;option *ngFor=&quot;let opt of question.options&quot; [value]=&quot;opt.key&quot;&gt;{{opt.value}}&lt;/option&gt;
    &lt;/select&gt;

  &lt;/div&gt; 

  &lt;div class=&quot;errorMessage&quot; *ngIf=&quot;!isValid&quot;&gt;{{question.label}} is required&lt;/div&gt;
&lt;/div&gt;
</code><code language="ts" name="dynamic-form-question.component.ts" format="linenums">import { Component, Input } from &apos;@angular/core&apos;;
import { FormGroup } from &apos;@angular/forms&apos;;

import { QuestionBase }     from &apos;./question-base&apos;;

@Component({
  selector: &apos;df-question&apos;,
  templateUrl: &apos;app/dynamic-form-question.component.html&apos;
})
export class DynamicFormQuestionComponent {
  @Input() question: QuestionBase&lt;any&gt;;
  @Input() form: FormGroup;
  get isValid() { return this.form.controls[this.question.key].valid; }
}
</code></code-tabs><p>Notice this component can present any type of question in our model. 
We only have two types of questions at this point but we can imagine many more.
The <code>ngSwitch</code> determines which type of question to display.</p><span>
</span><p>In both components  we&apos;re relying on Angular&apos;s <strong>formGroup</strong> to connect the template HTML to the
underlying control objects, populated from the question model with display and validation rules.</p><span>
</span><p><code>formControlName</code> and <code>formGroup</code> are directives defined in <code>ReactiveFormsModule</code>. Our templates can can access these directives directly since we imported <code>ReactiveFormsModule</code> from <code>AppModule</code>.  </p><span>
</span><h2 id="questionnaire-data">Questionnaire data</h2><span>
</span><p><code>DynamicFormComponent</code> expects the list of questions in the form of an array bound to  <code>@Input() questions</code>.</p><span>
</span><p> The set of questions we have defined for the job application is returned from the <code>QuestionService</code>. 
 In a real app we&apos;d retrieve these questions from storage.</p><span>
</span><p> The key point is that we control the hero job application questions entirely through the objects returned from <code>QuestionService</code>. 
 Questionnaire maintenance is a simple matter of adding, updating, and removing objects from the <code>questions</code> array.</p><span>
</span><p>app/question.service.ts</p><code language="ts" format="linenums">import { Injectable }       from &apos;@angular/core&apos;;

import { DropdownQuestion } from &apos;./question-dropdown&apos;;
import { QuestionBase }     from &apos;./question-base&apos;;
import { TextboxQuestion }  from &apos;./question-textbox&apos;;

@Injectable()
export class QuestionService {

  // Todo: get from a remote source of question metadata
  // Todo: make asynchronous
  getQuestions() {

    let questions: QuestionBase&lt;any&gt;[] = [

      new DropdownQuestion({
        key: &apos;brave&apos;,
        label: &apos;Bravery Rating&apos;,
        options: [
          {key: &apos;solid&apos;,  value: &apos;Solid&apos;},
          {key: &apos;great&apos;,  value: &apos;Great&apos;},
          {key: &apos;good&apos;,   value: &apos;Good&apos;},
          {key: &apos;unproven&apos;, value: &apos;Unproven&apos;}
        ],
        order: 3
      }),

      new TextboxQuestion({
        key: &apos;firstName&apos;,
        label: &apos;First name&apos;,
        value: &apos;Bombasto&apos;,
        required: true,
        order: 1
      }),

      new TextboxQuestion({
        key: &apos;emailAddress&apos;,
        label: &apos;Email&apos;,
        type: &apos;email&apos;,
        order: 2
      })
    ];

    return questions.sort((a, b) =&gt; a.order - b.order);
  }
}
</code><p>Finally, we display an instance of the form in the <code>AppComponent</code> shell.</p><span>
</span><p>app.component.ts</p><code language="ts" format="linenums">import { Component }       from &apos;@angular/core&apos;;

import { QuestionService } from &apos;./question.service&apos;;

@Component({
  selector: &apos;my-app&apos;,
  template: `
    &lt;div&gt;
      &lt;h2&gt;Job Application for Heroes&lt;/h2&gt;
      &lt;dynamic-form [questions]=&quot;questions&quot;&gt;&lt;/dynamic-form&gt;
    &lt;/div&gt;
  `,
  providers:  [QuestionService]
})
export class AppComponent {
  questions: any[];

  constructor(service: QuestionService) {
    this.questions = service.getQuestions();
  }
}
</code><a id="dynamic-template"></a><h2 id="dynamic-template">Dynamic Template</h2><span>
</span><p>Although in this example we&apos;re modelling a job application for heroes, there are no references to any specific hero question 
outside the objects returned by <code>QuestionService</code>. </p><span>
</span><p>This is very important since it allows us to repurpose the components for any type of survey
as long as it&apos;s compatible with our <em>question</em> object model. 
The key is the dynamic data binding of metadata used to render the form 
without making any hardcoded assumptions about specific questions. 
In addition to control metadata, we are also adding validation dynamically.</p><span>
</span><p>The <em>Save</em> button is disabled until the form is in a valid state. 
When the form is valid, we can click <em>Save</em> and the app renders the current form values as JSON. 
This proves that any user input is bound back to the data model.
Saving and retrieving the data is an exercise for another time.</p><span>
</span><p>The final form looks like this:</p><span>
</span><figure class="image-display"><img src="https://angular.io/resources/images/cookbooks/dynamic-form/dynamic-form.png" alt="Dynamic-Form"></figure><p><a href="https://angular.io/docs/ts/latest/cookbook/dynamic-form.html#top">Back to top</a></p></div></div>
        </article>
      
        <article>
          <h3>Form Validation</h3>
          <div><div class="showcase-content"><a id="top"></a><p>We can improve overall data quality by validating user input for accuracy and completeness.</p><span>
</span><p>In this cookbook we show how to validate user input in the UI and display useful validation messages 
using first the template-driven forms and then the reactive forms approach.</p><span>
</span><a id="toc"></a><h2 id="contents">Contents</h2><span>
</span><p>  <a href="https://angular.io/docs/ts/latest/cookbook/form-validation.html#template1">Simple Template-Driven Forms</a></p><span>
</span><p>  <a href="https://angular.io/docs/ts/latest/cookbook/form-validation.html#template2">Template-Driven Forms with validation messages in code</a></p><span>
</span><p>  <a href="https://angular.io/docs/ts/latest/cookbook/form-validation.html#reactive">Reactive Forms with validation in code</a></p><span>
</span><p>  <a href="https://angular.io/docs/ts/latest/cookbook/form-validation.html#custom-validation">Custom validation</a></p><span>
</span><p>  <a href="https://angular.io/docs/ts/latest/cookbook/form-validation.html#testing">Testing</a></p><span>
</span><a id="live-example"></a><p><strong>Try the live example to see and download the full cookbook source code</strong></p><span>
</span><live-example name="cb-form-validation" embedded="embedded" img="cookbooks/form-validation/plunker.png"></live-example><a id="template1"></a><h2 id="simple-template-driven-forms">Simple Template-Driven Forms</h2><span>
</span><p>In the template-driven approach, you arrange 
<a href="https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Forms_in_HTML">form elements</a> in the component&apos;s template.</p><span>
</span><p>You add Angular form directives (mostly directives beginning <code>ng...</code>) to help
Angular construct a corresponding internal control model that implements form functionality.
We say that the control model is <em>implicit</em> in the template.</p><span>
</span><p>To validate user input, you add <a href="https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/HTML5/Constraint_validation">HTML validation attributes</a> 
to the elements. Angular interprets those as well, adding validator functions to the control model.</p><span>
</span><p>Angular exposes information about the state of the controls including 
whether the user has &quot;touched&quot; the control or made changes and if the control values are valid.</p><span>
</span><p>In the first template validation example, 
we add more HTML to read that control state and update the display appropriately.
Here&apos;s an excerpt from the template html for a single input box control bound to the hero name:</p><span>
</span><p>template/hero-form-template1.component.html (Hero name)</p><code language="html" format="">&lt;label for=&quot;name&quot;&gt;Name&lt;/label&gt;

&lt;input type=&quot;text&quot; id=&quot;name&quot; class=&quot;form-control&quot;
       required minlength=&quot;4&quot; maxlength=&quot;24&quot;
       name=&quot;name&quot; [(ngModel)]=&quot;hero.name&quot;
       #name=&quot;ngModel&quot; &gt;

&lt;div *ngIf=&quot;name.errors &amp;&amp; (name.dirty || name.touched)&quot;
     class=&quot;alert alert-danger&quot;&gt;
    &lt;div [hidden]=&quot;!name.errors.required&quot;&gt;
      Name is required
    &lt;/div&gt;
    &lt;div [hidden]=&quot;!name.errors.minlength&quot;&gt;
      Name must be at least 4 characters long.
    &lt;/div&gt;
    &lt;div [hidden]=&quot;!name.errors.maxlength&quot;&gt;
      Name cannot be more than 24 characters long.
    &lt;/div&gt;
&lt;/div&gt;
</code><p>Note the following:</p><span>
</span><ul>
<li><p>The <code>&lt;input&gt;</code> element carries the HTML validation attributes: <code>required</code>, <code>minlength</code>, and <code>maxlength</code>.</p>
</li>
<li><p>We set the <code>name</code> attribute of the input box to <code>&quot;name&quot;</code> so Angular can track this input element and associate it
with an Angular form control called <code>name</code> in its internal control model.</p>
</li>
<li><p>We use the <code>[(ngModel)]</code> directive to two-way data bind the input box to the <code>hero.name</code> property.</p>
</li>
<li><p>We set a template variable (<code>#name</code>) to the value <code>&quot;ngModel&quot;</code> (always <code>ngModel</code>).
This gives us a reference to the Angular <code>NgModel</code> directive 
associated with this control that we can use <em>in the template</em>
to check for control states such as <code>valid</code> and <code>dirty</code>.</p>
</li>
<li><p>The <code>*ngIf</code> on <code>&lt;div&gt;</code> element reveals a set of nested message <code>divs</code> but only if there are &quot;name&quot; errors and
the control is either <code>dirty</code> or <code>touched</code>.</p>
</li>
<li><p>Each nested <code>&lt;div&gt;</code> can present a custom message for one of the possible validation errors.
We&apos;ve prepared messages for <code>required</code>, <code>minlength</code>, and <code>maxlength</code>.</p>
</li>
</ul><span>
</span><p>The full template repeats this kind of layout for each data entry control on the form.</p><span>
</span><div class="l-sub-section"><h4 id="why-check-_dirty_-and-_touched_-">Why check <em>dirty</em> and <em>touched</em>?</h4><span>
</span><p>We shouldn&apos;t show errors for a new hero before the user has had a chance to edit the value.
The checks for <code>dirty</code> and <code>touched</code> prevent premature display of errors.</p><span>
</span><p>Learn about <code>dirty</code> and <code>touched</code> in the <a href="https://angular.io/docs/ts/latest/guide/forms.html">Forms</a> chapter.</p><span>
</span></div><p>The component class manages the hero model used in the data binding
as well as other code to support the view.</p><span>
</span><p>template/hero-form-template1.component.ts (class)</p><code language="ts" format="linenums">export class HeroFormTemplate1Component {

  powers = [&apos;Really Smart&apos;, &apos;Super Flexible&apos;, &apos;Weather Changer&apos;];

  hero = new Hero(18, &apos;Dr. WhatIsHisWayTooLongName&apos;, this.powers[0], &apos;Dr. What&apos;);

  submitted = false;

  onSubmit() {
    this.submitted = true;
  }

  addHero() {
    this.hero = new Hero(42, &apos;&apos;, &apos;&apos;);
  }
}
</code><p>Use this template-driven validation technique when working with static forms with simple, standard validation rules.</p><span>
</span><p>Here are the complete files for the first version of <code>HeroFormTemplateCompononent</code> in the template-driven approach:</p><span>
</span><code-tabs><code language="html" name="template/hero-form-template1.component.html" format="linenums">&lt;div class=&quot;container&quot;&gt;
  &lt;div [hidden]=&quot;submitted&quot;&gt;
    &lt;h1&gt;Hero Form 1 (Template)&lt;/h1&gt;
    &lt;form #heroForm=&quot;ngForm&quot;  *ngIf=&quot;active&quot;  (ngSubmit)=&quot;onSubmit()&quot;&gt;
      &lt;div class=&quot;form-group&quot;&gt;
        &lt;label for=&quot;name&quot;&gt;Name&lt;/label&gt;

        &lt;input type=&quot;text&quot; id=&quot;name&quot; class=&quot;form-control&quot;
               required minlength=&quot;4&quot; maxlength=&quot;24&quot;
               name=&quot;name&quot; [(ngModel)]=&quot;hero.name&quot;
               #name=&quot;ngModel&quot; &gt;

        &lt;div *ngIf=&quot;name.errors &amp;&amp; (name.dirty || name.touched)&quot;
             class=&quot;alert alert-danger&quot;&gt;
            &lt;div [hidden]=&quot;!name.errors.required&quot;&gt;
              Name is required
            &lt;/div&gt;
            &lt;div [hidden]=&quot;!name.errors.minlength&quot;&gt;
              Name must be at least 4 characters long.
            &lt;/div&gt;
            &lt;div [hidden]=&quot;!name.errors.maxlength&quot;&gt;
              Name cannot be more than 24 characters long.
            &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;

      &lt;div class=&quot;form-group&quot;&gt;
        &lt;label for=&quot;alterEgo&quot;&gt;Alter Ego&lt;/label&gt;
        &lt;input type=&quot;text&quot; id=&quot;alterEgo&quot; class=&quot;form-control&quot;
               name=&quot;alterEgo&quot;
               [(ngModel)]=&quot;hero.alterEgo&quot; &gt;
      &lt;/div&gt;

      &lt;div class=&quot;form-group&quot;&gt;
        &lt;label for=&quot;power&quot;&gt;Hero Power&lt;/label&gt;
        &lt;select id=&quot;power&quot; class=&quot;form-control&quot;
                name=&quot;power&quot;
                [(ngModel)]=&quot;hero.power&quot; required
                #power=&quot;ngModel&quot; &gt;
          &lt;option *ngFor=&quot;let p of powers&quot; [value]=&quot;p&quot;&gt;{{p}}&lt;/option&gt;
        &lt;/select&gt;

        &lt;div *ngIf=&quot;power.errors &amp;&amp; power.touched&quot; class=&quot;alert alert-danger&quot;&gt;
          &lt;div [hidden]=&quot;!power.errors.required&quot;&gt;Power is required&lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;

      &lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot;
             [disabled]=&quot;!heroForm.form.valid&quot;&gt;Submit&lt;/button&gt;
      &lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot;
             (click)=&quot;addHero()&quot;&gt;New Hero&lt;/button&gt;
    &lt;/form&gt;
  &lt;/div&gt;

  &lt;hero-submitted [hero]=&quot;hero&quot; [(submitted)]=&quot;submitted&quot;&gt;&lt;/hero-submitted&gt;
&lt;/div&gt;
</code><code language="ts" name="template/hero-form-template1.component.ts" format="linenums">import { Component } from &apos;@angular/core&apos;;


import { Hero }      from &apos;../shared/hero&apos;;

@Component({
  moduleId:  module.id,
  selector: &apos;hero-form-template1&apos;,
  templateUrl: &apos;hero-form-template1.component.html&apos;
})
export class HeroFormTemplate1Component {

  powers = [&apos;Really Smart&apos;, &apos;Super Flexible&apos;, &apos;Weather Changer&apos;];

  hero = new Hero(18, &apos;Dr. WhatIsHisWayTooLongName&apos;, this.powers[0], &apos;Dr. What&apos;);

  submitted = false;

  onSubmit() {
    this.submitted = true;
  }

  addHero() {
    this.hero = new Hero(42, &apos;&apos;, &apos;&apos;);
  }
}
</code></code-tabs><a id="template2"></a><h2 id="template-driven-forms-with-validation-messages-in-code">Template-Driven Forms with validation messages in code</h2><span>
</span><p>While the layout is straightforward, 
there are obvious shortcomings with the way we handle validation messages:</p><span>
</span><ul>
<li><p>It takes a lot of HTML to represent all possible error conditions. 
This gets out of hand when there are many controls and many validation rules.</p>
</li>
<li><p>We&apos;re not fond of so much JavaScript logic in HTML.</p>
</li>
<li><p>The messages are static strings, hard-coded into the template. 
We often require dynamic messages that we should shape in code.</p>
</li>
</ul><span>
</span><p>We can move the logic and the messages into the component with a few changes to 
the template and component.</p><span>
</span><p>Here&apos;s the hero name again, excerpted from the revised template (&quot;Template 2&quot;), next to the original version:</p><span>
</span><code-tabs><code language="html" name="hero-form-template2.component.html (name #2)" format="linenums">        &lt;label for=&quot;name&quot;&gt;Name&lt;/label&gt;

        &lt;input type=&quot;text&quot; id=&quot;name&quot; class=&quot;form-control&quot;
               required minlength=&quot;4&quot; maxlength=&quot;24&quot; forbiddenName=&quot;bob&quot;
               name=&quot;name&quot; [(ngModel)]=&quot;hero.name&quot; &gt;

        &lt;div *ngIf=&quot;formErrors.name&quot; class=&quot;alert alert-danger&quot;&gt;
          {{ formErrors.name }}
        &lt;/div&gt;
</code><code language="html" name="hero-form-template1.component.html (name #1)" format="linenums">&lt;label for=&quot;name&quot;&gt;Name&lt;/label&gt;

&lt;input type=&quot;text&quot; id=&quot;name&quot; class=&quot;form-control&quot;
       required minlength=&quot;4&quot; maxlength=&quot;24&quot;
       name=&quot;name&quot; [(ngModel)]=&quot;hero.name&quot;
       #name=&quot;ngModel&quot; &gt;

&lt;div *ngIf=&quot;name.errors &amp;&amp; (name.dirty || name.touched)&quot;
     class=&quot;alert alert-danger&quot;&gt;
    &lt;div [hidden]=&quot;!name.errors.required&quot;&gt;
      Name is required
    &lt;/div&gt;
    &lt;div [hidden]=&quot;!name.errors.minlength&quot;&gt;
      Name must be at least 4 characters long.
    &lt;/div&gt;
    &lt;div [hidden]=&quot;!name.errors.maxlength&quot;&gt;
      Name cannot be more than 24 characters long.
    &lt;/div&gt;
&lt;/div&gt;
</code></code-tabs><p>The <code>&lt;input&gt;</code> element HTML is almost the same. There are noteworthy differences:</p><span>
</span><ul>
<li><p>The hard-code error message <code>&lt;divs&gt;</code> are gone.</p>
</li>
<li><p>There&apos;s a new attribute, <code>forbiddenName</code>, that is actually a custom validation directive.
It invalidates the control if the user enters &quot;bob&quot; anywhere in the name (<a href="https://angular.io/docs/ts/latest/cookbook/form-validation.html#live-example">try it</a>).
We discuss <a href="https://angular.io/docs/ts/latest/cookbook/form-validation.html#custom-validation">custom validation directives</a> later in this cookbook.</p>
</li>
<li><p>The <code>#name</code> template variable is gone because we no longer refer to the Angular control for this element.</p>
</li>
<li><p>Binding to the new <code>formErrors.name</code> property is sufficent to display all name validation error messages.</p>
</li>
</ul><span>
</span><h4 id="component-class">Component class</h4><span>
</span><p>The original component code stays the same.
We <em>added</em> new code to acquire the Angular form control and compose error messages.</p><span>
</span><p>The first step is to acquire the form control that Angular created from the template by querying for it.</p><span>
</span><p>Look back at the top of the component template where we set the 
<code>#heroForm</code> template variable in the <code>&lt;form&gt;</code> element:</p><span>
</span><p>template/hero-form-template1.component.html (form tag)</p><code language="html" format="">&lt;form #heroForm=&quot;ngForm&quot;  *ngIf=&quot;active&quot;  (ngSubmit)=&quot;onSubmit()&quot;&gt;
</code><p>The <code>heroForm</code> variable is a reference to the control model that Angular derived from the template.
We tell Angular to inject that model into the component class&apos;s <code>currentForm</code> property using a <code>@ViewChild</code> query:</p><span>
</span><p>template/hero-form-template2.component.ts (heroForm)</p><code language="ts" format="">heroForm: NgForm;
@ViewChild(&apos;heroForm&apos;) currentForm: NgForm;

ngAfterViewChecked() {
  this.formChanged();
}

formChanged() {
  if (this.currentForm === this.heroForm) { return; }
  this.heroForm = this.currentForm;
  if (this.heroForm) {
    this.heroForm.valueChanges
      .subscribe(data =&gt; this.onValueChanged(data));
  }
}
</code><p>Some observations:</p><span>
</span><ul>
<li><p>Angular <code>@ViewChild</code> queries for a template variable when you pass it 
the name of that variable as a string (<code>&apos;heroForm&apos;</code> in this case).</p>
</li>
<li><p>The <code>heroForm</code> object changes several times during the life of the component, most notably when we add a new hero.
We&apos;ll have to re-inspect it periodically.</p>
</li>
<li><p>Angular calls the <code>ngAfterViewChecked</code> <a href="https://angular.io/docs/ts/latest/guide/lifecycle-hooks.html#afterview">lifecycle hook method</a> 
when anything changes in the view.
That&apos;s the right time to see if there&apos;s a new <code>heroForm</code> object.</p>
</li>
<li><p>When there <em>is</em> a new <code>heroForm</code> model, we subscribe to its <code>valueChanged</code> <em>Observable</em> property.
The <code>onValueChanged</code> handler looks for validation errors after every user keystroke.  </p>
</li>
</ul><span>
</span><p>template/hero-form-template2.component.ts (handler)</p><code language="ts" format="">onValueChanged(data?: any) {
  if (!this.heroForm) { return; }
  const form = this.heroForm.form;

  for (const field in this.formErrors) {
    // clear previous error message (if any)
    this.formErrors[field] = &apos;&apos;;
    const control = form.get(field);

    if (control &amp;&amp; control.dirty &amp;&amp; !control.valid) {
      const messages = this.validationMessages[field];
      for (const key in control.errors) {
        this.formErrors[field] += messages[key] + &apos; &apos;;
      }
    }
  }
}

formErrors = {
  &apos;name&apos;: &apos;&apos;,
  &apos;power&apos;: &apos;&apos;
};
</code><p>The <code>onValueChanged</code> handler interprets user data entry. 
The <code>data</code> object passed into the handler contains the current element values.
The handler ignores them. Instead, it iterates over the fields of the component&apos;s <code>formErrors</code> object.</p><span>
</span><p>The <code>formErrors</code> is a dictionary of the hero fields that have validation rules and their current error messages.
Only two hero properties have validation rules, <code>name</code> and <code>power</code>.
The messages are empty strings when the hero data are valid.</p><span>
</span><p>For each field, the handler</p><span>
</span><ul>
<li>clears the prior error message if any</li>
<li>acquires the field&apos;s corresponding Angular form control </li>
<li>if such a control exists <em>and</em> its been changed (&quot;dirty&quot;) <em>and</em> its invalid ...</li>
<li>the handler composes a consolidated error message for all of the control&apos;s errors.</li>
</ul><span>
</span><p>We&apos;ll need some error messages of course, a set for each validated property, one message per validation rule:</p><span>
</span><p>template/hero-form-template2.component.ts (messages)</p><code language="ts" format="">validationMessages = {
  &apos;name&apos;: {
    &apos;required&apos;:      &apos;Name is required.&apos;,
    &apos;minlength&apos;:     &apos;Name must be at least 4 characters long.&apos;,
    &apos;maxlength&apos;:     &apos;Name cannot be more than 24 characters long.&apos;,
    &apos;forbiddenName&apos;: &apos;Someone named &quot;Bob&quot; cannot be a hero.&apos;
  },
  &apos;power&apos;: {
    &apos;required&apos;: &apos;Power is required.&apos;
  }
};
</code><p>Now every time the user makes a change, the <code>onValueChanged</code> handler checks for validation errors and produces messages accordingly.</p><span>
</span><h3 id="is-this-an-improvement-">Is this an improvement?</h3><span>
</span><p>Clearly the template got substantially smaller while the component code got substantially larger. 
It&apos;s not easy to see the benefit when there are just three fields and only two of them have validation rules.</p><span>
</span><p>Consider what happens as we increase the number of validated fields and rules.
In general, HTML is harder to read and maintain than code. 
The initial template was already large and threatening to get rapidly worse as we add more validation message <code>&lt;divs&gt;</code>.</p><span>
</span><p>After moving the validation messaging to the component, 
the template grows more slowly and proportionally.
Each field has approximately the same number of lines no matter its number of validation rules.
The component also grows proportionally, at the rate of one line per validated field
and one line per validation message.</p><span>
</span><p>Both trends are manageable.</p><span>
</span><p>Now that the messages are in code, we have more flexibility. We can compose messages more intelligently. 
We can refactor the messages out of the component, perhaps to a service class that retrieves them from the server.
In short, there are more opportunities to improve message handling now that text and logic have moved from template to code.</p><span>
</span><h3 id="_formmodule_-and-template-driven-forms"><em>FormModule</em> and template-driven forms</h3><span>
</span><p>Angular has two different forms modules &#x2014; <code>FormsModule</code> and <code>ReactiveFormsModule</code> &#x2014; 
that correspond with the two approaches to form development.
Both modules come from the same <code>@angular/forms</code> library package.</p><span>
</span><p>We&apos;ve been reviewing the &quot;Template-driven&quot; approach which requires the <code>FormsModule</code>
Here&apos;s how we imported it in the <code>HeroFormTemplateModule</code>.</p><span>
</span><p>template/hero-form-template.module.ts</p><code language="ts" format="">import { NgModule }     from &apos;@angular/core&apos;;
import { FormsModule }  from &apos;@angular/forms&apos;;

import { SharedModule }               from &apos;../shared/shared.module&apos;;
import { HeroFormTemplate1Component } from &apos;./hero-form-template1.component&apos;;
import { HeroFormTemplate2Component } from &apos;./hero-form-template2.component&apos;;

@NgModule({
  imports:      [ SharedModule, FormsModule ],
  declarations: [ HeroFormTemplate1Component, HeroFormTemplate2Component ],
  exports:      [ HeroFormTemplate1Component, HeroFormTemplate2Component ]
})
export class HeroFormTemplateModule { }
</code><div class="l-sub-section"><p>We haven&apos;t talked about the <code>SharedModule</code> or its <code>SubmittedComponent</code> which appears at the bottom of every
form template in this cookbook.  </p><span>
</span><p>They&apos;re not germane to the validation story. Look at the <a href="https://angular.io/docs/ts/latest/cookbook/form-validation.html#live-example">live example</a> if you&apos;re interested.</p><span>
</span></div><a id="reactive"></a><h2 id="reactive-forms">Reactive Forms</h2><span>
</span><p>In the template-driven approach, you markup the template with form elements, validation attributes, 
and <code>ng...</code> directives from the Angular <code>FormsModule</code>.
At runtime, Angular interprets the template and derives its <em>form control model</em>.</p><span>
</span><p><strong>Reactive Forms</strong> takes a different approach. 
You create the form control model in code. You write the template with form elements
and<code>form...</code> directives from the Angular <code>ReactiveFormsModule</code>.
At runtime, Angular binds the template elements to your control model based on your instructions.</p><span>
</span><p>This approach requires a bit more effort. <em>You have to write the control model and manage it</em>.</p><span>
</span><p>In return, you can</p><span>
</span><ul>
<li>add, change, and remove validation functions on the fly</li>
<li>manipulate the control model dynamically from within the component</li>
<li><a href="https://angular.io/docs/ts/latest/cookbook/form-validation.html#testing">test</a> validation and control logic with isolated unit tests.</li>
</ul><span>
</span><p>The third cookbook sample re-writes the hero form in <em>reactive forms</em> style.</p><span>
</span><h3 id="switch-to-the-_reactiveformsmodule_">Switch to the <em>ReactiveFormsModule</em></h3><span>
</span><p>The reactive forms classes and directives come from the Angular <code>ReactiveFormsModule</code>, not the <code>FormsModule</code>.
The application module for the &quot;Reactive Forms&quot; feature in this sample looks like this:</p><span>
</span><p>app/reactive/hero-form-reactive.module.ts</p><code language="ts" format="">import { NgModule }            from &apos;@angular/core&apos;;
import { ReactiveFormsModule } from &apos;@angular/forms&apos;;

import { SharedModule }              from &apos;../shared/shared.module&apos;;
import { HeroFormReactiveComponent } from &apos;./hero-form-reactive.component&apos;;

@NgModule({
  imports:      [ SharedModule, ReactiveFormsModule ],
  declarations: [ HeroFormReactiveComponent ],
  exports:      [ HeroFormReactiveComponent ]
})
export class HeroFormReactiveModule { }
</code><p>The &quot;Reactive Forms&quot; feature module and component are in the <code>app/reactive</code> folder. 
Let&apos;s focus on the <code>HeroFormReactiveComponent</code> there, starting with its template.</p><span>
</span><h3 id="component-template">Component template</h3><span>
</span><p>We begin by changing the <code>&lt;form&gt;</code> tag so that it binds the Angular <code>formGroup</code> directive in the template
to the <code>heroForm</code> property in the component class. 
The <code>heroForm</code> is the control model that the component class builds and maintains.</p><span>
</span><code language="html" format="">&lt;form [formGroup]=&quot;heroForm&quot;  *ngIf=&quot;active&quot;  (ngSubmit)=&quot;onSubmit()&quot;&gt;
</code><p>Then we modify the template HTML elements to match the <em>reactive forms</em> style.
Here is the &quot;name&quot; portion of the template again, revised for reactive forms and compared with the template-driven version:</p><span>
</span><code-tabs><code language="html" name="hero-form-reactive.component.html (name #3)" format="linenums">&lt;label for=&quot;name&quot;&gt;Name&lt;/label&gt;

&lt;input type=&quot;text&quot; id=&quot;name&quot; class=&quot;form-control&quot;
       formControlName=&quot;name&quot; required &gt;

&lt;div *ngIf=&quot;formErrors.name&quot; class=&quot;alert alert-danger&quot;&gt;
  {{ formErrors.name }}
&lt;/div&gt;
</code><code language="html" name="hero-form-template1.component.html (name #2)" format="linenums">        &lt;label for=&quot;name&quot;&gt;Name&lt;/label&gt;

        &lt;input type=&quot;text&quot; id=&quot;name&quot; class=&quot;form-control&quot;
               required minlength=&quot;4&quot; maxlength=&quot;24&quot; forbiddenName=&quot;bob&quot;
               name=&quot;name&quot; [(ngModel)]=&quot;hero.name&quot; &gt;

        &lt;div *ngIf=&quot;formErrors.name&quot; class=&quot;alert alert-danger&quot;&gt;
          {{ formErrors.name }}
        &lt;/div&gt;
</code></code-tabs><p>Key changes:</p><span>
</span><ul>
<li><p>the validation attributes are gone (except <code>required</code>) because we&apos;ll be validating in code.</p>
</li>
<li><p><code>required</code> remains, not for validation purposes (we&apos;ll cover that in the code), 
but rather for css styling and accessibility.</p>
</li>
</ul><span>
</span><div class="l-sub-section"><p>A future version of reactive forms will add the <code>required</code> HTML validation attribute to the DOM element
(and perhaps the <code>aria-required</code> attribute) when the control has the <code>required</code> validator function. </p><span>
</span><p>Until then, apply the <code>required</code> attribute <em>and</em> add the <code>Validator.required</code> function
to the control model, as we&apos;ll do below.</p><span>
</span></div><ul>
<li><p>the <code>formControlName</code> replaces the <code>name</code> attribute; it serves the same
purpose of correlating the input box with the Angular form control.</p>
</li>
<li><p>the two-way <code>[(ngModel)]</code> binding is gone. 
The reactive approach does not use data binding to move data into and out of the form controls.
We do that in code.</p>
</li>
</ul><span>
</span><div class="l-sub-section"><p>The retreat from data binding is a principle of the reactive paradigm rather than a technical limitation.</p><span>
</span></div><h3 id="component-class">Component class</h3><span>
</span><p>The component class is now responsible for defining and managing the form control model. </p><span>
</span><p>Angular no longer derives the control model from the template so we can no longer query for it.
We create the Angular form control model explicitly with the help of the <code>FormBuilder</code>.</p><span>
</span><p>Here&apos;s the section of code devoted to that process, paired with the template-driven code it replaces:</p><span>
</span><code-tabs><code language="ts" name="reactive/hero-form-reactive.component.ts (FormBuilder)" format="linenums">  heroForm: FormGroup;
  constructor(private fb: FormBuilder) { }

  ngOnInit(): void {
    this.buildForm();
  }

  buildForm(): void {
    this.heroForm = this.fb.group({
      &apos;name&apos;: [this.hero.name, [
          Validators.required,
          Validators.minLength(4),
          Validators.maxLength(24),
          forbiddenNameValidator(/bob/i)
        ]
      ],
      &apos;alterEgo&apos;: [this.hero.alterEgo],
      &apos;power&apos;:    [this.hero.power, Validators.required]
    });

    this.heroForm.valueChanges
      .subscribe(data =&gt; this.onValueChanged(data));

    this.onValueChanged(); // (re)set validation messages now
  }
</code><code language="ts" name="template/hero-form-template2.component.ts (ViewChild)" format="linenums">heroForm: NgForm;
@ViewChild(&apos;heroForm&apos;) currentForm: NgForm;

ngAfterViewChecked() {
  this.formChanged();
}

formChanged() {
  if (this.currentForm === this.heroForm) { return; }
  this.heroForm = this.currentForm;
  if (this.heroForm) {
    this.heroForm.valueChanges
      .subscribe(data =&gt; this.onValueChanged(data));
  }
}
</code></code-tabs><ul>
<li><p>we inject the <code>FormBuilder</code> in a constructor.</p>
</li>
<li><p>we call a <code>buildForm</code> method in the <code>ngOnInit</code> <a href="https://angular.io/docs/ts/latest/guide/lifecycle-hooks.html#hooks-overview">lifecycle hook method</a>
because that&apos;s when we&apos;ll have the hero data. We&apos;ll call it again in the <code>addHero</code> method.</p>
</li>
</ul><span>
</span><div class="l-sub-section"><p>A real app would retrieve the hero asynchronously from a data service, a task best performed in the <code>ngOnInit</code> hook.</p><span>
</span></div><ul>
<li>the <code>buildForm</code> method uses the <code>FormBuilder</code> (<code>fb</code>) to declare the form control model.
Then it attaches the same <code>onValueChanged</code> handler (there&apos;s a one line difference) 
to the form&apos;s <code>valueChanged</code> event and calls it immediately 
to set error messages for the new control model.</li>
</ul><span>
</span><h4 id="_formbuilder_-declaration"><em>FormBuilder</em> declaration</h4><span>
</span><p>The <code>FormBuilder</code> declaration object specifies the three controls of the sample&apos;s hero form. </p><span>
</span><p>Each control spec is a control name with an array value. 
The first array element is the current value of the corresponding hero field.
The (optional) second value is a validator function or an array of validator functions.</p><span>
</span><p>Most of the validator functions are stock validators provided by Angular as static methods of the <code>Validators</code> class.
Angular has stock validators that correspond to the standard HTML validation attributes.</p><span>
</span><p>The <code>forbiddenNames</code> validator on the <code>&quot;name&quot;</code> control is a custom validator, 
discussed in a separate <a href="https://angular.io/docs/ts/latest/cookbook/form-validation.html#custom-validation">section below</a>.</p><span>
</span><div class="l-sub-section"><span> </span><p>Learn more about <code>FormBuilder</code> in a <em>forthcoming</em> chapter on reactive forms. </p><span>
</span></div><h4 id="committing-hero-value-changes">Committing hero value changes</h4><span>
</span><p>In two-way data binding, the user&apos;s changes flow automatically from the controls back to the data model properties.
Reactive forms do not use data binding to update data model properties. 
The developer decides <em>when and how</em> to update the data model from control values.</p><span>
</span><p>This sample updates the model twice:</p><span>
</span><ol>
<li>when the user submits the form</li>
<li>when the user chooses to add a new hero</li>
</ol><span>
</span><p>The <code>onSubmit</code> method simply replaces the <code>hero</code> object with the combined values of the form:</p><span>
</span><code language="ts" format="">onSubmit() {
  this.submitted = true;
  this.hero = this.heroForm.value;
}
</code><div class="l-sub-section"><p>This example is &quot;lucky&quot; in that the <code>heroForm.value</code> properties <em>just happen</em> to
correspond <em>exactly</em> to the hero data object properties.</p><span>
</span></div><p>The <code>addHero</code> method discards pending changes and creates a brand new <code>hero</code> model object.</p><span>
</span><code language="ts" format="">addHero() {
  this.hero = new Hero(42, &apos;&apos;, &apos;&apos;);
  this.buildForm();
}
</code><p>Then it calls <code>buildForm</code> again which replaces the previous <code>heroForm</code> control model with a new one.
The <code>&lt;form&gt;</code> tag&apos;s <code>[formGroup]</code> binding refreshes the page with the new control model.</p><span>
</span><p>Here&apos;s the complete reactive component file, compared to the two template-driven component files.</p><span>
</span><code-tabs><code language="ts" name="reactive/hero-form-reactive.component.ts (#3)" format="linenums">import { Component, OnInit }                  from &apos;@angular/core&apos;;
import { FormGroup, FormBuilder, Validators } from &apos;@angular/forms&apos;;

import { Hero }                   from &apos;../shared/hero&apos;;
import { forbiddenNameValidator } from &apos;../shared/forbidden-name.directive&apos;;

@Component({
  moduleId:  module.id,
  selector: &apos;hero-form-reactive3&apos;,
  templateUrl: &apos;hero-form-reactive.component.html&apos;
})
export class HeroFormReactiveComponent implements OnInit {

  powers = [&apos;Really Smart&apos;, &apos;Super Flexible&apos;, &apos;Weather Changer&apos;];

  hero = new Hero(18, &apos;Dr. WhatIsHisName&apos;, this.powers[0], &apos;Dr. What&apos;);

  submitted = false;

  onSubmit() {
    this.submitted = true;
    this.hero = this.heroForm.value;
  }
  addHero() {
    this.hero = new Hero(42, &apos;&apos;, &apos;&apos;);
    this.buildForm();

    this.active = false;
    setTimeout(() =&gt; this.active = true, 0);
  }

  heroForm: FormGroup;
  constructor(private fb: FormBuilder) { }

  ngOnInit(): void {
    this.buildForm();
  }

  buildForm(): void {
    this.heroForm = this.fb.group({
      &apos;name&apos;: [this.hero.name, [
          Validators.required,
          Validators.minLength(4),
          Validators.maxLength(24),
          forbiddenNameValidator(/bob/i)
        ]
      ],
      &apos;alterEgo&apos;: [this.hero.alterEgo],
      &apos;power&apos;:    [this.hero.power, Validators.required]
    });

    this.heroForm.valueChanges
      .subscribe(data =&gt; this.onValueChanged(data));

    this.onValueChanged(); // (re)set validation messages now
  }


  onValueChanged(data?: any) {
    if (!this.heroForm) { return; }
    const form = this.heroForm;

    for (const field in this.formErrors) {
      // clear previous error message (if any)
      this.formErrors[field] = &apos;&apos;;
      const control = form.get(field);

      if (control &amp;&amp; control.dirty &amp;&amp; !control.valid) {
        const messages = this.validationMessages[field];
        for (const key in control.errors) {
          this.formErrors[field] += messages[key] + &apos; &apos;;
        }
      }
    }
  }

  formErrors = {
    &apos;name&apos;: &apos;&apos;,
    &apos;power&apos;: &apos;&apos;
  };

  validationMessages = {
    &apos;name&apos;: {
      &apos;required&apos;:      &apos;Name is required.&apos;,
      &apos;minlength&apos;:     &apos;Name must be at least 4 characters long.&apos;,
      &apos;maxlength&apos;:     &apos;Name cannot be more than 24 characters long.&apos;,
      &apos;forbiddenName&apos;: &apos;Someone named &quot;Bob&quot; cannot be a hero.&apos;
    },
    &apos;power&apos;: {
      &apos;required&apos;: &apos;Power is required.&apos;
    }
  };
}
</code><code language="ts" name="template/hero-form-template2.component.ts (#2)" format="linenums">import { Component, AfterViewChecked, ViewChild } from &apos;@angular/core&apos;;
import { NgForm } from &apos;@angular/forms&apos;;

import { Hero }      from &apos;../shared/hero&apos;;

@Component({
  moduleId:  module.id,
  selector: &apos;hero-form-template2&apos;,
  templateUrl: &apos;hero-form-template2.component.html&apos;
})
export class HeroFormTemplate2Component implements AfterViewChecked {

  powers = [&apos;Really Smart&apos;, &apos;Super Flexible&apos;, &apos;Weather Changer&apos;];

  hero = new Hero(18, &apos;Dr. WhatIsHisWayTooLongName&apos;, this.powers[0], &apos;Dr. What&apos;);

  submitted = false;

  onSubmit() {
    this.submitted = true;
  }

  addHero() {
    this.hero = new Hero(42, &apos;&apos;, &apos;&apos;);
  }

  heroForm: NgForm;
  @ViewChild(&apos;heroForm&apos;) currentForm: NgForm;

  ngAfterViewChecked() {
    this.formChanged();
  }

  formChanged() {
    if (this.currentForm === this.heroForm) { return; }
    this.heroForm = this.currentForm;
    if (this.heroForm) {
      this.heroForm.valueChanges
        .subscribe(data =&gt; this.onValueChanged(data));
    }
  }

  onValueChanged(data?: any) {
    if (!this.heroForm) { return; }
    const form = this.heroForm.form;

    for (const field in this.formErrors) {
      // clear previous error message (if any)
      this.formErrors[field] = &apos;&apos;;
      const control = form.get(field);

      if (control &amp;&amp; control.dirty &amp;&amp; !control.valid) {
        const messages = this.validationMessages[field];
        for (const key in control.errors) {
          this.formErrors[field] += messages[key] + &apos; &apos;;
        }
      }
    }
  }

  formErrors = {
    &apos;name&apos;: &apos;&apos;,
    &apos;power&apos;: &apos;&apos;
  };

  validationMessages = {
    &apos;name&apos;: {
      &apos;required&apos;:      &apos;Name is required.&apos;,
      &apos;minlength&apos;:     &apos;Name must be at least 4 characters long.&apos;,
      &apos;maxlength&apos;:     &apos;Name cannot be more than 24 characters long.&apos;,
      &apos;forbiddenName&apos;: &apos;Someone named &quot;Bob&quot; cannot be a hero.&apos;
    },
    &apos;power&apos;: {
      &apos;required&apos;: &apos;Power is required.&apos;
    }
  };
}
</code><code language="ts" name="template/hero-form-template1.component.ts (#1)" format="linenums">import { Component } from &apos;@angular/core&apos;;


import { Hero }      from &apos;../shared/hero&apos;;

@Component({
  moduleId:  module.id,
  selector: &apos;hero-form-template1&apos;,
  templateUrl: &apos;hero-form-template1.component.html&apos;
})
export class HeroFormTemplate1Component {

  powers = [&apos;Really Smart&apos;, &apos;Super Flexible&apos;, &apos;Weather Changer&apos;];

  hero = new Hero(18, &apos;Dr. WhatIsHisWayTooLongName&apos;, this.powers[0], &apos;Dr. What&apos;);

  submitted = false;

  onSubmit() {
    this.submitted = true;
  }

  addHero() {
    this.hero = new Hero(42, &apos;&apos;, &apos;&apos;);
  }
}
</code></code-tabs><div class="l-sub-section"><p>Run the <a href="https://angular.io/docs/ts/latest/cookbook/form-validation.html#live-example">live example</a> to see how the reactive form behaves
and to compare all of the files in this cookbook sample.</p><span>
</span></div><a id="custom-validation"></a><h2 id="custom-validation">Custom validation</h2><span>
</span><p>This cookbook sample has a custom <code>forbiddenNamevalidator</code> function that&apos;s applied to both the 
template-driven and the reactive form controls. It&apos;s in the <code>app/shared</code> folder
and declared in the <code>SharedModule</code>.</p><span>
</span><p>Here&apos;s the <code>forbiddenNamevalidator</code> function itself:</p><span>
</span><p>shared/forbidden-name.directive.ts (forbiddenNameValidator)</p><code language="ts" format="">/** A hero&apos;s name can&apos;t match the given regular expression */
export function forbiddenNameValidator(nameRe: RegExp): ValidatorFn {
  return (control: AbstractControl): {[key: string]: any} =&gt; {
    const name = control.value;
    const no = nameRe.test(name);
    return no ? {&apos;forbiddenName&apos;: {name}} : null;
  };
}
</code><p>The function is actually a factory that takes a regular expression to detect a <em>specific</em> forbidden name
and returns a validator function.</p><span>
</span><p>In this sample, the forbidden name is &quot;bob&quot;; 
the validator rejects any hero name containing &quot;bob&quot;.
Elsewhere it could reject &quot;alice&quot; or any name that the configuring regular expression matches.</p><span>
</span><p>The <code>forbiddenNamevalidator</code> factory returns the configured validator function.
That function takes an Angular control object and returns <em>either</em>
null if the control value is valid <em>or</em> a validation error object.
The validation error object typically has a property whose name is the validation key (&apos;forbiddenName&apos;)
and whose value is an arbitrary dictionary of values that we could insert into an error message (<code>{name}</code>).</p><span>
</span><div class="l-sub-section"><p>Learn more about validator functions in a <em>forthcoming</em> chapter on custom form validation.</p><span>
</span></div><h4 id="custom-validation-directive">Custom validation directive</h4><span>
</span><p>In the reactive forms component we added a configured <code>forbiddenNamevalidator</code>
to the bottom of the <code>&apos;name&apos;</code> control&apos;s validator function list.</p><span>
</span><p>reactive/hero-form-reactive.component.ts (name validators)</p><code language="ts" format="">&apos;name&apos;: [this.hero.name, [
    Validators.required,
    Validators.minLength(4),
    Validators.maxLength(24),
    forbiddenNameValidator(/bob/i)
  ]
],
</code><p>In the template-driven component template, we add the selector (<code>forbiddenName</code>) of a custom <em>attribute directive</em> to the name&apos;s input box
and configured it to reject &quot;bob&quot;.</p><span>
</span><p>template/hero-form-template2.component.html (name input)</p><code language="html" format="">&lt;input type=&quot;text&quot; id=&quot;name&quot; class=&quot;form-control&quot;
       required minlength=&quot;4&quot; maxlength=&quot;24&quot; forbiddenName=&quot;bob&quot;
       name=&quot;name&quot; [(ngModel)]=&quot;hero.name&quot; &gt;
</code><p>The corresponding <code>ForbiddenValidatorDirective</code> is a wrapper around the <code>forbiddenNamevalidator</code>.</p><span>
</span><p>Angular forms recognizes the directive&apos;s role in the validation process because the directive registers itself
with the <code>NG_VALIDATORS</code> provider, a provider with an extensible collection of validation directives.</p><span>
</span><p>shared/forbidden-name.directive.ts (providers)</p><code language="ts" format="">providers: [{provide: NG_VALIDATORS, useExisting: ForbiddenValidatorDirective, multi: true}]
</code><p>The rest of the directive is unremarkable and we present it here without further comment.</p><span>
</span><p>shared/forbidden-name.directive.ts (directive)</p><code language="ts" format="linenums">@Directive({
  selector: &apos;[forbiddenName]&apos;,
  providers: [{provide: NG_VALIDATORS, useExisting: ForbiddenValidatorDirective, multi: true}]
})
export class ForbiddenValidatorDirective implements Validator, OnChanges {
  @Input() forbiddenName: string;
  private valFn = Validators.nullValidator;

  ngOnChanges(changes: SimpleChanges): void {
    const change = changes[&apos;forbiddenName&apos;];
    if (change) {
      const val: string | RegExp = change.currentValue;
      const re = val instanceof RegExp ? val : new RegExp(val, &apos;i&apos;);
      this.valFn = forbiddenNameValidator(re);
    } else {
      this.valFn = Validators.nullValidator;
    }
  }

  validate(control: AbstractControl): {[key: string]: any} {
    return this.valFn(control);
  }
}
</code><a id="testing"></a><h2 id="testing-considerations">Testing Considerations</h2><span>
</span><p>We can write <em>isolated unit tests</em> of validation and control logic in <em>Reactive Forms</em>.</p><span>
</span><p><em>Isolated unit tests</em> probe the component class directly, independent of its
interactions with its template, the DOM, other dependencies, or Angular itself.</p><span>
</span><p>Such tests have minimal setup, are quick to write, and easy to maintain.
They do not require the <code>Angular TestBed</code> or asynchronous testing practices.</p><span>
</span><p>That&apos;s not possible with <em>Template-driven</em> forms.
The template-driven approach relies on Angular to produce the control model and 
to derive validation rules from the HTML validation attributes.
You must use the <code>Angular TestBed</code> to create component test instances,
write asynchronous tests, and interact with the DOM.</p><span>
</span><p>While not difficult, this takes more time, work and skill &#x2014; 
factors that tend to diminish test code coverage and quality.</p></div></div>
        </article>
      
        <article>
          <h3>RC4 to RC5 Migration</h3>
          <div><div class="showcase-content"><span>
</span><p><em>Angular Modules</em>, also known as <em>NgModules</em>, are the powerful new way to organize and bootstrap your Angular application. </p><span>
</span><p>The new  <code>@NgModule</code> decorator gives you module-level components, directives, and pipes without 
the need to specify them repeatedly in every component of your application. </p><span>
</span><p>The <code>@NgModule</code> metadata give the Angular compiler the context needed so that you can use the same code 
regardless of whether you are running Angular in <a href="https://angular.io/docs/ts/latest/glossary.html#aot">Ahead of Time</a> or <a href="https://angular.io/docs/ts/latest/glossary.html#jit">Just in Time</a> mode.</p><span>
</span><h2 id="how-do-i-use-them-">How do I use them?</h2><span>
</span><p>If you were previously writing an Angular application, your app should continue to work in RC5. 
We&#x2019;ve worked hard to ensure that applications that worked with RC4 continue to work while you migrate. 
For this to work, we&#x2019;re doing 2 things automatically for you:</p><span>
</span><ul>
<li>We create an implicit <code>NgModule</code> for you as part of the <code>bootstrap()</code> command</li>
<li>We automatically hoist your components, pipes, and directives</li>
</ul><span>
</span><p>While your application will continue to work today, 
it&#x2019;s important that you update your application to ensure future updates and deprecations don&#x2019;t negatively affect you. 
To make it easier, you can think of the process as having 5 steps.</p><span>
</span><ol>
<li><p><strong>Update to RC5</strong> - Your application should continue to work without modification, but it&#x2019;s important that you are running the latest version of Angular.</p>
</li>
<li><p><strong>Create an <em>NgModule</em></strong> - Create the root <code>NgModule</code> that you&#x2019;ll use to bootstrap your application.</p>
</li>
<li><p><strong>Update your bootstrap</strong> - Bootstrap that module instead of your root component</p>
</li>
<li><p><strong>Update your 3rd party libraries</strong> - Take advantage of the latest from Forms, Material, Http, and more</p>
</li>
<li><p><strong>Cleanup</strong> - Clean up your code. 
The deprecated classes, methods and properties will be removed from Angular very soon.</p>
</li>
</ol><span>
</span><p>Prefer to look at code and diffs? 
Check out the upgrade in <a href="https://github.com/StephenFluin/ngmodule-migration/commit/9f9c6ae099346e491fc31d77bf65ed440e1f164c">one commit</a>.</p><span>
</span><h2 id="1-update-to-rc5">1. Update to RC5</h2><span>
</span><p>If you use npm, you should be able to either update your <code>package.json</code> file and run <code>npm install</code>. 
Or alternatively you can run the following command:</p><span>
</span><code format="." language="bash">npm install @angular/{core,common,compiler,platform-browser,platform-browser-dynamic} --save
</code><p>Update your optional libraries</p><span>
</span><code format="." language="bash">npm install @angular/router
npm install @angular/forms
npm install @angular2-material/{core,button,card,...}@latest
</code><p>Update the Angular CLI if you&apos;re using that tool</p><span>
</span><code format="." language="bash">npm install angular-cli @angular/tsc-wrapped --save-dev
</code><h2 id="2-create-an-_ngmodule_">2. Create an <em>NgModule</em></h2><span>
</span><p>Create a new file called app.module.ts. Populate it with your root component as follows:</p><span>
</span><code format="." language="javascript">import { NgModule }       from &apos;@angular/core&apos;;
import { BrowserModule  } from &apos;@angular/platform-browser&apos;;
import { AppComponent }   from &apos;./app.component&apos;;

@NgModule({
    declarations: [AppComponent],
    imports:      [BrowserModule],
    bootstrap:    [AppComponent],
})
export class AppModule {}
</code><h2 id="3-update-your-bootstrap">3. Update your bootstrap</h2><span>
</span><p>Update your <code>main.ts</code> file to bootstrap using the &quot;Just in Time&quot; (JIT) compiler.</p><span>
</span><code format="." language="javascript">import { platformBrowserDynamic } from &apos;@angular/platform-browser-dynamic&apos;;
import { AppModule }              from &apos;./app/app.module&apos;;

platformBrowserDynamic().bootstrapModule(AppModule);
</code><h2 id="4-import-library-modules-in-your-_ngmodule_">4. Import library modules in your <em>NgModule</em></h2><span>
</span><p>Remove the Angular and 3rd party library providers from your <code>AppComponent</code> providers 
and switch to <code>NgModule</code> imports as seen in this example.</p><span>
</span><code format="." language="javascript">imports: [
    BrowserModule, 
    // Router
    RouterModule.forRoot(config), 
    // Forms
    FormsModule, 
    // Material Design
    MdSlideToggleModule, 
    MdButtonModule, 
    MdToolbarModule, 
    MdCardModule, 
    MdInputModule,
],
</code><h2 id="5-cleanup">5. Cleanup</h2><span>
</span><p>For RC5, you can leave your components, directives and pipes 
in the <code>directives</code> and <code>pipes</code> properties of your <code>@Component</code> metadata.
In fact, we automatically hoist (add) them to the NgModule to which they belong.</p><span>
</span><div class="alert is-important"><p>This option is temporary for backward compatibility. 
It will be removed in the final release of Angular 2.0.</p><span>
</span><p>Get ahead of the game and start moving your component <code>directives</code> and <code>pipes</code> 
into module <code>declarations</code> as soon as possible.
We intend to delete <em>all</em> deprecated class, methods, and properties in the next RC.</p><span>
</span></div></div></div>
        </article>
      
        <article>
          <h3>Set the Document Title</h3>
          <div><div class="showcase-content"><a id="top"></a><p>Our app should be able to make the browser title bar say whatever we want it to say.
This cookbook explains how to do it.</p><span>
</span><p><strong>See the <live-example name="cb-set-document-title"></live-example></strong>.</p><span>
</span><div class="l-sub-section"><img src="https://angular.io/resources/images/devguide/plunker-separate-window-button.png" alt="pop out the window" align="right"><p>To see the browser Title bar changes,
pop out the preview window by clicking the blue &apos;X&apos; button in the upper right corner.</p><span>
</span></div><h2 id="the-problem-with-lt-title-gt-">The problem with <em>&lt;title&gt;</em></h2><span>
</span><p>The obvious approach is to bind a property of the component to the HTML <code>&lt;title&gt;</code> like this:</p><span>
</span><code format="">&lt;title&gt;{{This_Does_Not_Work}}&lt;/title&gt;</code><p>Sorry but that won&apos;t work.
The root component of our application is an element contained within the <code>&lt;body&gt;</code> tag.
The HTML <code>&lt;title&gt;</code> is in the document <code>&lt;head&gt;</code>, outside the body, making it inaccessible to Angular data binding.</p><span>
</span><p>We could grab the browser <code>document</code> object and set the title manually.
That&apos;s dirty and undermines our chances of running the app outside of a browser someday.</p><span>
</span><div class="l-sub-section"><p>Running your app outside a browser means that you can take advantage of server-side
pre-rendering for near-instant first app render times and for SEO.  It means you could run from
inside a Web Worker to improve your app&apos;s responsiveness by using multiple threads.  And it
means that you could run your app inside Electron.js or Windows Universal to deliver it to the desktop.</p><span>
</span></div><h2 id="use-the-title-service">Use the <em>Title</em> service</h2><span>
</span><p>Fortunately, Angular 2 bridges the gap by providing a <code>Title</code> service as part of the <em>Browser platform</em>.
The <a href="https://angular.io/docs/ts/latest/api/platform-browser/index/Title-class.html">Title</a> service is a simple class that provides an API
for getting and setting the current HTML document title:</p><span>
</span><ul>
<li><code>getTitle() : string</code> &#x2014; Gets the title of the current HTML document.</li>
<li><code>setTitle( newTitle : string )</code> &#x2014; Sets the title of the current HTML document. </li>
</ul><span>
</span><p>Let&apos;s inject the <code>Title</code> service into the root <code>AppComponent</code> and expose a bindable <code>setTitle</code> method that calls it:</p><span>
</span><p>app/app.component.ts (class)</p><code language="ts" format="">export class AppComponent {
  public constructor(private titleService: Title ) { }

  public setTitle( newTitle: string) {
    this.titleService.setTitle( newTitle );
  }
}
</code><p>We bind that method to three anchor tags and, voil&#xE0;!</p><span>
</span><figure class="image-display"><img src="https://angular.io/resources/images/cookbooks/set-document-title/set-title-anim.gif" alt="Set title"></figure><p>Here&apos;s the complete solution</p><span>
</span><code-tabs><code language="ts" name="app/main.ts" format="linenums">import { platformBrowserDynamic } from &apos;@angular/platform-browser-dynamic&apos;;

import { AppModule } from &apos;./app.module&apos;;

platformBrowserDynamic().bootstrapModule(AppModule);
</code><code language="ts" name="app/app.module.ts" format="linenums">import { NgModule } from &apos;@angular/core&apos;;
import { BrowserModule, Title }  from &apos;@angular/platform-browser&apos;;

import { AppComponent } from &apos;./app.component&apos;;

@NgModule({
  imports: [
    BrowserModule
  ],
  declarations: [
    AppComponent
  ],
  providers: [
    Title
  ],
  bootstrap: [ AppComponent ]
})
export class AppModule { }
</code><code language="ts" name="app/app.component.ts" format="linenums">// Import the native Angular services.
import { Component } from &apos;@angular/core&apos;;
import { Title }     from &apos;@angular/platform-browser&apos;;

@Component({
selector: &apos;my-app&apos;,
template:
  `&lt;p&gt;
    Select a title to set on the current HTML document:
  &lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;&lt;a (click)=&quot;setTitle( &apos;Good morning!&apos; )&quot;&gt;Good morning&lt;/a&gt;.&lt;/li&gt;
    &lt;li&gt;&lt;a (click)=&quot;setTitle( &apos;Good afternoon!&apos; )&quot;&gt;Good afternoon&lt;/a&gt;.&lt;/li&gt;
    &lt;li&gt;&lt;a (click)=&quot;setTitle( &apos;Good evening!&apos; )&quot;&gt;Good evening&lt;/a&gt;.&lt;/li&gt;
  &lt;/ul&gt;
  `
})
export class AppComponent {
  public constructor(private titleService: Title ) { }

  public setTitle( newTitle: string) {
    this.titleService.setTitle( newTitle );
  }
}
</code></code-tabs><!--Todo: tie this back to the router so we can see how to use this Title service to (re)set the title
that appears in the window navigation history and shows up in the back/forward buttons
during routing.

See https://github.com/angular/angular/issues/7630#issuecomment-198328802
--><h2 id="why-we-provide-the-title-service-in-bootstrap-">Why we provide the <em>Title</em> service in <em>bootstrap</em></h2><span>
</span><p>We generally recommended providing application-wide services in the root application component, <code>AppComponent</code>.</p><span>
</span><p>Here we recommend registering the title service during bootstrapping,
a location we reserve for configuring the runtime Angular environment.</p><span>
</span><p>That&apos;s exactly what we&apos;re doing.
The <code>Title</code> service is part of the Angular <em>browser platform</em>.
If we bootstrap our application into a different platform,
we&apos;ll have to provide a different <code>Title</code> service that understands the concept of a &quot;document title&quot; for that specific platform.
Ideally the application itself neither knows nor cares about the runtime environment.</p><span>
</span><p><a href="https://angular.io/docs/ts/latest/cookbook/set-document-title.html#top">Back to top</a></p></div></div>
        </article>
      
        <article>
          <h3>TypeScript to JavaScript</h3>
          <div><div class="showcase-content"><p>Everything that we can do in Angular 2 in TypeScript, we can also do
in JavaScript. Translating from one language to the other is mostly a
matter of changing the way we organize our code and the way we access
Angular 2 APIs.</p><span>
</span><p>Since TypeScript is a popular language option in Angular 2, many of the
code examples you see on the Internet as well as on this site are written
in TypeScript. This cookbook contains recipes for translating these kinds of
code examples to ES5, so that they can be applied to Angular 2 JavaScript
applications.</p><span>
</span><a id="toc"></a><h2 id="table-of-contents">Table of contents</h2><span>
</span><p><a href="https://angular.io/docs/ts/latest/cookbook/ts-to-js.html#modularity">Modularity: imports and exports</a></p><span>
</span><p><a href="https://angular.io/docs/ts/latest/cookbook/ts-to-js.html#class-metadata">Classes and Class Metadata</a></p><span>
</span><p><a href="https://angular.io/docs/ts/latest/cookbook/ts-to-js.html#property-metadata">Input and Output Metadata</a></p><span>
</span><p><a href="https://angular.io/docs/ts/latest/cookbook/ts-to-js.html#dependency-injection">Dependency Injection</a></p><span>
</span><p><a href="https://angular.io/docs/ts/latest/cookbook/ts-to-js.html#other-property-metadata">Host and Query Metadata</a></p><span>
</span><p><strong>Run and compare the live <live-example name="cb-ts-to-js">TypeScript</live-example> and <live-example name="cb-ts-to-js" lang="js">JavaScript</live-example>
code shown in this cookbook.</strong></p><span>
</span><a id="modularity"></a><h2 id="importing-and-exporting">Importing and Exporting</h2><span>
</span><table width="100%"><colgroup><col width="50%"><col width="50%"></colgroup><tbody><tr><th>TypeScript</th><th>ES5 JavaScript</th></tr><tr><td><h3 id="importing-angular-2-code">Importing Angular 2 Code</h3>
<p>In TypeScript code, Angular 2 classes, functions, and other members
are imported with TypeScript <code>import</code> statements:</p>
<code language="ts" format="">import { platformBrowserDynamic } from &apos;@angular/platform-browser-dynamic&apos;;
import {
  LocationStrategy,
  HashLocationStrategy
} from &apos;@angular/common&apos;;
</code></td><td><h3 id="accessing-angular-2-code-through-the-ng-global">Accessing Angular 2 Code through the ng global</h3>
<p>In JavaScript code, when using
<a href="https://angular.io/docs/ts/latest/glossary.html#!#scoped-package">the Angular 2 packages</a>,
we can access Angular code through the global <code>ng</code> object. In the
nested members of this object we&apos;ll find everything we would import
from <code>angular2</code> in TypeScript:</p>
<code language="js" format="">var platformBrowserDynamic =
  ng.platformBrowserDynamic.platformBrowserDynamic;
var LocationStrategy =
  ng.common.LocationStrategy;
var HashLocationStrategy =
  ng.common.HashLocationStrategy;
</code></td></tr><tr><td><h3 id="importing-and-exporting-application-code">Importing and Exporting Application Code</h3>
<p>Each file in an Angular 2 TypeScript application constitutes a
TypeScript module. When we want to make something from a module available
to other modules, we <code>export</code> it.</p>
<code language="ts" format="">export class HeroComponent {
  title = &apos;Hero Detail&apos;;
  getName() {return &apos;Windstorm&apos;; }
}
</code><p>In other modules we can then <code>import</code> things that have been exported
elsewhere.</p>
<code language="ts" format="">import { HeroComponent } from &apos;./hero.component&apos;;
</code></td><td><h3 id="sharing-application-code">Sharing Application Code</h3>
<p>In an Angular 2 JavaScript application, we load each file to the page
using a <code>&lt;script&gt;</code> tag. Each file can make things available to other
files via the shared global <code>window</code> scope.</p>
<p>We often introduce an application namespace
object (such as <code>&quot;app&quot;</code>) onto <code>window</code> and attach everything we need
to share to that namespace object. 
We also wrap our code in an 
<a href="https://en.wikipedia.org/wiki/Immediately-invoked_function_expression">Immediately Invoked Function Expression (IIFE)</a>.
These practices together prevent our code from
polluting the global scope.</p>
<code language="js" format="">(function(app) {
  function HeroComponent() {
    this.title = &quot;Hero Detail&quot;;
  }

  app.HeroComponent = HeroComponent;

})(window.app = window.app || {});
</code><p>We can then access anything from this shared namespace in
other files.</p>
<code language="js" format="">(function(app) {
  var HeroComponent = app.HeroComponent;
})(window.app = window.app || {});
</code><p>Note that the order of <code>&lt;script&gt;</code> tags on the page is significant. 
We must load a file that defines a shared member before
a file that uses that member.</p>
</td></tr></tbody></table><div class="alert is-helpful"><p>Alternatively, we can use a module loader such as Webpack or
Browserify in an Angular 2 JavaScript project. In such a project, we would
use CommonJS modules and the <code>require</code> function to load Angular 2 framework code.
We would then use <code>module.exports</code> and <code>require</code> to export and import application
code.</p><span>
</span></div><span>
</span><table width="100%"><colgroup><col width="50%"><col width="50%"></colgroup><tbody><tr><th>TypeScript</th><th>ES5 JavaScript</th></tr><tr><td><h3 id="classes">Classes</h3>
<p>We put most of our Angular 2 TypeScript code into TypeScript classes.</p>
<code language="ts" format="">export class HeroComponent {
  title = &apos;Hero Detail&apos;;
  getName() {return &apos;Windstorm&apos;; }
}
</code></td><td><h3 id="constructors-and-prototypes">Constructors and Prototypes</h3>
<p>ES5 JavaScript has no classes. We use the constructor
pattern instead which works with Angular 2 as well as classes do.</p>
<code language="js" format="">function HeroComponent() {
  this.title = &quot;Hero Detail&quot;;
}

HeroComponent.prototype.getName =
  function() {return &apos;Windstorm&apos;;};
</code></td></tr><tr><td>
<p>Most Angular 2 classes have one or more TypeScript <em>decorators</em>
attached to provide configuration and metadata. For example,
a component must have a <a href="https://angular.io/docs/ts/latest/api/core/index/Component-decorator.html"><code>@Component</code></a> decorator.</p>
<code language="ts" format="">import { Component } from &apos;@angular/core&apos;;

@Component({
  selector: &apos;hero-view&apos;,
  template:
    &apos;&lt;h1&gt;Hero: {{getName()}}&lt;/h1&gt;&apos;
})
export class HeroComponent {
  title = &apos;Hero Detail&apos;;
  getName() {return &apos;Windstorm&apos;; }
}
</code></td><td>
<p>In JavaScript, we can attach an <code>annotations</code> array to a constructor
to provide metadata. 
Each item in the array corresponds to a TypeScript decorator.</p>
<p>In the following example, we create a new instance of <code>Component</code> that corresponds
to the <a href="https://angular.io/docs/ts/latest/api/core/index/Component-decorator.html"><code>@Component</code></a> TypeScript decorator.</p>
<code language="js" format="">  function HeroComponent() {
    this.title = &quot;Hero Detail&quot;;
  }

  HeroComponent.annotations = [
    new ng.core.Component({
      selector: &apos;hero-view&apos;,
      template:
        &apos;&lt;h1&gt;Hero: {{getName()}}&lt;/h1&gt;&apos;
    })
  ];
  HeroComponent.prototype.getName =
    function() {return &apos;Windstorm&apos;;};
</code>
<p>The pattern of creating a constructor and decorating it with metadata
is so common that Angular provides an alternative convenience API for it.
This API lets us define everything in a single expression.</p>
<p>With this API we first call the <code>ng.core.Component</code> function,
followed by a chained <code>Class</code> method call. The argument to <code>Class</code>
is an object that defines the constructor and the instance methods
of the component:</p>
<code language="js" format="">var HeroComponent = ng.core.Component({
    selector: &apos;hero-view-2&apos;,
    template:
      &apos;&lt;h1&gt;Name: {{getName()}}&lt;/h1&gt;&apos;,
  })
  .Class({
    constructor: function() {
    },
    getName: function() {
      return &apos;Windstorm&apos;;
    }
  });
</code><p>Similar APIs are also available for other decorators. You can define a
directive:</p>
<code>var MyDirective = ng.core.Directive({
  ...
}).Class({
  ...
});
</code><p>Or a pipe:</p>
<code>var MyPipe = ng.core.Pipe({
  name: &apos;myPipe&apos;
}).Class({
  ...
});
</code></td></tr><tr><td><h3 id="interfaces">Interfaces</h3>
<p>When defining classes that need to implement a certain method, it
is common to use TypeScript interfaces that enforce that the 
method signature is correct. Component lifecycle methods like <code>ngOnInit</code>
are one example of this pattern. <code>ngOnInit</code> is defined in the <code>OnInit</code>
interface.</p>
<code language="ts" format="">import { Component, OnInit } from &apos;@angular/core&apos;;
class HeroComponent
    implements OnInit {
  name: string;
  ngOnInit() {
    this.name = &apos;Windstorm&apos;;
  }
}
</code></td><td><h3 id="implementing-methods-without-interfaces">Implementing Methods without Interfaces</h3>
<p>TypeScript interfaces are purely for developer convenience
and are not used by Angular 2 at runtime. This means that in JavaScript
code we don&apos;t need to substitute anything for interfaces. We can just
implement the methods.</p>
<code language="js" format="">function HeroComponent() {}
HeroComponent.prototype.ngOnInit =
  function() {
    this.name = &apos;Windstorm&apos;;
  };
</code></td></tr></tbody></table><span>
</span><table width="100%"><colgroup><col width="50%"><col width="50%"></colgroup><tbody><tr><th>TypeScript</th><th>ES5 JavaScript</th></tr><tr><td><h3 id="input-and-output-decorators">Input and Output Decorators</h3>
<p>In TypeScript, property decorators are often used to provide additional metadata
for components and directives.</p>
<p>For <a href="https://angular.io/docs/ts/latest/guide/template-syntax.html#inputs-outputs">inputs and outputs</a>, 
we use <a href="https://angular.io/docs/ts/latest/api/core/index/Input-var.html"><code>@Input</code></a>
and <a href="https://angular.io/docs/ts/latest/api/core/index/Output-var.html"><code>@Output</code></a> property decorators.
They may optionally specify input and output binding names if we want them to be
different from the class property names.</p>
<code language="ts" format="">@Component({
  selector: &apos;my-confirm&apos;,
  template: `
    &lt;button (click)=&quot;onOkClick()&quot;&gt;
      {{okMsg}}
    &lt;/button&gt;
    &lt;button (click)=&quot;onNotOkClick()&quot;&gt;
      {{notOkMsg}}
    &lt;/button&gt;
  `
})
class ConfirmComponent {
  @Input() okMsg: string;
  @Input(&apos;cancelMsg&apos;) notOkMsg: string;
  @Output() ok =
    new EventEmitter();
  @Output(&apos;cancel&apos;) notOk =
    new EventEmitter();

  onOkClick() {
    this.ok.next(true);
  }
  onNotOkClick() {
    this.notOk.next(true);
  }
}
</code><div class="alert is-helpful"><p>In TypeScript we can also use the <code>inputs</code> and <code>outputs</code> array metadata 
instead of the <code>@Input</code> and <code>@Output</code> property decorators.</p><span>
</span></div></td><td>
<p>There is no equivalent of a property decorator in ES5 JavaScript. Instead, 
we add comparable information to the <code>Component</code> (or <code>Directive</code>) metadata.</p>
<p>In this example, we add <code>inputs</code> and <code>outputs</code> array attributes
containing the input and output property names. 
If we need a binding name that is different from the
property itself, we use the <code>propertyName: bindingName</code> syntax.</p>
<code language="js" format="">var ConfirmComponent = ng.core.Component({
  selector: &apos;my-confirm&apos;,
  inputs: [
    &apos;okMsg&apos;,
    &apos;notOkMsg: cancelMsg&apos;
  ],
  outputs: [
    &apos;ok&apos;,
    &apos;notOk: cancel&apos;
  ],
  template:
    &apos;&lt;button (click)=&quot;onOkClick()&quot;&gt;&apos; +
      &apos;{{okMsg}}&apos; +
    &apos;&lt;/button&gt;&apos; +
    &apos;&lt;button (click)=&quot;onNotOkClick()&quot;&gt;&apos; +
      &apos;{{notOkMsg}}&apos; +
    &apos;&lt;/button&gt;&apos;
}).Class({
  constructor: function() {
    this.ok = new ng.core.EventEmitter();
    this.notOk = new ng.core.EventEmitter();
  },
  onOkClick: function() {
    this.ok.next(true);
  },
  onNotOkClick: function() {
    this.notOk.next(true);
  }
});
</code></td></tr></tbody></table><h2 id="dependency-injection">Dependency Injection</h2><span>
</span><table width="100%"><colgroup><col width="50%"><col width="50%"></colgroup><tbody><tr><th>TypeScript</th><th>ES5 JavaScript</th></tr><tr><td><h3 id="injection-by-type">Injection by Type</h3>
<p>Angular 2 can often use TypeScript type information to
determine what needs to be injected.</p>
<code language="ts" format="">@Component({
  selector: &apos;hero-di&apos;,
  template: `&lt;h1&gt;Hero: {{name}}&lt;/h1&gt;`
})
class HeroComponent {
  name: string;
  constructor(dataService: DataService) {
    this.name = dataService.getHeroName();
  }
}
</code></td><td><h3 id="injection-with-parameter-tokens">Injection with Parameter Tokens</h3>
<p>Since no type information is available in ES5 JavaScript,
we must identify &quot;injectables&quot; in some other way.</p>
<p>We attach a <code>parameters</code> array to the constructor function. 
Each array item is the dependency injection token that identifies the thing to be injected. 
Often the token is the constructor function for the class-like dependency.</p>
<code language="js" format="">app.HeroDIComponent = HeroComponent;

function HeroComponent(dataService) {
  this.name = dataService.getHeroName();
}
HeroComponent.parameters = [
  app.DataService
];
HeroComponent.annotations = [
  new ng.core.Component({
    selector: &apos;hero-di&apos;,
    template: &apos;&lt;h1&gt;Hero: {{name}}&lt;/h1&gt;&apos;
  })
];
</code><p>When using the class convenience API, we can also supply the parameter
tokens by wrapping the constructor in an array.</p>
<code language="js" format="">var HeroComponent = ng.core.Component({
  selector: &apos;hero-di-inline&apos;,
  template: &apos;&lt;h1&gt;Hero: {{name}}&lt;/h1&gt;&apos;
})
.Class({
  constructor:
    [app.DataService, 
     function(service) {
       this.name = service.getHeroName();
     }]
});
</code></td></tr><tr><td><h3 id="injection-with-the-inject-decorator">Injection with the @Inject decorator</h3>
<p>When the thing being injected doesn&apos;t correspond directly to a type,
we use the <code>@Inject()</code> decorator to supply the injection token.</p>
<p>In this example, we&apos;re injecting a string identified by the &quot;heroName&quot; token.</p>
<code language="ts" format="">@Component({
  selector: &apos;hero-di-inject&apos;,
  template: `&lt;h1&gt;Hero: {{name}}&lt;/h1&gt;`
})
class HeroComponent {
  constructor(
    @Inject(&apos;heroName&apos;)
      private name: string) {
  }
}
</code></td><td><h3 id="injection-with-plain-string-tokens">Injection with plain string tokens</h3>
<p>In JavaScript we add the token string to the injection parameters array.</p>
<code language="js" format="">function HeroComponent(name) {
  this.name = name;
}
HeroComponent.parameters = [
  &apos;heroName&apos;
];
HeroComponent.annotations = [
  new ng.core.Component({
    selector: &apos;hero-di-inject&apos;,
    template: &apos;&lt;h1&gt;Hero: {{name}}&lt;/h1&gt;&apos;
  })
];
</code><p>Alternatively, we can create a token with the <code>Inject</code> method and
add that to the constructor array in the annotations like this:</p>
<code language="js" format="">var HeroComponent = ng.core.Component({
  selector: &apos;hero-di-inline2&apos;,
  template: &apos;&lt;h1&gt;Hero: {{name}}&lt;/h1&gt;&apos;
})
.Class({
  constructor:
    [new ng.core.Inject(&apos;heroName&apos;), 
     function(name) {
       this.name = name;
     }]
});
</code></td></tr><tr><td><h3 id="additional-injection-decorators">Additional Injection Decorators</h3>
<p>We can attach additional decorators to constructor parameters
to qualify the injection behavior. We can mark
optional dependencies with the <a href="https://angular.io/docs/ts/latest/api/core/index/Optional-var.html"><code>@Optional</code></a>,
inject host element attributes with <a href="https://angular.io/docs/ts/latest/api/core/index/Attribute-var.html"><code>@Attribute</code></a>,
inject content child queries with <a href="https://angular.io/docs/ts/latest/api/core/index/Query-var.html"><code>@Query</code></a>
and inject view child queries with <a href="https://angular.io/docs/ts/latest/api/core/index/ViewQuery-var.html"><code>@ViewQuery</code></a>).</p>
<code language="ts" format="">@Component({
  selector: &apos;hero-title&apos;,
  template: `
    &lt;h1&gt;{{titlePrefix}} {{title}}&lt;/h1&gt;
    &lt;button (click)=&quot;ok()&quot;&gt;OK&lt;/button&gt;
    &lt;p&gt;{{ msg }}&lt;/p&gt;
  `
})
class TitleComponent {
  private msg: string = &apos;&apos;;
  constructor(
    @Inject(&apos;titlePrefix&apos;)
    @Optional()
      private titlePrefix: string,
    @Attribute(&apos;title&apos;)
      private title: string) {
  }

  ok() {
    this.msg = &apos;OK!&apos;;
  }
}
</code></td><td>
<p>To achieve the same effect in JavaScript, use the constructor array notation
in which the injection information precedes the constructor function itself.</p>
<p>Use the injection support functions <code>Attribute</code>, <code>Host</code>, <code>Optional</code>, <code>Self</code>, <code>SkipSelf</code> to qualify dependency injection behavior.</p>
<p>Use a nested array to combine injection functions.</p>
<code language="js" format="">var TitleComponent = ng.core.Component({
  selector: &apos;hero-title&apos;,
  template:
    &apos;&lt;h1&gt;{{titlePrefix}} {{title}}&lt;/h1&gt;&apos; +
    &apos;&lt;button (click)=&quot;ok()&quot;&gt;OK&lt;/button&gt;&apos; +
    &apos;&lt;p&gt;{{ msg }}&lt;/p&gt;&apos;
}).Class({
  constructor: [
    [
      new ng.core.Optional(),
      new ng.core.Inject(&apos;titlePrefix&apos;)
    ],
    new ng.core.Attribute(&apos;title&apos;),
    function(titlePrefix, title) {
      this.titlePrefix = titlePrefix;
      this.title  = title;
      this.msg = &apos;&apos;;
    }
  ],
  ok: function() {
    this.msg = &apos;OK!&apos;;
  }
});
</code><p>We can apply other additional parameter decorators such as
<a href="https://angular.io/docs/ts/latest/api/core/index/Host-var.html"><code>@Host</code></a> and
<a href="https://angular.io/docs/ts/latest/api/core/index/SkipSelf-var.html"><code>@SkipSelf</code></a> in the same way -
by adding <code>new ng.core.Host()</code> or <code>ng.core.SkipSelf()</code> in the
parameters array.</p>
</td></tr></tbody></table><span>
</span><table width="100%"><colgroup><col width="50%"><col width="50%"></colgroup><tbody><tr><th>TypeScript</th><th>ES5 JavaScript  </th></tr><tr><td><h3 id="host-decorators">Host Decorators</h3>
<p>We can use host property decorators to bind a host element to a component or directive.
The <a href="https://angular.io/docs/ts/latest/api/core/index/HostBinding-var.html"><code>@HostBinding</code></a> decorator
binds host element properties to component data properties. 
The <a href="https://angular.io/docs/ts/latest/api/core/index/HostListener-var.html"><code>@HostListener</code></a> decorator bimds
host element events to component event handlers.</p>
<code language="ts" format="">@Component({
  selector: &apos;heroes-bindings&apos;,
  template: `&lt;h1 [class.active]=&quot;active&quot;&gt;
    Tour of Heroes
  &lt;/h1&gt;`
})
class HeroesComponent {
  @HostBinding() title = &apos;Tooltip content&apos;;
  @HostBinding(&apos;class.heading&apos;)
    hClass = true;
  active: boolean;

  constructor() {}

  @HostListener(&apos;click&apos;)
  clicked() {
    this.active = !this.active;
  }

  @HostListener(&apos;dblclick&apos;, [&apos;$event&apos;])
  doubleClicked(evt: Event) {
    this.active = true;
  }
}
</code><div class="alert is-helpful"><p>In TypeScript we can also use <code>host</code> metadata 
instead of the <code>@HostBinding</code> and <code>@HostListener</code> property decorators.</p><span>
</span></div></td><td>
<p>We add a <code>host</code> attribute to the component metadata to achieve the
same effect as <code>@HostBinding</code> and <code>@HostListener</code>. </p>
<p>The  <code>host</code> value is an object whose properties are host property and listener bindings:</p>
<ul>
<li>Each key follows regular Angular 2 binding syntax: <code>[property]</code> for host bindings
or <code>(event)</code> for host listeners.</li>
<li>Each value identifies the corresponding component property or method.</li>
</ul>
<code language="js" format="">var HeroesComponent = ng.core.Component({
  selector: &apos;heroes-bindings&apos;,
  template: &apos;&lt;h1 [class.active]=&quot;active&quot;&gt;&apos; +
    &apos;Tour of Heroes&apos; +
  &apos;&lt;/h1&gt;&apos;,
  host: {
    &apos;[title]&apos;: &apos;title&apos;,
    &apos;[class.heading]&apos;: &apos;hClass&apos;,
    &apos;(click)&apos;: &apos;clicked()&apos;,
    &apos;(dblclick)&apos;: &apos;doubleClicked($event)&apos;
  }
}).Class({
  constructor: function() {
    this.title = &apos;Tooltip content&apos;;
    this.hClass = true;
  },
  clicked: function() {
    this.active = !this.active;
  },
  doubleClicked: function(evt) {
    this.active = true;
  }
});
</code></td></tr><tr><td><h3 id="query-decorators">Query Decorators</h3>
<p>There are several property decorators for querying the descendants of
a component or directive.</p>
<p>The <a href="https://angular.io/docs/ts/latest/api/core/index/ViewChild-var.html"><code>@ViewChild</code></a> and
<a href="https://angular.io/docs/ts/latest/api/core/index/ViewChildren-var.html"><code>@ViewChildren</code></a> property decorators
allow a component to query instances of other components that are used in
its view.</p>
<code language="ts" format="">@Component({
  selector: &apos;heroes-queries&apos;,
  template: `
    &lt;a-hero *ngFor=&quot;let hero of heroData&quot;
          [hero]=&quot;hero&quot;&gt;
      &lt;active-label&gt;&lt;/active-label&gt;
    &lt;/a-hero&gt;
    &lt;button (click)=&quot;activate()&quot;&gt;
      Activate
    &lt;/button&gt;
  `
})
class HeroesQueriesComponent {
  heroData = [
    {id: 1, name: &apos;Windstorm&apos;},
    {id: 2, name: &apos;Superman&apos;}
  ];

  @ViewChildren(HeroComponent)
  heroCmps: QueryList&lt;HeroComponent&gt;;

  activate() {
    this.heroCmps.forEach(
      (cmp) =&gt; cmp.activate()
    );
  }
}
</code><p>The <a href="https://angular.io/docs/ts/latest/api/core/index/ContentChild-var.html"><code>@ContentChild</code></a> and
<a href="https://angular.io/docs/ts/latest/api/core/index/ContentChildren-var.html"><code>@ContentChildren</code></a> property decorators
allow a component to query instances of other components that have been projected
into its view from elsewhere.</p>
<code language="ts" format="">@Component({
  selector: &apos;a-hero&apos;,
  template: `&lt;h2 [class.active]=active&gt;
    {{hero.name}}
    &lt;ng-content&gt;&lt;/ng-content&gt;
  &lt;/h2&gt;`
})
class HeroComponent {
  @Input() hero: any;
  active: boolean;

  @ContentChild(ActiveLabelComponent)
  label: ActiveLabelComponent;

  activate() {
    this.active = true;
    this.label.activate();
  }
}
</code><div class="alert is-helpful"><p>In TypeScript we can also use the <code>queries</code> metadata 
instead of the <code>@ViewChild</code> and <code>@ContentChild</code> property decorators.      </p><span>
</span></div></td><td>
<p>We access a component&apos;s view children by adding a <code>queries</code> attribute to
the component metadata. It should be an object where:</p>
<ul>
<li>Each key is the name of a component property that will hold the view children</li>
<li>Each value is an instance of either <code>ViewChild</code> or <code>ViewChildren</code>.</li>
</ul>
<code language="js" format="">var AppComponent = ng.core.Component({
  selector: &apos;heroes-queries&apos;,
  template:
    &apos;&lt;a-hero *ngFor=&quot;let hero of heroData&quot;&apos; +
          &apos;[hero]=&quot;hero&quot;&gt;&apos; +
      &apos;&lt;active-label&gt;&lt;/active-label&gt;&apos; +
    &apos;&lt;/a-hero&gt;&apos; +
    &apos;&lt;button (click)=&quot;activate()&quot;&gt;&apos; +
      &apos;Activate&apos; +
    &apos;&lt;/button&gt;&apos;,    
  queries: {
    heroCmps: new ng.core.ViewChildren(
                    HeroComponent)
  }
}).Class({
  constructor: function() {
    this.heroData = [
      {id: 1, name: &apos;Windstorm&apos;},
      {id: 2, name: &apos;Superman&apos;}
    ];
  },
  activate: function() {
    this.heroCmps.forEach(function(cmp) {
      cmp.activate();
    });
  }
});
</code><p>We add <em>content</em> child queries to the same <code>queries</code> attribute
in the same manner, using instances of <code>ContentChild</code> or <code>ContentChildren</code>:</p>
<code language="js" format="">var HeroComponent = ng.core.Component({
  selector: &apos;a-hero&apos;,
  template: &apos;&lt;h2 [class.active]=active&gt;&apos; +
    &apos;{{hero.name}} &apos; +
    &apos;&lt;ng-content&gt;&lt;/ng-content&gt;&apos; +
  &apos;&lt;/h2&gt;&apos;,
  inputs: [&apos;hero&apos;],
  queries: {
    label: new ng.core.ContentChild(
                 ActiveLabelComponent)
  }
}).Class({
  constructor: [function() { }],
  activate: function() {
    this.active = true;
    this.label.activate();
  }
});
app.HeroQueriesComponent = HeroComponent;
</code></td></tr></tbody></table></div></div>
        </article>
      
        <article>
          <h3>Visual Studio 2015 QuickStart</h3>
          <div><div class="showcase-content"><a id="top"></a><p>Some developers prefer Visual Studio as their Interactive Development Environment (IDE).</p><span>
</span><p>This cookbook describes the steps required to set up and use the
Angular 2 QuickStart files in Visual Studio 2015 within an ASP.NET 4.x project.</p><span>
</span><div class="l-sub-section"><p>There is no <em>live example</em> for this cookbook because it describes Visual Studio, not the application.</p><span>
</span></div><a id="asp-net-4"></a><h2 id="asp-net-4-x-project">ASP.NET 4.x Project</h2><span>
</span><p>The steps for setting up the QuickStart files with an ASP.NET 4.x project in
Visual Studio 2015 are as follows:</p><span>
</span><ul>
<li><a href="https://angular.io/docs/ts/latest/cookbook/visual-studio-2015.html#prereq">Prerequisite</a>: Install Node.js</li>
<li><a href="https://angular.io/docs/ts/latest/cookbook/visual-studio-2015.html#download">Step 1</a>: Download the QuickStart files</li>
<li><a href="https://angular.io/docs/ts/latest/cookbook/visual-studio-2015.html#setup-vs">Step 2</a>: Set up Visual Studio for TypeScript</li>
<li><a href="https://angular.io/docs/ts/latest/cookbook/visual-studio-2015.html#create-project">Step 3</a>: Create the Visual Studio ASP.NET project</li>
<li><a href="https://angular.io/docs/ts/latest/cookbook/visual-studio-2015.html#copy">Step 4</a>: Copy the QuickStart files into the ASP.NET project folder</li>
<li><a href="https://angular.io/docs/ts/latest/cookbook/visual-studio-2015.html#restore">Step 5</a>: Restore required packages</li>
<li><a href="https://angular.io/docs/ts/latest/cookbook/visual-studio-2015.html#edit-config">Step 6</a>: Edit the TypeScript configuration file</li>
<li><a href="https://angular.io/docs/ts/latest/cookbook/visual-studio-2015.html#build-and-run">Step 7</a>: Build and run the app</li>
</ul><span>
</span><h2 id="prereq">Prerequisite: Node.js</h2><p>Install <strong><a href="https://nodejs.org/en/download/">Node.js&#xAE; and npm</a></strong>
if they are not already on your machine.</p><span>
</span><div class="l-sub-section"><p><strong>Verify that you are running node version <code>4.4.x</code> - <code>5.x.x</code>, and npm <code>3.x.x</code></strong>
by running <code>node -v</code> and <code>npm -v</code> in a terminal/console window.
Older versions produce errors.</p><span>
</span></div><h2 id="download">Step 1: Download the QuickStart files</h2><p><a href="https://github.com/angular/quickstart">Download the QuickStart source</a>
from github. If you downloaded as a zip file, extract the files.</p><span>
</span><h2 id="setup-vs">Step 2: Set up Visual Studio for TypeScript</h2><p>Ensure you have the latest version of Visual Studio 2015 installed. 
Then open Visual Studio and install the latest set of TypeScript tools as follows:</p><span>
</span><ul>
<li>Open <code>Tools</code> | <code>Extensions and Updates</code>.</li>
<li>Select <code>Online</code> in the tree on the left.</li>
<li>Search for <code>TypeScript</code> using the search box in the upper right.</li>
<li>Select the most current available TypeScript version.</li>
<li>Download and install the package.</li>
</ul><span>
</span><h2 id="create-project">Step 3: Create the Visual Studio ASP.NET project</h2><p>Create the ASP.NET 4.x project as follows:</p><span>
</span><ul>
<li>In Visual Studio, select <code>File</code> | <code>New</code> | <code>Project</code> from the menu.</li>
<li>In the template tree, select <code>Templates</code> | <code>Visual C#</code> (or <code>Visual Basic</code>) | <code>Web</code>.</li>
<li>Select the <code>ASP.NET Web Application</code> template, give the project a name, and click OK.</li>
<li>Select the desired ASP.NET 4.5.2 template and click OK.</li>
</ul><span>
</span><div class="l-sub-section"><p>In this cookbook we&apos;ll select the <code>Empty</code> template with no added folders, 
no authentication and no hosting. Pick the template and options appropriate for your project.</p><span>
</span></div><h2 id="copy">Step 4: Copy the QuickStart files into the ASP.NET project folder</h2><p>Copy the QuickStart files we downloaded from github into the folder containing the <code>.csproj</code> file.
Include the files in the Visual Studio project as follows:</p><span>
</span><ul>
<li>Click the <code>Show All Files</code> button in Solution Explorer to reveal all of the hidden files in the project.</li>
<li>Right-click on each folder/file to be included in the project and select <code>Include in Project</code>.
Minimally, include the following folder/files:<ul>
<li>app folder (answer <em>No</em>  if asked to search for TypeScript Typings)</li>
<li>styles.css</li>
<li>index.html</li>
<li>package.json</li>
<li>tsconfig.json</li>
<li>typings.json</li>
</ul>
</li>
</ul><span>
</span><h2 id="restore">Step 5: Restore the required packages</h2><p>Restore the packages required for an Angular application as follows:</p><span>
</span><ul>
<li>Right-click on the <code>package.json</code> file in Solution Explorer and select <code>Restore Packages</code>.
<br>This uses <code>npm</code> to install all of the packages defined in the <code>package.json</code> file. 
It may take some time.</li>
<li>If desired, open the Output window (<code>View</code> | <code>Output</code>) to watch the npm commands execute.</li>
<li>Ignore the warnings.</li>
<li>When the restore is finished, a message should say: <code>npm command completed with exit code 0</code>.</li>
<li>Click the <code>Refresh</code> icon in Solution Explorer.</li>
<li><strong>Do not</strong> include the <code>node_modules</code> folder in the project. Let it be a hidden project project folder.</li>
</ul><span>
</span><div class="alert is-important"><p>An error such as &quot;<em>@angular/compiler is not in the npm registry</em>&quot; suggests that Visual Studio 2015
is using an older version of npm. Update to the latest installed version of npm:</p><span>
</span><ul>
<li><code>Tools</code> | <code>Options</code> to open the Options dialog.</li>
<li>In the tree on the left, select <code>Projects and Solutions</code> | <code>External Web Tools</code>.</li>
<li>On the right, move the <code>$(PATH)</code> entry above the <code>$(DevEnvDir</code>) entries. This tells Visual Studio to
use the external tools (such as npm) found in your path before using its own version of the external tools.</li>
<li>Click OK to close the dialog.</li>
<li>Restart Visual Studio for this change to take effect.</li>
</ul><span>
</span></div><h2 id="edit-config">Step 6: Edit the TypeScript configuration file</h2><p>For Visual Studio 2015 we must add <code>&quot;compileOnSave&quot;: true</code> to the TypeScript configuration (<code>tsconfig.json</code>) file 
as shown here. </p><span>
</span><p>tsconfig.json (scripts)</p><code language="json" format="linenums">{
  &quot;compilerOptions&quot;: {
    &quot;target&quot;: &quot;es5&quot;,
    &quot;module&quot;: &quot;commonjs&quot;,
    &quot;moduleResolution&quot;: &quot;node&quot;,
    &quot;sourceMap&quot;: true,
    &quot;emitDecoratorMetadata&quot;: true,
    &quot;experimentalDecorators&quot;: true,
    &quot;removeComments&quot;: false,
    &quot;noImplicitAny&quot;: true,
    &quot;suppressImplicitAnyIndexErrors&quot;: true
  },
  &quot;compileOnSave&quot;: true
}
</code><p>After making this change, <strong>exit</strong> Visual Studio and reopen it to reload the project.  </p><span>
</span><h2 id="build-and-run">Step 7: Build and run the app</h2><p>Click the Run button or press F5 to build and run the application.</p><span>
</span><p>This launches the default browser and runs the QuickStart sample application.</p><span>
</span><p>Try editing any of the project files. <em>Save</em> and refresh the browser to
see the changes. </p><span>
</span><div class="alert is-important"><p>Compiler errors such as &quot;<em>Property &#x2018;map&#x2019; does not exist on type &#x2018;Observable<response>&#x2019;</response></em>&quot; and
&quot;<em>Observable cannot be found</em>&quot; indicate an old release of Visual Studio.
Exit Visual Studio and follow the <a href="https://github.com/Microsoft/TypeScript/issues/8518">instructions here</a>.</p><span>
</span><p>You&apos;ll be asked to replace the file</p><span>
</span><code>c:\Program Files (x86)\Microsoft Visual Studio 14.0\Common7\IDE\CommonExtensions\Microsoft\TypeScript.typescriptServices.js
</code><p>This operation requires admin privileges.</p><span>
</span></div><h2 id="routing">Note on Routing Applications</h2><p>If this application used the Angular router, a browser refresh could return a <em>404 - Page Not Found</em>.
Look at the address bar. Does it contain a navigation url (a &quot;deep link&quot;)? 
We&apos;ll have to configure the server to return <code>index.html</code> for these requests.
Until we do, remove the navigation path and refresh again. </p></div></div>
        </article>
      <h2></h2>
    </div>
  </body>
</html>
  